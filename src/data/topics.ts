// This file is auto-generated. Do not edit manually.
import { CommandCategory, TopicCategory } from './types';

export const topics: CommandCategory[] = [
  {
    "id": "acl",
    "topicName": "ACL",
    "description": "Valkey Access Control List",
    "htmlContent": "<p>The Valkey ACL, short for Access Control List, is a feature that allows certain connections to be limited in terms of the commands that can be executed and the keys that can be accessed.<br>The way it works is that, after connecting, a client is required to provide a username and a valid password to authenticate.<br>If authentication succeeded, the connection is associated with a given user and the limits the user has.<br>Valkey can be configured so that new connections are already authenticated with a &quot;default&quot; user (this is the default configuration).<br>Configuring the default user has, as a side effect, the ability to provide only a specific subset of functionalities to connections that are not explicitly authenticated.</p>\n<p>The standard way to authenticate is the two-argument form of the <code>AUTH</code> command:</p>\n<pre><code>AUTH &lt;username&gt; &lt;password&gt;\n</code></pre>\n<p>If the password is valid matches, the connection will be authenticated to the user with the name <code>&lt;username&gt;</code>.</p>\n<p>When the single argument form of the command is used, where only the password is specified, it is assumed that the implicit username is &quot;default&quot;.</p>\n<pre><code>AUTH &lt;password&gt;\n</code></pre>\n<p>This form authenticates against the &quot;default&quot; user&#39;s password, either set by ACLs or by setting <code>requirepass</code>.</p>\n<h2>When ACLs are useful</h2>\n<p>Before using ACLs, you may want to ask yourself what&#39;s the goal you want to<br>accomplish by implementing this layer of protection. Normally there are<br>two main goals that are well served by ACLs:</p>\n<ol>\n<li>You want to improve security by restricting the access to commands and keys, so that untrusted clients have no access and trusted clients have just the minimum access level to the database in order to perform the work needed. For instance, certain clients may just be able to execute read only commands.</li>\n<li>You want to improve operational safety, so that processes or humans accessing Valkey are not allowed to damage the data or the configuration due to software errors or manual mistakes. For instance, there is no reason for a worker that fetches delayed jobs from Valkey to be able to call the <code>FLUSHALL</code> command.</li>\n</ol>\n<p>Another typical usage of ACLs is related to managed Valkey instances. Valkey is<br>often provided as a managed service both by internal company teams that handle<br>the Valkey infrastructure for the other internal customers they have, or is<br>provided in a software-as-a-service setup by cloud providers. In both<br>setups, we want to be sure that configuration commands are excluded for the<br>customers.</p>\n<h2>Configure ACLs with the ACL command</h2>\n<p>ACLs are defined using a DSL (domain specific language) that describes what<br>a given user is allowed to do. Such rules are always implemented from the<br>first to the last, left-to-right, because sometimes the order of the rules is<br>important to understand what the user is really able to do.</p>\n<p>By default there is a single user defined, called <em>default</em>. We<br>can use the <code>ACL LIST</code> command in order to check the currently active ACLs<br>and verify what the configuration of a freshly started, defaults-configured<br>Valkey instance is:</p>\n<pre><code>&gt; ACL LIST\n1) &quot;user default on nopass ~* &amp;* +@all&quot;\n</code></pre>\n<p>The command above reports the list of users in the same format that is<br>used in the Valkey configuration files, by translating the current ACLs set<br>for the users back into their description.</p>\n<p>The first two words in each line are &quot;user&quot; followed by the username. The<br>next words are ACL rules that describe different things. We&#39;ll show how the rules work in detail, but for now it is enough to say that the default<br>user is configured to be active (on), to require no password (nopass), to<br>access every possible key (<code>~*</code>) and Pub/Sub channel (<code>&amp;*</code>), and be able to<br>call every possible command (<code>+@all</code>).</p>\n<p>Also, in the special case of the default user, having the <em>nopass</em> rule means<br>that new connections are automatically authenticated with the default user<br>without any explicit <code>AUTH</code> call needed.</p>\n<h2>ACL rules</h2>\n<p>The following is the list of valid ACL rules. Certain rules are just<br>single words that are used in order to activate or remove a flag, or to<br>perform a given change to the user ACL. Other rules are char prefixes that<br>are concatenated with command or category names, key patterns, and<br>so forth.</p>\n<p>Enable and disallow users:</p>\n<ul>\n<li><code>on</code>: Enable the user: it is possible to authenticate as this user.</li>\n<li><code>off</code>: Disallow the user: it&#39;s no longer possible to authenticate with this user; however, previously authenticated connections will still work. Note that if the default user is flagged as <em>off</em>, new connections will start as not authenticated and will require the user to send <code>AUTH</code> or <code>HELLO</code> with the AUTH option in order to authenticate in some way, regardless of the default user configuration.</li>\n</ul>\n<p>Allow and disallow commands:</p>\n<ul>\n<li><code>+&lt;command&gt;</code>: Add the command to the list of commands the user can call. Can be used with <code>|</code> for allowing subcommands (e.g &quot;+config|get&quot;).</li>\n<li><code>-&lt;command&gt;</code>: Remove the command to the list of commands the user can call. Starting Valkey 7.0, it can be used with <code>|</code> for blocking subcommands (e.g &quot;-config|set&quot;).</li>\n<li><code>+@&lt;category&gt;</code>: Add all the commands in such category to be called by the user, with valid categories being like @admin, @set, @sortedset, ... and so forth, see the full list by calling the <code>ACL CAT</code> command. The special category @all means all the commands, both the ones currently present in the server, and the ones that will be loaded in the future via modules.</li>\n<li><code>-@&lt;category&gt;</code>: Like <code>+@&lt;category&gt;</code> but removes the commands from the list of commands the client can call.</li>\n<li><code>+&lt;command&gt;|first-arg</code>: Allow a specific first argument of an otherwise disabled command. It is only supported on commands with no sub-commands, and is not allowed as negative form like -SELECT|1, only additive starting with &quot;+&quot;. This feature is deprecated and may be removed in the future.</li>\n<li><code>allcommands</code>: Alias for +@all. Note that it implies the ability to execute all the future commands loaded via the modules system.</li>\n<li><code>nocommands</code>: Alias for -@all.</li>\n</ul>\n<p>Allow and disallow certain keys and key permissions:</p>\n<ul>\n<li><code>~&lt;pattern&gt;</code>: Add a pattern of keys that can be mentioned as part of commands. For instance <code>~*</code> allows all the keys. The pattern is a glob-style pattern like the one of <code>KEYS</code>. It is possible to specify multiple patterns.</li>\n<li><code>%R~&lt;pattern&gt;</code>: Add the specified read key pattern. This behaves similar to the regular key pattern but only grants permission to read from keys that match the given pattern. See <a href=\"#key-permissions\">key permissions</a> for more information.</li>\n<li><code>%W~&lt;pattern&gt;</code>: Add the specified write key pattern. This behaves similar to the regular key pattern but only grants permission to write to keys that match the given pattern. See <a href=\"#key-permissions\">key permissions</a> for more information.</li>\n<li><code>%RW~&lt;pattern&gt;</code>: Alias for <code>~&lt;pattern&gt;</code>. </li>\n<li><code>allkeys</code>: Alias for <code>~*</code>.</li>\n<li><code>resetkeys</code>: Flush the list of allowed keys patterns. For instance the ACL <code>~foo:* ~bar:* resetkeys ~objects:*</code>, will only allow the client to access keys that match the pattern <code>objects:*</code>.</li>\n</ul>\n<p>Allow and disallow Pub/Sub channels:</p>\n<ul>\n<li><code>&amp;&lt;pattern&gt;</code>: Add a glob style pattern of Pub/Sub channels that can be accessed by the user. It is possible to specify multiple channel patterns. Note that pattern matching is done only for channels mentioned by <code>PUBLISH</code> and <code>SUBSCRIBE</code>, whereas <code>PSUBSCRIBE</code> requires a literal match between its channel patterns and those allowed for user.</li>\n<li><code>allchannels</code>: Alias for <code>&amp;*</code> that allows the user to access all Pub/Sub channels.</li>\n<li><code>resetchannels</code>: Flush the list of allowed channel patterns and disconnect the user&#39;s Pub/Sub clients if these are no longer able to access their respective channels and/or channel patterns.</li>\n</ul>\n<p>Configure valid passwords for the user:</p>\n<ul>\n<li><code>&gt;&lt;password&gt;</code>: Add this password to the list of valid passwords for the user. For example <code>&gt;mypass</code> will add &quot;mypass&quot; to the list of valid passwords.  This directive clears the <em>nopass</em> flag (see later). Every user can have any number of passwords.</li>\n<li><code>&lt;&lt;password&gt;</code>: Remove this password from the list of valid passwords. Emits an error in case the password you are trying to remove is actually not set.</li>\n<li><code>#&lt;hash&gt;</code>: Add this SHA-256 hash value to the list of valid passwords for the user. This hash value will be compared to the hash of a password entered for an ACL user. This allows users to store hashes in the <code>acl.conf</code> file rather than storing cleartext passwords. Only SHA-256 hash values are accepted as the password hash must be 64 characters and only contain lowercase hexadecimal characters.</li>\n<li><code>!&lt;hash&gt;</code>: Remove this hash value from the list of valid passwords. This is useful when you do not know the password specified by the hash value but would like to remove the password from the user.</li>\n<li><code>nopass</code>: All the set passwords of the user are removed, and the user is flagged as requiring no password: it means that every password will work against this user. If this directive is used for the default user, every new connection will be immediately authenticated with the default user without any explicit AUTH command required. Note that the <em>resetpass</em> directive will clear this condition.</li>\n<li><code>resetpass</code>: Flushes the list of allowed passwords and removes the <em>nopass</em> status. After <em>resetpass</em>, the user has no associated passwords and there is no way to authenticate without adding some password (or setting it as <em>nopass</em> later).</li>\n</ul>\n<p><em>Note: if a user is not flagged with nopass and has no list of valid passwords, that user is effectively impossible to use because there will be no way to log in as that user.</em></p>\n<p>Configure selectors for the user:</p>\n<ul>\n<li><code>(&lt;rule list&gt;)</code>: Create a new selector to match rules against. Selectors are evaluated after the user permissions, and are evaluated according to the order they are defined. If a command matches either the user permissions or any selector, it is allowed. See <a href=\"#selectors\">selectors</a> for more information.</li>\n<li><code>clearselectors</code>: Delete all of the selectors attached to the user.</li>\n</ul>\n<p>Reset the user:</p>\n<ul>\n<li><code>reset</code> Performs the following actions: resetpass, resetkeys, resetchannels, allchannels (if acl-pubsub-default is set), off, clearselectors, -@all. The user returns to the same state it had immediately after its creation.</li>\n</ul>\n<h2>Create and edit user ACLs with the ACL SETUSER command</h2>\n<p>Users can be created and modified in two main ways:</p>\n<ol>\n<li>Using the ACL command and its <code>ACL SETUSER</code> subcommand.</li>\n<li>Modifying the server configuration, where users can be defined, and restarting the server. With an <em>external ACL file</em>, just call <code>ACL LOAD</code>.</li>\n</ol>\n<p>In this section we&#39;ll learn how to define users using the <code>ACL</code> command.<br>With such knowledge, it will be trivial to do the same things via the<br>configuration files. Defining users in the configuration deserves its own<br>section and will be discussed later separately.</p>\n<p>To start, try the simplest <code>ACL SETUSER</code> command call:</p>\n<pre><code>&gt; ACL SETUSER alice\nOK\n</code></pre>\n<p>The <code>ACL SETUSER</code> command takes the username and a list of ACL rules to apply<br>to the user. However the above example did not specify any rule at all.<br>This will just create the user if it did not exist, using the defaults for new<br>users. If the user already exists, the command above will do nothing at all.</p>\n<p>Check the default user status:</p>\n<pre><code>&gt; ACL LIST\n1) &quot;user alice off resetchannels -@all&quot;\n2) &quot;user default on nopass ~* &amp;* +@all&quot;\n</code></pre>\n<p>The new user &quot;alice&quot; is:</p>\n<ul>\n<li>In the off status, so <code>AUTH</code> will not work for the user &quot;alice&quot;.</li>\n<li>The user also has no passwords set.</li>\n<li>Cannot access any command. Note that the user is created by default without the ability to access any command, so the <code>-@all</code> in the output above could be omitted; however, <code>ACL LIST</code> attempts to be explicit rather than implicit.</li>\n<li>There are no key patterns that the user can access.</li>\n<li>There are no Pub/Sub channels that the user can access.</li>\n</ul>\n<p>Such user is completely useless. Let&#39;s try to define the user so that<br>it is active, has a password, and can access with only the <code>GET</code> command<br>to key names starting with the string &quot;cached:&quot;.</p>\n<pre><code>&gt; ACL SETUSER alice on &gt;p1pp0 ~cached:* +get\nOK\n</code></pre>\n<p>Now the user can do something, but will refuse to do other things:</p>\n<pre><code>&gt; AUTH alice p1pp0\nOK\n&gt; GET foo\n(error) NOPERM this user has no permissions to access one of the keys used as arguments\n&gt; GET cached:1234\n(nil)\n&gt; SET cached:1234 zap\n(error) NOPERM this user has no permissions to run the &#39;set&#39; command\n</code></pre>\n<p>Things are working as expected. In order to inspect the configuration of the<br>user alice (remember that user names are case sensitive), it is possible to<br>use an alternative to <code>ACL LIST</code> which is designed to be more suitable for<br>computers to read, while <code>ACL GETUSER</code> is more human readable.</p>\n<pre><code>&gt; ACL GETUSER alice\n1) &quot;flags&quot;\n2) 1) &quot;on&quot;\n3) &quot;passwords&quot;\n4) 1) &quot;2d9c75...&quot;\n5) &quot;commands&quot;\n6) &quot;-@all +get&quot;\n7) &quot;keys&quot;\n8) &quot;~cached:*&quot;\n9) &quot;channels&quot;\n10) &quot;&quot;\n11) &quot;selectors&quot;\n12) (empty array)\n</code></pre>\n<p>The <code>ACL GETUSER</code> returns a field-value array that describes the user in more parsable terms. The output includes the set of flags, a list of key patterns, passwords, and so forth. The output is probably more readable if we use RESP3, so that it is returned as a map reply:</p>\n<pre><code>&gt; ACL GETUSER alice\n1# &quot;flags&quot; =&gt; 1~ &quot;on&quot;\n2# &quot;passwords&quot; =&gt; 1) &quot;2d9c75273d72b32df726fb545c8a4edc719f0a95a6fd993950b10c474ad9c927&quot;\n3# &quot;commands&quot; =&gt; &quot;-@all +get&quot;\n4# &quot;keys&quot; =&gt; &quot;~cached:*&quot;\n5# &quot;channels&quot; =&gt; &quot;&quot;\n6# &quot;selectors&quot; =&gt; (empty array)\n</code></pre>\n<p><em>Note: from now on, we&#39;ll continue using the Valkey default protocol, version 2</em></p>\n<p>Using another <code>ACL SETUSER</code> command (from a different user, because alice cannot run the <code>ACL</code> command), we can add multiple patterns to the user:</p>\n<pre><code>&gt; ACL SETUSER alice ~objects:* ~items:* ~public:*\nOK\n&gt; ACL LIST\n1) &quot;user alice on #2d9c75... ~cached:* ~objects:* ~items:* ~public:* resetchannels -@all +get&quot;\n2) &quot;user default on nopass ~* &amp;* +@all&quot;\n</code></pre>\n<p>The user representation in memory is now as we expect it to be.</p>\n<h2>Multiple calls to ACL SETUSER</h2>\n<p>It is very important to understand what happens when <code>ACL SETUSER</code> is called<br>multiple times. What is critical to know is that every <code>ACL SETUSER</code> call will<br>NOT reset the user, but will just apply the ACL rules to the existing user.<br>The user is reset only if it was not known before. In that case, a brand new<br>user is created with zeroed-ACLs. The user cannot do anything, is<br>disallowed, has no passwords, and so forth. This is the best default for safety.</p>\n<p>However later calls will just modify the user incrementally. For instance,<br>the following sequence:</p>\n<pre><code>&gt; ACL SETUSER myuser +set\nOK\n&gt; ACL SETUSER myuser +get\nOK\n</code></pre>\n<p>Will result in myuser being able to call both <code>GET</code> and <code>SET</code>:</p>\n<pre><code>&gt; ACL LIST\n1) &quot;user default on nopass ~* &amp;* +@all&quot;\n2) &quot;user myuser off resetchannels -@all +get +set&quot;\n</code></pre>\n<h2>Command categories</h2>\n<p>Setting user ACLs by specifying all the commands one after the other is<br>really annoying, so instead we do things like this:</p>\n<pre><code>&gt; ACL SETUSER antirez on +@all -@dangerous &gt;42a979... ~*\n</code></pre>\n<p>By saying +@all and -@dangerous, we included all the commands and later removed<br>all the commands that are tagged as dangerous inside the Valkey command table.<br>Note that command categories <strong>never include modules commands</strong> with<br>the exception of +@all. If you say +@all, all the commands can be executed by<br>the user, even future commands loaded via the modules system. However if you<br>use the ACL rule +@read or any other, the modules commands are always<br>excluded. This is very important because you should just trust the Valkey<br>internal command table. Modules may expose dangerous things and in<br>the case of an ACL that is just additive, that is, in the form of <code>+@all -...</code><br>You should be absolutely sure that you&#39;ll never include what you did not mean<br>to.</p>\n<p>The following is a list of command categories and their meanings:</p>\n<ul>\n<li><strong>admin</strong> - Administrative commands. Normal applications will never need to use<br>these. Includes <code>REPLICAOF</code>, <code>CONFIG</code>, <code>DEBUG</code>, <code>SAVE</code>, <code>MONITOR</code>, <code>ACL</code>, <code>SHUTDOWN</code>, etc.</li>\n<li><strong>bitmap</strong> - Data type: bitmaps related.</li>\n<li><strong>blocking</strong> - Potentially blocking the connection until released by another<br>command.</li>\n<li><strong>connection</strong> - Commands affecting the connection or other connections.<br>This includes <code>AUTH</code>, <code>SELECT</code>, <code>COMMAND</code>, <code>CLIENT</code>, <code>ECHO</code>, <code>PING</code>, etc.</li>\n<li><strong>dangerous</strong> - Potentially dangerous commands (each should be considered with care for<br>various reasons). This includes <code>FLUSHALL</code>, <code>MIGRATE</code>, <code>RESTORE</code>, <code>SORT</code>, <code>KEYS</code>,<br><code>CLIENT</code>, <code>DEBUG</code>, <code>INFO</code>, <code>CONFIG</code>, <code>SAVE</code>, <code>REPLICAOF</code>, etc.</li>\n<li><strong>geo</strong> - Data type: geospatial indexes related.</li>\n<li><strong>hash</strong> - Data type: hashes related.</li>\n<li><strong>hyperloglog</strong> - Data type: hyperloglog related.</li>\n<li><strong>fast</strong> - Fast O(1) commands. May loop on the number of arguments, but not the<br>number of elements in the key.</li>\n<li><strong>keyspace</strong> - Writing or reading from keys, databases, or their metadata<br>in a type agnostic way. Includes <code>DEL</code>, <code>RESTORE</code>, <code>DUMP</code>, <code>RENAME</code>, <code>EXISTS</code>, <code>DBSIZE</code>,<br><code>KEYS</code>, <code>EXPIRE</code>, <code>TTL</code>, <code>FLUSHALL</code>, etc. Commands that may modify the keyspace,<br>key, or metadata will also have the <code>write</code> category. Commands that only read<br>the keyspace, key, or metadata will have the <code>read</code> category.</li>\n<li><strong>list</strong> - Data type: lists related.</li>\n<li><strong>pubsub</strong> - PubSub-related commands.</li>\n<li><strong>read</strong> - Reading from keys (values or metadata). Note that commands that don&#39;t<br>interact with keys, will not have either <code>read</code> or <code>write</code>.</li>\n<li><strong>scripting</strong> - Scripting related.</li>\n<li><strong>set</strong> - Data type: sets related.</li>\n<li><strong>sortedset</strong> - Data type: sorted sets related.</li>\n<li><strong>slow</strong> - All commands that are not <code>fast</code>.</li>\n<li><strong>stream</strong> - Data type: streams related.</li>\n<li><strong>string</strong> - Data type: strings related.</li>\n<li><strong>transaction</strong> - <code>WATCH</code> / <code>MULTI</code> / <code>EXEC</code> related commands.</li>\n<li><strong>write</strong> - Writing to keys (values or metadata).</li>\n</ul>\n<p>Valkey can also show you a list of all categories and the exact commands each category includes using the Valkey <code>ACL CAT</code> command. It can be used in two forms:</p>\n<pre><code>ACL CAT -- Will just list all the categories available\nACL CAT &lt;category-name&gt; -- Will list all the commands inside the category\n</code></pre>\n<p>Examples:</p>\n<pre><code> &gt; ACL CAT\n 1) &quot;keyspace&quot;\n 2) &quot;read&quot;\n 3) &quot;write&quot;\n 4) &quot;set&quot;\n 5) &quot;sortedset&quot;\n 6) &quot;list&quot;\n 7) &quot;hash&quot;\n 8) &quot;string&quot;\n 9) &quot;bitmap&quot;\n10) &quot;hyperloglog&quot;\n11) &quot;geo&quot;\n12) &quot;stream&quot;\n13) &quot;pubsub&quot;\n14) &quot;admin&quot;\n15) &quot;fast&quot;\n16) &quot;slow&quot;\n17) &quot;blocking&quot;\n18) &quot;dangerous&quot;\n19) &quot;connection&quot;\n20) &quot;transaction&quot;\n21) &quot;scripting&quot;\n</code></pre>\n<p>As you can see, so far there are 21 distinct categories. Now let&#39;s check what<br>command is part of the <em>geo</em> category:</p>\n<pre><code> &gt; ACL CAT geo\n 1) &quot;geohash&quot;\n 2) &quot;georadius_ro&quot;\n 3) &quot;georadiusbymember&quot;\n 4) &quot;geopos&quot;\n 5) &quot;geoadd&quot;\n 6) &quot;georadiusbymember_ro&quot;\n 7) &quot;geodist&quot;\n 8) &quot;georadius&quot;\n 9) &quot;geosearch&quot;\n10) &quot;geosearchstore&quot;\n</code></pre>\n<p>Note that commands may be part of multiple categories. For example, an<br>ACL rule like <code>+@geo -@read</code> will result in certain geo commands to be<br>excluded because they are read-only commands.</p>\n<h2>Allow/block subcommands</h2>\n<p>Subcommands can be allowed/blocked just like other<br>commands (by using the separator <code>|</code> between the command and subcommand, for<br>example: <code>+config|get</code> or <code>-config|set</code>)</p>\n<p>That is true for all commands except DEBUG. In order to allow/block specific DEBUG subcommands, see the next section.</p>\n<h2>Allow the first-arg of a blocked command</h2>\n<p><strong>Note: This feature is deprecated and may be removed in the future.</strong></p>\n<p>Sometimes the ability to exclude or include a command or a subcommand as a whole is not enough.<br>Many deployments may not be happy providing the ability to execute a <code>SELECT</code> for any DB, but may<br>still want to be able to run <code>SELECT 0</code>.</p>\n<p>In such case we could alter the ACL of a user in the following way:</p>\n<pre><code>ACL SETUSER myuser -select +select|0\n</code></pre>\n<p>First, remove the <code>SELECT</code> command and then add the allowed<br>first-arg. Note that <strong>it is not possible to do the reverse</strong> since first-args<br>can be only added, not excluded. It is safer to specify all the first-args<br>that are valid for some user since it is possible that<br>new first-args may be added in the future.</p>\n<p>Another example:</p>\n<pre><code>ACL SETUSER myuser -debug +debug|digest\n</code></pre>\n<p>Note that first-arg matching may add some performance penalty; however, it is hard to measure even with synthetic benchmarks. The<br>additional CPU cost is only paid when such commands are called, and not when<br>other commands are called.</p>\n<p>It is possible to use this mechanism in order to allow subcommands in Valkey<br>versions prior to 7.0 (see above section).</p>\n<h2>+@all VS -@all</h2>\n<p>In the previous section, it was observed how it is possible to define command<br>ACLs based on adding/removing single commands.</p>\n<h2>Selectors</h2>\n<p>Valkey supports adding multiple sets of rules that are evaluated independently of each other.<br>These secondary sets of permissions are called selectors and added by wrapping a set of rules within parentheses.<br>In order to execute a command, either the root permissions (rules defined outside of parenthesis) or any of the selectors (rules defined inside parenthesis) must match the given command.<br>Internally, the root permissions are checked first followed by selectors in the order they were added.</p>\n<p>For example, consider a user with the ACL rules <code>+GET ~key1 (+SET ~key2)</code>.<br>This user is able to execute <code>GET key1</code> and <code>SET key2 hello</code>, but not <code>GET key2</code> or <code>SET key1 world</code>.</p>\n<p>Unlike the user&#39;s root permissions, selectors cannot be modified after they are added.<br>Instead, selectors can be removed with the <code>clearselectors</code> keyword, which removes all of the added selectors.<br>Note that <code>clearselectors</code> does not remove the root permissions.</p>\n<h2>Key permissions</h2>\n<p>key patterns can also be used to define how a command is able to touch a key.<br>This is achieved through rules that define key permissions.<br>The key permission rules take the form of <code>%(&lt;permission&gt;)~&lt;pattern&gt;</code>.<br>Permissions are defined as individual characters that map to the following key permissions:</p>\n<ul>\n<li>W (Write): The data stored within the key may be updated or deleted. </li>\n<li>R (Read): User supplied data from the key is processed, copied or returned. Note that this does not include metadata such as size information (example <code>STRLEN</code>), type information (example <code>TYPE</code>) or information about whether a value exists within a collection (example <code>SISMEMBER</code>).</li>\n</ul>\n<p>Permissions can be composed together by specifying multiple characters.<br>Specifying the permission as &#39;RW&#39; is considered full access and is analogous to just passing in <code>~&lt;pattern&gt;</code>.</p>\n<p>For a concrete example, consider a user with ACL rules <code>+@all ~app1:* (+@read ~app2:*)</code>.<br>This user has full access on <code>app1:*</code> and readonly access on <code>app2:*</code>.<br>However, some commands support reading data from one key, doing some transformation, and storing it into another key.<br>One such command is the <code>COPY</code> command, which copies the data from the source key into the destination key.<br>The example set of ACL rules is unable to handle a request copying data from <code>app2:user</code> into <code>app1:user</code>, since neither the root permission nor the selector fully matches the command.<br>However, using key selectors you can define a set of ACL rules that can handle this request <code>+@all ~app1:* %R~app2:*</code>.<br>The first pattern is able to match <code>app1:user</code> and the second pattern is able to match <code>app2:user</code>.</p>\n<p>Which type of permission is required for a command is documented through <a href=\"key-specs.md#logical-operation-flags\">key specifications</a>.<br>The type of permission is based off the keys logical operation flags.<br>The insert, update, and delete flags map to the write key permission.<br>The access flag maps to the read key permission.<br>If the key has no logical operation flags, such as <code>EXISTS</code>, the user still needs either key read or key write permissions to execute the command. </p>\n<p>Note: Side channels to accessing user data are ignored when it comes to evaluating whether read permissions are required to execute a command.<br>This means that some write commands that return metadata about the modified key only require write permission on the key to execute.<br>For example, consider the following two commands:</p>\n<ul>\n<li><code>LPUSH key1 data</code>: modifies &quot;key1&quot; but only returns metadata about it, the size of the list after the push, so the command only requires write permission on &quot;key1&quot; to execute.</li>\n<li><code>LPOP key2</code>: modifies &quot;key2&quot; but also returns data from it, the left most item in the list, so the command requires both read and write permission on &quot;key2&quot; to execute.</li>\n</ul>\n<p>If an application needs to make sure no data is accessed from a key, including side channels, it&#39;s recommended to not provide any access to the key.</p>\n<h2>How passwords are stored internally</h2>\n<p>Valkey internally stores passwords hashed with SHA256. If you set a password<br>and check the output of <code>ACL LIST</code> or <code>ACL GETUSER</code>, you&#39;ll see a long hex<br>string that looks pseudo random. Here is an example, because in the previous<br>examples, for the sake of brevity, the long hex string was trimmed:</p>\n<pre><code>&gt; ACL GETUSER default\n1) &quot;flags&quot;\n2) 1) &quot;on&quot;\n3) &quot;passwords&quot;\n4) 1) &quot;2d9c75273d72b32df726fb545c8a4edc719f0a95a6fd993950b10c474ad9c927&quot;\n5) &quot;commands&quot;\n6) &quot;+@all&quot;\n7) &quot;keys&quot;\n8) &quot;~*&quot;\n9) &quot;channels&quot;\n10) &quot;&amp;*&quot;\n11) &quot;selectors&quot;\n12) (empty array)\n</code></pre>\n<p>Using SHA256 provides the ability to avoid storing the password in clear text<br>while still allowing for a very fast <code>AUTH</code> command, which is a very important<br>feature of Valkey and is coherent with what clients expect from Valkey.</p>\n<p>However ACL <em>passwords</em> are not really passwords. They are shared secrets<br>between the server and the client, because the password is<br>not an authentication token used by a human being. For instance:</p>\n<ul>\n<li>There are no length limits, the password will just be memorized in some client software. There is no human that needs to recall a password in this context.</li>\n<li>The ACL password does not protect any other thing. For example, it will never be the password for some email account.</li>\n<li>Often when you are able to access the hashed password itself, by having full access to the Valkey commands of a given server, or corrupting the system itself, you already have access to what the password is protecting: the Valkey instance stability and the data it contains.</li>\n</ul>\n<p>For this reason, slowing down the password authentication, in order to use an<br>algorithm that uses time and space to make password cracking hard,<br>is a very poor choice. What we suggest instead is to generate strong<br>passwords, so that nobody will be able to crack it using a<br>dictionary or a brute force attack even if they have the hash. To do so, there is a special ACL<br>command <code>ACL GENPASS</code> that generates passwords using the system cryptographic pseudorandom<br>generator:</p>\n<pre><code>&gt; ACL GENPASS\n&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;\n</code></pre>\n<p>The command outputs a 32-byte (256-bit) pseudorandom string converted to a<br>64-byte alphanumerical string. This is long enough to avoid attacks and short<br>enough to be easy to manage, cut &amp; paste, store, and so forth. This is what<br>you should use in order to generate Valkey passwords.</p>\n<h2>Use an external ACL file</h2>\n<p>There are two ways to store users inside the Valkey configuration:</p>\n<ol>\n<li>Users can be specified directly inside the <code>valkey.conf</code> file.</li>\n<li>It is possible to specify an external ACL file.</li>\n</ol>\n<p>The two methods are <em>mutually incompatible</em>, so Valkey will ask you to use one<br>or the other. Specifying users inside <code>valkey.conf</code> is<br>good for simple use cases. When there are multiple users to define, in a<br>complex environment, we recommend you use the ACL file instead.</p>\n<p>The format used inside <code>valkey.conf</code> and in the external ACL file is exactly<br>the same, so it is trivial to switch from one to the other, and is<br>the following:</p>\n<pre><code>user &lt;username&gt; ... acl rules ...\n</code></pre>\n<p>For instance:</p>\n<pre><code>user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99\n</code></pre>\n<p>When you want to use an external ACL file, you are required to specify<br>the configuration directive called <code>aclfile</code>, like this:</p>\n<pre><code>aclfile /etc/valkey/users.acl\n</code></pre>\n<p>When you are just specifying a few users directly inside the <code>valkey.conf</code><br>file, you can use <code>CONFIG REWRITE</code> in order to store the new user configuration<br>inside the file by rewriting it.</p>\n<p>The external ACL file however is more powerful. You can do the following:</p>\n<ul>\n<li>Use <code>ACL LOAD</code> if you modified the ACL file manually and you want Valkey to reload the new configuration. Note that this command is able to load the file <em>only if all the users are correctly specified</em>. Otherwise, an error is reported to the user, and the old configuration will remain valid.</li>\n<li>Use <code>ACL SAVE</code> to save the current ACL configuration to the ACL file.</li>\n</ul>\n<p>Note that <code>CONFIG REWRITE</code> does not also trigger <code>ACL SAVE</code>. When you use<br>an ACL file, the configuration and the ACLs are handled separately.</p>\n<h2>ACL rules for Sentinel and Replicas</h2>\n<p>In case you don&#39;t want to provide Valkey replicas and Valkey Sentinel instances<br>full access to your Valkey instances, the following is the set of commands<br>that must be allowed in order for everything to work correctly.</p>\n<p>For Sentinel, allow the user to access the following commands both in the primary and replica instances:</p>\n<ul>\n<li>AUTH, CLIENT, SUBSCRIBE, SCRIPT, PUBLISH, PING, INFO, MULTI, SLAVEOF, CONFIG, CLIENT, EXEC.</li>\n</ul>\n<p>Sentinel does not need to access any key in the database but does use Pub/Sub, so the ACL rule would be the following (note: <code>AUTH</code> is not needed since it is always allowed):</p>\n<pre><code>ACL SETUSER sentinel-user on &gt;somepassword allchannels +multi +slaveof +ping +exec +subscribe +config|rewrite +role +publish +info +client|setname +client|kill +script|kill\n</code></pre>\n<p>Valkey replicas require the following commands to be allowed on the primary instance:</p>\n<ul>\n<li>PSYNC, REPLCONF, PING</li>\n</ul>\n<p>No keys need to be accessed, so this translates to the following rules:</p>\n<pre><code>ACL setuser replica-user on &gt;somepassword +psync +replconf +ping\n</code></pre>\n<p>Note that you don&#39;t need to configure the replicas to allow the primary to be able to execute any set of commands. The primary is always authenticated as the root user from the point of view of replicas.</p>\n"
  },
  {
    "id": "cli",
    "topicName": "CLI",
    "description": "Valkey command line interface\n",
    "htmlContent": "<h2>Usage</h2>\n<p><strong><code>valkey-cli</code></strong> [<em>OPTIONS</em>] [<em>cmd</em> [<em>arg</em>...]]</p>\n<h2>Description</h2>\n<p>The Valkey command line interface is used for administration, troubleshooting and experimenting with Valkey.</p>\n<p>In interactive mode, <code>valkey-cli</code> has basic line editing capabilities to provide a familiar typing experience.</p>\n<p>To launch the program in special modes, you can use several options, including:</p>\n<ul>\n<li>Simulate a replica and print the replication stream it receives from the primary.</li>\n<li>Check the latency of a Valkey server and display statistics. </li>\n<li>Request ASCII-art spectrogram of latency samples and frequencies.</li>\n</ul>\n<p>This topic covers the different aspects of <code>valkey-cli</code>, starting from the simplest and ending with the more advanced features.</p>\n<h2>Options</h2>\n<p><strong><code>-h</code></strong> <em>hostname</em><br>: Server hostname (default: 127.0.0.1).</p>\n<p><strong><code>-p</code></strong> <em>port</em><br>: Server port (default: 6379).</p>\n<p><strong><code>-t</code></strong> <em>timeout</em><br>: Server connection timeout in seconds (decimals allowed).<br>  Default timeout is 0, meaning no limit, depending on the OS.</p>\n<p><strong><code>-s</code></strong> <em>socket</em><br>: Server socket (overrides hostname and port).</p>\n<p><strong><code>-a</code></strong> <em>password</em><br>: Password to use when connecting to the server.<br>  You can also use the <code>REDISCLI_AUTH</code> environment<br>  variable to pass this password more safely.<br>  (If both are used, this argument takes precedence.)</p>\n<p><strong><code>--user</code></strong> <em>username</em><br>: Used to send ACL style &#39;AUTH username pass&#39;. Needs <code>-a</code>.</p>\n<p><strong><code>--pass</code></strong> <em>password</em><br>: Alias of -a for consistency with the new --user option.</p>\n<p><strong><code>--askpass</code></strong><br>: Force user to input password with mask from STDIN.<br>  If this argument is used, <code>-a</code> and the <code>REDISCLI_AUTH</code><br>  environment variable will be ignored.</p>\n<p><strong><code>-u</code></strong> <em>uri</em><br>: Server URI on format <code>valkey://user:password@host:port/dbnum</code>.<br>  User, password and dbnum are optional. For authentication<br>  without a username, use username &#39;default&#39;. For TLS, use<br>  the scheme &#39;valkeys&#39;.</p>\n<p><strong><code>-r</code></strong> <em>repeat</em><br>: Execute specified command N times.</p>\n<p><strong><code>-i</code></strong> <em>interval</em><br>: When <code>-r</code> is used, waits <em>interval</em> seconds per command.<br>  It is possible to specify sub-second times like <code>-i 0.1</code>.<br>  This interval is also used in <code>--scan</code> and <code>--stat</code> per cycle.<br>  and in <code>--bigkeys</code>, <code>--memkeys</code>, and <code>--hotkeys</code> per 100 cycles.</p>\n<p><strong><code>-n</code></strong> <em>db</em><br>: Database number.</p>\n<p><strong><code>-2</code></strong><br>: Start session in RESP2 protocol mode.</p>\n<p><strong><code>-3</code></strong><br>: Start session in RESP3 protocol mode.</p>\n<p><strong><code>-x</code></strong><br>: Read last argument from STDIN (see example below).</p>\n<p><strong><code>-X</code></strong><br>: Read <tag> argument from STDIN (see example below).</p>\n<p><strong><code>-d</code></strong> <em>delimiter</em><br>: Delimiter between response bulks for raw formatting (default: <code>\\n</code>).</p>\n<p><strong><code>-D</code></strong> <em>delimiter</em><br>: Delimiter between responses for raw formatting (default: <code>\\n</code>).</p>\n<p><strong><code>-c</code></strong><br>: Enable cluster mode (follow -ASK and -MOVED redirections).</p>\n<p><strong><code>-e</code></strong><br>: Return exit error code when command execution fails.</p>\n<p><strong><code>-4</code></strong><br>: Prefer IPv4 over IPv6 on DNS lookup.</p>\n<p><strong><code>-6</code></strong><br>: Prefer IPv6 over IPv4 on DNS lookup.&#39;</p>\n<p><strong><code>--tls</code></strong><br>: Establish a secure TLS connection.</p>\n<p><strong><code>--sni</code></strong> <em>host</em><br>: Server name indication for TLS.</p>\n<p><strong><code>--cacert</code></strong> <em>file</em><br>: CA Certificate file to verify with.</p>\n<p><strong><code>--cacertdir</code></strong> <em>dir</em><br>: Directory where trusted CA certificates are stored.<br>  If neither cacert nor cacertdir are specified, the default<br>  system-wide trusted root certs configuration will apply.</p>\n<p><strong><code>--insecure</code></strong><br>: Allow insecure TLS connection by skipping cert validation.</p>\n<p><strong><code>--cert</code></strong> <em>file</em><br>: Client certificate to authenticate with.</p>\n<p><strong><code>--key</code></strong> <em>file</em><br>: Private key file to authenticate with.</p>\n<p><strong><code>--tls-ciphers</code></strong> <em>list</em><br>: Sets the list of preferred ciphers (TLSv1.2 and below)<br>  in order of preference from highest to lowest separated by colon (&quot;:&quot;).<br>  See the <strong>ciphers</strong>(1ssl) manpage for more information about the syntax of this string.</p>\n<p><strong><code>--tls-ciphersuites</code></strong> <em>list</em><br>: Sets the list of preferred ciphersuites (TLSv1.3)<br>  in order of preference from highest to lowest separated by colon (&quot;:&quot;).<br>  See the <strong>ciphers</strong>(1ssl) manpage for more information about the syntax of this string,<br>  and specifically for TLSv1.3 ciphersuites.</p>\n<p><strong><code>--raw</code></strong><br>: Use raw formatting for replies (default when STDOUT is<br>  not a tty).</p>\n<p><strong><code>--no-raw</code></strong><br>: Force formatted output even when STDOUT is not a tty.</p>\n<p><strong><code>--quoted-input</code></strong><br>: Force input to be handled as quoted strings.</p>\n<p><strong><code>--csv</code></strong><br>: Output in CSV format.</p>\n<p><strong><code>--json</code></strong><br>: Output in JSON format (default RESP3, use -2 if you want to use with RESP2).</p>\n<p><strong><code>--quoted-json</code></strong><br>: Same as --json, but produce ASCII-safe quoted strings, not Unicode.</p>\n<p><strong><code>--show-pushes</code></strong> <strong><code>yes</code></strong>|<strong><code>no</code></strong><br>: Whether to print RESP3 PUSH messages.  Enabled by default when<br>  STDOUT is a tty but can be overridden with --show-pushes no.</p>\n<p><strong><code>--stat</code></strong><br>: Print rolling stats about server: mem, clients, ...</p>\n<p><strong><code>--latency</code></strong><br>: Enter a special mode continuously sampling latency.<br>  If you use this mode in an interactive session it runs<br>  forever displaying real-time stats. Otherwise if <code>--raw</code> or<br>  <code>--csv</code> is specified, or if you redirect the output to a non<br>  TTY, it samples the latency for 1 second (you can use<br>  <code>-i</code> to change the interval), then produces a single output<br>  and exits.</p>\n<p><strong><code>--latency-history</code></strong><br>: Like <code>--latency</code> but tracking latency changes over time.<br>  Default time interval is 15 sec. Change it using <code>-i</code>.</p>\n<p><strong><code>--latency-dist</code></strong><br>: Shows latency as a spectrum, requires xterm 256 colors.<br>  Default time interval is 1 sec. Change it using <code>-i</code>.</p>\n<p><strong><code>--lru-test</code></strong> <em>keys</em><br>: Simulate a cache workload with an 80-20 distribution.</p>\n<p><strong><code>--replica</code></strong><br>: Simulate a replica showing commands received from the primary.</p>\n<p><strong><code>--rdb</code></strong> <em>filename</em><br>: Transfer an RDB dump from remote server to local file.<br>  Use filename of &quot;-&quot; to write to stdout.</p>\n<p><strong><code>--functions-rdb</code></strong> <em>filename</em><br>: Like <code>--rdb</code> but only get the functions (not the keys)<br>  when getting the RDB dump file.</p>\n<p><strong><code>--pipe</code></strong><br>: Transfer raw RESP protocol from stdin to server.</p>\n<p><strong><code>--pipe-timeout</code></strong> <em>n</em><br>: In <code>--pipe</code> mode, abort with error if after sending all data.<br>  no reply is received within <em>n</em> seconds.<br>  Default timeout: 30. Use 0 to wait forever.</p>\n<p><strong><code>--bigkeys</code></strong><br>: Sample keys looking for keys with many elements (complexity).</p>\n<p><strong><code>--memkeys</code></strong><br>: Sample keys looking for keys consuming a lot of memory.</p>\n<p><strong><code>--memkeys-samples</code></strong> <em>n</em><br>: Sample keys looking for keys consuming a lot of memory.<br>  And define number of key elements to sample</p>\n<p><strong><code>--hotkeys</code></strong><br>: Sample keys looking for hot keys.<br>  only works when maxmemory-policy is <code>*lfu</code>.</p>\n<p><strong><code>--scan</code></strong><br>: List all keys using the SCAN command.</p>\n<p><strong><code>--pattern</code></strong> <em>pat</em><br>: Keys pattern when using the <code>--scan</code>, <code>--bigkeys</code> or <code>--hotkeys</code><br>  options (default: <code>*</code>).</p>\n<p><strong><code>--count</code></strong> <em>count</em><br>: Count option when using the <code>--scan</code>, <code>--bigkeys</code> or <code>--hotkeys</code> (default: 10).</p>\n<p><strong><code>--quoted-pattern</code></strong> <em>pat</em><br>: Same as <code>--pattern</code>, but the specified string can be<br>  quoted, in order to pass an otherwise non binary-safe string.</p>\n<p><strong><code>--intrinsic-latency</code></strong> <em>sec</em><br>: Run a test to measure intrinsic system latency.<br>  The test will run for the specified amount of seconds.</p>\n<p><strong><code>--eval</code></strong> <em>file</em><br>: Send an EVAL command using the Lua script at <em>file</em>.</p>\n<p><strong><code>--ldb</code></strong><br>: Used with <code>--eval</code> enable the Server Lua debugger.</p>\n<p><strong><code>--ldb-sync-mode</code></strong><br>: Like <code>--ldb</code> but uses the synchronous Lua debugger, in<br>  this mode the server is blocked and script changes are<br>  not rolled back from the server memory.</p>\n<p><strong><code>--cluster</code></strong> <em>command</em> [<em>args</em>...] [<em>opts</em>...]<br>: Cluster Manager command and arguments (see below).</p>\n<p><strong><code>--verbose</code></strong><br>: Verbose mode.</p>\n<p><strong><code>--no-auth-warning</code></strong><br>: Don&#39;t show warning message when using password on command<br>  line interface.</p>\n<p><strong><code>--help</code></strong><br>: Output help and exit.</p>\n<p><strong><code>--version</code></strong><br>: Output version and exit.</p>\n<h2>Cluster Manager commands</h2>\n<p>For management of <a href=\"cluster-tutorial.md\">Valkey Cluster</a>, the following syntax is used:</p>\n<p><strong><code>valkey-cli</code></strong> <strong><code>--cluster</code></strong> <em>command</em> [<em>args</em>...] [<em>opts</em>...]</p>\n<pre><code>  Command        Args\n  --------------------------------------------------------------------------------\n  create         host1:port1 ... hostN:portN\n                 --cluster-replicas &lt;arg&gt;\n  check          &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n                 --cluster-search-multiple-owners\n  info           &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n  fix            &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n                 --cluster-search-multiple-owners\n                 --cluster-fix-with-unreachable-masters\n  reshard        &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n                 --cluster-from &lt;arg&gt;\n                 --cluster-to &lt;arg&gt;\n                 --cluster-slots &lt;arg&gt;\n                 --cluster-yes\n                 --cluster-timeout &lt;arg&gt;\n                 --cluster-pipeline &lt;arg&gt;\n                 --cluster-replace\n  rebalance      &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;\n                 --cluster-use-empty-masters\n                 --cluster-timeout &lt;arg&gt;\n                 --cluster-simulate\n                 --cluster-pipeline &lt;arg&gt;\n                 --cluster-threshold &lt;arg&gt;\n                 --cluster-replace\n  add-node       new_host:new_port existing_host:existing_port\n                 --cluster-replica\n                 --cluster-master-id &lt;arg&gt;\n  del-node       host:port node_id\n  call           host:port command arg arg .. arg\n                 --cluster-only-masters\n                 --cluster-only-replicas\n  set-timeout    host:port milliseconds\n  import         host:port\n                 --cluster-from &lt;arg&gt;\n                 --cluster-from-user &lt;arg&gt;\n                 --cluster-from-pass &lt;arg&gt;\n                 --cluster-from-askpass\n                 --cluster-copy\n                 --cluster-replace\n  backup         host:port backup_directory\n  help\n</code></pre>\n<h2>Command line usage</h2>\n<p>To run a Valkey command and return a standard output at the terminal, include the command to execute as separate arguments of <code>valkey-cli</code>:</p>\n<pre><code>$ valkey-cli INCR mycounter\n(integer) 7\n</code></pre>\n<p>The reply of the command is &quot;7&quot;. Since Valkey replies are typed (strings, arrays, integers, nil, errors, etc.), you see the type of the reply between parentheses. This additional information may not be ideal when the output of <code>valkey-cli</code> must be used as input of another command or redirected into a file.</p>\n<p><code>valkey-cli</code> only shows additional information for human readability when it detects the standard output is a tty, or terminal. For all other outputs it will auto-enable the <em>raw output mode</em>, as in the following example:</p>\n<pre><code>$ valkey-cli INCR mycounter &gt; /tmp/output.txt\n$ cat /tmp/output.txt\n8\n</code></pre>\n<p>Note that <code>(integer)</code> is omitted from the output because <code>valkey-cli</code> detects<br>the output is no longer written to the terminal. You can force raw output<br>even on the terminal with the <code>--raw</code> option:</p>\n<pre><code>$ valkey-cli --raw INCR mycounter\n9\n</code></pre>\n<p>You can force human readable output when writing to a file or in<br>pipe to other commands by using <code>--no-raw</code>.</p>\n<h2>String quoting and escaping</h2>\n<p>When <code>valkey-cli</code> parses a command, whitespace characters automatically delimit the arguments.<br>In interactive mode, a newline sends the command for parsing and execution.<br>To input string values that contain whitespaces or non-printable characters, you can use quoted and escaped strings.</p>\n<p>Quoted string values are enclosed in double (<code>&quot;</code>) or single (<code>&#39;</code>) quotation marks.<br>Escape sequences are used to put nonprintable characters in character and string literals.</p>\n<p>An escape sequence contains a backslash (<code>\\</code>) symbol followed by one of the escape sequence characters.</p>\n<p>Doubly-quoted strings support the following escape sequences:</p>\n<ul>\n<li><code>\\&quot;</code> - double-quote</li>\n<li><code>\\n</code> - newline</li>\n<li><code>\\r</code> - carriage return</li>\n<li><code>\\t</code> - horizontal tab</li>\n<li><code>\\b</code> - backspace</li>\n<li><code>\\a</code> - alert</li>\n<li><code>\\\\</code> - backslash</li>\n<li><code>\\xhh</code> - any ASCII character represented by a hexadecimal number (<em>hh</em>)</li>\n</ul>\n<p>Single quotes assume the string is literal, and allow only the following escape sequences:</p>\n<ul>\n<li><code>\\&#39;</code> - single quote</li>\n<li><code>\\\\</code> - backslash</li>\n</ul>\n<p>For example, to return <code>Hello World</code> on two lines:</p>\n<pre><code>127.0.0.1:6379&gt; SET mykey &quot;Hello\\nWorld&quot;\nOK\n127.0.0.1:6379&gt; GET mykey\nHello\nWorld\n</code></pre>\n<p>When you input strings that contain single or double quotes, as you might in passwords, for example, escape the string, like so: </p>\n<pre><code>127.0.0.1:6379&gt; AUTH some_admin_user &quot;&gt;^8T&gt;6Na{u|jp&gt;+v\\&quot;55\\@_;OU(OR]7mbAYGqsfyu48(j&#39;%hQH7;v*f1H${*gD(Se&#39;&quot;\n</code></pre>\n<h2>Host, port, password, and database</h2>\n<p>By default, <code>valkey-cli</code> connects to the server at the address 127.0.0.1 with port 6379.<br>You can change the port using several command line options. To specify a different host name or an IP address, use the <code>-h</code> option. In order to set a different port, use <code>-p</code>.</p>\n<pre><code>$ valkey-cli -h valkey15.example.com -p 6390 PING\nPONG\n</code></pre>\n<p>If your instance is password protected, the <code>-a &lt;password&gt;</code> option will<br>perform authentication saving the need of explicitly using the <code>AUTH</code> command:</p>\n<pre><code>$ valkey-cli -a myUnguessablePazzzzzword123 PING\nPONG\n</code></pre>\n<p><strong>NOTE:</strong> For security reasons, provide the password to <code>valkey-cli</code> automatically via the<br><code>REDISCLI_AUTH</code> environment variable.</p>\n<p>Finally, it&#39;s possible to send a command that operates on a database number<br>other than the default number zero by using the <code>-n &lt;dbnum&gt;</code> option:</p>\n<pre><code>$ valkey-cli FLUSHALL\nOK\n$ valkey-cli -n 1 INCR a\n(integer) 1\n$ valkey-cli -n 1 INCR a\n(integer) 2\n$ valkey-cli -n 2 INCR a\n(integer) 1\n</code></pre>\n<p>Some or all of this information can also be provided by using the <code>-u &lt;uri&gt;</code><br>option and the URI pattern <code>valkey://user:password@host:port/dbnum</code>:</p>\n<pre><code>$ valkey-cli -u valkey://LJenkins:p%40ssw0rd@valkey-16379.example.com:16379/0 PING\nPONG\n</code></pre>\n<p><strong>NOTE:</strong><br>User, password and dbnum are optional.<br>For authentication without a username, use username <code>default</code>.<br>For TLS, use the scheme <code>valkeys</code>.</p>\n<h2>SSL/TLS</h2>\n<p>By default, <code>valkey-cli</code> uses a plain TCP connection to connect to Valkey.<br>You may enable SSL/TLS using the <code>--tls</code> option, along with <code>--cacert</code> or<br><code>--cacertdir</code> to configure a trusted root certificate bundle or directory.</p>\n<p>If the target server requires authentication using a client side certificate,<br>you can specify a certificate and a corresponding private key using <code>--cert</code> and<br><code>--key</code>.</p>\n<h2>Getting input from other programs</h2>\n<p>There are two ways you can use <code>valkey-cli</code> in order to receive input from other<br>commands via the standard input. One is to use the target payload as the last argument<br>from <em>stdin</em>. For example, in order to set the Valkey key <code>net_services</code><br>to the content of the file <code>/etc/services</code> from a local file system, use the <code>-x</code><br>option:</p>\n<pre><code>$ valkey-cli -x SET net_services &lt; /etc/services\nOK\n$ valkey-cli GETRANGE net_services 0 50\n&quot;#\\n# Network services, Internet style\\n#\\n# Note that &quot;\n</code></pre>\n<p>In the first line of the above session, <code>valkey-cli</code> was executed with the <code>-x</code> option and a file was redirected to the CLI&#39;s<br>standard input as the value to satisfy the <code>SET net_services</code> command phrase. This is useful for scripting.</p>\n<p>A different approach is to feed <code>valkey-cli</code> a sequence of commands written in a<br>text file:</p>\n<pre><code>$ cat /tmp/commands.txt\nSET item:3374 100\nINCR item:3374\nAPPEND item:3374 xxx\nGET item:3374\n$ cat /tmp/commands.txt | valkey-cli\nOK\n(integer) 101\n(integer) 6\n&quot;101xxx&quot;\n</code></pre>\n<p>All the commands in <code>commands.txt</code> are executed consecutively by<br><code>valkey-cli</code> as if they were typed by the user in interactive mode. Strings can be<br>quoted inside the file if needed, so that it&#39;s possible to have single<br>arguments with spaces, newlines, or other special characters:</p>\n<pre><code>$ cat /tmp/commands.txt\nSET arg_example &quot;This is a single argument&quot;\nSTRLEN arg_example\n$ cat /tmp/commands.txt | valkey-cli\nOK\n(integer) 25\n</code></pre>\n<h2>Continuously run the same command</h2>\n<p>It is possible to execute a single command a specified number of times<br>with a user-selected pause between executions. This is useful in<br>different contexts - for example when we want to continuously monitor some<br>key content or <code>INFO</code> field output, or when we want to simulate some<br>recurring write event, such as pushing a new item into a list every 5 seconds.</p>\n<p>This feature is controlled by two options: <code>-r &lt;count&gt;</code> and <code>-i &lt;delay&gt;</code>.<br>The <code>-r</code> option states how many times to run a command and <code>-i</code> sets<br>the delay between the different command calls in seconds (with the ability<br>to specify values such as 0.1 to represent 100 milliseconds).</p>\n<p>By default the interval (or delay) is set to 0, so commands are just executed<br>ASAP:</p>\n<pre><code>$ valkey-cli -r 5 INCR counter_value\n(integer) 1\n(integer) 2\n(integer) 3\n(integer) 4\n(integer) 5\n</code></pre>\n<p>To run the same command indefinitely, use <code>-1</code> as the count value.<br>To monitor over time the RSS memory size it&#39;s possible to use the following command:</p>\n<pre><code>$ valkey-cli -r -1 -i 1 INFO | grep rss_human\nused_memory_rss_human:2.71M\nused_memory_rss_human:2.73M\nused_memory_rss_human:2.73M\nused_memory_rss_human:2.73M\n... a new line will be printed each second ...\n</code></pre>\n<h2>Mass insertion of data using <code>valkey-cli</code></h2>\n<p>Mass insertion using <code>valkey-cli</code> is covered in a separate page as it is a<br>worthwhile topic itself. Please refer to our <a href=\"mass-insertion.md\">mass insertion guide</a>.</p>\n<h2>CSV output</h2>\n<p>A CSV (Comma Separated Values) output feature exists within <code>valkey-cli</code> to export data from Valkey to an external program.  </p>\n<pre><code>$ valkey-cli LPUSH mylist a b c d\n(integer) 4\n$ valkey-cli --csv LRANGE mylist 0 -1\n&quot;d&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;\n</code></pre>\n<p>Note that the <code>--csv</code> flag will only work on a single command, not the entirety of a DB as an export.</p>\n<h2>Running Lua scripts</h2>\n<p>The <code>valkey-cli</code> has extensive support for using the debugging facility<br>of Lua scripting, available with Valkey 3.2 onwards. For this feature, refer to the <a href=\"ldb.md\">Valkey Lua debugger documentation</a>.</p>\n<p>Even without using the debugger, <code>valkey-cli</code> can be used to<br>run scripts from a file as an argument:</p>\n<pre><code>$ cat /tmp/script.lua\nreturn server.call(&#39;SET&#39;,KEYS[1],ARGV[1])\n$ valkey-cli --eval /tmp/script.lua location:hastings:temp , 23\nOK\n</code></pre>\n<p>The Valkey <code>EVAL</code> command takes the list of keys the script uses, and the<br>other non key arguments, as different arrays. When calling <code>EVAL</code> you<br>provide the number of keys as a number. </p>\n<p>When calling <code>valkey-cli</code> with the <code>--eval</code> option above, there is no need to specify the number of keys<br>explicitly. Instead it uses the convention of separating keys and arguments<br>with a comma. This is why in the above call you see <code>location:hastings:temp , 23</code> as arguments.</p>\n<p>So <code>location:hastings:temp</code> will populate the <code>KEYS</code> array, and <code>23</code> the <code>ARGV</code> array.</p>\n<p>The <code>--eval</code> option is useful when writing simple scripts. For more<br>complex work, the Lua debugger is recommended. It is possible to mix the two approaches, since the debugger can also execute scripts from an external file.</p>\n<h1>Interactive mode</h1>\n<p>We have explored how to use the Valkey CLI as a command line program.<br>This is useful for scripts and certain types of testing, however most<br>people will spend the majority of time in <code>valkey-cli</code> using its interactive<br>mode.</p>\n<p>In interactive mode the user types Valkey commands at the prompt. The command<br>is sent to the server, processed, and the reply is parsed back and rendered<br>into a simpler form to read.</p>\n<p>Nothing special is needed for running the <code>valkey-cli</code> in interactive mode -<br>just execute it without any arguments</p>\n<pre><code>$ valkey-cli\n127.0.0.1:6379&gt; PING\nPONG\n</code></pre>\n<p>The string <code>127.0.0.1:6379&gt;</code> is the prompt. It displays the connected Valkey server instance&#39;s hostname and port.</p>\n<p>The prompt updates as the connected server changes or when operating on a database different from the database number zero:</p>\n<pre><code>127.0.0.1:6379&gt; SELECT 2\nOK\n127.0.0.1:6379[2]&gt; DBSIZE\n(integer) 1\n127.0.0.1:6379[2]&gt; SELECT 0\nOK\n127.0.0.1:6379&gt; DBSIZE\n(integer) 503\n</code></pre>\n<h2>Handling connections and reconnections</h2>\n<p>Using the <code>CONNECT</code> command in interactive mode makes it possible to connect<br>to a different instance, by specifying the <em>hostname</em> and <em>port</em> we want<br>to connect to:</p>\n<pre><code>127.0.0.1:6379&gt; CONNECT metal 6379\nmetal:6379&gt; PING\nPONG\n</code></pre>\n<p>As you can see the prompt changes accordingly when connecting to a different server instance.<br>If a connection is attempted to an instance that is unreachable, the <code>valkey-cli</code> goes into disconnected<br>mode and attempts to reconnect with each new command:</p>\n<pre><code>127.0.0.1:6379&gt; CONNECT 127.0.0.1 9999\nCould not connect to Valkey at 127.0.0.1:9999: Connection refused\nnot connected&gt; PING\nCould not connect to Valkey at 127.0.0.1:9999: Connection refused\nnot connected&gt; PING\nCould not connect to Valkey at 127.0.0.1:9999: Connection refused\n</code></pre>\n<p>Generally after a disconnection is detected, <code>valkey-cli</code> always attempts to<br>reconnect transparently; if the attempt fails, it shows the error and<br>enters the disconnected state. The following is an example of disconnection<br>and reconnection:</p>\n<pre><code>127.0.0.1:6379&gt; INFO SERVER\nCould not connect to Valkey at 127.0.0.1:6379: Connection refused\nnot connected&gt; PING\nPONG\n127.0.0.1:6379&gt; \n(now we are connected again)\n</code></pre>\n<p>When a reconnection is performed, <code>valkey-cli</code> automatically re-selects the<br>last database number selected. However, all other states about the<br>connection is lost, such as within a MULTI/EXEC transaction:</p>\n<pre><code>$ valkey-cli\n127.0.0.1:6379&gt; MULTI\nOK\n127.0.0.1:6379&gt; PING\nQUEUED\n\n( here the server is manually restarted )\n\n127.0.0.1:6379&gt; EXEC\n(error) ERR EXEC without MULTI\n</code></pre>\n<p>This is usually not an issue when using the <code>valkey-cli</code> in interactive mode for<br>testing, but this limitation should be known.</p>\n<h2>Editing, history, completion and hints</h2>\n<p>Because <code>valkey-cli</code> uses the &quot;linenoise&quot; line editing library shipped with<br>Valkey, it has line editing capabilities without depending on <code>libreadline</code> or<br>other optional libraries.</p>\n<p>Command execution history can be accessed in order to avoid retyping commands by pressing the arrow keys (up and down).<br>The history is preserved between restarts of the CLI, in a file named<br><code>.valkeycli_history</code> inside the user home directory, as specified<br>by the <code>HOME</code> environment variable. It is possible to use a different<br>history filename by setting the <code>REDISCLI_HISTFILE</code> environment variable,<br>and disable it by setting it to <code>/dev/null</code>.</p>\n<p>The <code>valkey-cli</code> is also able to perform command-name completion by pressing the TAB<br>key, as in the following example:</p>\n<pre><code>127.0.0.1:6379&gt; Z&lt;TAB&gt;\n127.0.0.1:6379&gt; ZADD&lt;TAB&gt;\n127.0.0.1:6379&gt; ZCARD&lt;TAB&gt;\n</code></pre>\n<p>Once Valkey command name has been entered at the prompt, the <code>valkey-cli</code> will display<br>syntax hints. Like command history, this behavior can be turned on and off via the <code>valkey-cli</code> preferences.</p>\n<h2>Preferences</h2>\n<p>There are two ways to customize <code>valkey-cli</code> behavior. The file <code>.valkeyclirc</code><br>in the home directory is loaded by the CLI on startup. You can override the<br>file&#39;s default location by setting the <code>REDISCLI_RCFILE</code> environment variable to<br>an alternative path. Preferences can also be set during a CLI session, in which<br>case they will last only the duration of the session.</p>\n<p>To set preferences, use the special <code>:set</code> command. The following preferences<br>can be set, either by typing the command in the CLI or adding it to the<br><code>.valkeyclirc</code> file:</p>\n<ul>\n<li><code>:set hints</code> - enables syntax hints</li>\n<li><code>:set nohints</code> - disables syntax hints</li>\n</ul>\n<h2>Running the same command N times</h2>\n<p>It is possible to run the same command multiple times in interactive mode by prefixing the command<br>name by a number:</p>\n<pre><code>127.0.0.1:6379&gt; 5 INCR mycounter\n(integer) 1\n(integer) 2\n(integer) 3\n(integer) 4\n(integer) 5\n</code></pre>\n<h2>Showing help about Valkey commands</h2>\n<p><code>valkey-cli</code> provides online help for most Valkey <a href=\"../commands/\">commands</a>, using the <code>HELP</code> command. The command can be used<br>in two forms:</p>\n<ul>\n<li><code>HELP @&lt;category&gt;</code> shows all the commands about a given category. The<br>categories are: <ul>\n<li><code>@generic</code></li>\n<li><code>@string</code></li>\n<li><code>@list</code></li>\n<li><code>@set</code></li>\n<li><code>@sorted_set</code></li>\n<li><code>@hash</code></li>\n<li><code>@pubsub</code></li>\n<li><code>@transactions</code></li>\n<li><code>@connection</code></li>\n<li><code>@server</code></li>\n<li><code>@scripting</code></li>\n<li><code>@hyperloglog</code></li>\n<li><code>@cluster</code></li>\n<li><code>@geo</code></li>\n<li><code>@stream</code></li>\n</ul>\n</li>\n<li><code>HELP &lt;commandname&gt;</code> shows specific help for the command given as argument.</li>\n</ul>\n<p>For example in order to show help for the <code>PFADD</code> command, use:</p>\n<pre><code>127.0.0.1:6379&gt; HELP PFADD\n\nPFADD key element [element ...]\nsummary: Adds the specified elements to the specified HyperLogLog.\nsince: 2.8.9\n</code></pre>\n<p>Note that <code>HELP</code> supports TAB completion as well.</p>\n<h2>Clearing the terminal screen</h2>\n<p>Using the <code>CLEAR</code> command in interactive mode clears the terminal&#39;s screen.</p>\n<h1>Special modes of operation</h1>\n<p>So far we saw two main modes of <code>valkey-cli</code>.</p>\n<ul>\n<li>Command line execution of Valkey commands.</li>\n<li>Interactive &quot;REPL&quot; usage.</li>\n</ul>\n<p>The CLI performs other auxiliary tasks related to Valkey that<br>are explained in the next sections:</p>\n<ul>\n<li>Monitoring tool to show continuous stats about a Valkey server.</li>\n<li>Scanning a Valkey database for very large keys.</li>\n<li>Key space scanner with pattern matching.</li>\n<li>Acting as a <a href=\"pubsub.md\">Pub/Sub</a> client to subscribe to channels.</li>\n<li>Monitoring the commands executed into a Valkey instance.</li>\n<li>Checking the <a href=\"latency.md\">latency</a> of a Valkey server in different ways.</li>\n<li>Checking the scheduler latency of the local computer.</li>\n<li>Transferring RDB backups from a remote Valkey server locally.</li>\n<li>Acting as a Valkey replica for showing what a replica receives.</li>\n<li>Simulating <a href=\"lru-cache.md\">LRU</a> workloads for showing stats about keys hits.</li>\n<li>A client for the Lua debugger.</li>\n</ul>\n<h2>Continuous stats mode</h2>\n<p>Continuous stats mode is probably one of the lesser known yet very useful features of <code>valkey-cli</code> to monitor Valkey instances in real time. To enable this mode, the <code>--stat</code> option is used.<br>The output is very clear about the behavior of the CLI in this mode:</p>\n<pre><code>$ valkey-cli --stat\n------- data ------ --------------------- load -------------------- - child -\nkeys       mem      clients blocked requests            connections\n506        1015.00K 1       0       24 (+0)             7\n506        1015.00K 1       0       25 (+1)             7\n506        3.40M    51      0       60461 (+60436)      57\n506        3.40M    51      0       146425 (+85964)     107\n507        3.40M    51      0       233844 (+87419)     157\n507        3.40M    51      0       321715 (+87871)     207\n508        3.40M    51      0       408642 (+86927)     257\n508        3.40M    51      0       497038 (+88396)     257\n</code></pre>\n<p>In this mode a new line is printed every second with useful information and differences of request values between old data points. Memory usage, client connection counts, and various other statistics about the connected Valkey database can be easily understood with this auxiliary <code>valkey-cli</code> tool.</p>\n<p>The <code>-i &lt;interval&gt;</code> option in this case works as a modifier in order to<br>change the frequency at which new lines are emitted. The default is one<br>second.</p>\n<h2>Scanning for big keys</h2>\n<p>In this special mode, <code>valkey-cli</code> works as a key space analyzer. It scans the<br>dataset for big keys, but also provides information about the data types<br>that the data set consists of. This mode is enabled with the <code>--bigkeys</code> option,<br>and produces verbose output:</p>\n<pre><code>$ valkey-cli --bigkeys\n\n# Scanning the entire keyspace to find biggest keys as well as\n# average sizes per key type.  You can use -i 0.01 to sleep 0.01 sec\n# per SCAN command (not usually needed).\n\n[00.00%] Biggest string found so far &#39;key-419&#39; with 3 bytes\n[05.14%] Biggest list   found so far &#39;mylist&#39; with 100004 items\n[35.77%] Biggest string found so far &#39;counter:__rand_int__&#39; with 6 bytes\n[73.91%] Biggest hash   found so far &#39;myobject&#39; with 3 fields\n\n-------- summary -------\n\nSampled 506 keys in the keyspace!\nTotal key length in bytes is 3452 (avg len 6.82)\n\nBiggest string found &#39;counter:__rand_int__&#39; has 6 bytes\nBiggest   list found &#39;mylist&#39; has 100004 items\nBiggest   hash found &#39;myobject&#39; has 3 fields\n\n504 strings with 1403 bytes (99.60% of keys, avg size 2.78)\n1 lists with 100004 items (00.20% of keys, avg size 100004.00)\n0 sets with 0 members (00.00% of keys, avg size 0.00)\n1 hashs with 3 fields (00.20% of keys, avg size 3.00)\n0 zsets with 0 members (00.00% of keys, avg size 0.00)\n</code></pre>\n<p>In the first part of the output, each new key larger than the previous larger<br>key (of the same type) encountered is reported. The summary section<br>provides general stats about the data inside the Valkey instance.</p>\n<p>The program uses the <code>SCAN</code> command, so it can be executed against a busy<br>server without impacting the operations, however the <code>-i</code> option can be<br>used in order to throttle the scanning process of the specified fraction<br>of second for each <code>SCAN</code> command. </p>\n<p>For example, <code>-i 0.01</code> will slow down the program execution considerably, but will also reduce the load on the server<br>to a negligible amount.</p>\n<p>Note that the summary also reports in a cleaner form the biggest keys found<br>for each time. The initial output is just to provide some interesting info<br>ASAP if running against a very large data set.</p>\n<h2>Getting a list of keys</h2>\n<p>It is also possible to scan the key space, again in a way that does not<br>block the Valkey server (which does happen when you use a command<br>like <code>KEYS *</code>), and print all the key names, or filter them for specific<br>patterns. This mode, like the <code>--bigkeys</code> option, uses the <code>SCAN</code> command,<br>so keys may be reported multiple times if the dataset is changing, but no<br>key would ever be missing, if that key was present since the start of the<br>iteration. Because of the command that it uses this option is called <code>--scan</code>.</p>\n<pre><code>$ valkey-cli --scan | head -10\nkey-419\nkey-71\nkey-236\nkey-50\nkey-38\nkey-458\nkey-453\nkey-499\nkey-446\nkey-371\n</code></pre>\n<p>Note that <code>head -10</code> is used in order to print only the first ten lines of the<br>output.</p>\n<p>Scanning is able to use the underlying pattern matching capability of<br>the <code>SCAN</code> command with the <code>--pattern</code> option.</p>\n<pre><code>$ valkey-cli --scan --pattern &#39;*-11*&#39;\nkey-114\nkey-117\nkey-118\nkey-113\nkey-115\nkey-112\nkey-119\nkey-11\nkey-111\nkey-110\nkey-116\n</code></pre>\n<p>Piping the output through the <code>wc</code> command can be used to count specific<br>kind of objects, by key name:</p>\n<pre><code>$ valkey-cli --scan --pattern &#39;user:*&#39; | wc -l\n3829433\n</code></pre>\n<p>You can use <code>-i 0.01</code> to add a delay between calls to the <code>SCAN</code> command.<br>This will make the command slower but will significantly reduce load on the server.</p>\n<h2>Pub/sub mode</h2>\n<p>The CLI is able to publish messages in Valkey Pub/Sub channels using<br>the <code>PUBLISH</code> command. Subscribing to channels in order to receive<br>messages is different - the terminal is blocked and waits for<br>messages, so this is implemented as a special mode in <code>valkey-cli</code>. Unlike<br>other special modes this mode is not enabled by using a special option,<br>but simply by using the <code>SUBSCRIBE</code> or <code>PSUBSCRIBE</code> command, which are available in<br>interactive or command mode:</p>\n<pre><code>$ valkey-cli PSUBSCRIBE &#39;*&#39;\nReading messages... (press Ctrl-C to quit)\n1) &quot;PSUBSCRIBE&quot;\n2) &quot;*&quot;\n3) (integer) 1\n</code></pre>\n<p>The <em>reading messages</em> message shows that we entered Pub/Sub mode.<br>When another client publishes some message in some channel, such as with the command <code>valkey-cli PUBLISH mychannel mymessage</code>, the CLI in Pub/Sub mode will show something such as:</p>\n<pre><code>1) &quot;pmessage&quot;\n2) &quot;*&quot;\n3) &quot;mychannel&quot;\n4) &quot;mymessage&quot;\n</code></pre>\n<p>This is very useful for debugging Pub/Sub issues.<br>To exit the Pub/Sub mode just process <code>CTRL-C</code>.</p>\n<h2>Monitoring commands executed in Valkey</h2>\n<p>Similarly to the Pub/Sub mode, the monitoring mode is entered automatically<br>once you use the <code>MONITOR</code> command. All commands received by the active Valkey instance will be printed to the standard output:</p>\n<pre><code>$ valkey-cli MONITOR\nOK\n1460100081.165665 [0 127.0.0.1:51706] &quot;set&quot; &quot;shipment:8000736522714:status&quot; &quot;sorting&quot;\n1460100083.053365 [0 127.0.0.1:51707] &quot;get&quot; &quot;shipment:8000736522714:status&quot;\n</code></pre>\n<p>Note that it is possible to pipe the output, so you can monitor<br>for specific patterns using tools such as <code>grep</code>.</p>\n<h2>Monitoring the latency of Valkey instances</h2>\n<p>Valkey is often used in contexts where latency is very critical. Latency<br>involves multiple moving parts within the application, from the client library<br>to the network stack, to the Valkey instance itself.</p>\n<p>The <code>valkey-cli</code> has multiple facilities for studying the latency of a Valkey<br>instance and understanding the latency&#39;s maximum, average and distribution.</p>\n<p>The basic latency-checking tool is the <code>--latency</code> option. Using this<br>option the CLI runs a loop where the <code>PING</code> command is sent to the Valkey<br>instance and the time to receive a reply is measured. This happens 100<br>times per second, and stats are updated in a real time in the console:</p>\n<pre><code>$ valkey-cli --latency\nmin: 0, max: 1, avg: 0.19 (427 samples)\n</code></pre>\n<p>The stats are provided in milliseconds. Usually, the average latency of<br>a very fast instance tends to be overestimated a bit because of the<br>latency due to the kernel scheduler of the system running <code>valkey-cli</code><br>itself, so the average latency of 0.19 above may easily be 0.01 or less.<br>However this is usually not a big problem, since most developers are interested in<br>events of a few milliseconds or more.</p>\n<p>Sometimes it is useful to study how the maximum and average latencies<br>evolve during time. The <code>--latency-history</code> option is used for that<br>purpose: it works exactly like <code>--latency</code>, but every 15 seconds (by<br>default) a new sampling session is started from scratch:</p>\n<pre><code>$ valkey-cli --latency-history\nmin: 0, max: 1, avg: 0.14 (1314 samples) -- 15.01 seconds range\nmin: 0, max: 1, avg: 0.18 (1299 samples) -- 15.00 seconds range\nmin: 0, max: 1, avg: 0.20 (113 samples)^C\n</code></pre>\n<p>Sampling sessions&#39; length can be changed with the <code>-i &lt;interval&gt;</code> option.</p>\n<p>The most advanced latency study tool, but also the most complex to<br>interpret for non-experienced users, is the ability to use color terminals<br>to show a spectrum of latencies. You&#39;ll see a colored output that indicates the<br>different percentages of samples, and different ASCII characters that indicate<br>different latency figures. This mode is enabled using the <code>--latency-dist</code><br>option:</p>\n<pre><code>$ valkey-cli --latency-dist\n(output not displayed, requires a color terminal, try it!)\n</code></pre>\n<p>There is another pretty unusual latency tool implemented inside <code>valkey-cli</code>.<br>It does not check the latency of a Valkey instance, but the latency of the<br>computer running <code>valkey-cli</code>. This latency is intrinsic to the kernel scheduler,<br>the hypervisor in case of virtualized instances, and so forth.</p>\n<p>Valkey calls it <em>intrinsic latency</em> because it&#39;s mostly opaque to the programmer.<br>If the Valkey instance has high latency regardless of all the obvious things<br>that may be the source cause, it&#39;s worth to check what&#39;s the best your system<br>can do by running <code>valkey-cli</code> in this special mode directly in the system you<br>are running Valkey servers on.</p>\n<p>By measuring the intrinsic latency, you know that this is the baseline,<br>and Valkey cannot outdo your system. In order to run the CLI<br>in this mode, use the <code>--intrinsic-latency &lt;test-time&gt;</code>. Note that the test time is in seconds and dictates how long the test should run.</p>\n<pre><code>$ ./valkey-cli --intrinsic-latency 5\nMax latency so far: 1 microseconds.\nMax latency so far: 7 microseconds.\nMax latency so far: 9 microseconds.\nMax latency so far: 11 microseconds.\nMax latency so far: 13 microseconds.\nMax latency so far: 15 microseconds.\nMax latency so far: 34 microseconds.\nMax latency so far: 82 microseconds.\nMax latency so far: 586 microseconds.\nMax latency so far: 739 microseconds.\n\n65433042 total runs (avg latency: 0.0764 microseconds / 764.14 nanoseconds per run).\nWorst run took 9671x longer than the average latency.\n</code></pre>\n<p>IMPORTANT: this command must be executed on the computer that runs the Valkey server instance, not on a different host. It does not connect to a Valkey instance and performs the test locally.</p>\n<p>In the above case, the system cannot do better than 739 microseconds of worst<br>case latency, so one can expect certain queries to occasionally run less than 1 millisecond.</p>\n<h2>Remote backups of RDB files</h2>\n<p>During a Valkey replication&#39;s first synchronization, the primary and the replica<br>exchange the whole data set in the form of an RDB file. This feature is exploited<br>by <code>valkey-cli</code> in order to provide a remote backup facility that allows a<br>transfer of an RDB file from any Valkey instance to the local computer running<br><code>valkey-cli</code>. To use this mode, call the CLI with the <code>--rdb &lt;dest-filename&gt;</code><br>option:</p>\n<pre><code>$ valkey-cli --rdb /tmp/dump.rdb\nSYNC sent to master, writing 13256 bytes to &#39;/tmp/dump.rdb&#39;\nTransfer finished with success.\n</code></pre>\n<p>This is a simple but effective way to ensure disaster recovery<br>RDB backups exist of your Valkey instance. When using this options in<br>scripts or <code>cron</code> jobs, make sure to check the return value of the command.<br>If it is non zero, an error occurred as in the following example:</p>\n<pre><code>$ valkey-cli --rdb /tmp/dump.rdb\nSYNC with master failed: -ERR Can&#39;t SYNC while not connected with my master\n$ echo $?\n1\n</code></pre>\n<h2>Replica mode</h2>\n<p>The replica mode of the CLI is an advanced feature useful for<br>Valkey developers and for debugging operations.<br>It allows for the inspection of the content a primary sends to its replicas in the replication<br>stream in order to propagate the writes to its replicas. The option<br>name is simply <code>--replica</code>. The following is a working example:</p>\n<pre><code>$ valkey-cli --replica\nSYNC with master, discarding 13256 bytes of bulk transfer...\nSYNC done. Logging commands from master.\n&quot;PING&quot;\n&quot;SELECT&quot;,&quot;0&quot;\n&quot;SET&quot;,&quot;last_name&quot;,&quot;Enigk&quot;\n&quot;PING&quot;\n&quot;INCR&quot;,&quot;mycounter&quot;\n</code></pre>\n<p>The command begins by discarding the RDB file of the first synchronization<br>and then logs each command received in CSV format.</p>\n<p>If you think some of the commands are not replicated correctly in your replicas<br>this is a good way to check what&#39;s happening, and also useful information<br>in order to improve the bug report.</p>\n<h2>Performing an LRU simulation</h2>\n<p>Valkey is often used as a cache with <a href=\"lru-cache.md\">LRU eviction</a>.<br>Depending on the number of keys and the amount of memory allocated for the<br>cache (specified via the <code>maxmemory</code> directive), the amount of cache hits<br>and misses will change. Sometimes, simulating the rate of hits is very<br>useful to correctly provision your cache.</p>\n<p>The <code>valkey-cli</code> has a special mode where it performs a simulation of GET and SET<br>operations, using an 80-20% power law distribution in the requests pattern.<br>This means that 20% of keys will be requested 80% of times, which is a<br>common distribution in caching scenarios.</p>\n<p>Theoretically, given the distribution of the requests and the Valkey memory<br>overhead, it should be possible to compute the hit rate analytically<br>with a mathematical formula. However, Valkey can be configured with<br>different LRU settings (number of samples) and LRU&#39;s implementation, which<br>is approximated in Valkey, changes a lot between different versions. Similarly<br>the amount of memory per key may change between versions. That is why this<br>tool was built: its main motivation was for testing the quality of Valkey&#39; LRU<br>implementation, but now is also useful for testing how a given version<br>behaves with the settings originally intended for deployment.</p>\n<p>To use this mode, specify the amount of keys in the test and configure a sensible <code>maxmemory</code> setting as a first attempt.</p>\n<p>IMPORTANT NOTE: Configuring the <code>maxmemory</code> setting in the Valkey configuration<br>is crucial: if there is no cap to the maximum memory usage, the hit will<br>eventually be 100% since all the keys can be stored in memory. If too many keys are specified with maximum memory, eventually all of the computer RAM will be used. It is also needed to configure an appropriate<br><em>maxmemory policy</em>; most of the time <code>allkeys-lru</code> is selected.</p>\n<p>In the following example there is a configured a memory limit of 100MB and an LRU<br>simulation using 10 million keys.</p>\n<p>WARNING: the test uses pipelining and will stress the server, don&#39;t use it<br>with production instances.</p>\n<pre><code>$ ./valkey-cli --lru-test 10000000\n156000 Gets/sec | Hits: 4552 (2.92%) | Misses: 151448 (97.08%)\n153750 Gets/sec | Hits: 12906 (8.39%) | Misses: 140844 (91.61%)\n159250 Gets/sec | Hits: 21811 (13.70%) | Misses: 137439 (86.30%)\n151000 Gets/sec | Hits: 27615 (18.29%) | Misses: 123385 (81.71%)\n145000 Gets/sec | Hits: 32791 (22.61%) | Misses: 112209 (77.39%)\n157750 Gets/sec | Hits: 42178 (26.74%) | Misses: 115572 (73.26%)\n154500 Gets/sec | Hits: 47418 (30.69%) | Misses: 107082 (69.31%)\n151250 Gets/sec | Hits: 51636 (34.14%) | Misses: 99614 (65.86%)\n</code></pre>\n<p>The program shows stats every second. In the first seconds the cache starts to be populated. The misses rate later stabilizes into the actual figure that can be expected:</p>\n<pre><code>120750 Gets/sec | Hits: 48774 (40.39%) | Misses: 71976 (59.61%)\n122500 Gets/sec | Hits: 49052 (40.04%) | Misses: 73448 (59.96%)\n127000 Gets/sec | Hits: 50870 (40.06%) | Misses: 76130 (59.94%)\n124250 Gets/sec | Hits: 50147 (40.36%) | Misses: 74103 (59.64%)\n</code></pre>\n<p>A miss rate of 59% may not be acceptable for certain use cases therefor<br>100MB of memory is not enough. Observe an example using a half gigabyte of memory. After several<br>minutes the output stabilizes to the following figures:</p>\n<pre><code>140000 Gets/sec | Hits: 135376 (96.70%) | Misses: 4624 (3.30%)\n141250 Gets/sec | Hits: 136523 (96.65%) | Misses: 4727 (3.35%)\n140250 Gets/sec | Hits: 135457 (96.58%) | Misses: 4793 (3.42%)\n140500 Gets/sec | Hits: 135947 (96.76%) | Misses: 4553 (3.24%)\n</code></pre>\n<p>With 500MB there is sufficient space for the key quantity (10 million) and distribution (80-20 style).</p>\n"
  },
  {
    "id": "valkey.conf",
    "topicName": "Configuration",
    "description": "Overview of valkey.conf, the Valkey configuration file\n",
    "htmlContent": "<p>Valkey is able to start without a configuration file using a built-in default<br>configuration, however this setup is only recommended for testing and<br>development purposes.</p>\n<p>The proper way to configure Valkey is by providing a Valkey configuration file,<br>usually called <code>valkey.conf</code>.</p>\n<p>The <code>valkey.conf</code> file contains a number of directives that have a very simple<br>format:</p>\n<pre><code>keyword argument1 argument2 ... argumentN\n</code></pre>\n<p>This is an example of a configuration directive:</p>\n<pre><code>replicaof 127.0.0.1 6380\n</code></pre>\n<p>It is possible to provide strings containing spaces as arguments using<br>(double or single) quotes, as in the following example:</p>\n<pre><code>requirepass &quot;hello world&quot;\n</code></pre>\n<p>Single-quoted string can contain characters escaped by backslashes, and<br>double-quoted strings can additionally include any ASCII symbols encoded using<br>backslashed hexadecimal notation &quot;\\xff&quot;.</p>\n<p>The list of configuration directives, and their meaning and intended usage<br>is available in the self documented example valkey.conf shipped into the<br>Valkey distribution.</p>\n<ul>\n<li>The self documented <a href=\"https://raw.githubusercontent.com/valkey-io/valkey/7.2/valkey.conf\">valkey.conf for Valkey OSS 7.2</a>.</li>\n<li>The self documented <a href=\"https://raw.githubusercontent.com/redis/redis/7.2/redis.conf\">redis.conf for Redis OSS 7.2</a>.</li>\n<li>The self documented <a href=\"https://raw.githubusercontent.com/redis/redis/7.0/redis.conf\">redis.conf for Redis OSS 7.0</a>.</li>\n<li>The self documented <a href=\"https://raw.githubusercontent.com/redis/redis/6.2/redis.conf\">redis.conf for Redis OSS 6.2</a>.</li>\n</ul>\n<h2>Passing arguments via the command line</h2>\n<p>You can also pass Valkey configuration parameters<br>using the command line directly. This is very useful for testing purposes.<br>The following is an example that starts a new Valkey instance using port 6380<br>as a replica of the instance running at 127.0.0.1 port 6379.</p>\n<pre><code>./valkey-server --port 6380 --replicaof 127.0.0.1 6379\n</code></pre>\n<p>The format of the arguments passed via the command line is exactly the same<br>as the one used in the valkey.conf file, with the exception that the keyword<br>is prefixed with <code>--</code>.</p>\n<p>Note that internally this generates an in-memory temporary config file<br>(possibly concatenating the config file passed by the user, if any) where<br>arguments are translated into the format of valkey.conf.</p>\n<h2>Changing Valkey configuration while the server is running</h2>\n<p>It is possible to reconfigure Valkey on the fly without stopping and restarting<br>the service, or querying the current configuration programmatically using the<br>special commands <code>CONFIG SET</code> and <code>CONFIG GET</code>.</p>\n<p>Not all of the configuration directives are supported in this way, but most<br>are supported as expected.<br>Please refer to the <code>CONFIG SET</code> and <code>CONFIG GET</code> pages for more information.</p>\n<p>Note that modifying the configuration on the fly <strong>has no effects on the<br>valkey.conf file</strong> so at the next restart of Valkey the old configuration will<br>be used instead.</p>\n<p>Make sure to also modify the <code>valkey.conf</code> file accordingly to the configuration<br>you set using <code>CONFIG SET</code>.<br>You can do it manually, or you can use <code>CONFIG REWRITE</code>, which will automatically scan your <code>valkey.conf</code> file and update the fields which don&#39;t match the current configuration value.<br>Fields non existing but set to the default value are not added.<br>Comments inside your configuration file are retained.</p>\n<h2>Configuring Valkey as a cache</h2>\n<p>If you plan to use Valkey as a cache where every key will have an<br>expire set, you may consider using the following configuration instead<br>(assuming a max memory limit of 2 megabytes as an example):</p>\n<pre><code>maxmemory 2mb\nmaxmemory-policy allkeys-lru\n</code></pre>\n<p>In this configuration there is no need for the application to set a<br>time to live for keys using the <code>EXPIRE</code> command (or equivalent) since<br>all the keys will be evicted using an approximated LRU algorithm as long<br>as we hit the 2 megabyte memory limit.</p>\n<p>Basically, in this configuration Valkey acts in a similar way to memcached.<br>We have more extensive documentation about using Valkey as an LRU cache <a href=\"lru-cache.md\">here</a>.</p>\n"
  },
  {
    "id": "server",
    "topicName": "The Valkey server",
    "description": "Manual for valkey-server, the Valkey server program\n",
    "htmlContent": "<h2>Usage</h2>\n<p><strong><code>valkey-server</code></strong> [ <em>/path/to/valkey.conf</em> ] [ <em>OPTIONS</em> ] [<strong><code>-</code></strong>]<br><strong><code>valkey-server</code></strong> <strong><code>-v</code></strong> | <strong><code>--version</code></strong><br><strong><code>valkey-server</code></strong> <strong><code>-h</code></strong> | <strong><code>--help</code></strong><br><strong><code>valkey-server</code></strong> <strong><code>--test-memory</code></strong> <em>megabytes</em><br><strong><code>valkey-server</code></strong> <strong><code>--check-system</code></strong></p>\n<h2>Description</h2>\n<p><code>valkey-server</code> is the Valkey database program.</p>\n<p>What is Valkey? See <a href=\"introduction.md\">Introduction</a>.</p>\n<h2>Options</h2>\n<p>The configuration file and the configuration directives are documented in<br><a href=\"valkey.conf.md\">Configuration</a>. Use <code>-</code> to read configuration from stdin.</p>\n<p>Each of the configuration directives can be provided on the command line<br>with its name prefixed by two dashes. For example, <code>--port 6380</code> on the command<br>line is equivalent to <code>port 6380</code> in the config file.</p>\n<p>Additional options:</p>\n<p><strong><code>-v</code></strong>, <strong><code>--version</code></strong><br>: Output version and exit.</p>\n<p><strong><code>-h</code></strong>, <strong><code>--help</code></strong><br>: Output help and exit.</p>\n<p><strong><code>--test-memory</code></strong> <em>megabytes</em><br>: Run a memory test and exit.</p>\n<p><strong><code>--check-sytem</code></strong><br>: Output some operating system properties relevant for running Valkey and exit.</p>\n<p><strong><code>--sentinel</code></strong><br>: Start in <a href=\"sentinel.md\">sentinel</a> mode</p>\n<h2>Examples</h2>\n<p>Run the server with default config:</p>\n<pre><code>valkey-server\n</code></pre>\n<p>Read configuration from stdin:</p>\n<pre><code>echo &#39;maxmemory 128mb&#39; | valkey-server -\n</code></pre>\n<p>Start with a configuration file:</p>\n<pre><code>valkey-server /etc/valkey/6379.conf\n</code></pre>\n<p>Start with configuration as command line options:</p>\n<pre><code>valkey-server --port 7777\n</code></pre>\n<p>Start as a replica of another Valkey server that can accessed at 127.0.0.1:8888:</p>\n<pre><code>valkey-server --port 7777 --replicaof 127.0.0.1 8888\n</code></pre>\n<p>Start with a config file, then some additional options overriding the ones in<br>the config file, and finally some more options from stdin:</p>\n<pre><code>valkey-server /etc/myvalkey.conf --loglevel verbose -\n</code></pre>\n<p>Start with a config file and some additional options overriding the ones in<br>the config file:</p>\n<pre><code>valkey-server /etc/myvalkey.conf --loglevel verbose\n</code></pre>\n<h2>See also</h2>\n<p><a href=\"./\">Valkey documentation</a>, <a href=\"introduction.md\">Introduction</a>, <a href=\"valkey.conf.md\">Configuration</a>, <a href=\"installation.md\">Installation</a>, <a href=\"cli.md\">valkey-cli</a></p>\n"
  },
  {
    "id": "clients",
    "topicName": "Client handling",
    "description": "How the Valkey server manages client connections\n",
    "htmlContent": "<p>This document provides information about how Valkey handles clients at the network layer level: connections, timeouts, buffers, and other similar topics are covered here.</p>\n<h2>Accepting Client Connections</h2>\n<p>Valkey accepts clients connections on the configured TCP port and on the Unix socket if enabled. When a new client connection is accepted the following operations are performed:</p>\n<ul>\n<li>The client socket is put in the non-blocking state since Valkey uses multiplexing and non-blocking I/O.</li>\n<li>The <code>TCP_NODELAY</code> option is set in order to ensure that there are no delays to the connection.</li>\n<li>A <em>readable</em> file event is created so that Valkey is able to collect the client queries as soon as new data is available to read on the socket.</li>\n</ul>\n<p>After the client is initialized, Valkey checks if it is already at the limit<br>configured for the number of simultaneous clients (configured using the <code>maxclients</code> configuration directive, see the next section of this document for further information).</p>\n<p>When Valkey can&#39;t accept a new client connection because the maximum number of clients<br>has been reached, it tries to send an error to the client in order to<br>make it aware of this condition, closing the connection immediately.<br>The error message will reach the client even if the connection is<br>closed immediately by Valkey because the new socket output buffer is usually<br>big enough to contain the error, so the kernel will handle transmission<br>of the error.</p>\n<h2>What Order are Client Requests Served In?</h2>\n<p>The order is determined by a combination of the client socket file descriptor<br>number and order in which the kernel reports events, so the order should be<br>considered as unspecified.</p>\n<p>However, Valkey does the following two things when serving clients:</p>\n<ul>\n<li>It only performs a single <code>read()</code> system call every time there is something new to read from the client socket. This ensures that if we have multiple clients connected, and a few send queries at a high rate, other clients are not penalized and will not experience latency issues.</li>\n<li>However once new data is read from a client, all the queries contained in the current buffers are processed sequentially. This improves locality and does not need iterating a second time to see if there are clients that need some processing time.</li>\n</ul>\n<h2>Maximum Concurrent Connected Clients</h2>\n<p>The limit for the maximum number of clients that can be handled simultaneously<br>is configurable using the <code>maxclients</code> directive in <code>valkey.conf</code>. The default<br>is 10,000 clients.</p>\n<p>However, Valkey checks with the kernel what the maximum number of file<br>descriptors that we are able to open is (the <em>soft limit</em> is checked). If the<br>limit is less than the maximum number of clients we want to handle, plus<br>32 (that is the number of file descriptors Valkey reserves for internal uses),<br>then the maximum number of clients is updated to match the number<br>of clients it is <em>really able to handle</em> under the current operating system<br>limit.</p>\n<p>When <code>maxclients</code> is set to a number greater than Valkey can support, a message is logged at startup:</p>\n<pre><code>$ ./valkey-server --maxclients 100000\n[41422] 23 Jan 11:28:33.179 # Unable to set the max number of files limit to 100032 (Invalid argument), setting the max clients configuration to 10112.\n</code></pre>\n<p>When Valkey is configured in order to handle a specific number of clients it<br>is a good idea to make sure that the operating system limit for the maximum<br>number of file descriptors per process is also set accordingly.</p>\n<p>Under Linux these limits can be set both in the current session and as a<br>system-wide setting with the following commands:</p>\n<ul>\n<li><code>ulimit -Sn 100000 # This will only work if hard limit is big enough.</code></li>\n<li><code>sysctl -w fs.file-max=100000</code></li>\n</ul>\n<h2>Output Buffer Limits</h2>\n<p>Valkey needs to handle a variable-length output buffer for every client, since<br>a command can produce a large amount of data that needs to be transferred to the<br>client.</p>\n<p>However it is possible that a client sends more commands producing more output<br>to serve at a faster rate than that which Valkey can send the existing output to the<br>client. This is especially true with Pub/Sub clients in case a client is not<br>able to process new messages fast enough.</p>\n<p>Both conditions will cause the client output buffer to grow and consume<br>more and more memory. For this reason by default Sets limits to the<br>output buffer size for different kind of clients. When the limit is reached<br>the client connection is closed and the event logged in the Valkey log file.</p>\n<p>There are two kind of limits Valkey uses:</p>\n<ul>\n<li>The <strong>hard limit</strong> is a fixed limit that when reached will make Valkey close the client connection as soon as possible.</li>\n<li>The <strong>soft limit</strong> instead is a limit that depends on the time, for instance a soft limit of 32 megabytes per 10 seconds means that if the client has an output buffer bigger than 32 megabytes for, continuously, 10 seconds, the connection gets closed.</li>\n</ul>\n<p>Different kind of clients have different default limits:</p>\n<ul>\n<li><strong>Normal clients</strong> have a default limit of 0, that means, no limit at all, because most normal clients use blocking implementations sending a single command and waiting for the reply to be completely read before sending the next command, so it is always not desirable to close the connection in case of a normal client.</li>\n<li><strong>Pub/Sub clients</strong> have a default hard limit of 32 megabytes and a soft limit of 8 megabytes per 60 seconds.</li>\n<li><strong>Replicas</strong> have a default hard limit of 256 megabytes and a soft limit of 64 megabyte per 60 seconds.</li>\n</ul>\n<p>It is possible to change the limit at runtime using the <code>CONFIG SET</code> command or in a permanent way using the Valkey configuration file <code>valkey.conf</code>. See the example <code>valkey.conf</code> in the Valkey distribution for more information about how to set the limit.</p>\n<h2>Query Buffer Hard Limit</h2>\n<p>Every client is also subject to a query buffer limit. This is a non-configurable hard limit that will close the connection when the client query buffer (that is the buffer we use to accumulate commands from the client) reaches 1 GB, and is actually only an extreme limit to avoid a server crash in case of client or server software bugs.</p>\n<h2>Client Eviction</h2>\n<p>Valkey is built to handle a very large number of client connections.<br>Client connections tend to consume memory, and when there are many of them, the aggregate memory consumption can be extremely high, leading to data eviction or out-of-memory errors.<br>These cases can be mitigated to an extent using <a href=\"#output-buffer-limits\">output buffer limits</a>, but Valkey allows us a more robust configuration to limit the aggregate memory used by all clients&#39; connections.</p>\n<p>This mechanism is called <strong>client eviction</strong>, and it&#39;s essentially a safety mechanism that will disconnect clients once the aggregate memory usage of all clients is above a threshold.<br>The mechanism first attempts to disconnect clients that use the most memory.<br>It disconnects the minimal number of clients needed to return below the <code>maxmemory-clients</code> threshold.</p>\n<p><code>maxmemory-clients</code> defines the maximum aggregate memory usage of all clients connected to Valkey.<br>The aggregation takes into account all the memory used by the client connections: the <a href=\"#query-buffer-hard-limit\">query buffer</a>, the output buffer, and other intermediate buffers.</p>\n<p>Note that replica and primary connections aren&#39;t affected by the client eviction mechanism. Therefore, such connections are never evicted.</p>\n<p><code>maxmemory-clients</code> can be set permanently in the configuration file (<code>valkey.conf</code>) or via the <code>CONFIG SET</code> command.<br>This setting can either be 0 (meaning no limit), a size in bytes (possibly with <code>mb</code>/<code>gb</code> suffix),<br>or a percentage of <code>maxmemory</code> by using the <code>%</code> suffix (e.g. setting it to <code>10%</code> would mean 10% of the <code>maxmemory</code> configuration).</p>\n<p>The default setting is 0, meaning client eviction is turned off by default.<br>However, for any large production deployment, it is highly recommended to configure some non-zero <code>maxmemory-clients</code> value.<br>A value <code>5%</code>, for example, can be a good place to start.</p>\n<p>It is possible to flag a specific client connection to be excluded from the client eviction mechanism.<br>This is useful for control path connections.<br>If, for example, you have an application that monitors the server via the <code>INFO</code> command and alerts you in case of a problem, you might want to make sure this connection isn&#39;t evicted.<br>You can do so using the following command (from the relevant client&#39;s connection):</p>\n<p><code>CLIENT NO-EVICT</code> <code>on</code></p>\n<p>And you can revert that with:</p>\n<p><code>CLIENT NO-EVICT</code> <code>off</code></p>\n<p>For more information and an example refer to the <code>maxmemory-clients</code> section in the default <code>valkey.conf</code> file.</p>\n<p>Client eviction is available from Redis OSS 7.0.</p>\n<h2>Client Timeouts</h2>\n<p>By default recent versions of Valkey don&#39;t close the connection with the client<br>if the client is idle for many seconds: the connection will remain open forever.</p>\n<p>However if you don&#39;t like this behavior, you can configure a timeout, so that<br>if the client is idle for more than the specified number of seconds, the client connection will be closed.</p>\n<p>You can configure this limit via <code>valkey.conf</code> or simply using <code>CONFIG SET timeout &lt;value&gt;</code>.</p>\n<p>Note that the timeout only applies to normal clients and it <strong>does not apply to Pub/Sub clients</strong>, since a Pub/Sub connection is a <em>push style</em> connection so a client that is idle is the norm.</p>\n<p>Even if by default connections are not subject to timeout, there are two conditions when it makes sense to set a timeout:</p>\n<ul>\n<li>Mission critical applications where a bug in the client software may saturate the Valkey server with idle connections, causing service disruption.</li>\n<li>As a debugging mechanism in order to be able to connect with the server if a bug in the client software saturates the server with idle connections, making it impossible to interact with the server.</li>\n</ul>\n<p>Timeouts are not to be considered very precise: Valkey avoids setting timer events or running O(N) algorithms in order to check idle clients, so the check is performed incrementally from time to time. This means that it is possible that while the timeout is set to 10 seconds, the client connection will be closed, for instance, after 12 seconds if many clients are connected at the same time.</p>\n<h2>The CLIENT Command</h2>\n<p>The Valkey <code>CLIENT</code> command allows you to inspect the state of every connected client, to kill a specific client, and to name connections. It is a very powerful debugging tool if you use Valkey at scale.</p>\n<p><code>CLIENT LIST</code> is used in order to obtain a list of connected clients and their state:</p>\n<pre><code>127.0.0.1:6379&gt; client list\naddr=127.0.0.1:52555 fd=5 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client\naddr=127.0.0.1:52787 fd=6 name= age=6 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping\n</code></pre>\n<p>In the above example two clients are connected to the Valkey server. Let&#39;s look at what some of the data returned represents:</p>\n<ul>\n<li><strong>addr</strong>: The client address, that is, the client IP and the remote port number it used to connect with the Valkey server.</li>\n<li><strong>fd</strong>: The client socket file descriptor number.</li>\n<li><strong>name</strong>: The client name as set by <code>CLIENT SETNAME</code>.</li>\n<li><strong>age</strong>: The number of seconds the connection existed for.</li>\n<li><strong>idle</strong>: The number of seconds the connection is idle.</li>\n<li><strong>flags</strong>: The kind of client (N means normal client, check the <a href=\"../commands/client-list.md\">full list of flags</a>).</li>\n<li><strong>omem</strong>: The amount of memory used by the client for the output buffer.</li>\n<li><strong>cmd</strong>: The last executed command.</li>\n</ul>\n<p>See the <a href=\"../commands/client-list.md\"><code>CLIENT LIST</code></a> documentation for the full listing of fields and their purpose.</p>\n<p>Once you have the list of clients, you can close a client&#39;s connection using the <code>CLIENT KILL</code> command, specifying the client address as its argument.</p>\n<p>The commands <code>CLIENT SETNAME</code> and <code>CLIENT GETNAME</code> can be used to set and get the connection name. Starting with Redis OSS 4.0, the client name is shown in the<br><code>SLOWLOG</code> output, to help identify clients that create latency issues.</p>\n<h2>TCP keepalive</h2>\n<p>Valkey has TCP keepalive (<code>SO_KEEPALIVE</code> socket option) enabled by default and set to about 300 seconds. This option is useful in order to detect dead peers (clients that cannot be reached even if they look connected). Moreover, if there is network equipment between clients and servers that need to see some traffic in order to take the connection open, the option will prevent unexpected connection closed events.</p>\n"
  },
  {
    "id": "client-side-caching",
    "topicName": "Client-side caching",
    "description": "Server-assisted, client-side caching in Valkey\n",
    "htmlContent": "<p>Client-side caching is a technique used to create high performance services.<br>It exploits the memory available on application servers, servers that are<br>usually distinct computers compared to the Valkey nodes, to store some subset<br>of the Valkey information directly in the application side.</p>\n<p>Normally when data is required, the application servers ask the Valkey about<br>such information, like in the following diagram:</p>\n<pre><code>+-------------+                                +----------+\n|             | ------- GET user:1234 -------&gt; |          |\n| Application |                                |  Valkey  |\n|             | &lt;---- username = Alice ------- |          |\n+-------------+                                +----------+\n</code></pre>\n<p>When client-side caching is used, the application will store the reply of<br>popular queries directly inside the application memory, so that it can<br>reuse such replies later, without contacting the Valkey again:</p>\n<pre><code>+-------------+                                +----------+\n|             |                                |          |\n| Application |       ( No chat needed )       |  Valkey  |\n|             |                                |          |\n+-------------+                                +----------+\n| Local cache |\n|             |\n| user:1234 = |\n| username    |\n| Alice       |\n+-------------+\n</code></pre>\n<p>While the application memory used for the local cache may not be very big,<br>the time needed in order to access the local computer memory is orders of<br>magnitude smaller compared to accessing a networked service like a Valkey.<br>Since often the same small percentage of data are accessed frequently,<br>this pattern can greatly reduce the latency for the application to get data<br>and, at the same time, the load in the Valkey side.</p>\n<p>Moreover there are many datasets where items change very infrequently.<br>For instance, most user posts in a social network are either immutable or<br>rarely edited by the user. Adding to this the fact that usually a small<br>percentage of the posts are very popular, either because a small set of users<br>have a lot of followers and/or because recent posts have a lot more<br>visibility, it is clear why such a pattern can be very useful.</p>\n<p>Usually the two key advantages of client-side caching are:</p>\n<ol>\n<li>Data is available with a very small latency.</li>\n<li>The Valkey system receives less queries, allowing it to serve the same dataset with a smaller number of nodes.</li>\n</ol>\n<h2>There are two hard problems in computer science...</h2>\n<p>A problem with the above pattern is how to invalidate the information that<br>the application is holding, in order to avoid presenting stale data to the<br>user. For example after the application above locally cached the information<br>for user:1234, Alice may update her username to Flora. Yet the application<br>may continue to serve the old username for user:1234.</p>\n<p>Sometimes, depending on the exact application we are modeling, this isn&#39;t a<br>big deal, so the client will just use a fixed maximum &quot;time to live&quot; for the<br>cached information. Once a given amount of time has elapsed, the information<br>will no longer be considered valid. More complex patterns, when using Valkey,<br>leverage the Pub/Sub system in order to send invalidation messages to<br>listening clients. This can be made to work but is tricky and costly from<br>the point of view of the bandwidth used, because often such patterns involve<br>sending the invalidation messages to every client in the application, even<br>if certain clients may not have any copy of the invalidated data. Moreover<br>every application query altering the data requires to use the <code>PUBLISH</code><br>command, costing the Valkey more CPU time to process this command.</p>\n<p>Regardless of what schema is used, there is a simple fact: many very large<br>applications implement some form of client-side caching, because it is the<br>next logical step to having a fast store or a fast cache server. For this<br>reason Valkey implements direct support for client-side caching, in order<br>to make this pattern much simpler to implement, more accessible, reliable,<br>and efficient.</p>\n<h2>The Valkey implementation of client-side caching</h2>\n<p>The Valkey client-side caching support is called <em>Tracking</em>, and has two modes:</p>\n<ul>\n<li>In the default mode, the server remembers what keys a given client accessed, and sends invalidation messages when the same keys are modified. This costs memory in the server side, but sends invalidation messages only for the set of keys that the client might have in memory.</li>\n<li>In the <em>broadcasting</em> mode, the server does not attempt to remember what keys a given client accessed, so this mode costs no memory at all in the server side. Instead clients subscribe to key prefixes such as <code>object:</code> or <code>user:</code>, and receive a notification message every time a key matching a subscribed prefix is touched.</li>\n</ul>\n<p>To recap, for now let&#39;s forget for a moment about the broadcasting mode, to<br>focus on the first mode. We&#39;ll describe broadcasting in more detail later.</p>\n<ol>\n<li>Clients can enable tracking if they want. Connections start without tracking enabled.</li>\n<li>When tracking is enabled, the server remembers what keys each client requested during the connection lifetime (by sending read commands about such keys).</li>\n<li>When a key is modified by some client, or is evicted because it has an associated expire time, or evicted because of a <em>maxmemory</em> policy, all the clients with tracking enabled that may have the key cached, are notified with an <em>invalidation message</em>.</li>\n<li>When clients receive invalidation messages, they are required to remove the corresponding keys, in order to avoid serving stale data.</li>\n</ol>\n<p>This is an example of the protocol:</p>\n<ul>\n<li>Client 1 <code>-&gt;</code> Server: CLIENT TRACKING ON</li>\n<li>Client 1 <code>-&gt;</code> Server: GET foo</li>\n<li>(The server remembers that Client 1 may have the key &quot;foo&quot; cached)</li>\n<li>(Client 1 may remember the value of &quot;foo&quot; inside its local memory)</li>\n<li>Client 2 <code>-&gt;</code> Server: SET foo SomeOtherValue</li>\n<li>Server <code>-&gt;</code> Client 1: INVALIDATE &quot;foo&quot;</li>\n</ul>\n<p>This looks great superficially, but if you imagine 10k connected clients all<br>asking for millions of keys over long living connection, the server ends up<br>storing too much information. For this reason Valkey uses two key ideas in<br>order to limit the amount of memory used server-side and the CPU cost of<br>handling the data structures implementing the feature:</p>\n<ul>\n<li>The server remembers the list of clients that may have cached a given key in a single global table. This table is called the <strong>Invalidation Table</strong>. The invalidation table can contain a maximum number of entries. If a new key is inserted, the server may evict an older entry by pretending that such key was modified (even if it was not), and sending an invalidation message to the clients. Doing so, it can reclaim the memory used for this key, even if this will force the clients having a local copy of the key to evict it.</li>\n<li>Inside the invalidation table we don&#39;t really need to store pointers to clients&#39; structures, that would force a garbage collection procedure when the client disconnects: instead what we do is just store client IDs (each Valkey client has a unique numerical ID). If a client disconnects, the information will be incrementally garbage collected as caching slots are invalidated.</li>\n<li>There is a single keys namespace, not divided by Valkey numbers. So if a client is caching the key <code>foo</code> in Valkey 2, and some other client changes the value of the key <code>foo</code> in Valkey 3, an invalidation message will still be sent. This way we can ignore Valkey numbers reducing both the memory usage and the implementation complexity.</li>\n</ul>\n<h2>Two connections mode</h2>\n<p>Using the new version of the Valkey protocol, RESP3, it is possible to run the data queries and receive the invalidation messages in the same connection. However many client implementations may prefer to implement client-side caching using two separated connections: one for data, and one for invalidation messages. For this reason when a client enables tracking, it can specify to redirect the invalidation messages to another connection by specifying the &quot;client ID&quot; of a different connection. Many data connections can redirect invalidation messages to the same connection, this is useful for clients implementing connection pooling. The two connections model is the only one that is also supported for RESP2 (which lacks the ability to multiplex different kind of information in the same connection).</p>\n<p>Here&#39;s an example of a complete session using the Valkey protocol in the old RESP2 mode involving the following steps: enabling tracking redirecting to another connection, asking for a key, and getting an invalidation message once the key gets modified.</p>\n<p>To start, the client opens a first connection that will be used for invalidations, requests the connection ID, and subscribes via Pub/Sub to the special channel that is used to get invalidation messages when in RESP2 modes (remember that RESP2 is the usual Valkey protocol, and not the more advanced protocol that you can use, optionally, using the <code>HELLO</code> command):</p>\n<pre><code>(Connection 1 -- used for invalidations)\nCLIENT ID\n:4\nSUBSCRIBE __redis__:invalidate\n*3\n$9\nsubscribe\n$20\n__redis__:invalidate\n:1\n</code></pre>\n<p>Now we can enable tracking from the data connection:</p>\n<pre><code>(Connection 2 -- data connection)\nCLIENT TRACKING on REDIRECT 4\n+OK\n\nGET foo\n$3\nbar\n</code></pre>\n<p>The client may decide to cache <code>&quot;foo&quot; =&gt; &quot;bar&quot;</code> in the local memory.</p>\n<p>A different client will now modify the value of the &quot;foo&quot; key:</p>\n<pre><code>(Some other unrelated connection)\nSET foo bar\n+OK\n</code></pre>\n<p>As a result, the invalidations connection will receive a message that invalidates the specified key.</p>\n<pre><code>(Connection 1 -- used for invalidations)\n*3\n$7\nmessage\n$20\n__redis__:invalidate\n*1\n$3\nfoo\n</code></pre>\n<p>The client will check if there are cached keys in this caching slot, and will evict the information that is no longer valid.</p>\n<p>Note that the third element of the Pub/Sub message is not a single key but<br>is a Valkey array with just a single element. Since we send an array, if there<br>are groups of keys to invalidate, we can do that in a single message.<br>In case of a flush (<code>FLUSHALL</code> or <code>FLUSHDB</code>), a <code>null</code> message will be sent.</p>\n<p>A very important thing to understand about client-side caching used with<br>RESP2 and a Pub/Sub connection in order to read the invalidation messages,<br>is that using Pub/Sub is entirely a trick <strong>in order to reuse old client<br>implementations</strong>, but actually the message is not really sent to a channel<br>and received by all the clients subscribed to it. Only the connection we<br>specified in the <code>REDIRECT</code> argument of the <code>CLIENT</code> command will actually<br>receive the Pub/Sub message, making the feature a lot more scalable.</p>\n<p>When RESP3 is used instead, invalidation messages are sent (either in the<br>same connection, or in the secondary connection when redirection is used)<br>as <code>push</code> messages (read the RESP3 specification for more information).</p>\n<h2>What tracking tracks</h2>\n<p>As you can see clients do not need, by default, to tell the server what keys<br>they are caching. Every key that is mentioned in the context of a read-only<br>command is tracked by the server, because it <em>could be cached</em>.</p>\n<p>This has the obvious advantage of not requiring the client to tell the server<br>what it is caching. Moreover in many clients implementations, this is what<br>you want, because a good solution could be to just cache everything that is not<br>already cached, using a first-in first-out approach: we may want to cache a<br>fixed number of objects, every new data we retrieve, we could cache it,<br>discarding the oldest cached object. More advanced implementations may instead<br>drop the least used object or alike.</p>\n<p>Note that anyway if there is write traffic on the server, caching slots<br>will get invalidated during the course of the time. In general when the<br>server assumes that what we get we also cache, we are making a tradeoff:</p>\n<ol>\n<li>It is more efficient when the client tends to cache many things with a policy that welcomes new objects.</li>\n<li>The server will be forced to retain more data about the client keys.</li>\n<li>The client will receive useless invalidation messages about objects it did not cache.</li>\n</ol>\n<p>So there is an alternative described in the next section.</p>\n<h2>Opt-in caching</h2>\n<p>Clients implementations may want to cache only selected keys, and communicate<br>explicitly to the server what they&#39;ll cache and what they will not. This will<br>require more bandwidth when caching new objects, but at the same time reduces<br>the amount of data that the server has to remember and the amount of<br>invalidation messages received by the client.</p>\n<p>In order to do this, tracking must be enabled using the OPTIN option:</p>\n<pre><code>CLIENT TRACKING on REDIRECT 1234 OPTIN\n</code></pre>\n<p>In this mode, by default, keys mentioned in read queries <em>are not supposed to be cached</em>, instead when a client wants to cache something, it must send a special command immediately before the actual command to retrieve the data:</p>\n<pre><code>CLIENT CACHING YES\n+OK\nGET foo\n&quot;bar&quot;\n</code></pre>\n<p>The <code>CACHING</code> command affects the command executed immediately after it,<br>however in case the next command is <code>MULTI</code>, all the commands in the<br>transaction will be tracked. Similarly in case of Lua scripts, all the<br>commands executed by the script will be tracked.</p>\n<h2>Broadcasting mode</h2>\n<p>So far we described the first client-side caching model that Valkey implements.<br>There is another one, called broadcasting, that sees the problem from the<br>point of view of a different tradeoff, does not consume any memory on the<br>server side, but instead sends more invalidation messages to clients.<br>In this mode we have the following main behaviors:</p>\n<ul>\n<li>Clients enable client-side caching using the <code>BCAST</code> option, specifying one or more prefixes using the <code>PREFIX</code> option. For instance: <code>CLIENT TRACKING on REDIRECT 10 BCAST PREFIX object: PREFIX user:</code>. If no prefix is specified at all, the prefix is assumed to be the empty string, so the client will receive invalidation messages for every key that gets modified. Instead if one or more prefixes are used, only keys matching one of the specified prefixes will be sent in the invalidation messages.</li>\n<li>The server does not store anything in the invalidation table. Instead it uses a different <strong>Prefixes Table</strong>, where each prefix is associated to a list of clients.</li>\n<li>No two prefixes can track overlapping parts of the keyspace. For instance, having the prefix &quot;foo&quot; and &quot;foob&quot; would not be allowed, since they would both trigger an invalidation for the key &quot;foobar&quot;. However, just using the prefix &quot;foo&quot; is sufficient.</li>\n<li>Every time a key matching any of the prefixes is modified, all the clients subscribed to that prefix, will receive the invalidation message.</li>\n<li>The server will consume CPU proportional to the number of registered prefixes. If you have just a few, it is hard to see any difference. With a big number of prefixes the CPU cost can become quite large.</li>\n<li>In this mode the server can perform the optimization of creating a single reply for all the clients subscribed to a given prefix, and send the same reply to all. This helps to lower the CPU usage.</li>\n</ul>\n<h2>The NOLOOP option</h2>\n<p>By default client-side tracking will send invalidation messages to the<br>client that modified the key. Sometimes clients want this, since they<br>implement very basic logic that does not involve automatically caching<br>writes locally. However, more advanced clients may want to cache even the<br>writes they are doing in the local in-memory table. In such case receiving<br>an invalidation message immediately after the write is a problem, since it<br>will force the client to evict the value it just cached.</p>\n<p>In this case it is possible to use the <code>NOLOOP</code> option: it works both<br>in normal and broadcasting mode. Using this option, clients are able to<br>tell the server they don&#39;t want to receive invalidation messages for keys<br>that they modified.</p>\n<h2>Avoiding race conditions</h2>\n<p>When implementing client-side caching redirecting the invalidation messages<br>to a different connection, you should be aware that there is a possible<br>race condition. See the following example interaction, where we&#39;ll call<br>the data connection &quot;D&quot; and the invalidation connection &quot;I&quot;:</p>\n<pre><code>[D] client -&gt; server: GET foo\n[I] server -&gt; client: Invalidate foo (somebody else touched it)\n[D] server -&gt; client: &quot;bar&quot; (the reply of &quot;GET foo&quot;)\n</code></pre>\n<p>As you can see, because the reply to the GET was slower to reach the<br>client, we received the invalidation message before the actual data that<br>is already no longer valid. So we&#39;ll keep serving a stale version of the<br>foo key. To avoid this problem, it is a good idea to populate the cache<br>when we send the command with a placeholder:</p>\n<pre><code>Client cache: set the local copy of &quot;foo&quot; to &quot;caching-in-progress&quot;\n[D] client-&gt; server: GET foo.\n[I] server -&gt; client: Invalidate foo (somebody else touched it)\nClient cache: delete &quot;foo&quot; from the local cache.\n[D] server -&gt; client: &quot;bar&quot; (the reply of &quot;GET foo&quot;)\nClient cache: don&#39;t set &quot;bar&quot; since the entry for &quot;foo&quot; is missing.\n</code></pre>\n<p>Such a race condition is not possible when using a single connection for both<br>data and invalidation messages, since the order of the messages is always known<br>in that case.</p>\n<h2>What to do when losing connection with the server</h2>\n<p>Similarly, if we lost the connection with the socket we use in order to<br>get the invalidation messages, we may end with stale data. In order to avoid<br>this problem, we need to do the following things:</p>\n<ol>\n<li>Make sure that if the connection is lost, the local cache is flushed.</li>\n<li>Both when using RESP2 with Pub/Sub, or RESP3, ping the invalidation channel periodically (you can send PING commands even when the connection is in Pub/Sub mode!). If the connection looks broken and we are not able to receive ping backs, after a maximum amount of time, close the connection and flush the cache.</li>\n</ol>\n<h2>What to cache</h2>\n<p>Clients may want to run internal statistics about the number of times<br>a given cached key was actually served in a request, to understand in the<br>future what is good to cache. In general:</p>\n<ul>\n<li>We don&#39;t want to cache many keys that change continuously.</li>\n<li>We don&#39;t want to cache many keys that are requested very rarely.</li>\n<li>We want to cache keys that are requested often and change at a reasonable rate. For an example of key not changing at a reasonable rate, think of a global counter that is continuously <code>INCR</code>emented.</li>\n</ul>\n<p>However simpler clients may just evict data using some random sampling just<br>remembering the last time a given cached value was served, trying to evict<br>keys that were not served recently.</p>\n<h2>Other hints for implementing client libraries</h2>\n<ul>\n<li>Handling TTLs: make sure you also request the key TTL and set the TTL in the local cache if you want to support caching keys with a TTL.</li>\n<li>Putting a max TTL on every key is a good idea, even if it has no TTL. This protects against bugs or connection issues that would make the client have old data in the local copy.</li>\n<li>Limiting the amount of memory used by clients is absolutely needed. There must be a way to evict old keys when new ones are added.</li>\n</ul>\n<h2>Limiting the amount of memory used by Valkey</h2>\n<p>Be sure to configure a suitable value for the maximum number of keys remembered by Valkey or alternatively use the BCAST mode that consumes no memory at all on the Valkey side. Note that the memory consumed by Valkey when BCAST is not used, is proportional both to the number of keys tracked and the number of clients requesting such keys.</p>\n"
  },
  {
    "id": "protocol",
    "topicName": "Serialization protocol specification",
    "description": "Valkey's serialization protocol (RESP) is the wire protocol that clients implement",
    "htmlContent": "<p>To communicate with the Valkey server, Valkey clients use a protocol called REdis Serialization Protocol (RESP).<br>While the protocol was designed for Redis, it&#39;s used by many other client-server software projects.</p>\n<p>RESP is a compromise among the following considerations:</p>\n<ul>\n<li>Simple to implement.</li>\n<li>Fast to parse.</li>\n<li>Human readable.</li>\n</ul>\n<p>RESP can serialize different data types including integers, strings, and arrays.<br>It also features an error-specific type.<br>A client sends a request to the Valkey server as an array of strings.<br>The array&#39;s contents are the command and its arguments that the server should execute.<br>The server&#39;s reply type is command-specific.</p>\n<p>RESP is binary-safe and uses prefixed length to transfer bulk data so it does not require processing bulk data transferred from one process to another.</p>\n<p>RESP is the protocol you should implement in your Valkey client.</p>\n<p><strong>Note:</strong><br>The protocol outlined here is used only for client-server communication.<br><a href=\"cluster-spec.md\">Valkey Cluster</a> uses a different binary protocol for exchanging messages between nodes.</p>\n<h2>RESP versions</h2>\n<p>The first version of the RESP protocol was experimental and was never widely used.</p>\n<p>The next version, RESP2, early became the standard communication method for clients with Redis OSS.</p>\n<p><a href=\"https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md\">RESP3</a> is a superset of RESP2 that mainly aims to make a client author&#39;s life a little bit easier.<br>Redis OSS 6.0 introduced experimental opt-in support of RESP3&#39;s features (excluding streaming strings and streaming aggregates).<br>In addition, the introduction of the <code>HELLO</code> command allows clients to handshake and upgrade the connection&#39;s protocol version (see <a href=\"#client-handshake\">Client handshake</a>).</p>\n<p>Up to and including Redis OSS 7, both RESP2 and RESP3 clients can invoke all core commands.<br>However, commands may return differently typed replies for different protocol versions.</p>\n<p>Future versions of Valkey may change the default protocol version, but it is unlikely that RESP2 will become entirely deprecated.<br>It is possible, however, that new features in upcoming versions will require the use of RESP3.</p>\n<h2>Network layer</h2>\n<p>A client connects to a Valkey server by creating a TCP connection to its port (the default is 6379).</p>\n<p>While RESP is technically non-TCP specific, the protocol is used exclusively with TCP connections (or equivalent stream-oriented connections like Unix sockets) in the context of Valkey.</p>\n<h2>Request-Response model</h2>\n<p>The Valkey server accepts commands composed of different arguments.<br>Then, the server processes the command and sends the reply back to the client.</p>\n<p>This is the simplest model possible; however, there are some exceptions:</p>\n<ul>\n<li>Valkey requests can be <a href=\"#multiple-commands-and-pipelining\">pipelined</a>.<br>Pipelining enables clients to send multiple commands at once and wait for replies later.</li>\n<li>When a RESP2 connection subscribes to a <a href=\"pubsub.md\">Pub/Sub</a> channel, the protocol changes semantics and becomes a <em>push</em> protocol.<br>The client no longer requires sending commands because the server will automatically send new messages to the client (for the channels the client is subscribed to) as soon as they are received.</li>\n<li>The <code>MONITOR</code> command.<br>Invoking the <code>MONITOR</code> command switches the connection to an ad-hoc push mode.<br>The protocol of this mode is not specified but is obvious to parse.</li>\n<li><a href=\"security.md#protected-mode\">Protected mode</a>.<br>Connections opened from a non-loopback address to a Valkey while in protected mode are denied and terminated by the server.<br>Before terminating the connection, Valkey unconditionally sends a <code>-DENIED</code> reply, regardless of whether the client writes to the socket.</li>\n<li>The <a href=\"#pushes\">RESP3 Push type</a>.<br>As the name suggests, a push type allows the server to send out-of-band data to the connection.<br>The server may push data at any time, and the data isn&#39;t necessarily related to specific commands executed by the client.</li>\n<li>When RESP3 is used, the commands <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code> and their pattern and sharded variants,<br>return either an error reply <em>or one or more Push replies, without any regular in-band reply</em>.<br>This is considered a design mistake of these commands but the behaviour is kept for backward compatibility.<br>Clients need to compensate for this behaviour.</li>\n</ul>\n<p>Excluding these exceptions, the Valkey protocol is a simple request-response protocol.</p>\n<h2>RESP protocol description</h2>\n<p>RESP is essentially a serialization protocol that supports several data types.<br>In RESP, the first byte of data determines its type.</p>\n<p>Valkey generally uses RESP as a <a href=\"#request-response-model\">request-response</a> protocol in the following way:</p>\n<ul>\n<li>Clients send commands to a Valkey server as an <a href=\"#arrays\">array</a> of <a href=\"#bulk-strings\">bulk strings</a>.<br>The first (and sometimes also the second) bulk string in the array is the command&#39;s name.<br>Subsequent elements of the array are the arguments for the command.</li>\n<li>The server replies with a RESP type.<br>The reply&#39;s type is determined by the command&#39;s implementation and possibly by the client&#39;s protocol version.</li>\n</ul>\n<p>RESP is a binary protocol that uses control sequences encoded in standard ASCII.<br>The <code>A</code> character, for example, is encoded with the binary byte of value 65.<br>Similarly, the characters CR (<code>\\r</code>), LF (<code>\\n</code>) and SP (<code> </code>) have binary byte values of 13, 10 and 32, respectively.</p>\n<p>The <code>\\r\\n</code> (CRLF) is the protocol&#39;s <em>terminator</em>, which <strong>always</strong> separates its parts.</p>\n<p>The first byte in an RESP-serialized payload always identifies its type.<br>Subsequent bytes constitute the type&#39;s contents.</p>\n<p>We categorize every RESP data type as either <em>simple</em>, <em>bulk</em> or <em>aggregate</em>.</p>\n<p>Simple types are similar to scalars in programming languages that represent plain literal values. Booleans and Integers are such examples.</p>\n<p>RESP strings are either <em>simple</em> or <em>bulk</em>.<br>Simple strings never contain carriage return (<code>\\r</code>) or line feed (<code>\\n</code>) characters.<br>Bulk strings can contain any binary data and may also be referred to as <em>binary</em> or <em>blob</em>.<br>Note that bulk strings may be further encoded and decoded, e.g. with a wide multi-byte encoding, by the client.</p>\n<p>Aggregates, such as Arrays and Maps, can have varying numbers of sub-elements and nesting levels.</p>\n<p>The following table summarizes the RESP data types that Valkey supports:</p>\n<table>\n<thead>\n<tr>\n<th>RESP data type</th>\n<th>Minimal protocol version</th>\n<th>Category</th>\n<th>First byte</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"#simple-strings\">Simple strings</a></td>\n<td>RESP2</td>\n<td>Simple</td>\n<td><code>+</code></td>\n</tr>\n<tr>\n<td><a href=\"#simple-errors\">Simple Errors</a></td>\n<td>RESP2</td>\n<td>Simple</td>\n<td><code>-</code></td>\n</tr>\n<tr>\n<td><a href=\"#integers\">Integers</a></td>\n<td>RESP2</td>\n<td>Simple</td>\n<td><code>:</code></td>\n</tr>\n<tr>\n<td><a href=\"#bulk-strings\">Bulk strings</a></td>\n<td>RESP2</td>\n<td>Aggregate</td>\n<td><code>$</code></td>\n</tr>\n<tr>\n<td><a href=\"#arrays\">Arrays</a></td>\n<td>RESP2</td>\n<td>Aggregate</td>\n<td><code>*</code></td>\n</tr>\n<tr>\n<td><a href=\"#nulls\">Nulls</a></td>\n<td>RESP3</td>\n<td>Simple</td>\n<td><code>_</code></td>\n</tr>\n<tr>\n<td><a href=\"#booleans\">Booleans</a></td>\n<td>RESP3</td>\n<td>Simple</td>\n<td><code>#</code></td>\n</tr>\n<tr>\n<td><a href=\"#doubles\">Doubles</a></td>\n<td>RESP3</td>\n<td>Simple</td>\n<td><code>,</code></td>\n</tr>\n<tr>\n<td><a href=\"#big-numbers\">Big numbers</a></td>\n<td>RESP3</td>\n<td>Simple</td>\n<td><code>(</code></td>\n</tr>\n<tr>\n<td><a href=\"#bulk-errors\">Bulk errors</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>!</code></td>\n</tr>\n<tr>\n<td><a href=\"#verbatim-strings\">Verbatim strings</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>=</code></td>\n</tr>\n<tr>\n<td><a href=\"#maps\">Maps</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>%</code></td>\n</tr>\n<tr>\n<td><a href=\"#sets\">Sets</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>~</code></td>\n</tr>\n<tr>\n<td><a href=\"#pushes\">Pushes</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>&gt;</code></td>\n</tr>\n</tbody></table>\n<h3>Simple strings</h3>\n<p>Simple strings are encoded as a plus (<code>+</code>) character, followed by a string.<br>The string mustn&#39;t contain a CR (<code>\\r</code>) or LF (<code>\\n</code>) character and is terminated by CRLF (i.e., <code>\\r\\n</code>).</p>\n<p>Simple strings transmit short, non-binary strings with minimal overhead.<br>For example, many Valkey commands reply with just &quot;OK&quot; on success.<br>The encoding of this Simple String is the following 5 bytes:</p>\n<pre><code>+OK\\r\\n\n</code></pre>\n<p>When Valkey replies with a simple string, a client library should return to the caller a string value composed of the first character after the <code>+</code> up to the end of the string, excluding the final CRLF bytes.</p>\n<p>To send binary strings, use <a href=\"#bulk-strings\">bulk strings</a> instead.</p>\n<h3>Simple errors</h3>\n<p>RESP has specific data types for errors.<br>Simple errors, or simply just errors, are similar to <a href=\"#simple-strings\">simple strings</a>, but their first character is the minus (<code>-</code>) character.<br>The difference between simple strings and errors in RESP is that clients should treat errors as exceptions, whereas the string encoded in the error type is the error message itself.</p>\n<p>The basic format is:</p>\n<pre><code>-Error message\\r\\n\n</code></pre>\n<p>Valkey replies with an error only when something goes wrong, for example, when you try to operate against the wrong data type, or when the command does not exist.<br>The client should raise an exception when it receives an Error reply.</p>\n<p>The following are examples of error replies:</p>\n<pre><code>-ERR unknown command &#39;asdf&#39;\n-WRONGTYPE Operation against a key holding the wrong kind of value\n</code></pre>\n<p>The first upper-case word after the <code>-</code>, up to the first space or newline, represents the kind of error returned.<br>This word is called an <em>error prefix</em>.<br>Note that the error prefix is a convention used by Valkey rather than part of the RESP error type.</p>\n<p>For example, in Valkey, <code>ERR</code> is a generic error, whereas <code>WRONGTYPE</code> is a more specific error that implies that the client attempted an operation against the wrong data type.<br>The error prefix allows the client to understand the type of error returned by the server without checking the exact error message.</p>\n<p>A client implementation can return different types of exceptions for various errors, or provide a generic way for trapping errors by directly providing the error name to the caller as a string.</p>\n<p>However, such a feature should not be considered vital as it is rarely useful.<br>Also, simpler client implementations can return a generic error value, such as <code>false</code>.</p>\n<h3>Integers</h3>\n<p>This type is a CRLF-terminated string that represents a signed, base-10, 64-bit integer.</p>\n<p>RESP encodes integers in the following way:</p>\n<pre><code>:[&lt;+|-&gt;]&lt;value&gt;\\r\\n\n</code></pre>\n<ul>\n<li>The colon (<code>:</code>) as the first byte.</li>\n<li>An optional plus (<code>+</code>) or minus (<code>-</code>) as the sign.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the integer&#39;s unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n</ul>\n<p>For example, <code>:0\\r\\n</code> and <code>:1000\\r\\n</code> are integer replies (of zero and one thousand, respectively).</p>\n<p>Many Valkey commands return RESP integers, including <code>INCR</code>, <code>LLEN</code>, and <code>LASTSAVE</code>.<br>An integer, by itself, has no special meaning other than in the context of the command that returned it.<br>For example, it is an incremental number for <code>INCR</code>, a UNIX timestamp for <code>LASTSAVE</code>, and so forth.<br>However, the returned integer is guaranteed to be in the range of a signed 64-bit integer.</p>\n<p>In some cases, integers can represent true and false Boolean values.<br>For instance, <code>SISMEMBER</code> returns 1 for true and 0 for false.</p>\n<p>Other commands, including <code>SADD</code>, <code>SREM</code>, and <code>SETNX</code>, return 1 when the data changes and 0 otherwise.</p>\n<h3>Bulk strings</h3>\n<p>A bulk string represents a single binary string.<br>The string can be of any size, but by default, Valkey limits it to 512 MB (see the <code>proto-max-bulk-len</code> configuration directive).</p>\n<p>RESP encodes bulk strings in the following way:</p>\n<pre><code>$&lt;length&gt;\\r\\n&lt;data&gt;\\r\\n\n</code></pre>\n<ul>\n<li>The dollar sign (<code>$</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the string&#39;s length, in bytes, as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>The data.</li>\n<li>A final CRLF.</li>\n</ul>\n<p>So the string &quot;hello&quot; is encoded as follows:</p>\n<pre><code>$5\\r\\nhello\\r\\n\n</code></pre>\n<p>The empty string&#39;s encoding is:</p>\n<pre><code>$0\\r\\n\\r\\n\n</code></pre>\n<p><a name=\"nil-reply\"></a></p>\n<h3>Arrays</h3>\n<p>Clients send commands to the Valkey server as RESP arrays.<br>Similarly, some Valkey commands that return collections of elements use arrays as their replies.<br>An example is the <code>LRANGE</code> command that returns elements of a list.</p>\n<p>RESP Arrays&#39; encoding uses the following format:</p>\n<pre><code>*&lt;number-of-elements&gt;\\r\\n&lt;element-1&gt;...&lt;element-n&gt;\n</code></pre>\n<ul>\n<li>An asterisk (<code>*</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of elements in the array as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>An additional RESP type for every element of the array.</li>\n</ul>\n<p>So an empty Array is just the following:</p>\n<pre><code>*0\\r\\n\n</code></pre>\n<p>Whereas the encoding of an array consisting of the two bulk strings &quot;hello&quot; and &quot;world&quot; is:</p>\n<pre><code>*2\\r\\n$5\\r\\nhello\\r\\n$5\\r\\nworld\\r\\n\n</code></pre>\n<p>As you can see, after the <code>*&lt;count&gt;CRLF</code> part prefixing the array, the other data types that compose the array are concatenated one after the other.<br>For example, an Array of three integers is encoded as follows:</p>\n<pre><code>*3\\r\\n:1\\r\\n:2\\r\\n:3\\r\\n\n</code></pre>\n<p>Arrays can contain mixed data types.<br>For instance, the following encoding is of a list of four integers and a bulk string:</p>\n<pre><code>*5\\r\\n\n:1\\r\\n\n:2\\r\\n\n:3\\r\\n\n:4\\r\\n\n$5\\r\\n\nhello\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<p>The first line the server sent is <code>*5\\r\\n</code>.<br>This numeric value tells the client that five reply types are about to follow it.<br>Then, every successive reply constitutes an element in the array.</p>\n<p>All of the aggregate RESP types support nesting.<br>For example, a nested array of two arrays is encoded as follows:</p>\n<pre><code>*2\\r\\n\n*3\\r\\n\n:1\\r\\n\n:2\\r\\n\n:3\\r\\n\n*2\\r\\n\n+Hello\\r\\n\n-World\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<p>The above encodes a two-element array.<br>The first element is an array that, in turn, contains three integers (1, 2, 3).<br>The second element is another array containing a simple string and an error.</p>\n<p><strong>Note:</strong><br>In some places, the RESP Array type may be referred to as <em>multi bulk</em>.<br>The two are the same.</p>\n<h3>Nulls</h3>\n<p>The null data type represents non-existent values.</p>\n<p>In RESP3, null is encoded using the underscore (<code>_</code>) character, followed by the CRLF terminator (<code>\\r\\n</code>).<br>Here&#39;s null&#39;s raw RESP encoding:</p>\n<pre><code>_\\r\\n\n</code></pre>\n<p>RESP2 features two specially crafted values for representing null values,<br>known as &quot;null bulk strings&quot; and &quot;null arrays&quot;.<br>This duality has always been a redundancy that added zero semantical value to the protocol itself.<br>The null type, introduced in RESP3, aims to fix this wrong.<br>Clients should handle all these representations of null in the same way.<br>For example, a Ruby library should return <code>nil</code> while a C library should return <code>NULL</code> (or set a special flag in the reply object).</p>\n<h4>Null bulk strings</h4>\n<p>Whereas RESP3 has a dedicated data type for <a href=\"#nulls\">null values</a>, RESP2 has no such type.<br>Instead, due to historical reasons, the representation of null values in RESP2 is via predetermined forms of the <a href=\"#bulk-strings\">bulk strings</a> and <a href=\"#arrays\">arrays</a> types.</p>\n<p>The null bulk string represents a non-existing value.<br>The <code>GET</code> command returns the Null Bulk String when the target key doesn&#39;t exist.</p>\n<p>It is encoded as a bulk string with the length of negative one (-1), like so:</p>\n<pre><code>$-1\\r\\n\n</code></pre>\n<p>A Valkey client should return a nil object when the server replies with a null bulk string rather than the empty string.</p>\n<h4>Null arrays</h4>\n<p>Whereas RESP3 has a dedicated data type for <a href=\"#nulls\">null values</a>, RESP2 has no such type. Instead, due to historical reasons, the representation of null values in RESP2 is via predetermined forms of the <a href=\"#bulk-strings\">Bulk Strings</a> and <a href=\"#arrays\">arrays</a> types.</p>\n<p>Null arrays exist as an alternative way of representing a null value.<br>For instance, when the <code>BLPOP</code> command times out, it returns a null array.</p>\n<p>The encoding of a null array is that of an array with the length of -1, i.e.</p>\n<pre><code>*-1\\r\\n\n</code></pre>\n<p>When Valkey replies with a null array, the client should return a null object rather than an empty array.</p>\n<h4>Null elements in arrays</h4>\n<p>Single elements of an array may be <a href=\"#nulls\">null</a>.<br>This is used in Valkey replies to signal that these elements are missing and not empty strings. This can happen, for example, with the <code>SORT</code> command when used with the <code>GET pattern</code> option<br>if the specified key is missing.</p>\n<p>Here&#39;s an example of an array reply containing a null element, represented as a RESP2 null bulk string:</p>\n<pre><code>*3\\r\\n\n$5\\r\\n\nhello\\r\\n\n$-1\\r\\n\n$5\\r\\n\nworld\\r\\n\n</code></pre>\n<p>Above, the second element is null.<br>The client library should return to its caller something like this:</p>\n<pre><code>[&quot;hello&quot;,nil,&quot;world&quot;]\n</code></pre>\n<h3>Booleans</h3>\n<p>RESP booleans are encoded as follows:</p>\n<pre><code>#&lt;t|f&gt;\\r\\n\n</code></pre>\n<ul>\n<li>The octothorpe character (<code>#</code>) as the first byte.</li>\n<li>A <code>t</code> character for true values, or an <code>f</code> character for false ones.</li>\n<li>The CRLF terminator.</li>\n</ul>\n<h3>Doubles</h3>\n<p>The Double RESP type encodes a double-precision floating point value.<br>Doubles are encoded as follows:</p>\n<pre><code>,[&lt;+|-&gt;]&lt;integral&gt;[.&lt;fractional&gt;][&lt;E|e&gt;[sign]&lt;exponent&gt;]\\r\\n\n</code></pre>\n<ul>\n<li>The comma character (<code>,</code>) as the first byte.</li>\n<li>An optional plus (<code>+</code>) or minus (<code>-</code>) as the sign.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 integral value.</li>\n<li>An optional dot (<code>.</code>), followed by one or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 fractional value.</li>\n<li>An optional capital or lowercase letter E (<code>E</code> or <code>e</code>), followed by an optional plus (<code>+</code>) or minus (<code>-</code>) as the exponent&#39;s sign, ending with one or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 exponent value.</li>\n<li>The CRLF terminator.</li>\n</ul>\n<p>Here&#39;s the encoding of the number 1.23:</p>\n<pre><code>,1.23\\r\\n\n</code></pre>\n<p>Because the fractional part is optional, the integer value of ten (10) can, therefore, be RESP-encoded both as an integer as well as a double:</p>\n<pre><code>:10\\r\\n\n,10\\r\\n\n</code></pre>\n<p>In such cases, the Valkey client should return native integer and double values, respectively, providing that these types are supported by the language of its implementation.</p>\n<p>The positive infinity, negative infinity and NaN values are encoded as follows:</p>\n<pre><code>,inf\\r\\n\n,-inf\\r\\n\n,nan\\r\\n\n</code></pre>\n<p><a name=\"big-number-reply\"></a></p>\n<h3>Big numbers</h3>\n<p>This type can encode integer values outside the range of signed 64-bit integers.</p>\n<p>Big numbers use the following encoding:</p>\n<pre><code>([+|-]&lt;number&gt;\\r\\n\n</code></pre>\n<ul>\n<li>The left parenthesis character (<code>(</code>) as the first byte.</li>\n<li>An optional plus (<code>+</code>) or minus (<code>-</code>) as the sign.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n</ul>\n<p>Example:</p>\n<pre><code>(3492890328409238509324850943850943825024385\\r\\n\n</code></pre>\n<p>Big numbers can be positive or negative but can&#39;t include fractionals.<br>Client libraries written in languages with a big number type should return a big number.<br>When big numbers aren&#39;t supported, the client should return a string and, when possible, signal to the caller that the reply is a big integer (depending on the API used by the client library).</p>\n<h3>Bulk errors</h3>\n<p>This type combines the purpose of <a href=\"#simple-errors\">simple errors</a> with the expressive power of <a href=\"#bulk-strings\">bulk strings</a>.</p>\n<p>It is encoded as:</p>\n<pre><code>!&lt;length&gt;\\r\\n&lt;error&gt;\\r\\n\n</code></pre>\n<ul>\n<li>An exclamation mark (<code>!</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the error&#39;s length, in bytes, as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>The error itself.</li>\n<li>A final CRLF.</li>\n</ul>\n<p>As a convention, the error begins with an uppercase (space-delimited) word that conveys the error message.</p>\n<p>For instance, the error &quot;SYNTAX invalid syntax&quot; is represented by the following protocol encoding:</p>\n<pre><code>!21\\r\\n\nSYNTAX invalid syntax\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<h3>Verbatim strings</h3>\n<p>This type is similar to the <a href=\"#bulk-strings\">bulk string</a>, with the addition of providing a hint about the data&#39;s encoding.</p>\n<p>A verbatim string&#39;s RESP encoding is as follows:</p>\n<pre><code>=&lt;length&gt;\\r\\n&lt;encoding&gt;:&lt;data&gt;\\r\\n\n</code></pre>\n<ul>\n<li>An equal sign (<code>=</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the string&#39;s total length, in bytes, as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>Exactly three (3) bytes represent the data&#39;s encoding.</li>\n<li>The colon (<code>:</code>) character separates the encoding and data.</li>\n<li>The data.</li>\n<li>A final CRLF.</li>\n</ul>\n<p>Example:</p>\n<pre><code>=15\\r\\n\ntxt:Some string\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<p>Some client libraries may ignore the difference between this type and the string type and return a native string in both cases.<br>However, interactive clients, such as command line interfaces (e.g., <a href=\"cli.md\"><code>valkey-cli</code></a>), can use this type and know that their output should be presented to the human user as is and without quoting the string.</p>\n<p>For example, the Valkey command <code>INFO</code> outputs a report that includes newlines.<br>When using RESP3, <code>valkey-cli</code> displays it correctly because it is sent as a Verbatim String reply (with its three bytes being &quot;txt&quot;).<br>When using RESP2, however, the <code>valkey-cli</code> is hard-coded to look for the <code>INFO</code> command to ensure its correct display to the user.</p>\n<h3>Maps</h3>\n<p>The RESP map encodes a collection of key-value tuples, i.e., a dictionary or a hash.</p>\n<p>It is encoded as follows:</p>\n<pre><code>%&lt;number-of-entries&gt;\\r\\n&lt;key-1&gt;&lt;value-1&gt;...&lt;key-n&gt;&lt;value-n&gt;\n</code></pre>\n<ul>\n<li>A percent character (<code>%</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of entries, or key-value tuples, in the map as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>Two additional RESP types for every key and value in the map.</li>\n</ul>\n<p>For example, the following JSON object:</p>\n<pre><code>{\n    &quot;first&quot;: 1,\n    &quot;second&quot;: 2\n}\n</code></pre>\n<p>Can be encoded in RESP like so:</p>\n<pre><code>%2\\r\\n\n+first\\r\\n\n:1\\r\\n\n+second\\r\\n\n:2\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<p>Both map keys and values can be any of RESP&#39;s types.</p>\n<p>Valkey clients should return the idiomatic dictionary type that their language provides.<br>However, low-level programming languages (such as C, for example) will likely return an array along with type information that indicates to the caller that it is a dictionary.</p>\n<p><strong>Note:</strong><br>RESP2 doesn&#39;t have a map type.<br>A map in RESP2 is represented by a flat array containing the keys and the values.<br>The first element is a key, followed by the corresponding value, then the next key and so on, like this:<br><code>key1, value1, key2, value2, ...</code>.</p>\n<h3>Sets</h3>\n<p>Sets are somewhat like <a href=\"#arrays\">Arrays</a> but are unordered and should only contain unique elements.</p>\n<p>RESP set&#39;s encoding is:</p>\n<pre><code>~&lt;number-of-elements&gt;\\r\\n&lt;element-1&gt;...&lt;element-n&gt;\n</code></pre>\n<ul>\n<li>A tilde (<code>~</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of elements in the set as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>An additional RESP type for every element of the Set.</li>\n</ul>\n<p>Clients should return the native set type if it is available in their programming language.<br>Alternatively, in the absence of a native set type, an array coupled with type information can be used (in C, for example).</p>\n<p><a name=\"push-event\"></a></p>\n<h3>Pushes</h3>\n<p>RESP&#39;s pushes contain out-of-band data.<br>They are an exception to the protocol&#39;s request-response model and provide a generic <em>push mode</em> for connections.</p>\n<p>Push events are encoded similarly to <a href=\"#arrays\">arrays</a>, differing only in their first byte:</p>\n<pre><code>&gt;&lt;number-of-elements&gt;\\r\\n&lt;element-1&gt;...&lt;element-n&gt;\n</code></pre>\n<ul>\n<li>A greater-than sign (<code>&gt;</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of elements in the message as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>An additional RESP type for every element of the push event.</li>\n</ul>\n<p>Pushed data may precede or follow any of RESP&#39;s data types but never inside them.<br>That means a client won&#39;t find push data in the middle of a map reply, for example.<br>It also means that pushed data may appear before or after a command&#39;s reply, as well as by itself (without calling any command).</p>\n<p>Clients should react to pushes by invoking a callback that implements their handling of the pushed data.</p>\n<h2>Client handshake</h2>\n<p>New RESP connections should begin the session by calling the <code>HELLO</code> command.<br>This practice accomplishes two things:</p>\n<ol>\n<li>It allows servers to be backward compatible with RESP2 versions.<br>  This is needed in Valkey to make the transition to version 3 of the protocol gentler.</li>\n<li>The <code>HELLO</code> command returns information about the server and the protocol that the client can use for different goals.</li>\n</ol>\n<p>The <code>HELLO</code> command has the following high-level syntax:</p>\n<pre><code>HELLO &lt;protocol-version&gt; [optional-arguments]\n</code></pre>\n<p>The first argument of the command is the protocol version we want the connection to be set.<br>By default, the connection starts in RESP2 mode.<br>If we specify a connection version that is too big and unsupported by the server, it should reply with a <code>-NOPROTO</code> error. Example:</p>\n<pre><code>Client: HELLO 4\nServer: -NOPROTO sorry, this protocol version is not supported.\n</code></pre>\n<p>At that point, the client may retry with a lower protocol version.</p>\n<p>Similarly, the client can easily detect a server that is only able to speak RESP2:</p>\n<pre><code>Client: HELLO 3\nServer: -ERR unknown command &#39;HELLO&#39;\n</code></pre>\n<p>The client can then proceed and use RESP2 to communicate with the server.</p>\n<p>Note that even if the protocol&#39;s version is supported, the <code>HELLO</code> command may return an error, perform no action and remain in RESP2 mode.<br>For example, when used with invalid authentication credentials in the command&#39;s optional <code>!AUTH</code> clause:</p>\n<pre><code>Client: HELLO 3 AUTH default mypassword\nServer: -ERR invalid password\n(the connection remains in RESP2 mode)\n</code></pre>\n<p>A successful reply to the <code>HELLO</code> command is a map reply.<br>The information in the reply is partly server-dependent, but certain fields are mandatory for all the RESP3 implementations:</p>\n<ul>\n<li><strong>server</strong>: &quot;redis&quot; (or other software name).</li>\n<li><strong>version</strong>: the server&#39;s version.</li>\n<li><strong>proto</strong>: the highest supported version of the RESP protocol.</li>\n</ul>\n<p>In Valkey&#39; RESP3 implementation, the following fields are also emitted:</p>\n<ul>\n<li><strong>id</strong>: the connection&#39;s identifier (ID).</li>\n<li><strong>mode</strong>: &quot;standalone&quot;, &quot;sentinel&quot; or &quot;cluster&quot;.</li>\n<li><strong>role</strong>: &quot;primary&quot; or &quot;replica&quot;.</li>\n<li><strong>modules</strong>: list of loaded modules as an Array of Bulk Strings.</li>\n</ul>\n<h2>Sending commands to a Valkey server</h2>\n<p>Now that you are familiar with the RESP serialization format, you can use it to help write a Valkey client library.<br>We can further specify how the interaction between the client and the server works:</p>\n<ul>\n<li>A client sends the Valkey server an <a href=\"#arrays\">array</a> consisting of only bulk strings.</li>\n<li>A Valkey server replies to clients, sending any valid RESP data type as a reply.</li>\n</ul>\n<p>So, for example, a typical interaction could be the following.</p>\n<p>The client sends the command <code>LLEN mylist</code> to get the length of the list stored at the key <em>mylist</em>.<br>Then the server replies with an <a href=\"#integers\">integer</a> reply as in the following example (<code>C:</code> is the client, <code>S:</code> the server).</p>\n<pre><code>C: *2\\r\\n\nC: $4\\r\\n\nC: LLEN\\r\\n\nC: $6\\r\\n\nC: mylist\\r\\n\n\nS: :48293\\r\\n\n</code></pre>\n<p>As usual, we separate different parts of the protocol with newlines for simplicity, but the actual interaction is the client sending <code>*2\\r\\n$4\\r\\nLLEN\\r\\n$6\\r\\nmylist\\r\\n</code> as a whole.</p>\n<h2>Multiple commands and pipelining</h2>\n<p>A client can use the same connection to issue multiple commands.<br>Pipelining is supported, so multiple commands can be sent with a single write operation by the client.<br>The client can skip reading replies and continue to send the commands one after the other.<br>All the replies can be read at the end.</p>\n<p>For more information, see <a href=\"pipelining.md\">Pipelining</a>.</p>\n<h2>Inline commands</h2>\n<p>Sometimes you may need to send a command to the Valkey server but only have <code>telnet</code> available.<br>While the Valkey protocol is simple to implement, it is not ideal for interactive sessions, and <code>valkey-cli</code> may not always be available.<br>For this reason, Valkey also accepts commands in the <em>inline command</em> format.</p>\n<p>The following example demonstrates a server/client exchange using an inline command (the server chat starts with <code>S:</code>, the client chat with <code>C:</code>):</p>\n<pre><code>C: PING\nS: +PONG\n</code></pre>\n<p>Here&#39;s another example of an inline command where the server returns an integer:</p>\n<pre><code>C: EXISTS somekey\nS: :0\n</code></pre>\n<p>Basically, to issue an inline command, you write space-separated arguments in a telnet session.<br>Since no command starts with <code>*</code> (the identifying byte of RESP Arrays), Valkey detects this condition and parses your command inline.</p>\n<h2>High-performance parser for the Valkey protocol</h2>\n<p>While the Valkey protocol is human-readable and easy to implement, its implementation can exhibit performance similar to that of a binary protocol.</p>\n<p>RESP uses prefixed lengths to transfer bulk data.<br>That makes scanning the payload for special characters unnecessary (unlike parsing JSON, for example).<br>For the same reason, quoting and escaping the payload isn&#39;t needed.</p>\n<p>Reading the length of aggregate types (for example, bulk strings or arrays) can be processed with code that performs a single operation per character while at the same time scanning for the CR character.</p>\n<p>Example (in C):</p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint main(void) {\n    unsigned char *p = &quot;$123\\r\\n&quot;;\n    int len = 0;\n\n    p++;\n    while(*p != &#39;\\r&#39;) {\n        len = (len*10)+(*p - &#39;0&#39;);\n        p++;\n    }\n\n    /* Now p points at &#39;\\r&#39;, and the len is in bulk_len. */\n    printf(&quot;%d\\n&quot;, len);\n    return 0;\n}\n</code></pre>\n<p>After the first CR is identified, it can be skipped along with the following LF without further processing.<br>Then, the bulk data can be read with a single read operation that doesn&#39;t inspect the payload in any way.<br>Finally, the remaining CR and LF characters are discarded without additional processing.</p>\n<p>While comparable in performance to a binary protocol, the Valkey protocol is significantly more straightforward to implement in most high-level languages, reducing the number of bugs in client software.</p>\n<h2>Tips for Valkey client authors</h2>\n<ul>\n<li>For testing purposes, use <a href=\"lua-api.md#lua-to-resp3-type-conversion\">Lua&#39;s type conversions</a> to have Valkey reply with any RESP2/RESP3 needed.<br>As an example, a RESP3 double can be generated like so:<pre><code>EVAL &quot;return { double = tonumber(ARGV[1]) }&quot; 0 1e0\n</code></pre>\n</li>\n</ul>\n"
  },
  {
    "id": "strings",
    "topicName": "Strings",
    "description": "Introduction to Strings\n",
    "htmlContent": "<p>Strings store sequences of bytes, including text, serialized objects, and binary arrays.<br>As such, strings are the simplest type of value you can associate with<br>a Valkey key.<br>They&#39;re often used for caching, but they support additional functionality that lets you implement counters and perform bitwise operations, too.</p>\n<p>Since Valkey keys are strings, when we use the string type as a value too,<br>we are mapping a string to another string. The string data type is useful<br>for a number of use cases, like caching HTML fragments or pages.</p>\n<pre><code>127.0.0.1:6379&gt; SET bike:1 Deimos\nOK\n127.0.0.1:6379&gt; GET bike:1\n&quot;Deimos&quot;\n</code></pre>\n<p>As you can see using the <code>SET</code> and the <code>GET</code> commands are the way we set<br>and retrieve a string value. Note that <code>SET</code> will replace any existing value<br>already stored into the key, in the case that the key already exists, even if<br>the key is associated with a non-string value. So <code>SET</code> performs an assignment.</p>\n<p>Values can be strings (including binary data) of every kind, for instance you<br>can store a jpeg image inside a value. A value can&#39;t be bigger than 512 MB.</p>\n<p>The <code>SET</code> command has interesting options, that are provided as additional<br>arguments. For example, I may ask <code>SET</code> to fail if the key already exists,<br>or the opposite, that it only succeed if the key already exists:</p>\n<pre><code>127.0.0.1:6379&gt; set bike:1 bike nx\n(nil)\n127.0.0.1:6379&gt; set bike:1 bike xx\nOK\n</code></pre>\n<p>There are a number of other commands for operating on strings. For example<br>the <code>GETSET</code> command sets a key to a new value, returning the old value as the<br>result. You can use this command, for example, if you have a<br>system that increments a Valkey key using <code>INCR</code><br>every time your web site receives a new visitor. You may want to collect this<br>information once every hour, without losing a single increment.<br>You can <code>GETSET</code> the key, assigning it the new value of &quot;0&quot; and reading the<br>old value back.</p>\n<p>The ability to set or retrieve the value of multiple keys in a single<br>command is also useful for reduced latency. For this reason there are<br>the <code>MSET</code> and <code>MGET</code> commands:</p>\n<pre><code>127.0.0.1:6379&gt; mset bike:1 &quot;Deimos&quot; bike:2 &quot;Ares&quot; bike:3 &quot;Vanth&quot;\nOK\n127.0.0.1:6379&gt; mget bike:1 bike:2 bike:3\n1) &quot;Deimos&quot;\n2) &quot;Ares&quot;\n3) &quot;Vanth&quot;\n</code></pre>\n<p>When <code>MGET</code> is used, Valkey returns an array of values.</p>\n<h3>Strings as counters</h3>\n<p>Even if strings are the basic values of Valkey, there are interesting operations<br>you can perform with them. For instance, one is atomic increment:</p>\n<pre><code>127.0.0.1:6379&gt; set total_crashes 0\nOK\n127.0.0.1:6379&gt; incr total_crashes\n(integer) 1\n127.0.0.1:6379&gt; incrby total_crashes 10\n(integer) 11\n</code></pre>\n<p>The <code>INCR</code> command parses the string value as an integer,<br>increments it by one, and finally sets the obtained value as the new value.<br>There are other similar commands like <code>INCRBY</code>,<br><code>DECR</code> and <code>DECRBY</code>. Internally it&#39;s<br>always the same command, acting in a slightly different way.</p>\n<p>What does it mean that INCR is atomic?<br>That even multiple clients issuing INCR against<br>the same key will never enter into a race condition. For instance, it will never<br>happen that client 1 reads &quot;10&quot;, client 2 reads &quot;10&quot; at the same time, both<br>increment to 11, and set the new value to 11. The final value will always be<br>12 and the read-increment-set operation is performed while all the other<br>clients are not executing a command at the same time.</p>\n<h2>Limits</h2>\n<p>By default, a single String can be a maximum of 512 MB.</p>\n<h2>Basic commands</h2>\n<h3>Getting and setting Strings</h3>\n<ul>\n<li><code>SET</code> stores a string value.</li>\n<li><code>SETNX</code> stores a string value only if the key doesn&#39;t already exist. Useful for implementing locks.</li>\n<li><code>GET</code> retrieves a string value.</li>\n<li><code>MGET</code> retrieves multiple string values in a single operation.</li>\n</ul>\n<h3>Managing counters</h3>\n<ul>\n<li><code>INCRBY</code> atomically increments (and decrements when passing a negative number) counters stored at a given key.</li>\n<li>Another command exists for floating point counters: <code>INCRBYFLOAT</code>.</li>\n</ul>\n<h3>Bitwise operations</h3>\n<p>To perform bitwise operations on a string, see the <a href=\"bitmaps.md\">bitmaps data type</a> docs.</p>\n<p>See the <a href=\"../commands/#string\">complete list of string commands</a>.</p>\n<h2>Performance</h2>\n<p>Most string operations are O(1), which means they&#39;re highly efficient.<br>However, be careful with the <code>SUBSTR</code>, <code>GETRANGE</code>, and <code>SETRANGE</code> commands, which can be O(n).<br>These random-access string commands may cause performance issues when dealing with large strings.</p>\n<h2>Alternatives</h2>\n<p>If you&#39;re storing structured data as a serialized string, you may also want to consider Valkey <a href=\"hashes.md\">hashes</a>.</p>\n"
  },
  {
    "id": "lists",
    "topicName": "Lists",
    "description": "Introduction to Lists\n",
    "htmlContent": "<p>Lists are linked lists of string values.<br>Lists are frequently used to:</p>\n<ul>\n<li>Implement stacks and queues.</li>\n<li>Build queue management for background worker systems.</li>\n</ul>\n<h2>Basic commands</h2>\n<ul>\n<li><code>LPUSH</code> adds a new element to the head of a list; <code>RPUSH</code> adds to the tail.</li>\n<li><code>LPOP</code> removes and returns an element from the head of a list; <code>RPOP</code> does the same but from the tails of a list. </li>\n<li><code>LLEN</code> returns the length of a list.</li>\n<li><code>LMOVE</code> atomically moves elements from one list to another.</li>\n<li><code>LTRIM</code> reduces a list to the specified range of elements.</li>\n</ul>\n<h3>Blocking commands</h3>\n<p>Lists support several blocking commands.<br>For example:</p>\n<ul>\n<li><code>BLPOP</code> removes and returns an element from the head of a list.<br>If the list is empty, the command blocks until an element becomes available or until the specified timeout is reached.</li>\n<li><code>BLMOVE</code> atomically moves elements from a source list to a target list.<br>If the source list is empty, the command will block until a new element becomes available.</li>\n</ul>\n<p>See the <a href=\"../commands/#list\">complete series of list commands</a>.</p>\n<h2>Examples</h2>\n<ul>\n<li>Treat a list like a queue (first in, first out):</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; LPUSH bikes:repairs bike:1\n(integer) 1\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:2\n(integer) 2\n127.0.0.1:6379&gt; RPOP bikes:repairs\n&quot;bike:1&quot;\n127.0.0.1:6379&gt; RPOP bikes:repairs\n&quot;bike:2&quot;\n</code></pre>\n<ul>\n<li>Treat a list like a stack (first in, last out):</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; LPUSH bikes:repairs bike:1\n(integer) 1\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:2\n(integer) 2\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:2&quot;\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:1&quot;\n</code></pre>\n<ul>\n<li>Check the length of a list:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; LLEN bikes:repairs\n(integer) 0\n</code></pre>\n<ul>\n<li>Atomically pop an element from one list and push to another:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; LPUSH bikes:repairs bike:1\n(integer) 1\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:2\n(integer) 2\n127.0.0.1:6379&gt; LMOVE bikes:repairs bikes:finished LEFT LEFT\n&quot;bike:2&quot;\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:1&quot;\n127.0.0.1:6379&gt; LRANGE bikes:finished 0 -1\n1) &quot;bike:2&quot;\n</code></pre>\n<ul>\n<li>To limit the length of a list you can call <code>LTRIM</code>:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3 bike:4 bike:5\n(integer) 5\n127.0.0.1:6379&gt; LTRIM bikes:repairs 0 2\nOK\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:1&quot;\n2) &quot;bike:2&quot;\n3) &quot;bike:3&quot;\n</code></pre>\n<h3>What are Lists?</h3>\n<p>To explain the List data type it&#39;s better to start with a little bit of theory,<br>as the term <em>List</em> is often used in an improper way by information technology<br>folks. For instance &quot;Python Lists&quot; are not what the name may suggest (Linked<br>Lists), but rather Arrays (the same data type is called Array in<br>Ruby actually).</p>\n<p>From a very general point of view a List is just a sequence of ordered<br>elements: 10,20,1,2,3 is a list. But the properties of a List implemented using<br>an Array are very different from the properties of a List implemented using a<br><em>Linked List</em>.</p>\n<p>Lists are implemented via Linked Lists. This means that even if you have<br>millions of elements inside a list, the operation of adding a new element in<br>the head or in the tail of the list is performed <em>in constant time</em>. The speed of adding a<br>new element with the <code>LPUSH</code> command to the head of a list with ten<br>elements is the same as adding an element to the head of list with 10<br>million elements.</p>\n<p>What&#39;s the downside? Accessing an element <em>by index</em> is very fast in lists<br>implemented with an Array (constant time indexed access) and not so fast in<br>lists implemented by linked lists (where the operation requires an amount of<br>work proportional to the index of the accessed element).</p>\n<p>Lists are implemented with linked lists because for a database system it<br>is crucial to be able to add elements to a very long list in a very fast way.<br>Another strong advantage, as you&#39;ll see in a moment, is that Lists can be<br>taken at constant length in constant time.</p>\n<p>When fast access to the middle of a large collection of elements is important,<br>there is a different data structure that can be used, called sorted sets.<br>Sorted sets are covered in the <a href=\"sorted-sets.md\">Sorted sets</a> tutorial page.</p>\n<h3>First steps with Lists</h3>\n<p>The <code>LPUSH</code> command adds a new element into a list, on the<br>left (at the head), while the <code>RPUSH</code> command adds a new<br>element into a list, on the right (at the tail). Finally the<br><code>LRANGE</code> command extracts ranges of elements from lists:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1\n(integer) 1\n127.0.0.1:6379&gt; RPUSH bikes:repairs bike:2\n(integer) 2\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:important_bike\n(integer) 3\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:important_bike&quot;\n2) &quot;bike:1&quot;\n3) &quot;bike:2&quot;\n</code></pre>\n<p>Note that <code>LRANGE</code> takes two indexes, the first and the last<br>element of the range to return. Both the indexes can be negative, telling Valkey<br>to start counting from the end: so -1 is the last element, -2 is the<br>penultimate element of the list, and so forth.</p>\n<p>As you can see <code>RPUSH</code> appended the elements on the right of the list, while<br>the final <code>LPUSH</code> appended the element on the left.</p>\n<p>Both commands are <em>variadic commands</em>, meaning that you are free to push<br>multiple elements into a list in a single call:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:important_bike bike:very_important_bike\n127.0.0.1:6379&gt; LRANGE mylist 0 -1\n1) &quot;bike:very_important_bike&quot;\n2) &quot;bike:important_bike&quot;\n3) &quot;bike:1&quot;\n4) &quot;bike:2&quot;\n5) &quot;bike:3&quot;\n</code></pre>\n<p>An important operation defined on Lists is the ability to <em>pop elements</em>.<br>Popping elements is the operation of both retrieving the element from the list,<br>and eliminating it from the list, at the same time. You can pop elements<br>from left and right, similarly to how you can push elements in both sides<br>of the list. We&#39;ll add three elements and pop three elements, so at the end of this<br>sequence of commands the list is empty and there are no more elements to<br>pop:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; RPOP bikes:repairs\n&quot;bike:3&quot;\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:1&quot;\n127.0.0.1:6379&gt; RPOP bikes:repairs\n&quot;bike:2&quot;\n127.0.0.1:6379&gt; RPOP bikes:repairs\n(nil)\n</code></pre>\n<p>Valkey returned a NULL value to signal that there are no elements in the<br>list.</p>\n<h3>Common use cases for lists</h3>\n<p>Lists are useful for a number of tasks, two very representative use cases<br>are the following:</p>\n<ul>\n<li>Remember the latest updates posted by users into a social network.</li>\n<li>Communication between processes, using a consumer-producer pattern where the producer pushes items into a list, and a consumer (usually a <em>worker</em>) consumes those items and executes actions. Valkey has special list commands to make this use case both more reliable and efficient.</li>\n</ul>\n<p>For example both the popular Ruby libraries <a href=\"https://github.com/resque/resque\">resque</a> and<br><a href=\"https://github.com/mperham/sidekiq\">sidekiq</a> use Lists under the hood in order to<br>implement background jobs.</p>\n<p>The popular Twitter social network <a href=\"https://www.infoq.com/presentations/Real-Time-Delivery-Twitter\">takes the latest tweets</a><br>posted by users into Lists.</p>\n<p>To describe a common use case step by step, imagine your home page shows the latest<br>photos published in a photo sharing social network and you want to speedup access.</p>\n<ul>\n<li>Every time a user posts a new photo, we add its ID into a list with <code>LPUSH</code>.</li>\n<li>When users visit the home page, we use <code>LRANGE 0 9</code> in order to get the latest 10 posted items.</li>\n</ul>\n<h3>Capped lists</h3>\n<p>In many use cases we just want to use lists to store the <em>latest items</em>,<br>whatever they are: social network updates, logs, or anything else.</p>\n<p>Valkey allows us to use lists as a capped collection, only remembering the latest<br>N items and discarding all the oldest items using the <code>LTRIM</code> command.</p>\n<p>The <code>LTRIM</code> command is similar to <code>LRANGE</code>, but <strong>instead of displaying the<br>specified range of elements</strong> it sets this range as the new list value. All<br>the elements outside the given range are removed.</p>\n<p>For example, if you&#39;re adding bikes on the end of a list of repairs, but only<br>want to worry about the 3 that have been on the list the longest:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3 bike:4 bike:5\n(integer) 5\n127.0.0.1:6379&gt; LTRIM bikes:repairs 0 2\nOK\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:1&quot;\n2) &quot;bike:2&quot;\n3) &quot;bike:3&quot;\n</code></pre>\n<p>The above <code>LTRIM</code> command tells Valkey to keep just list elements from index<br>0 to 2, everything else will be discarded. This allows for a very simple but<br>useful pattern: doing a List push operation + a List trim operation together<br>to add a new element and discard elements exceeding a limit. Using<br><code>LTRIM</code> with negative indexes can then be used to keep only the 3 most recently added:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3 bike:4 bike:5\n(integer) 5\n127.0.0.1:6379&gt; LTRIM bikes:repairs -3 -1\nOK\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:3&quot;\n2) &quot;bike:4&quot;\n3) &quot;bike:5&quot;\n</code></pre>\n<p>The above combination adds new elements and keeps only the 3<br>newest elements into the list. With <code>LRANGE</code> you can access the top items<br>without any need to remember very old data.</p>\n<p>Note: while <code>LRANGE</code> is technically an O(N) command, accessing small ranges<br>towards the head or the tail of the list is a constant time operation.</p>\n<h2>Blocking operations on lists</h2>\n<p>Lists have a special feature that make them suitable to implement queues,<br>and in general as a building block for inter process communication systems:<br>blocking operations.</p>\n<p>Imagine you want to push items into a list with one process, and use<br>a different process in order to actually do some kind of work with those<br>items. This is the usual producer / consumer setup, and can be implemented<br>in the following simple way:</p>\n<ul>\n<li>To push items into the list, producers call <code>LPUSH</code>.</li>\n<li>To extract / process items from the list, consumers call <code>RPOP</code>.</li>\n</ul>\n<p>However it is possible that sometimes the list is empty and there is nothing<br>to process, so <code>RPOP</code> just returns NULL. In this case a consumer is forced to wait<br>some time and retry again with <code>RPOP</code>. This is called <em>polling</em>, and is not<br>a good idea in this context because it has several drawbacks:</p>\n<ol>\n<li>Forces Valkey and clients to process useless commands (all the requests when the list is empty will get no actual work done, they&#39;ll just return NULL).</li>\n<li>Adds a delay to the processing of items, since after a worker receives a NULL, it waits some time. To make the delay smaller, we could wait less between calls to <code>RPOP</code>, with the effect of amplifying problem number 1, i.e. more useless calls to Valkey.</li>\n</ol>\n<p>So Valkey implements commands called <code>BRPOP</code> and <code>BLPOP</code> which are versions<br>of <code>RPOP</code> and <code>LPOP</code> able to block if the list is empty: they&#39;ll return to<br>the caller only when a new element is added to the list, or when a user-specified<br>timeout is reached.</p>\n<p>This is an example of a <code>BRPOP</code> call we could use in the worker:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2\n(integer) 2\n127.0.0.1:6379&gt; BRPOP bikes:repairs 1\n1) &quot;bikes:repairs&quot;\n2) &quot;bike:2&quot;\n127.0.0.1:6379&gt; BRPOP bikes:repairs 1\n1) &quot;bikes:repairs&quot;\n2) &quot;bike:1&quot;\n127.0.0.1:6379&gt; BRPOP bikes:repairs 1\n(nil)\n(2.01s)\n</code></pre>\n<p>It means: &quot;wait for elements in the list <code>bikes:repairs</code>, but return if after 1 second<br>no element is available&quot;.</p>\n<p>Note that you can use 0 as timeout to wait for elements forever, and you can<br>also specify multiple lists and not just one, in order to wait on multiple<br>lists at the same time, and get notified when the first list receives an<br>element.</p>\n<p>A few things to note about <code>BRPOP</code>:</p>\n<ol>\n<li>Clients are served in an ordered way: the first client that blocked waiting for a list, is served first when an element is pushed by some other client, and so forth.</li>\n<li>The return value is different compared to <code>RPOP</code>: it is a two-element array since it also includes the name of the key, because <code>BRPOP</code> and <code>BLPOP</code> are able to block waiting for elements from multiple lists.</li>\n<li>If the timeout is reached, NULL is returned.</li>\n</ol>\n<p>There are more things you should know about lists and blocking ops. We<br>suggest that you read more on the following:</p>\n<ul>\n<li>It is possible to build safer queues or rotating queues using <code>LMOVE</code>.</li>\n<li>There is also a blocking variant of the command, called <code>BLMOVE</code>.</li>\n</ul>\n<h2>Automatic creation and removal of keys</h2>\n<p>So far in our examples we never had to create empty lists before pushing<br>elements, or removing empty lists when they no longer have elements inside.<br>It is Valkey&#39; responsibility to delete keys when lists are left empty, or to create<br>an empty list if the key does not exist and we are trying to add elements<br>to it, for example, with <code>LPUSH</code>.</p>\n<p>This is not specific to lists, it applies to all the Valkey data types<br>composed of multiple elements -- Streams, Sets, Sorted Sets and Hashes.</p>\n<p>Basically we can summarize the behavior with three rules:</p>\n<ol>\n<li>When we add an element to an aggregate data type, if the target key does not exist, an empty aggregate data type is created before adding the element.</li>\n<li>When we remove elements from an aggregate data type, if the value remains empty, the key is automatically destroyed. The Stream data type is the only exception to this rule.</li>\n<li>Calling a read-only command such as <code>LLEN</code> (which returns the length of the list), or a write command removing elements, with an empty key, always produces the same result as if the key is holding an empty aggregate type of the type the command expects to find.</li>\n</ol>\n<p>Examples of rule 1:</p>\n<pre><code>127.0.0.1:6379&gt; DEL new_bikes\n(integer) 0\n127.0.0.1:6379&gt; LPUSH new_bikes bike:1 bike:2 bike:3\n(integer) 3\n</code></pre>\n<p>However we can&#39;t perform operations against the wrong type if the key exists:</p>\n<pre><code>127.0.0.1:6379&gt; SET new_bikes bike:1\nOK\n127.0.0.1:6379&gt; TYPE new_bikes\nstring\n127.0.0.1:6379&gt; LPUSH new_bikes bike:2 bike:3\n(error) WRONGTYPE Operation against a key holding the wrong kind of value\n</code></pre>\n<p>Example of rule 2:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; EXISTS bikes:repairs\n(integer) 1\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:3&quot;\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:2&quot;\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:1&quot;\n127.0.0.1:6379&gt; EXISTS bikes:repairs\n(integer) 0\n</code></pre>\n<p>The key no longer exists after all the elements are popped.</p>\n<p>Example of rule 3:</p>\n<pre><code>127.0.0.1:6379&gt; DEL bikes:repairs\n(integer) 0\n127.0.0.1:6379&gt; LLEN bikes:repairs\n(integer) 0\n127.0.0.1:6379&gt; LPOP bikes:repairs\n(nil)\n</code></pre>\n<h2>Limits</h2>\n<p>The max length of a List is 2^32 - 1 (4,294,967,295) elements.</p>\n<h2>Performance</h2>\n<p>List operations that access its head or tail are O(1), which means they&#39;re highly efficient.<br>However, commands that manipulate elements within a list are usually O(n).<br>Examples of these include <code>LINDEX</code>, <code>LINSERT</code>, and <code>LSET</code>.<br>Exercise caution when running these commands, mainly when operating on large lists.</p>\n<h2>Alternatives</h2>\n<p>Consider <a href=\"streams-intro.md\">Streams</a> as an alternative to lists when you need to store and process an indeterminate series of events.</p>\n"
  },
  {
    "id": "sets",
    "topicName": "Sets",
    "description": "Introduction to Sets\n",
    "htmlContent": "<p>A Set is an unordered collection of unique strings (members).<br>You can use Sets to efficiently:</p>\n<ul>\n<li>Track unique items (e.g., track all unique IP addresses accessing a given blog post).</li>\n<li>Represent relations (e.g., the set of all users with a given role).</li>\n<li>Perform common set operations such as intersection, unions, and differences.</li>\n</ul>\n<h2>Basic commands</h2>\n<ul>\n<li><code>SADD</code> adds a new member to a set.</li>\n<li><code>SREM</code> removes the specified member from the set.</li>\n<li><code>SISMEMBER</code> tests a string for set membership.</li>\n<li><code>SINTER</code> returns the set of members that two or more sets have in common (i.e., the intersection).</li>\n<li><code>SCARD</code> returns the size (a.k.a. cardinality) of a set.</li>\n</ul>\n<p>See the <a href=\"../commands/#set\">complete list of set commands</a>.</p>\n<h2>Examples</h2>\n<ul>\n<li>Store the sets of bikes racing in France and the USA. Note that<br>if you add a member that already exists, it will be ignored.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:france bike:1\n(integer) 1\n127.0.0.1:6379&gt; SADD bikes:racing:france bike:1\n(integer) 0\n127.0.0.1:6379&gt; SADD bikes:racing:france bike:2 bike:3\n(integer) 2\n127.0.0.1:6379&gt; SADD bikes:racing:usa bike:1 bike:4\n(integer) 2\n</code></pre>\n<ul>\n<li>Check whether bike:1 or bike:2 are racing in the US.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SISMEMBER bikes:racing:usa bike:1\n(integer) 1\n127.0.0.1:6379&gt; SISMEMBER bikes:racing:usa bike:2\n(integer) 0\n</code></pre>\n<ul>\n<li>Which bikes are competing in both races?</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SINTER bikes:racing:france bikes:racing:usa\n1) &quot;bike:1&quot;\n</code></pre>\n<ul>\n<li>How many bikes are racing in France?</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SCARD bikes:racing:france\n(integer) 3\n</code></pre>\n<h2>Tutorial</h2>\n<p>The <code>SADD</code> command adds new elements to a set. It&#39;s also possible<br>to do a number of other operations against sets like testing if a given element<br>already exists, performing the intersection, union or difference between<br>multiple sets, and so forth.</p>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:france bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; SMEMBERS bikes:racing:france\n1) bike:3\n2) bike:1\n3) bike:2\n</code></pre>\n<p>Here I&#39;ve added three elements to my set and told Valkey to return all the<br>elements. There is no order guarantee with a set. Valkey is free to return the<br>elements in any order at every call.</p>\n<p>Valkey has commands to test for set membership. These commands can be used on single as well as multiple items:</p>\n<pre><code>127.0.0.1:6379&gt; SISMEMBER bikes:racing:france bike:1\n(integer) 1\n127.0.0.1:6379&gt; SMISMEMBER bikes:racing:france bike:2 bike:3 bike:4\n1) (integer) 1\n2) (integer) 1\n3) (integer) 0\n</code></pre>\n<p>We can also find the difference between two sets. For instance, we may want<br>to know which bikes are racing in France but not in the USA:</p>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:usa bike:1 bike:4\n(integer) 2\n127.0.0.1:6379&gt; SDIFF bikes:racing:france bikes:racing:usa\n1) &quot;bike:3&quot;\n2) &quot;bike:2&quot;\n</code></pre>\n<p>There are other non trivial operations that are still easy to implement<br>using the right Valkey commands. For instance we may want a list of all the<br>bikes racing in France, the USA, and some other races. We can do this using<br>the <code>SINTER</code> command, which performs the intersection between different<br>sets. In addition to intersection you can also perform<br>unions, difference, and more. For example<br>if we add a third race we can see some of these commands in action:</p>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:france bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; SADD bikes:racing:usa bike:1 bike:4\n(integer) 2\n127.0.0.1:6379&gt; SADD bikes:racing:italy bike:1 bike:2 bike:3 bike:4\n(integer) 4\n127.0.0.1:6379&gt; SINTER bikes:racing:france bikes:racing:usa bikes:racing:italy\n1) &quot;bike:1&quot;\n127.0.0.1:6379&gt; SUNION bikes:racing:france bikes:racing:usa bikes:racing:italy\n1) &quot;bike:2&quot;\n2) &quot;bike:1&quot;\n3) &quot;bike:4&quot;\n4) &quot;bike:3&quot;\n127.0.0.1:6379&gt; SDIFF bikes:racing:france bikes:racing:usa bikes:racing:italy\n(empty array)\n127.0.0.1:6379&gt; SDIFF bikes:racing:france bikes:racing:usa\n1) &quot;bike:3&quot;\n2) &quot;bike:2&quot;\n127.0.0.1:6379&gt; SDIFF bikes:racing:usa bikes:racing:france\n1) &quot;bike:4&quot;\n</code></pre>\n<p>You&#39;ll note that the <code>SDIFF</code> command returns an empty array when the<br>difference between all sets is empty. You&#39;ll also note that the order of sets<br>passed to <code>SDIFF</code> matters, since the difference is not commutative.</p>\n<p>When you want to remove items from a set, you can use the <code>SREM</code> command to<br>remove one or more items from a set, or you can use the <code>SPOP</code> command to<br>remove a random item from a set. You can also <em>return</em> a random item from a<br>set without removing it using the <code>SRANDMEMBER</code> command:</p>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:france bike:1 bike:2 bike:3 bike:4 bike:5\n(integer) 5\n127.0.0.1:6379&gt; SREM bikes:racing:france bike:1\n(integer) 1\n127.0.0.1:6379&gt; SPOP bikes:racing:france\n&quot;bike:3&quot;\n127.0.0.1:6379&gt; SMEMBERS bikes:racing:france\n1) &quot;bike:2&quot;\n2) &quot;bike:4&quot;\n3) &quot;bike:5&quot;\n127.0.0.1:6379&gt; SRANDMEMBER bikes:racing:france\n&quot;bike:2&quot;\n</code></pre>\n<h2>Limits</h2>\n<p>The max size of a Set is 2^32 - 1 (4,294,967,295) members.</p>\n<h2>Performance</h2>\n<p>Most set operations, including adding, removing, and checking whether an item is a set member, are O(1).<br>This means that they&#39;re highly efficient.<br>However, for large sets with hundreds of thousands of members or more, you should exercise caution when running the <code>SMEMBERS</code> command.<br>This command is O(n) and returns the entire set in a single response.<br>As an alternative, consider the <code>SSCAN</code>, which lets you retrieve all members of a set iteratively.</p>\n"
  },
  {
    "id": "sorted-sets",
    "topicName": "Sorted Sets",
    "description": "Introduction to Sorted Sets\n",
    "htmlContent": "<p>A Sorted Set is a collection of unique strings (members) ordered by an associated score.<br>When more than one string has the same score, the strings are ordered lexicographically.<br>Some use cases for sorted sets include:</p>\n<ul>\n<li>Leaderboards. For example, you can use sorted sets to easily maintain  ordered lists of the highest scores in a massive online game.</li>\n<li>Rate limiters. In particular, you can use a sorted set to build a sliding-window rate limiter to prevent excessive API requests.</li>\n</ul>\n<p>You can think of sorted sets as a mix between a Set and<br>a Hash. Like sets, sorted sets are composed of unique, non-repeating<br>string elements, so in some sense a sorted set is a set as well.</p>\n<p>However while elements inside sets are not ordered, every element in<br>a sorted set is associated with a floating point value, called <em>the score</em><br>(this is why the type is also similar to a hash, since every element<br>is mapped to a value).</p>\n<p>Moreover, elements in a sorted set are <em>taken in order</em> (so they are not<br>ordered on request, order is a peculiarity of the data structure used to<br>represent sorted sets). They are ordered according to the following rule:</p>\n<ul>\n<li>If B and A are two elements with a different score, then A &gt; B if A.score is &gt; B.score.</li>\n<li>If B and A have exactly the same score, then A &gt; B if the A string is lexicographically greater than the B string. B and A strings can&#39;t be equal since sorted sets only have unique elements.</li>\n</ul>\n<p>Let&#39;s start with a simple example, we&#39;ll add all our racers and the score they got in the first race:</p>\n<pre><code>127.0.0.1:6379&gt; ZADD racer_scores 10 &quot;Norem&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZADD racer_scores 12 &quot;Castilla&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZADD racer_scores 8 &quot;Sam-Bodden&quot; 10 &quot;Royce&quot; 6 &quot;Ford&quot; 14 &quot;Prickett&quot;\n(integer) 4\n</code></pre>\n<p>As you can see <code>ZADD</code> is similar to <code>SADD</code>, but takes one additional argument<br>(placed before the element to be added) which is the score.<br><code>ZADD</code> is also variadic, so you are free to specify multiple score-value<br>pairs, even if this is not used in the example above.</p>\n<p>With sorted sets it is trivial to return a list of hackers sorted by their<br>birth year because actually <em>they are already sorted</em>.</p>\n<p>Implementation note: Sorted sets are implemented via a<br>dual-ported data structure containing both a skip list and a hash table, so<br>every time we add an element Valkey performs an O(log(N)) operation. That&#39;s<br>good, but when we ask for sorted elements Valkey does not have to do any work at<br>all, it&#39;s already sorted. Note that the <code>ZRANGE</code> order is low to high, while the <code>ZREVRANGE</code> order is high to low:</p>\n<pre><code>127.0.0.1:6379&gt; ZRANGE racer_scores 0 -1\n1) &quot;Ford&quot;\n2) &quot;Sam-Bodden&quot;\n3) &quot;Norem&quot;\n4) &quot;Royce&quot;\n5) &quot;Castilla&quot;\n6) &quot;Prickett&quot;\n127.0.0.1:6379&gt; ZREVRANGE racer_scores 0 -1\n1) &quot;Prickett&quot;\n2) &quot;Castilla&quot;\n3) &quot;Royce&quot;\n4) &quot;Norem&quot;\n5) &quot;Sam-Bodden&quot;\n6) &quot;Ford&quot;\n</code></pre>\n<p>Note: 0 and -1 means from element index 0 to the last element (-1 works<br>here just as it does in the case of the <code>LRANGE</code> command).</p>\n<p>It is possible to return scores as well, using the <code>WITHSCORES</code> argument:</p>\n<pre><code>127.0.0.1:6379&gt; ZRANGE racer_scores 0 -1 withscores\n 1) &quot;Ford&quot;\n 2) &quot;6&quot;\n 3) &quot;Sam-Bodden&quot;\n 4) &quot;8&quot;\n 5) &quot;Norem&quot;\n 6) &quot;10&quot;\n 7) &quot;Royce&quot;\n 8) &quot;10&quot;\n 9) &quot;Castilla&quot;\n10) &quot;12&quot;\n11) &quot;Prickett&quot;\n12) &quot;14&quot;\n</code></pre>\n<h3>Operating on ranges</h3>\n<p>Sorted sets are more powerful than this. They can operate on ranges.<br>Let&#39;s get all the racers with 10 or fewer points. We<br>use the <code>ZRANGEBYSCORE</code> command to do it:</p>\n<pre><code>127.0.0.1:6379&gt; ZRANGEBYSCORE racer_scores -inf 10\n1) &quot;Ford&quot;\n2) &quot;Sam-Bodden&quot;\n3) &quot;Norem&quot;\n4) &quot;Royce&quot;\n</code></pre>\n<p>We asked Valkey to return all the elements with a score between negative<br>infinity and 10 (both extremes are included).</p>\n<p>To remove an element we&#39;d simply call <code>ZREM</code> with the racer&#39;s name.<br>It&#39;s also possible to remove ranges of elements. Let&#39;s remove racer Castilla along with all<br>the racers with strictly fewer than 10 points:</p>\n<pre><code>127.0.0.1:6379&gt; ZREM racer_scores &quot;Castilla&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZREMRANGEBYSCORE racer_scores -inf 9\n(integer) 2\n127.0.0.1:6379&gt; ZRANGE racer_scores 0 -1\n1) &quot;Norem&quot;\n2) &quot;Royce&quot;\n3) &quot;Prickett&quot;\n</code></pre>\n<p><code>ZREMRANGEBYSCORE</code> is perhaps not the best command name,<br>but it can be very useful, and returns the number of removed elements.</p>\n<p>Another extremely useful operation defined for sorted set elements<br>is the get-rank operation. It is possible to ask what is the<br>position of an element in the set of ordered elements.<br>The <code>ZREVRANK</code> command is also available in order to get the rank, considering<br>the elements sorted in a descending way.</p>\n<pre><code>127.0.0.1:6379&gt; ZRANK racer_scores &quot;Norem&quot;\n(integer) 0\n127.0.0.1:6379&gt; ZREVRANK racer_scores &quot;Norem&quot;\n(integer) 3\n</code></pre>\n<h3>Lexicographical scores</h3>\n<p>A family of commands allow<br>getting ranges lexicographically, assuming elements in a sorted set are all<br>inserted with the same identical score. Elements are compared with the C<br><code>memcmp</code> function, so it is guaranteed that there is no collation, and every<br>Valkey instance will reply with the same output.</p>\n<p>The main commands to operate with lexicographical ranges are <code>ZRANGEBYLEX</code>,<br><code>ZREVRANGEBYLEX</code>, <code>ZREMRANGEBYLEX</code> and <code>ZLEXCOUNT</code>.</p>\n<p>For example, let&#39;s add again our list of famous hackers, but this time<br>using a score of zero for all the elements. We&#39;ll see that because of the sorted sets ordering rules, they are already sorted lexicographically. Using <code>ZRANGEBYLEX</code> we can ask for lexicographical ranges:</p>\n<pre><code>127.0.0.1:6379&gt; ZADD racer_scores 0 &quot;Norem&quot; 0 &quot;Sam-Bodden&quot; 0 &quot;Royce&quot; 0 &quot;Castilla&quot; 0 &quot;Prickett&quot; 0 &quot;Ford&quot;\n(integer) 3\n127.0.0.1:6379&gt; ZRANGE racer_scores 0 -1\n1) &quot;Castilla&quot;\n2) &quot;Ford&quot;\n3) &quot;Norem&quot;\n4) &quot;Prickett&quot;\n5) &quot;Royce&quot;\n6) &quot;Sam-Bodden&quot;\n127.0.0.1:6379&gt; ZRANGEBYLEX racer_scores [A [L\n1) &quot;Castilla&quot;\n2) &quot;Ford&quot;\n</code></pre>\n<p>Ranges can be inclusive or exclusive (depending on the first character),<br>also string infinite and minus infinite are specified respectively with<br>the <code>+</code> and <code>-</code> strings. See the documentation for more information.</p>\n<p>This feature is important because it allows us to use sorted sets as a generic<br>index. For example, if you want to index elements by a 128-bit unsigned<br>integer argument, all you need to do is to add elements into a sorted<br>set with the same score (for example 0) but with a 16 byte prefix<br>consisting of <strong>the 128 bit number in big endian</strong>. Since numbers in big<br>endian, when ordered lexicographically (in raw bytes order) are actually<br>ordered numerically as well, you can ask for ranges in the 128 bit space,<br>and get the element&#39;s value discarding the prefix.</p>\n<h2>Updating the score: leaderboards</h2>\n<p>Just a final note about sorted sets before switching to the next topic.<br>Sorted sets&#39; scores can be updated at any time. Just calling <code>ZADD</code> against<br>an element already included in the sorted set will update its score<br>(and position) with O(log(N)) time complexity.  As such, sorted sets are suitable<br>when there are tons of updates.</p>\n<p>Because of this characteristic a common use case is leaderboards.<br>The typical application is a Facebook game where you combine the ability to<br>take users sorted by their high score, plus the get-rank operation, in order<br>to show the top-N users, and the user rank in the leader board (e.g., &quot;you are<br>the #4932 best score here&quot;).</p>\n<h2>Examples</h2>\n<ul>\n<li>There are two ways we can use a sorted set to represent a leaderboard. If we know a racer&#39;s new score, we can update it directly via the <code>ZADD</code> command. However, if we want to add points to an existing score, we can use the <code>ZINCRBY</code> command.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; ZADD racer_scores 100 &quot;Wood&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZADD racer_scores 100 &quot;Henshaw&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZADD racer_scores 150 &quot;Henshaw&quot;\n(integer) 0\n127.0.0.1:6379&gt; ZINCRBY racer_scores 50 &quot;Wood&quot;\n&quot;150&quot;\n127.0.0.1:6379&gt; ZINCRBY racer_scores 50 &quot;Henshaw&quot;\n&quot;200&quot;\n</code></pre>\n<p>You&#39;ll see that <code>ZADD</code> returns 0 when the member already exists (the score is updated), while <code>ZINCRBY</code> returns the new score. The score for racer Henshaw went from 100, was changed to 150 with no regard for what score was there before, and then was incremented by 50 to 200.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>ZADD</code> adds a new member and associated score to a sorted set. If the member already exists, the score is updated.</li>\n<li><code>ZRANGE</code> returns members of a sorted set, sorted within a given range.</li>\n<li><code>ZRANK</code> returns the rank of the provided member, assuming the sorted is in ascending order.</li>\n<li><code>ZREVRANK</code> returns the rank of the provided member, assuming the sorted set is in descending order.</li>\n</ul>\n<p>See the <a href=\"../commands/#sorted-set\">complete list of sorted set commands</a>.</p>\n<h2>Performance</h2>\n<p>Most sorted set operations are O(log(n)), where <em>n</em> is the number of members.</p>\n<p>Exercise some caution when running the <code>ZRANGE</code> command with large returns values (e.g., in the tens of thousands or more).<br>This command&#39;s time complexity is O(log(n) + m), where <em>m</em> is the number of results returned. </p>\n"
  },
  {
    "id": "hashes",
    "topicName": "Hashes",
    "description": "Introduction to Hashes\n",
    "htmlContent": "<p>Hashes are record types structured as collections of field-value pairs.<br>You can use hashes to represent basic objects and to store groupings of counters, among other things.</p>\n<pre><code>127.0.0.1:6379&gt; HSET bike:1 model Deimos brand Ergonom type &#39;Enduro bikes&#39; price 4972\n(integer) 4\n127.0.0.1:6379&gt; HGET bike:1 model\n&quot;Deimos&quot;\n127.0.0.1:6379&gt; HGET bike:1 price\n&quot;4972&quot;\n127.0.0.1:6379&gt; HGETALL bike:1\n1) &quot;model&quot;\n2) &quot;Deimos&quot;\n3) &quot;brand&quot;\n4) &quot;Ergonom&quot;\n5) &quot;type&quot;\n6) &quot;Enduro bikes&quot;\n7) &quot;price&quot;\n8) &quot;4972&quot;\n</code></pre>\n<p>While hashes are handy to represent <em>objects</em>, actually the number of fields you can<br>put inside a hash has no practical limits (other than available memory), so you can use<br>hashes in many different ways inside your application.</p>\n<p>The command <code>HSET</code> sets multiple fields of the hash, while <code>HGET</code> retrieves<br>a single field. <code>HMGET</code> is similar to <code>HGET</code> but returns an array of values:</p>\n<pre><code>127.0.0.1:6379&gt; HMGET bike:1 model price no-such-field\n1) &quot;Deimos&quot;\n2) &quot;4972&quot;\n3) (nil)\n</code></pre>\n<p>There are commands that are able to perform operations on individual fields<br>as well, like <code>HINCRBY</code>:</p>\n<pre><code>127.0.0.1:6379&gt; HINCRBY bike:1 price 100\n(integer) 5072\n127.0.0.1:6379&gt; HINCRBY bike:1 price -100\n(integer) 4972\n</code></pre>\n<p>It is worth noting that small hashes (i.e., a few elements with small values) are<br>encoded in special way in memory that make them very memory efficient.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>HSET</code> sets the value of one or more fields on a hash.</li>\n<li><code>HGET</code> returns the value at a given field.</li>\n<li><code>HMGET</code> returns the values at one or more given fields.</li>\n<li><code>HINCRBY</code> increments the value at a given field by the integer provided.</li>\n</ul>\n<p>See the <a href=\"../commands/#hash\">complete list of hash commands</a>.</p>\n<h2>Examples</h2>\n<ul>\n<li>Store counters for the number of times bike:1 has been ridden, has crashed, or has changed owners:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; HINCRBY bike:1:stats rides 1\n(integer) 1\n127.0.0.1:6379&gt; HINCRBY bike:1:stats rides 1\n(integer) 2\n127.0.0.1:6379&gt; HINCRBY bike:1:stats rides 1\n(integer) 3\n127.0.0.1:6379&gt; HINCRBY bike:1:stats crashes 1\n(integer) 1\n127.0.0.1:6379&gt; HINCRBY bike:1:stats owners 1\n(integer) 1\n127.0.0.1:6379&gt; HGET bike:1:stats rides\n&quot;3&quot;\n127.0.0.1:6379&gt; HMGET bike:1:stats owners crashes\n1) &quot;1&quot;\n2) &quot;1&quot;\n</code></pre>\n<h2>Performance</h2>\n<p>Most Hash commands are O(1).</p>\n<p>A few commands - such as <code>HKEYS</code>, <code>HVALS</code>, and <code>HGETALL</code> - are O(n), where <em>n</em> is the number of field-value pairs.</p>\n<h2>Limits</h2>\n<p>Every hash can store up to 4,294,967,295 (2^32 - 1) field-value pairs.<br>In practice, your hashes are limited only by the overall memory on the VMs hosting your Valkey deployment.</p>\n"
  },
  {
    "id": "streams-intro",
    "topicName": "Streams",
    "description": "Introduction to Streams\n",
    "htmlContent": "<p>A Stream is a data structure that acts like an append-only log but also implements several operations to overcome some of the limits of a typical append-only log. These include random access in O(1) time and complex consumption strategies, such as consumer groups.<br>You can use streams to record and simultaneously syndicate events in real time.<br>Examples of Stream use cases include:</p>\n<ul>\n<li>Event sourcing (e.g., tracking user actions, clicks, etc.)</li>\n<li>Sensor monitoring (e.g., readings from devices in the field) </li>\n<li>Notifications (e.g., storing a record of each user&#39;s notifications in a separate stream)</li>\n</ul>\n<p>Valkey generates a unique ID for each stream entry.<br>You can use these IDs to retrieve their associated entries later or to read and process all subsequent entries in the stream. Note that because these IDs are related to time, the ones shown here may vary and will be different from the IDs you see in your own Valkey instance.</p>\n<p>Streams support several trimming strategies (to prevent streams from growing unbounded) and more than one consumption strategy (see <code>XREAD</code>, <code>XREADGROUP</code>, and <code>XRANGE</code>).</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>XADD</code> adds a new entry to a stream.</li>\n<li><code>XREAD</code> reads one or more entries, starting at a given position and moving forward in time.</li>\n<li><code>XRANGE</code> returns a range of entries between two supplied entry IDs.</li>\n<li><code>XLEN</code> returns the length of a stream.</li>\n</ul>\n<p>See the <a href=\"../commands/#stream\">complete list of stream commands</a>.</p>\n<h2>Examples</h2>\n<ul>\n<li>When our racers pass a checkpoint, we add a stream entry for each racer that includes the racer&#39;s name, speed, position, and location ID:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; XADD race:france * rider Castilla speed 30.2 position 1 location_id 1\n&quot;1692632086370-0&quot;\n127.0.0.1:6379&gt; XADD race:france * rider Norem speed 28.8 position 3 location_id 1\n&quot;1692632094485-0&quot;\n127.0.0.1:6379&gt; XADD race:france * rider Prickett speed 29.7 position 2 location_id 1\n&quot;1692632102976-0&quot;\n</code></pre>\n<ul>\n<li>Read two stream entries starting at ID <code>1692632086370-0</code>:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france 1692632086370-0 + COUNT 2\n1) 1) &quot;1692632086370-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;30.2&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n2) 1) &quot;1692632094485-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Norem&quot;\n      3) &quot;speed&quot;\n      4) &quot;28.8&quot;\n      5) &quot;position&quot;\n      6) &quot;3&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n</code></pre>\n<ul>\n<li>Read up to 100 new stream entries, starting at the end of the stream, and block for up to 300 ms if no entries are being written:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; XREAD COUNT 100 BLOCK 300 STREAMS race:france $\n(nil)\n</code></pre>\n<h2>Performance</h2>\n<p>Adding an entry to a stream is O(1).<br>Accessing any single entry is O(n), where <em>n</em> is the length of the ID.<br>Since stream IDs are typically short and of a fixed length, this effectively reduces to a constant time lookup.<br>For details on why, note that streams are implemented as <a href=\"https://en.wikipedia.org/wiki/Radix_tree\">radix trees</a>.</p>\n<p>Simply put, Streams provide highly efficient inserts and reads.<br>See each command&#39;s time complexity for the details.</p>\n<h2>Streams basics</h2>\n<p>Streams are an append-only data structure. The fundamental write command, called <code>XADD</code>, appends a new entry to the specified stream.</p>\n<p>Each stream entry consists of one or more field-value pairs, somewhat like a dictionary or a Hash:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:france * rider Castilla speed 29.9 position 1 location_id 2\n&quot;1692632147973-0&quot;\n</code></pre>\n<p>The above call to the <code>XADD</code> command adds an entry <code>rider: Castilla, speed: 29.9, position: 1, location_id: 2</code> to the stream at key <code>race:france</code>, using an auto-generated entry ID, which is the one returned by the command, specifically <code>1692632147973-0</code>. It gets as its first argument the key name <code>race:france</code>, the second argument is the entry ID that identifies every entry inside a stream. However, in this case, we passed <code>*</code> because we want the server to generate a new ID for us. Every new ID will be monotonically increasing, so in more simple terms, every new entry added will have a higher ID compared to all the past entries. Auto-generation of IDs by the server is almost always what you want, and the reasons for specifying an ID explicitly are very rare. We&#39;ll talk more about this later. The fact that each Stream entry has an ID is another similarity with log files, where line numbers, or the byte offset inside the file, can be used in order to identify a given entry. Returning back at our <code>XADD</code> example, after the key name and ID, the next arguments are the field-value pairs composing our stream entry.</p>\n<p>It is possible to get the number of items inside a Stream just using the <code>XLEN</code> command:</p>\n<pre><code>127.0.0.1:6379&gt; XLEN race:france\n(integer) 4\n</code></pre>\n<h3>Entry IDs</h3>\n<p>The entry ID returned by the <code>XADD</code> command, and identifying univocally each entry inside a given stream, is composed of two parts:</p>\n<pre><code>&lt;millisecondsTime&gt;-&lt;sequenceNumber&gt;\n</code></pre>\n<p>The milliseconds time part is actually the local time in the local Valkey node generating the stream ID, however if the current milliseconds time happens to be smaller than the previous entry time, then the previous entry time is used instead, so if a clock jumps backward the monotonically incrementing ID property still holds. The sequence number is used for entries created in the same millisecond. Since the sequence number is 64 bit wide, in practical terms there is no limit to the number of entries that can be generated within the same millisecond.</p>\n<p>The format of such IDs may look strange at first, and the gentle reader may wonder why the time is part of the ID. The reason is that Streams support range queries by ID. Because the ID is related to the time the entry is generated, this gives the ability to query for time ranges basically for free. We will see this soon while covering the <code>XRANGE</code> command.</p>\n<p>If for some reason the user needs incremental IDs that are not related to time but are actually associated to another external system ID, as previously mentioned, the <code>XADD</code> command can take an explicit ID instead of the <code>*</code> wildcard ID that triggers auto-generation, like in the following examples:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:usa 0-1 racer Castilla\n0-1\n127.0.0.1:6379&gt; XADD race:usa 0-2 racer Norem\n0-2\n</code></pre>\n<p>Note that in this case, the minimum ID is 0-1 and that the command will not accept an ID equal or smaller than a previous one:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:usa 0-1 racer Prickett\n(error) ERR The ID specified in XADD is equal or smaller than the target stream top item\n</code></pre>\n<p>If you&#39;re running Redis OSS 7 or later, you can also provide an explicit ID consisting of the milliseconds part only. In this case, the sequence portion of the ID will be automatically generated. To do this, use the syntax below:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:usa 0-* racer Prickett\n0-3\n</code></pre>\n<h2>Getting data from Streams</h2>\n<p>Now we are finally able to append entries in our stream via <code>XADD</code>. However, while appending data to a stream is quite obvious, the way streams can be queried in order to extract data is not so obvious. If we continue with the analogy of the log file, one obvious way is to mimic what we normally do with the Unix command <code>tail -f</code>, that is, we may start to listen in order to get the new messages that are appended to the stream. Note that unlike the blocking list operations of Valkey, where a given element will reach a single client which is blocking in a <em>pop style</em> operation like <code>BLPOP</code>, with streams we want multiple consumers to see the new messages appended to the stream (the same way many <code>tail -f</code> processes can see what is added to a log). Using the traditional terminology we want the streams to be able to <em>fan out</em> messages to multiple clients.</p>\n<p>However, this is just one potential access mode. We could also see a stream in quite a different way: not as a messaging system, but as a <em>time series store</em>. In this case, maybe it&#39;s also useful to get the new messages appended, but another natural query mode is to get messages by ranges of time, or alternatively to iterate the messages using a cursor to incrementally check all the history. This is definitely another useful access mode.</p>\n<p>Finally, if we see a stream from the point of view of consumers, we may want to access the stream in yet another way, that is, as a stream of messages that can be partitioned to multiple consumers that are processing such messages, so that groups of consumers can only see a subset of the messages arriving in a single stream. In this way, it is possible to scale the message processing across different consumers, without single consumers having to process all the messages: each consumer will just get different messages to process. This is basically what Kafka (TM) does with consumer groups. Reading messages via consumer groups is yet another interesting mode of reading from a Stream.</p>\n<p>Streams support all three of the query modes described above via different commands. The next sections will show them all, starting from the simplest and most direct to use: range queries.</p>\n<h3>Querying by range: XRANGE and XREVRANGE</h3>\n<p>To query the stream by range we are only required to specify two IDs, <em>start</em> and <em>end</em>. The range returned will include the elements having start or end as ID, so the range is inclusive. The two special IDs <code>-</code> and <code>+</code> respectively mean the smallest and the greatest ID possible.</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france - +\n1) 1) &quot;1692632086370-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;30.2&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n2) 1) &quot;1692632094485-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Norem&quot;\n      3) &quot;speed&quot;\n      4) &quot;28.8&quot;\n      5) &quot;position&quot;\n      6) &quot;3&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n3) 1) &quot;1692632102976-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Prickett&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.7&quot;\n      5) &quot;position&quot;\n      6) &quot;2&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n4) 1) &quot;1692632147973-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.9&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;2&quot;\n</code></pre>\n<p>Each entry returned is an array of two items: the ID and the list of field-value pairs. We already said that the entry IDs have a relation with the time, because the part at the left of the <code>-</code> character is the Unix time in milliseconds of the local node that created the stream entry, at the moment the entry was created (however note that streams are replicated with fully specified <code>XADD</code> commands, so the replicas will have identical IDs to the primary). This means that I could query a range of time using <code>XRANGE</code>. In order to do so, however, I may want to omit the sequence part of the ID: if omitted, in the start of the range it will be assumed to be 0, while in the end part it will be assumed to be the maximum sequence number available. This way, querying using just two milliseconds Unix times, we get all the entries that were generated in that range of time, in an inclusive way. For instance, if I want to query a two milliseconds period I could use:</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france 1692632086369 1692632086371\n1) 1) &quot;1692632086370-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;30.2&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n</code></pre>\n<p>I have only a single entry in this range. However in real data sets, I could query for ranges of hours, or there could be many items in just two milliseconds, and the result returned could be huge. For this reason, <code>XRANGE</code> supports an optional <strong>COUNT</strong> option at the end. By specifying a count, I can just get the first <em>N</em> items. If I want more, I can get the last ID returned, increment the sequence part by one, and query again. Let&#39;s see this in the following example. Let&#39;s assume that the stream <code>race:france</code> was populated with 4 items. To start my iteration, getting 2 items per command, I start with the full range, but with a count of 2.</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france - + COUNT 2\n1) 1) &quot;1692632086370-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;30.2&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n2) 1) &quot;1692632094485-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Norem&quot;\n      3) &quot;speed&quot;\n      4) &quot;28.8&quot;\n      5) &quot;position&quot;\n      6) &quot;3&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n</code></pre>\n<p>To continue the iteration with the next two items, I have to pick the last ID returned, that is <code>1692632094485-0</code>, and add the prefix <code>(</code> to it. The resulting exclusive range interval, that is <code>(1692632094485-0</code> in this case, can now be used as the new <em>start</em> argument for the next <code>XRANGE</code> call:</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france (1692632094485-0 + COUNT 2\n1) 1) &quot;1692632102976-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Prickett&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.7&quot;\n      5) &quot;position&quot;\n      6) &quot;2&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n2) 1) &quot;1692632147973-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.9&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;2&quot;\n</code></pre>\n<p>Now that we&#39;ve retrieved 4 items out of a stream that only had 4 entries in it, if we try to retrieve more items, we&#39;ll get an empty array:</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france (1692632147973-0 + COUNT 2\n(empty array)\n</code></pre>\n<p>Since <code>XRANGE</code> complexity is <em>O(log(N))</em> to seek, and then <em>O(M)</em> to return M elements, with a small count the command has a logarithmic time complexity, which means that each step of the iteration is fast. So <code>XRANGE</code> is also the de facto <em>streams iterator</em> and does not require an <strong>XSCAN</strong> command.</p>\n<p>The command <code>XREVRANGE</code> is the equivalent of <code>XRANGE</code> but returning the elements in inverted order, so a practical use for <code>XREVRANGE</code> is to check what is the last item in a Stream:</p>\n<pre><code>127.0.0.1:6379&gt; XREVRANGE race:france + - COUNT 1\n1) 1) &quot;1692632147973-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.9&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;2&quot;\n</code></pre>\n<p>Note that the <code>XREVRANGE</code> command takes the <em>start</em> and <em>stop</em> arguments in reverse order.</p>\n<h2>Listening for new items with XREAD</h2>\n<p>When we do not want to access items by a range in a stream, usually what we want instead is to <em>subscribe</em> to new items arriving to the stream. This concept may appear related to Valkey Pub/Sub, where you subscribe to a channel, or to Valkey blocking lists, where you wait for a key to get new elements to fetch, but there are fundamental differences in the way you consume a stream:</p>\n<ol>\n<li>A stream can have multiple clients (consumers) waiting for data. Every new item, by default, will be delivered to <em>every consumer</em> that is waiting for data in a given stream. This behavior is different than blocking lists, where each consumer will get a different element. However, the ability to <em>fan out</em> to multiple consumers is similar to Pub/Sub.</li>\n<li>While in Pub/Sub messages are <em>fire and forget</em> and are never stored anyway, and while when using blocking lists, when a message is received by the client it is <em>popped</em> (effectively removed) from the list, streams work in a fundamentally different way. All the messages are appended in the stream indefinitely (unless the user explicitly asks to delete entries): different consumers will know what is a new message from its point of view by remembering the ID of the last message received.</li>\n<li>Streams Consumer Groups provide a level of control that Pub/Sub or blocking lists cannot achieve, with different groups for the same stream, explicit acknowledgment of processed items, ability to inspect the pending items, claiming of unprocessed messages, and coherent history visibility for each single client, that is only able to see its private past history of messages.</li>\n</ol>\n<p>The command that provides the ability to listen for new messages arriving into a stream is called <code>XREAD</code>. It&#39;s a bit more complex than <code>XRANGE</code>, so we&#39;ll start showing simple forms, and later the whole command layout will be provided.</p>\n<pre><code>127.0.0.1:6379&gt; XREAD COUNT 2 STREAMS race:france 0\n1) 1) &quot;race:france&quot;\n   2) 1) 1) &quot;1692632086370-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Castilla&quot;\n            3) &quot;speed&quot;\n            4) &quot;30.2&quot;\n            5) &quot;position&quot;\n            6) &quot;1&quot;\n            7) &quot;location_id&quot;\n            8) &quot;1&quot;\n      2) 1) &quot;1692632094485-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Norem&quot;\n            3) &quot;speed&quot;\n            4) &quot;28.8&quot;\n            5) &quot;position&quot;\n            6) &quot;3&quot;\n            7) &quot;location_id&quot;\n            8) &quot;1&quot;\n</code></pre>\n<p>The above is the non-blocking form of <code>XREAD</code>. Note that the <strong>COUNT</strong> option is not mandatory, in fact the only mandatory option of the command is the <strong>STREAMS</strong> option, that specifies a list of keys together with the corresponding maximum ID already seen for each stream by the calling consumer, so that the command will provide the client only with messages with an ID greater than the one we specified.</p>\n<p>In the above command we wrote <code>STREAMS race:france 0</code> so we want all the messages in the Stream <code>race:france</code> having an ID greater than <code>0-0</code>. As you can see in the example above, the command returns the key name, because actually it is possible to call this command with more than one key to read from different streams at the same time. I could write, for instance: <code>STREAMS race:france race:italy 0 0</code>. Note how after the <strong>STREAMS</strong> option we need to provide the key names, and later the IDs. For this reason, the <strong>STREAMS</strong> option must always be the last option.<br>Any other options must come before the <strong>STREAMS</strong> option.</p>\n<p>Apart from the fact that <code>XREAD</code> can access multiple streams at once, and that we are able to specify the last ID we own to just get newer messages, in this simple form the command is not doing something so different compared to <code>XRANGE</code>. However, the interesting part is that we can turn <code>XREAD</code> into a <em>blocking command</em> easily, by specifying the <strong>BLOCK</strong> argument:</p>\n<pre><code>&gt; XREAD BLOCK 0 STREAMS race:france $\n</code></pre>\n<p>Note that in the example above, other than removing <strong>COUNT</strong>, I specified the new <strong>BLOCK</strong> option with a timeout of 0 milliseconds (that means to never timeout). Moreover, instead of passing a normal ID for the stream <code>race:france</code> I passed the special ID <code>$</code>. This special ID means that <code>XREAD</code> should use as last ID the maximum ID already stored in the stream <code>race:france</code>, so that we will receive only <em>new</em> messages, starting from the time we started listening. This is similar to the <code>tail -f</code> Unix command in some way.</p>\n<p>Note that when the <strong>BLOCK</strong> option is used, we do not have to use the special ID <code>$</code>. We can use any valid ID. If the command is able to serve our request immediately without blocking, it will do so, otherwise it will block. Normally if we want to consume the stream starting from new entries, we start with the ID <code>$</code>, and after that we continue using the ID of the last message received to make the next call, and so forth.</p>\n<p>The blocking form of <code>XREAD</code> is also able to listen to multiple Streams, just by specifying multiple key names. If the request can be served synchronously because there is at least one stream with elements greater than the corresponding ID we specified, it returns with the results. Otherwise, the command will block and will return the items of the first stream which gets new data (according to the specified ID).</p>\n<p>Similarly to blocking list operations, blocking stream reads are <em>fair</em> from the point of view of clients waiting for data, since the semantics is FIFO style. The first client that blocked for a given stream will be the first to be unblocked when new items are available.</p>\n<p><code>XREAD</code> has no other options than <strong>COUNT</strong> and <strong>BLOCK</strong>, so it&#39;s a pretty basic command with a specific purpose to attach consumers to one or multiple streams. More powerful features to consume streams are available using the consumer groups API, however reading via consumer groups is implemented by a different command called <code>XREADGROUP</code>, covered in the next section of this guide.</p>\n<h2>Consumer groups</h2>\n<p>When the task at hand is to consume the same stream from different clients, then <code>XREAD</code> already offers a way to <em>fan-out</em> to N clients, potentially also using replicas in order to provide more read scalability. However in certain problems what we want to do is not to provide the same stream of messages to many clients, but to provide a <em>different subset</em> of messages from the same stream to many clients. An obvious case where this is useful is that of messages which are slow to process: the ability to have N different workers that will receive different parts of the stream allows us to scale message processing, by routing different messages to different workers that are ready to do more work.</p>\n<p>In practical terms, if we imagine having three consumers C1, C2, C3, and a stream that contains the messages 1, 2, 3, 4, 5, 6, 7 then what we want is to serve the messages according to the following diagram:</p>\n<pre><code>1 -&gt; C1\n2 -&gt; C2\n3 -&gt; C3\n4 -&gt; C1\n5 -&gt; C2\n6 -&gt; C3\n7 -&gt; C1\n</code></pre>\n<p>In order to achieve this, Valkey uses a concept called <em>consumer groups</em>. It is very important to understand that Valkey consumer groups have nothing to do, from an implementation standpoint, with Kafka (TM) consumer groups. Yet they are similar in functionality, so I decided to keep Kafka&#39;s (TM) terminology, as it originally popularized this idea.</p>\n<p>A consumer group is like a <em>pseudo consumer</em> that gets data from a stream, and actually serves multiple consumers, providing certain guarantees:</p>\n<ol>\n<li>Each message is served to a different consumer so that it is not possible that the same message will be delivered to multiple consumers.</li>\n<li>Consumers are identified, within a consumer group, by a name, which is a case-sensitive string that the clients implementing consumers must choose. This means that even after a disconnect, the stream consumer group retains all the state, since the client will claim again to be the same consumer. However, this also means that it is up to the client to provide a unique identifier.</li>\n<li>Each consumer group has the concept of the <em>first ID never consumed</em> so that, when a consumer asks for new messages, it can provide just messages that were not previously delivered.</li>\n<li>Consuming a message, however, requires an explicit acknowledgment using a specific command. Valkey interprets the acknowledgment as: this message was correctly processed so it can be evicted from the consumer group.</li>\n<li>A consumer group tracks all the messages that are currently pending, that is, messages that were delivered to some consumer of the consumer group, but are yet to be acknowledged as processed. Thanks to this feature, when accessing the message history of a stream, each consumer <em>will only see messages that were delivered to it</em>.</li>\n</ol>\n<p>In a way, a consumer group can be imagined as some <em>amount of state</em> about a stream:</p>\n<pre><code>+----------------------------------------+\n| consumer_group_name: mygroup           |\n| consumer_group_stream: somekey         |\n| last_delivered_id: 1292309234234-92    |\n|                                        |\n| consumers:                             |\n|    &quot;consumer-1&quot; with pending messages  |\n|       1292309234234-4                  |\n|       1292309234232-8                  |\n|    &quot;consumer-42&quot; with pending messages |\n|       ... (and so forth)               |\n+----------------------------------------+\n</code></pre>\n<p>If you see this from this point of view, it is very simple to understand what a consumer group can do, how it is able to just provide consumers with their history of pending messages, and how consumers asking for new messages will just be served with message IDs greater than <code>last_delivered_id</code>. At the same time, if you look at the consumer group as an auxiliary data structure for Streams, it is obvious that a single stream can have multiple consumer groups, that have a different set of consumers. Actually, it is even possible for the same stream to have clients reading without consumer groups via <code>XREAD</code>, and clients reading via <code>XREADGROUP</code> in different consumer groups.</p>\n<p>Now it&#39;s time to zoom in to see the fundamental consumer group commands. They are the following:</p>\n<ul>\n<li><code>XGROUP</code> is used in order to create, destroy and manage consumer groups.</li>\n<li><code>XREADGROUP</code> is used to read from a stream via a consumer group.</li>\n<li><code>XACK</code> is the command that allows a consumer to mark a pending message as correctly processed.</li>\n</ul>\n<h2>Creating a consumer group</h2>\n<p>Assuming I have a key <code>race:france</code> of type stream already existing, in order to create a consumer group I just need to do the following:</p>\n<pre><code>127.0.0.1:6379&gt; XGROUP CREATE race:france france_riders $\nOK\n</code></pre>\n<p>As you can see in the command above when creating the consumer group we have to specify an ID, which in the example is just <code>$</code>. This is needed because the consumer group, among the other states, must have an idea about what message to serve next at the first consumer connecting, that is, what was the <em>last message ID</em> when the group was just created. If we provide <code>$</code> as we did, then only new messages arriving in the stream from now on will be provided to the consumers in the group. If we specify <code>0</code> instead the consumer group will consume <em>all</em> the messages in the stream history to start with. Of course, you can specify any other valid ID. What you know is that the consumer group will start delivering messages that are greater than the ID you specify. Because <code>$</code> means the current greatest ID in the stream, specifying <code>$</code> will have the effect of consuming only new messages.</p>\n<p><code>XGROUP CREATE</code> also supports creating the stream automatically, if it doesn&#39;t exist, using the optional <code>MKSTREAM</code> subcommand as the last argument:</p>\n<pre><code>127.0.0.1:6379&gt; XGROUP CREATE race:italy italy_riders $ MKSTREAM\nOK\n</code></pre>\n<p>Now that the consumer group is created we can immediately try to read messages via the consumer group using the <code>XREADGROUP</code> command. We&#39;ll read from consumers, that we will call Alice and Bob, to see how the system will return different messages to Alice or Bob.</p>\n<p><code>XREADGROUP</code> is very similar to <code>XREAD</code> and provides the same <strong>BLOCK</strong> option, otherwise it is a synchronous command. However there is a <em>mandatory</em> option that must be always specified, which is <strong>GROUP</strong> and has two arguments: the name of the consumer group, and the name of the consumer that is attempting to read. The option <strong>COUNT</strong> is also supported and is identical to the one in <code>XREAD</code>.</p>\n<p>We&#39;ll add riders to the race:italy stream and try reading something using the consumer group:<br>Note: <em>here rider is the field name, and the name is the associated value. Remember that stream items are small dictionaries.</em></p>\n<pre><code>127.0.0.1:6379&gt; XADD race:italy * rider Castilla\n&quot;1692632639151-0&quot;\n127.0.0.1:6379&gt; XADD race:italy * rider Royce\n&quot;1692632647899-0&quot;\n127.0.0.1:6379&gt; XADD race:italy * rider Sam-Bodden\n&quot;1692632662819-0&quot;\n127.0.0.1:6379&gt; XADD race:italy * rider Prickett\n&quot;1692632670501-0&quot;\n127.0.0.1:6379&gt; XADD race:italy * rider Norem\n&quot;1692632678249-0&quot;\n127.0.0.1:6379&gt; XREADGROUP GROUP italy_riders Alice COUNT 1 STREAMS race:italy &gt;\n1) 1) &quot;race:italy&quot;\n   2) 1) 1) &quot;1692632639151-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Castilla&quot;\n</code></pre>\n<p><code>XREADGROUP</code> replies are just like <code>XREAD</code> replies. Note however the <code>GROUP &lt;group-name&gt; &lt;consumer-name&gt;</code> provided above. It states that I want to read from the stream using the consumer group <code>mygroup</code> and I&#39;m the consumer <code>Alice</code>. Every time a consumer performs an operation with a consumer group, it must specify its name, uniquely identifying this consumer inside the group.</p>\n<p>There is another very important detail in the command line above, after the mandatory <strong>STREAMS</strong> option the ID requested for the key <code>race:italy</code> is the special ID <code>&gt;</code>. This special ID is only valid in the context of consumer groups, and it means: <strong>messages never delivered to other consumers so far</strong>.</p>\n<p>This is almost always what you want, however it is also possible to specify a real ID, such as <code>0</code> or any other valid ID, in this case, however, what happens is that we request from <code>XREADGROUP</code> to just provide us with the <strong>history of pending messages</strong>, and in such case, will never see new messages in the group. So basically <code>XREADGROUP</code> has the following behavior based on the ID we specify:</p>\n<ul>\n<li>If the ID is the special ID <code>&gt;</code> then the command will return only new messages never delivered to other consumers so far, and as a side effect, will update the consumer group&#39;s <em>last ID</em>.</li>\n<li>If the ID is any other valid numerical ID, then the command will let us access our <em>history of pending messages</em>. That is, the set of messages that were delivered to this specified consumer (identified by the provided name), and never acknowledged so far with <code>XACK</code>.</li>\n</ul>\n<p>We can test this behavior immediately specifying an ID of 0, without any <strong>COUNT</strong> option: we&#39;ll just see the only pending message, that is, the one about Castilla:</p>\n<pre><code>127.0.0.1:6379&gt; XREADGROUP GROUP italy_riders Alice STREAMS race:italy 0\n1) 1) &quot;race:italy&quot;\n   2) 1) 1) &quot;1692632639151-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Castilla&quot;\n</code></pre>\n<p>However, if we acknowledge the message as processed, it will no longer be part of the pending messages history, so the system will no longer report anything:</p>\n<pre><code>127.0.0.1:6379&gt; XACK race:italy italy_riders 1692632639151-0\n(integer) 1\n127.0.0.1:6379&gt; XREADGROUP GROUP italy_riders Alice STREAMS race:italy 0\n1) 1) &quot;race:italy&quot;\n   2) (empty array)\n</code></pre>\n<p>Don&#39;t worry if you yet don&#39;t know how <code>XACK</code> works, the idea is just that processed messages are no longer part of the history that we can access.</p>\n<p>Now it&#39;s Bob&#39;s turn to read something:</p>\n<pre><code>127.0.0.1:6379&gt; XREADGROUP GROUP italy_riders Bob COUNT 2 STREAMS race:italy &gt;\n1) 1) &quot;race:italy&quot;\n   2) 1) 1) &quot;1692632647899-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Royce&quot;\n      2) 1) &quot;1692632662819-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Sam-Bodden&quot;\n</code></pre>\n<p>Bob asked for a maximum of two messages and is reading via the same group <code>mygroup</code>. So what happens is that Valkey reports just <em>new</em> messages. As you can see the &quot;Castilla&quot; message is not delivered, since it was already delivered to Alice, so Bob gets Royce and Sam-Bodden and so forth.</p>\n<p>This way Alice, Bob, and any other consumer in the group, are able to read different messages from the same stream, to read their history of yet to process messages, or to mark messages as processed. This allows creating different topologies and semantics for consuming messages from a stream.</p>\n<p>There are a few things to keep in mind:</p>\n<ul>\n<li>Consumers are auto-created the first time they are mentioned, no need for explicit creation.</li>\n<li>Even with <code>XREADGROUP</code> you can read from multiple keys at the same time, however for this to work, you need to create a consumer group with the same name in every stream. This is not a common need, but it is worth mentioning that the feature is technically available.</li>\n<li><code>XREADGROUP</code> is a <em>write command</em> because even if it reads from the stream, the consumer group is modified as a side effect of reading, so it can only be called on primary instances.</li>\n</ul>\n<p>An example of a consumer implementation, using consumer groups, written in the Ruby language could be the following. The Ruby code is aimed to be readable by virtually any experienced programmer, even if they do not know Ruby:</p>\n<pre><code class=\"language-ruby\">require &#39;redis&#39;\n\nif ARGV.length == 0\n    puts &quot;Please specify a consumer name&quot;\n    exit 1\nend\n\nConsumerName = ARGV[0]\nGroupName = &quot;mygroup&quot;\nr = Redis.new\n\ndef process_message(id,msg)\n    puts &quot;[#{ConsumerName}] #{id} = #{msg.inspect}&quot;\nend\n\n$lastid = &#39;0-0&#39;\n\nputs &quot;Consumer #{ConsumerName} starting...&quot;\ncheck_backlog = true\nwhile true\n    # Pick the ID based on the iteration: the first time we want to\n    # read our pending messages, in case we crashed and are recovering.\n    # Once we consumed our history, we can start getting new messages.\n    if check_backlog\n        myid = $lastid\n    else\n        myid = &#39;&gt;&#39;\n    end\n\n    items = r.xreadgroup(&#39;GROUP&#39;,GroupName,ConsumerName,&#39;BLOCK&#39;,&#39;2000&#39;,&#39;COUNT&#39;,&#39;10&#39;,&#39;STREAMS&#39;,:my_stream_key,myid)\n\n    if items == nil\n        puts &quot;Timeout!&quot;\n        next\n    end\n\n    # If we receive an empty reply, it means we were consuming our history\n    # and that the history is now empty. Let&#39;s start to consume new messages.\n    check_backlog = false if items[0][1].length == 0\n\n    items[0][1].each{|i|\n        id,fields = i\n\n        # Process the message\n        process_message(id,fields)\n\n        # Acknowledge the message as processed\n        r.xack(:my_stream_key,GroupName,id)\n\n        $lastid = id\n    }\nend\n</code></pre>\n<p>As you can see the idea here is to start by consuming the history, that is, our list of pending messages. This is useful because the consumer may have crashed before, so in the event of a restart we want to re-read messages that were delivered to us without getting acknowledged. Note that we might process a message multiple times or one time (at least in the case of consumer failures, but there are also the limits of Valkey persistence and replication involved, see the specific section about this topic).</p>\n<p>Once the history was consumed, and we get an empty list of messages, we can switch to using the <code>&gt;</code> special ID in order to consume new messages.</p>\n<h2>Recovering from permanent failures</h2>\n<p>The example above allows us to write consumers that participate in the same consumer group, each taking a subset of messages to process, and when recovering from failures re-reading the pending messages that were delivered just to them. However in the real world consumers may permanently fail and never recover. What happens to the pending messages of the consumer that never recovers after stopping for any reason?</p>\n<p>Valkey consumer groups offer a feature that is used in these situations in order to <em>claim</em> the pending messages of a given consumer so that such messages will change ownership and will be re-assigned to a different consumer. The feature is very explicit. A consumer has to inspect the list of pending messages, and will have to claim specific messages using a special command, otherwise the server will leave the messages pending forever and assigned to the old consumer. In this way different applications can choose if to use such a feature or not, and exactly how to use it.</p>\n<p>The first step of this process is just a command that provides observability of pending entries in the consumer group and is called <code>XPENDING</code>.<br>This is a read-only command which is always safe to call and will not change ownership of any message.<br>In its simplest form, the command is called with two arguments, which are the name of the stream and the name of the consumer group.</p>\n<pre><code>127.0.0.1:6379&gt; XPENDING race:italy italy_riders\n1) (integer) 2\n2) &quot;1692632647899-0&quot;\n3) &quot;1692632662819-0&quot;\n4) 1) 1) &quot;Bob&quot;\n      2) &quot;2&quot;\n</code></pre>\n<p>When called in this way, the command outputs the total number of pending messages in the consumer group (two in this case), the lower and higher message ID among the pending messages, and finally a list of consumers and the number of pending messages they have.<br>We have only Bob with two pending messages because the single message that Alice requested was acknowledged using <code>XACK</code>.</p>\n<p>We can ask for more information by giving more arguments to <code>XPENDING</code>, because the full command signature is the following:</p>\n<pre><code>XPENDING &lt;key&gt; &lt;groupname&gt; [[IDLE &lt;min-idle-time&gt;] &lt;start-id&gt; &lt;end-id&gt; &lt;count&gt; [&lt;consumer-name&gt;]]\n</code></pre>\n<p>By providing a start and end ID (that can be just <code>-</code> and <code>+</code> as in <code>XRANGE</code>) and a count to control the amount of information returned by the command, we are able to know more about the pending messages. The optional final argument, the consumer name, is used if we want to limit the output to just messages pending for a given consumer, but won&#39;t use this feature in the following example.</p>\n<pre><code>127.0.0.1:6379&gt; XPENDING race:italy italy_riders - + 10\n1) 1) &quot;1692632647899-0&quot;\n   2) &quot;Bob&quot;\n   3) (integer) 74642\n   4) (integer) 1\n2) 1) &quot;1692632662819-0&quot;\n   2) &quot;Bob&quot;\n   3) (integer) 74642\n   4) (integer) 1\n</code></pre>\n<p>Now we have the details for each message: the ID, the consumer name, the <em>idle time</em> in milliseconds, which is how many milliseconds have passed since the last time the message was delivered to some consumer, and finally the number of times that a given message was delivered.<br>We have two messages from Bob, and they are idle for 60000+ milliseconds, about a minute.</p>\n<p>Note that nobody prevents us from checking what the first message content was by just using <code>XRANGE</code>.</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:italy 1692632647899-0 1692632647899-0\n1) 1) &quot;1692632647899-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Royce&quot;\n</code></pre>\n<p>We have just to repeat the same ID twice in the arguments. Now that we have some ideas, Alice may decide that after 1 minute of not processing messages, Bob will probably not recover quickly, and it&#39;s time to <em>claim</em> such messages and resume the processing in place of Bob. To do so, we use the <code>XCLAIM</code> command.</p>\n<p>This command is very complex and full of options in its full form, since it is used for replication of consumer groups changes, but we&#39;ll use just the arguments that we need normally. In this case it is as simple as:</p>\n<pre><code>XCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; &lt;min-idle-time&gt; &lt;ID-1&gt; &lt;ID-2&gt; ... &lt;ID-N&gt;\n</code></pre>\n<p>Basically we say, for this specific key and group, I want that the message IDs specified will change ownership, and will be assigned to the specified consumer name <code>&lt;consumer&gt;</code>. However, we also provide a minimum idle time, so that the operation will only work if the idle time of the mentioned messages is greater than the specified idle time. This is useful because maybe two clients are retrying to claim a message at the same time:</p>\n<pre><code>Client 1: XCLAIM race:italy italy_riders Alice 60000 1692632647899-0\nClient 2: XCLAIM race:italy italy_riders Lora 60000 1692632647899-0\n</code></pre>\n<p>However, as a side effect, claiming a message will reset its idle time and will increment its number of deliveries counter, so the second client will fail claiming it. In this way we avoid trivial re-processing of messages (even if in the general case you cannot obtain exactly once processing).</p>\n<p>This is the result of the command execution:</p>\n<pre><code>127.0.0.1:6379&gt; XCLAIM race:italy italy_riders Alice 60000 1692632647899-0\n1) 1) &quot;1692632647899-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Royce&quot;\n</code></pre>\n<p>The message was successfully claimed by Alice, who can now process the message and acknowledge it, and move things forward even if the original consumer is not recovering.</p>\n<p>It is clear from the example above that as a side effect of successfully claiming a given message, the <code>XCLAIM</code> command also returns it. However this is not mandatory. The <strong>JUSTID</strong> option can be used in order to return just the IDs of the message successfully claimed. This is useful if you want to reduce the bandwidth used between the client and the server (and also the performance of the command) and you are not interested in the message because your consumer is implemented in a way that it will rescan the history of pending messages from time to time.</p>\n<p>Claiming may also be implemented by a separate process: one that just checks the list of pending messages, and assigns idle messages to consumers that appear to be active. Active consumers can be obtained using one of the observability features of Streams. This is the topic of the next section.</p>\n<h2>Automatic claiming</h2>\n<p>The <code>XAUTOCLAIM</code> command, added in Redis OSS 6.2, implements the claiming process that we&#39;ve described above.<br><code>XPENDING</code> and <code>XCLAIM</code> provide the basic building blocks for different types of recovery mechanisms.<br>This command optimizes the generic process by having Valkey manage it and offers a simple solution for most recovery needs.</p>\n<p><code>XAUTOCLAIM</code> identifies idle pending messages and transfers ownership of them to a consumer.<br>The command&#39;s signature looks like this:</p>\n<pre><code>XAUTOCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; &lt;min-idle-time&gt; &lt;start&gt; [COUNT count] [JUSTID]\n</code></pre>\n<p>So, in the example above, I could have used automatic claiming to claim a single message like this:</p>\n<pre><code>127.0.0.1:6379&gt; XAUTOCLAIM race:italy italy_riders Alice 60000 0-0 COUNT 1\n1) &quot;0-0&quot;\n2) 1) 1) &quot;1692632662819-0&quot;\n      2) 1) &quot;rider&quot;\n         2) &quot;Sam-Bodden&quot;\n</code></pre>\n<p>Like <code>XCLAIM</code>, the command replies with an array of the claimed messages, but it also returns a stream ID that allows iterating the pending entries.<br>The stream ID is a cursor, and I can use it in my next call to continue in claiming idle pending messages:</p>\n<pre><code>127.0.0.1:6379&gt; XAUTOCLAIM race:italy italy_riders Lora 60000 (1692632662819-0 COUNT 1\n1) &quot;1692632662819-0&quot;\n2) 1) 1) &quot;1692632647899-0&quot;\n      2) 1) &quot;rider&quot;\n         2) &quot;Royce&quot;\n</code></pre>\n<p>When <code>XAUTOCLAIM</code> returns the &quot;0-0&quot; stream ID as a cursor, that means that it reached the end of the consumer group pending entries list.<br>That doesn&#39;t mean that there are no new idle pending messages, so the process continues by calling <code>XAUTOCLAIM</code> from the beginning of the stream.</p>\n<h2>Claiming and the delivery counter</h2>\n<p>The counter that you observe in the <code>XPENDING</code> output is the number of deliveries of each message. The counter is incremented in two ways: when a message is successfully claimed via <code>XCLAIM</code> or when an <code>XREADGROUP</code> call is used in order to access the history of pending messages.</p>\n<p>When there are failures, it is normal that messages will be delivered multiple times, but eventually they usually get processed and acknowledged. However there might be a problem processing some specific message, because it is corrupted or crafted in a way that triggers a bug in the processing code. In such a case what happens is that consumers will continuously fail to process this particular message. Because we have the counter of the delivery attempts, we can use that counter to detect messages that for some reason are not processable. So once the deliveries counter reaches a given large number that you chose, it is probably wiser to put such messages in another stream and send a notification to the system administrator. This is basically the way that Streams implements the <em>dead letter</em> concept.</p>\n<h2>Streams observability</h2>\n<p>Messaging systems that lack observability are very hard to work with. Not knowing who is consuming messages, what messages are pending, the set of consumer groups active in a given stream, makes everything opaque. For this reason, Streams and consumer groups have different ways to observe what is happening. We already covered <code>XPENDING</code>, which allows us to inspect the list of messages that are under processing at a given moment, together with their idle time and number of deliveries.</p>\n<p>However we may want to do more than that, and the <code>XINFO</code> command is an observability interface that can be used with sub-commands in order to get information about streams or consumer groups.</p>\n<p>This command uses subcommands in order to show different information about the status of the stream and its consumer groups. For instance <strong>XINFO STREAM <key></strong> reports information about the stream itself.</p>\n<pre><code>127.0.0.1:6379&gt; XINFO STREAM race:italy\n 1) &quot;length&quot;\n 2) (integer) 5\n 3) &quot;radix-tree-keys&quot;\n 4) (integer) 1\n 5) &quot;radix-tree-nodes&quot;\n 6) (integer) 2\n 7) &quot;last-generated-id&quot;\n 8) &quot;1692632678249-0&quot;\n 9) &quot;groups&quot;\n10) (integer) 1\n11) &quot;first-entry&quot;\n12) 1) &quot;1692632639151-0&quot;\n    2) 1) &quot;rider&quot;\n       2) &quot;Castilla&quot;\n13) &quot;last-entry&quot;\n14) 1) &quot;1692632678249-0&quot;\n    2) 1) &quot;rider&quot;\n       2) &quot;Norem&quot;\n</code></pre>\n<p>The output shows information about how the stream is encoded internally, and also shows the first and last message in the stream. Another piece of information available is the number of consumer groups associated with this stream. We can dig further asking for more information about the consumer groups.</p>\n<pre><code>127.0.0.1:6379&gt; XINFO GROUPS race:italy\n1) 1) &quot;name&quot;\n   2) &quot;italy_riders&quot;\n   3) &quot;consumers&quot;\n   4) (integer) 3\n   5) &quot;pending&quot;\n   6) (integer) 2\n   7) &quot;last-delivered-id&quot;\n   8) &quot;1692632662819-0&quot;\n</code></pre>\n<p>As you can see in this and in the previous output, the <code>XINFO</code> command outputs a sequence of field-value items. Because it is an observability command this allows the human user to immediately understand what information is reported, and allows the command to report more information in the future by adding more fields without breaking compatibility with older clients. Other commands that must be more bandwidth efficient, like <code>XPENDING</code>, just report the information without the field names.</p>\n<p>The output of the example above, where the <strong>GROUPS</strong> subcommand is used, should be clear observing the field names. We can check in more detail the state of a specific consumer group by checking the consumers that are registered in the group.</p>\n<pre><code>127.0.0.1:6379&gt; XINFO CONSUMERS race:italy italy_riders\n1) 1) &quot;name&quot;\n   2) &quot;Alice&quot;\n   3) &quot;pending&quot;\n   4) (integer) 1\n   5) &quot;idle&quot;\n   6) (integer) 177546\n2) 1) &quot;name&quot;\n   2) &quot;Bob&quot;\n   3) &quot;pending&quot;\n   4) (integer) 0\n   5) &quot;idle&quot;\n   6) (integer) 424686\n3) 1) &quot;name&quot;\n   2) &quot;Lora&quot;\n   3) &quot;pending&quot;\n   4) (integer) 1\n   5) &quot;idle&quot;\n   6) (integer) 72241\n</code></pre>\n<p>In case you do not remember the syntax of the command, just ask the command itself for help:</p>\n<pre><code>&gt; XINFO HELP\n1) XINFO &lt;subcommand&gt; [&lt;arg&gt; [value] [opt] ...]. Subcommands are:\n2) CONSUMERS &lt;key&gt; &lt;groupname&gt;\n3)     Show consumers of &lt;groupname&gt;.\n4) GROUPS &lt;key&gt;\n5)     Show the stream consumer groups.\n6) STREAM &lt;key&gt; [FULL [COUNT &lt;count&gt;]\n7)     Show information about the stream.\n8) HELP\n9)     Prints this help.\n</code></pre>\n<h2>Differences with Kafka (TM) partitions</h2>\n<p>Consumer groups in Streams may resemble in some way Kafka (TM) partitioning-based consumer groups, however note that Streams are, in practical terms, very different. The partitions are only <em>logical</em> and the messages are just put into a single Valkey key, so the way the different clients are served is based on who is ready to process new messages, and not from which partition clients are reading. For instance, if the consumer C3 at some point fails permanently, Valkey will continue to serve C1 and C2 all the new messages arriving, as if now there are only two <em>logical</em> partitions.</p>\n<p>Similarly, if a given consumer is much faster at processing messages than the other consumers, this consumer will receive proportionally more messages in the same unit of time. This is possible since Valkey tracks all the unacknowledged messages explicitly, and remembers who received which message and the ID of the first message never delivered to any consumer.</p>\n<p>However, this also means that in Valkey if you really want to partition messages in the same stream into multiple Valkey instances, you have to use multiple keys and some sharding system such as Valkey Cluster or some other application-specific sharding system. A single Stream is not automatically partitioned to multiple instances.</p>\n<p>We could say that schematically the following is true:</p>\n<ul>\n<li>If you use 1 stream -&gt; 1 consumer, you are processing messages in order.</li>\n<li>If you use N streams with N consumers, so that only a given consumer hits a subset of the N streams, you can scale the above model of 1 stream -&gt; 1 consumer.</li>\n<li>If you use 1 stream -&gt; N consumers, you are load balancing to N consumers, however in that case, messages about the same logical item may be consumed out of order, because a given consumer may process message 3 faster than another consumer is processing message 4.</li>\n</ul>\n<p>So basically Kafka partitions are more similar to using N different Valkey keys, while Valkey consumer groups are a server-side load balancing system of messages from a given stream to N different consumers.</p>\n<h2>Capped Streams</h2>\n<p>Many applications do not want to collect data into a stream forever. Sometimes it is useful to have at maximum a given number of items inside a stream, other times once a given size is reached, it is useful to move data from Valkey to a storage which is not in memory and not as fast but suited to store the history for, potentially, decades to come. Streams have some support for this. One is the <strong>MAXLEN</strong> option of the <code>XADD</code> command. This option is very simple to use:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:italy MAXLEN 2 * rider Jones\n&quot;1692633189161-0&quot;\n127.0.0.1:6379&gt; XADD race:italy MAXLEN 2 * rider Wood\n&quot;1692633198206-0&quot;\n127.0.0.1:6379&gt; XADD race:italy MAXLEN 2 * rider Henshaw\n&quot;1692633208557-0&quot;\n127.0.0.1:6379&gt; XLEN race:italy\n(integer) 2\n127.0.0.1:6379&gt; XRANGE race:italy - +\n1) 1) &quot;1692633198206-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Wood&quot;\n2) 1) &quot;1692633208557-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Henshaw&quot;\n</code></pre>\n<p>Using <strong>MAXLEN</strong> the old entries are automatically evicted when the specified length is reached, so that the stream is left at a constant size. There is currently no option to tell the stream to just retain items that are not older than a given period, because such command, in order to run consistently, would potentially block for a long time in order to evict items. Imagine for example what happens if there is an insertion spike, then a long pause, and another insertion, all with the same maximum time. The stream would block to evict the data that became too old during the pause. So it is up to the user to do some planning and understand what is the maximum stream length desired. Moreover, while the length of the stream is proportional to the memory used, trimming by time is less simple to control and anticipate: it depends on the insertion rate which often changes over time (and when it does not change, then to just trim by size is trivial).</p>\n<p>However trimming with <strong>MAXLEN</strong> can be expensive: streams are represented by macro nodes into a radix tree, in order to be very memory efficient. Altering the single macro node, consisting of a few tens of elements, is not optimal. So it&#39;s possible to use the command in the following special form:</p>\n<pre><code>XADD race:italy MAXLEN ~ 1000 * ... entry fields here ...\n</code></pre>\n<p>The <code>~</code> argument between the <strong>MAXLEN</strong> option and the actual count means, I don&#39;t really need this to be exactly 1000 items. It can be 1000 or 1010 or 1030, just make sure to save at least 1000 items. With this argument, the trimming is performed only when we can remove a whole node. This makes it much more efficient, and it is usually what you want. You&#39;ll note here that the client libraries have various implementations of this. For example, the Python client defaults to approximate and has to be explicitly set to a true length.</p>\n<p>There is also the <code>XTRIM</code> command, which performs something very similar to what the <strong>MAXLEN</strong> option does above, except that it can be run by itself:</p>\n<pre><code>127.0.0.1:6379&gt; XTRIM race:italy MAXLEN 10\n(integer) 0\n</code></pre>\n<p>Or, as for the <code>XADD</code> option:</p>\n<pre><code>127.0.0.1:6379&gt; XTRIM race:italy MAXLEN ~ 10\n(integer) 0\n</code></pre>\n<p>However, <code>XTRIM</code> is designed to accept different trimming strategies. Another trimming strategy is <strong>MINID</strong>, that evicts entries with IDs lower than the one specified.</p>\n<p>As <code>XTRIM</code> is an explicit command, the user is expected to know about the possible shortcomings of different trimming strategies.</p>\n<p>Another useful eviction strategy that may be added to <code>XTRIM</code> in the future, is to remove by a range of IDs to ease use of <code>XRANGE</code> and <code>XTRIM</code> to move data from Valkey to other storage systems if needed.</p>\n<h2>Special IDs in the streams API</h2>\n<p>You may have noticed that there are several special IDs that can be used in the Valkey API. Here is a short recap, so that they can make more sense in the future.</p>\n<p>The first two special IDs are <code>-</code> and <code>+</code>, and are used in range queries with the <code>XRANGE</code> command. Those two IDs respectively mean the smallest ID possible (that is basically <code>0-1</code>) and the greatest ID possible (that is <code>18446744073709551615-18446744073709551615</code>). As you can see it is a lot cleaner to write <code>-</code> and <code>+</code> instead of those numbers.</p>\n<p>Then there are APIs where we want to say, the ID of the item with the greatest ID inside the stream. This is what <code>$</code> means. So for instance if I want only new entries with <code>XREADGROUP</code> I use this ID to signify I already have all the existing entries, but not the new ones that will be inserted in the future. Similarly when I create or set the ID of a consumer group, I can set the last delivered item to <code>$</code> in order to just deliver new entries to the consumers in the group.</p>\n<p>As you can see <code>$</code> does not mean <code>+</code>, they are two different things, as <code>+</code> is the greatest ID possible in every possible stream, while <code>$</code> is the greatest ID in a given stream containing given entries. Moreover APIs will usually only understand <code>+</code> or <code>$</code>, yet it was useful to avoid loading a given symbol with multiple meanings.</p>\n<p>Another special ID is <code>&gt;</code>, that is a special meaning only related to consumer groups and only when the <code>XREADGROUP</code> command is used. This special ID means that we want only entries that were never delivered to other consumers so far. So basically the <code>&gt;</code> ID is the <em>last delivered ID</em> of a consumer group.</p>\n<p>Finally the special ID <code>*</code>, that can be used only with the <code>XADD</code> command, means to auto select an ID for us for the new entry.</p>\n<p>So we have <code>-</code>, <code>+</code>, <code>$</code>, <code>&gt;</code> and <code>*</code>, and all have a different meaning, and most of the time, can be used in different contexts.</p>\n<h2>Persistence, replication and message safety</h2>\n<p>A Stream, like any other Valkey data structure, is asynchronously replicated to replicas and persisted into AOF and RDB files. However what may not be so obvious is that also the consumer groups full state is propagated to AOF, RDB and replicas, so if a message is pending in the primary, also the replica will have the same information. Similarly, after a restart, the AOF will restore the consumer groups&#39; state.</p>\n<p>However note that Streams and consumer groups are persisted and replicated using the Valkey default replication, so:</p>\n<ul>\n<li>AOF must be used with a strong fsync policy if persistence of messages is important in your application.</li>\n<li>By default the asynchronous replication will not guarantee that <code>XADD</code> commands or consumer groups state changes are replicated: after a failover something can be missing depending on the ability of replicas to receive the data from the primary.</li>\n<li>The <code>WAIT</code> command may be used in order to force the propagation of the changes to a set of replicas. However note that while this makes it very unlikely that data is lost, the Valkey failover process as operated by Sentinel or Valkey Cluster performs only a <em>best effort</em> check to failover to the replica which is the most updated, and under certain specific failure conditions may promote a replica that lacks some data.</li>\n</ul>\n<p>So when designing an application using Streams and consumer groups, make sure to understand the semantical properties your application should have during failures, and configure things accordingly, evaluating whether it is safe enough for your use case.</p>\n<h2>Removing single items from a stream</h2>\n<p>Streams also have a special command for removing items from the middle of a stream, just by ID. Normally for an append only data structure this may look like an odd feature, but it is actually useful for applications involving, for instance, privacy regulations. The command is called <code>XDEL</code> and receives the name of the stream followed by the IDs to delete:</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:italy - + COUNT 2\n1) 1) &quot;1692633198206-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Wood&quot;\n2) 1) &quot;1692633208557-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Henshaw&quot;\n127.0.0.1:6379&gt; XDEL race:italy 1692633208557-0\n(integer) 1\n127.0.0.1:6379&gt; XRANGE race:italy - + COUNT 2\n1) 1) &quot;1692633198206-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Wood&quot;\n</code></pre>\n<p>However in the current implementation, memory is not really reclaimed until a macro node is completely empty, so you should not abuse this feature.</p>\n<h2>Zero length streams</h2>\n<p>A difference between streams and other Valkey data structures is that when the other data structures no longer have any elements, as a side effect of calling commands that remove elements, the key itself will be removed. So for instance, a sorted set will be completely removed when a call to <code>ZREM</code> will remove the last element in the sorted set. Streams, on the other hand, are allowed to stay at zero elements, both as a result of using a <strong>MAXLEN</strong> option with a count of zero (<code>XADD</code> and <code>XTRIM</code> commands), or because <code>XDEL</code> was called.</p>\n<p>The reason why such an asymmetry exists is because Streams may have associated consumer groups, and we do not want to lose the state that the consumer groups defined just because there are no longer any items in the stream. Currently the stream is not deleted even when it has no associated consumer groups.</p>\n<h2>Total latency of consuming a message</h2>\n<p>Non blocking stream commands like <code>XRANGE</code> and <code>XREAD</code> or <code>XREADGROUP</code> without the BLOCK option are served synchronously like any other Valkey command, so to discuss latency of such commands is meaningless: it is more interesting to check the time complexity of the commands in the Valkey documentation. It should be enough to say that stream commands are at least as fast as sorted set commands when extracting ranges, and that <code>XADD</code> is very fast and can easily insert from half a million to one million items per second in an average machine if pipelining is used.</p>\n<p>However latency becomes an interesting parameter if we want to understand the delay of processing a message, in the context of blocking consumers in a consumer group, from the moment the message is produced via <code>XADD</code>, to the moment the message is obtained by the consumer because <code>XREADGROUP</code> returned with the message.</p>\n<h2>How serving blocked consumers works</h2>\n<p>Before providing the results of performed tests, it is interesting to understand what model Valkey uses in order to route stream messages (and in general actually how any blocking operation waiting for data is managed).</p>\n<ul>\n<li>The blocked client is referenced in a hash table that maps keys for which there is at least one blocking consumer, to a list of consumers that are waiting for such key. This way, given a key that received data, we can resolve all the clients that are waiting for such data.</li>\n<li>When a write happens, in this case when the <code>XADD</code> command is called, it calls the <code>signalKeyAsReady()</code> function. This function will put the key into a list of keys that need to be processed, because such keys may have new data for blocked consumers. Note that such <em>ready keys</em> will be processed later, so in the course of the same event loop cycle, it is possible that the key will receive other writes.</li>\n<li>Finally, before returning into the event loop, the <em>ready keys</em> are finally processed. For each key the list of clients waiting for data is scanned, and if applicable, such clients will receive the new data that arrived. In the case of streams the data is the messages in the applicable range requested by the consumer.</li>\n</ul>\n<p>As you can see, basically, before returning to the event loop both the client calling <code>XADD</code> and the clients blocked to consume messages, will have their reply in the output buffers, so the caller of <code>XADD</code> should receive the reply from Valkey at about the same time the consumers will receive the new messages.</p>\n<p>This model is <em>push-based</em>, since adding data to the consumers buffers will be performed directly by the action of calling <code>XADD</code>, so the latency tends to be quite predictable.</p>\n<h2>Latency tests results</h2>\n<p>In order to check these latency characteristics a test was performed using multiple instances of Ruby programs pushing messages having as an additional field the computer millisecond time, and Ruby programs reading the messages from the consumer group and processing them. The message processing step consisted of comparing the current computer time with the message timestamp, in order to understand the total latency.</p>\n<p>Results obtained:</p>\n<pre><code>Processed between 0 and 1 ms -&gt; 74.11%\nProcessed between 1 and 2 ms -&gt; 25.80%\nProcessed between 2 and 3 ms -&gt; 0.06%\nProcessed between 3 and 4 ms -&gt; 0.01%\nProcessed between 4 and 5 ms -&gt; 0.02%\n</code></pre>\n<p>So 99.9% of requests have a latency &lt;= 2 milliseconds, with the outliers that remain still very close to the average.</p>\n<p>Adding a few million unacknowledged messages to the stream does not change the gist of the benchmark, with most queries still processed with very short latency.</p>\n<p>A few remarks:</p>\n<ul>\n<li>Here we processed up to 10k messages per iteration, this means that the <code>COUNT</code> parameter of <code>XREADGROUP</code> was set to 10000. This adds a lot of latency but is needed in order to allow the slow consumers to be able to keep with the message flow. So you can expect a real world latency that is a lot smaller.</li>\n<li>The system used for this benchmark is very slow compared to today&#39;s standards.</li>\n</ul>\n"
  },
  {
    "id": "geospatial",
    "topicName": "Geospatial",
    "description": "Introduction to the Valkey Geospatial data type\n",
    "htmlContent": "<p>Geospatial indexes let you store coordinates and search for them.<br>This data structure is useful for finding nearby points within a given radius or bounding box.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>GEOADD</code> adds a location to a given geospatial index (note that longitude comes before latitude with this command).</li>\n<li><code>GEOSEARCH</code> returns locations with a given radius or a bounding box.</li>\n</ul>\n<p>See the <a href=\"../commands/#geo\">complete list of geospatial index commands</a>.</p>\n<h2>Examples</h2>\n<p>Suppose you&#39;re building a mobile app that lets you find all of the bike rental stations closest to your current location.</p>\n<p>Add several locations to a geospatial index:</p>\n<pre><code>127.0.0.1:6379&gt; GEOADD bikes:rentable -122.27652 37.805186 station:1\n(integer) 1\n127.0.0.1:6379&gt; GEOADD bikes:rentable -122.2674626 37.8062344 station:2\n(integer) 1\n127.0.0.1:6379&gt; GEOADD bikes:rentable -122.2469854 37.8104049 station:3\n(integer) 1\n</code></pre>\n<p>Find all locations within a 5 kilometer radius of a given location, and return the distance to each location:</p>\n<pre><code>127.0.0.1:6379&gt; GEOSEARCH bikes:rentable FROMLONLAT -122.2612767 37.7936847 BYRADIUS 5 km WITHDIST\n1) 1) &quot;station:1&quot;\n   2) &quot;1.8523&quot;\n2) 1) &quot;station:2&quot;\n   2) &quot;1.4979&quot;\n3) 1) &quot;station:3&quot;\n   2) &quot;2.2441&quot;\n</code></pre>\n"
  },
  {
    "id": "hyperloglogs",
    "topicName": "HyperLogLog",
    "description": "HyperLogLog is a probabilistic data structure that estimates the cardinality of a set.\n",
    "htmlContent": "<p>HyperLogLog is a probabilistic data structure that estimates the cardinality of a set. As a probabilistic data structure, HyperLogLog trades perfect accuracy for efficient space utilization.</p>\n<p>The HyperLogLog implementation uses up to 12 KB and provides a standard error of 0.81%.</p>\n<p>Counting unique items usually requires an amount of memory<br>proportional to the number of items you want to count, because you need<br>to remember the elements you have already seen in the past in order to avoid<br>counting them multiple times. However, a set of algorithms exist that trade<br>memory for precision: they return an estimated measure with a standard error,<br>which, in the case of the Valkey implementation for HyperLogLog, is less than 1%.<br>The magic of this algorithm is that you no longer need to use an amount of memory<br>proportional to the number of items counted, and instead can use a<br>constant amount of memory; 12k bytes in the worst case, or a lot less if your<br>HyperLogLog (We&#39;ll just call them HLL from now) has seen very few elements.</p>\n<p>HLLs in Valkey, while technically a different data structure, are encoded<br>as a String, so you can call <code>GET</code> to serialize a HLL, and <code>SET</code><br>to deserialize it back to the server.</p>\n<p>Conceptually the HLL API is like using Sets to do the same task. You would<br><code>SADD</code> every observed element into a set, and would use <code>SCARD</code> to check the<br>number of elements inside the set, which are unique since <code>SADD</code> will not<br>re-add an existing element.</p>\n<p>While you don&#39;t really <em>add items</em> into an HLL, because the data structure<br>only contains a state that does not include actual elements, the API is the<br>same:</p>\n<ul>\n<li>Every time you see a new element, you add it to the count with <code>PFADD</code>.</li>\n<li>When you want to retrieve the current approximation of unique elements added using the <code>PFADD</code> command, you can use the <code>PFCOUNT</code> command. If you need to merge two different HLLs, the <code>PFMERGE</code> command is available. Since HLLs provide approximate counts of unique elements, the result of the merge will give you an approximation of the number of unique elements across both source HLLs.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; PFADD bikes Hyperion Deimos Phoebe Quaoar\n(integer) 1\n127.0.0.1:6379&gt; PFCOUNT bikes\n(integer) 4\n127.0.0.1:6379&gt; PFADD commuter_bikes Salacia Mimas Quaoar\n(integer) 1\n127.0.0.1:6379&gt; PFMERGE all_bikes bikes commuter_bikes\nOK\n127.0.0.1:6379&gt; PFCOUNT all_bikes\n(integer) 6\n</code></pre>\n<p>Some examples of use cases for this data structure is counting unique queries<br>performed by users in a search form every day, number of unique visitors to a web page and other similar cases.</p>\n<p>Valkey is also able to perform the union of HLLs, please check the<br><a href=\"../commands/#hyperloglog\">full documentation</a> for more information.</p>\n<h2>Use cases</h2>\n<p><strong>Anonymous unique visits of a web page (SaaS, analytics tools)</strong> </p>\n<p>This application answers these questions: </p>\n<ul>\n<li>How many unique visits has this page had on this day? </li>\n<li>How many unique users have played this song? </li>\n<li>How many unique users have viewed this video?</li>\n</ul>\n<p><strong>Note:</strong><br>Storing the IP address or any other kind of personal identifier is against the law in some countries, which makes it impossible to get unique visitor statistics on your website.</p>\n<p>One HyperLogLog is created per page (video/song) per period, and every IP/identifier is added to it on every visit.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>PFADD</code> adds an item to a HyperLogLog.</li>\n<li><code>PFCOUNT</code> returns an estimate of the number of items in the set.</li>\n<li><code>PFMERGE</code> combines two or more HyperLogLogs into one.</li>\n</ul>\n<p>See the <a href=\"../commands/#hyperloglog\">complete list of HyperLogLog commands</a>.</p>\n<h2>Performance</h2>\n<p>Writing (<code>PFADD</code>) to and reading from (<code>PFCOUNT</code>) the HyperLogLog is done in constant time and space.<br>Merging HLLs is O(n), where <em>n</em> is the number of sketches.</p>\n<h2>Limits</h2>\n<p>The HyperLogLog can estimate the cardinality of sets with up to 18,446,744,073,709,551,616 (2^64) members.</p>\n<h2>Learn more</h2>\n<ul>\n<li>This blog post on <a href=\"https://web.archive.org/web/20241019222035/http://antirez.com/news/75\">the HyperLogLog data structure</a> has a lot of details about the data structure and its implementation in Valkey.</li>\n</ul>\n"
  },
  {
    "id": "bitmaps",
    "topicName": "Bitmaps",
    "description": "Introduction to Bitmaps\n",
    "htmlContent": "<p>Bitmaps are not an actual data type, but a set of bit-oriented operations<br>defined on the String type which is treated like a bit vector.<br>Since strings are binary safe blobs and their maximum length is 512 MB,<br>they are suitable to set up to 2^32 different bits.</p>\n<p>You can perform bitwise operations on one or more strings.<br>Some examples of bitmap use cases include:</p>\n<ul>\n<li>Efficient set representations for cases where the members of a set correspond to the integers 0-N.</li>\n<li>Object permissions, where each bit represents a particular permission, similar to the way that file systems store permissions.</li>\n</ul>\n<h2>Basic commands</h2>\n<ul>\n<li><code>SETBIT</code> sets a bit at the provided offset to 0 or 1.</li>\n<li><code>GETBIT</code> returns the value of a bit at a given offset.</li>\n</ul>\n<p>See the <a href=\"../commands/#bitmap\">complete list of bitmap commands</a>.</p>\n<h2>Example</h2>\n<p>Suppose you have 1000 cyclists racing through the country-side, with sensors on their bikes labeled 0-999.<br>You want to quickly determine whether a given sensor has pinged a tracking server within the hour to check in on a rider. </p>\n<p>You can represent this scenario using a bitmap whose key references the current hour.</p>\n<ul>\n<li>Rider 123 pings the server on January 1, 2024 within the 00:00 hour. You can then confirm that rider 123 pinged the server. You can also check to see if rider 456 has pinged the server for that same hour.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SETBIT pings:2024-01-01-00:00 123 1\n(integer) 0\n127.0.0.1:6379&gt; GETBIT pings:2024-01-01-00:00 123\n(integer) 1\n127.0.0.1:6379&gt; GETBIT pings:2024-01-01-00:00 456\n(integer) 0\n</code></pre>\n<h2>Bit Operations</h2>\n<p>Bit operations are divided into two groups: constant-time single bit<br>operations, like setting a bit to 1 or 0, or getting its value, and<br>operations on groups of bits, for example counting the number of set<br>bits in a given range of bits (e.g., population counting).</p>\n<p>One of the biggest advantages of bitmaps is that they often provide<br>extreme space savings when storing information. For example in a system<br>where different users are represented by incremental user IDs, it is possible<br>to remember a single bit information (for example, knowing whether<br>a user wants to receive a newsletter) of 4 billion users using just 512 MB of memory.</p>\n<p>The <code>SETBIT</code> command takes as its first argument the bit number, and as its second<br>argument the value to set the bit to, which is 1 or 0. The command<br>automatically enlarges the string if the addressed bit is outside the<br>current string length.</p>\n<p><code>GETBIT</code> just returns the value of the bit at the specified index.<br>Out of range bits (addressing a bit that is outside the length of the string<br>stored into the target key) are always considered to be zero.</p>\n<p>There are three commands operating on group of bits:</p>\n<ol>\n<li><code>BITOP</code> performs bit-wise operations between different strings. The provided operations are AND, OR, XOR and NOT.</li>\n<li><code>BITCOUNT</code> performs population counting, reporting the number of bits set to 1.</li>\n<li><code>BITPOS</code> finds the first bit having the specified value of 0 or 1.</li>\n</ol>\n<p>Both <code>BITPOS</code> and <code>BITCOUNT</code> are able to operate with byte ranges of the<br>string, instead of running for the whole length of the string. We can trivially see the number of bits that have been set in a bitmap.</p>\n<pre><code>127.0.0.1:6379&gt; BITCOUNT pings:2024-01-01-00:00\n(integer) 1\n</code></pre>\n<p>For example imagine you want to know the longest streak of daily visits of<br>your web site users. You start counting days starting from zero, that is the<br>day you made your web site public, and set a bit with <code>SETBIT</code> every time<br>the user visits the web site. As a bit index you simply take the current unix<br>time, subtract the initial offset, and divide by the number of seconds in a day<br>(normally, 3600*24).</p>\n<p>This way for each user you have a small string containing the visit<br>information for each day. With <code>BITCOUNT</code> it is possible to easily get<br>the number of days a given user visited the web site, while with<br>a few <code>BITPOS</code> calls, or simply fetching and analyzing the bitmap client-side,<br>it is possible to easily compute the longest streak.</p>\n<p>Bitmaps are trivial to split into multiple keys, for example for<br>the sake of sharding the data set and because in general it is better to<br>avoid working with huge keys. To split a bitmap across different keys<br>instead of setting all the bits into a key, a trivial strategy is just<br>to store M bits per key and obtain the key name with <code>bit-number/M</code> and<br>the Nth bit to address inside the key with <code>bit-number MOD M</code>.</p>\n<h2>Performance</h2>\n<p><code>SETBIT</code> and <code>GETBIT</code> are O(1).<br><code>BITOP</code> is O(n), where <em>n</em> is the length of the longest string in the comparison.</p>\n"
  },
  {
    "id": "bitfields",
    "topicName": "Bitfields",
    "description": "Introduction to Bitfields\n",
    "htmlContent": "<p>Bitfields let you set, increment, and get integer values of arbitrary bit length.<br>For example, you can operate on anything from unsigned 1-bit integers to signed 63-bit integers.</p>\n<p>These values are stored using binary-encoded Strings.<br>Bitfields support atomic read, write and increment operations, making them a good choice for managing counters and similar numerical values.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>BITFIELD</code> atomically sets, increments and reads one or more values.</li>\n<li><code>BITFIELD_RO</code> is a read-only variant of <code>BITFIELD</code>.</li>\n</ul>\n<h2>Example</h2>\n<p>Suppose you want to maintain two metrics for various bicycles: the current price and the number of owners over time. You can represent these counters with a 32-bit wide bitfield per for each bike.</p>\n<ul>\n<li>Bike 1 initially costs 1,000 (counter in offset 0) and has never had an owner. After being sold, it&#39;s now considered used and the price instantly drops to reflect its new condition, and it now has an owner (offset 1). After quite some time, the bike becomes a classic. The original owner sells it for a profit, so the price goes up and the number of owners does as well.Finally, you can look at the bike&#39;s current price and number of owners.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; BITFIELD bike:1:stats SET u32 #0 1000\n1) (integer) 0\n127.0.0.1:6379&gt; BITFIELD bike:1:stats INCRBY u32 #0 -50 INCRBY u32 #1 1\n1) (integer) 950\n2) (integer) 1\n127.0.0.1:6379&gt; BITFIELD bike:1:stats INCRBY u32 #0 500 INCRBY u32 #1 1\n1) (integer) 1450\n2) (integer) 2\n127.0.0.1:6379&gt; BITFIELD bike:1:stats GET u32 #0 GET u32 #1\n1) (integer) 1450\n2) (integer) 2\n</code></pre>\n<h2>Performance</h2>\n<p><code>BITFIELD</code> is O(n), where <em>n</em> is the number of counters accessed.</p>\n"
  },
  {
    "id": "eval-intro",
    "topicName": "Scripting with Lua",
    "description": "Executing Lua in Valkey\n",
    "htmlContent": "<p>Valkey lets users upload and execute Lua scripts on the server.<br>Scripts can employ programmatic control structures and use most of the <a href=\"../commands/\">commands</a> while executing to access the database.<br>Because scripts execute in the server, reading and writing data from scripts is very efficient.</p>\n<p>Valkey guarantees the script&#39;s atomic execution.<br>While executing the script, all server activities are blocked during its entire runtime.<br>These semantics mean that all of the script&#39;s effects either have yet to happen or had already happened.</p>\n<p>Scripting offers several properties that can be valuable in many cases.<br>These include:</p>\n<ul>\n<li>Providing locality by executing logic where data lives. Data locality reduces overall latency and saves networking resources.</li>\n<li>Blocking semantics that ensure the script&#39;s atomic execution.</li>\n<li>Enabling the composition of simple capabilities that are either missing from Valkey or are too niche to be a part of it.</li>\n</ul>\n<p>Lua lets you run part of your application logic inside Valkey.<br>Such scripts can perform conditional updates across multiple keys, possibly combining several different data types atomically.</p>\n<p>Scripts are executed in Valkey by an embedded execution engine.<br>Presently, Valkey supports a single scripting engine, the <a href=\"https://www.lua.org/\">Lua 5.1</a> interpreter.<br>Please refer to the <a href=\"lua-api.md\">Valkey Lua API Reference</a> page for complete documentation.</p>\n<p>Although the server executes them, Eval scripts are regarded as a part of the client-side application, which is why they&#39;re not named, versioned, or persisted.<br>So all scripts may need to be reloaded by the application at any time if missing (after a server restart, fail-over to a replica, etc.).<br>As of version 7.0, <a href=\"functions-intro.md\">Valkey Functions</a> offer an alternative approach to programmability which allow the server itself to be extended with additional programmed logic.</p>\n<h2>Getting started</h2>\n<p>We&#39;ll start scripting with Valkey by using the <code>EVAL</code> command.</p>\n<p>Here&#39;s our first example:</p>\n<pre><code>&gt; EVAL &quot;return &#39;Hello, scripting!&#39;&quot; 0\n&quot;Hello, scripting!&quot;\n</code></pre>\n<p>In this example, <code>EVAL</code> takes two arguments.<br>The first argument is a string that consists of the script&#39;s Lua source code.<br>The script doesn&#39;t need to include any definitions of Lua function.<br>It is just a Lua program that will run in the Valkey engine&#39;s context.</p>\n<p>The second argument is the number of arguments that follow the script&#39;s body, starting from the third argument, representing Valkey key names.<br>In this example, we used the value <em>0</em> because we didn&#39;t provide the script with any arguments, whether the names of keys or not.</p>\n<h2>Script parameterization</h2>\n<p>It is possible, although highly ill-advised, to have the application dynamically generate script source code per its needs.<br>For example, the application could send these two entirely different, but at the same time perfectly identical scripts:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return &#39;Hello&#39;&quot; 0\n&quot;Hello&quot;\n127.0.0.1:6379&gt; EVAL &quot;return &#39;Scripting!&#39;&quot; 0\n&quot;Scripting!&quot;\n</code></pre>\n<p>Although this mode of operation isn&#39;t blocked by Valkey, it is an anti-pattern due to script cache considerations (more on the topic below).<br>Instead of having your application generate subtle variations of the same scripts, you can parametrize them and pass any arguments needed for to execute them.</p>\n<p>The following example demonstrates how to achieve the same effects as above, but via parameterization:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return ARGV[1]&quot; 0 Hello\n&quot;Hello&quot;\n127.0.0.1:6379&gt; EVAL &quot;return ARGV[1]&quot; 0 Parameterization!\n&quot;Parameterization!&quot;\n</code></pre>\n<p>At this point, it is essential to understand the distinction Valkey makes between input arguments that are names of keys and those that aren&#39;t.</p>\n<p>While key names in Valkey are just strings, unlike any other string values, these represent keys in the database.<br>The name of a key is a fundamental concept in Valkey and is the basis for operating the Valkey Cluster.</p>\n<p><strong>Important:</strong><br>to ensure the correct execution of scripts, both in standalone and clustered deployments, all names of keys that a script accesses must be explicitly provided as input key arguments.<br>The script <strong>should only</strong> access keys whose names are given as input arguments.<br>Scripts <strong>should never</strong> access keys with programmatically-generated names or based on the contents of data structures stored in the database.</p>\n<p>Any input to the function that isn&#39;t the name of a key is a regular input argument.</p>\n<p>In the example above, both <em>Hello</em> and <em>Parameterization!</em> regular input arguments for the script.<br>Because the script doesn&#39;t touch any keys, we use the numerical argument <em>0</em> to specify there are no key name arguments.<br>The execution context makes arguments available to the script through <a href=\"lua-api.md#the-keys-global-variable\"><em>KEYS</em></a> and <a href=\"lua-api.md#the-argv-global-variable\"><em>ARGV</em></a> global runtime variables.<br>The <em>KEYS</em> table is pre-populated with all key name arguments provided to the script before its execution, whereas the <em>ARGV</em> table serves a similar purpose but for regular arguments.</p>\n<p>The following attempts to demonstrate the distribution of input arguments between the scripts <em>KEYS</em> and <em>ARGV</em> runtime global variables:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3] }&quot; 2 key1 key2 arg1 arg2 arg3\n1) &quot;key1&quot;\n2) &quot;key2&quot;\n3) &quot;arg1&quot;\n4) &quot;arg2&quot;\n5) &quot;arg3&quot;\n</code></pre>\n<p><strong>Note:</strong><br>as can been seen above, Lua&#39;s table arrays are returned as <a href=\"protocol.md#arrays\">RESP2 array replies</a>, so it is likely that your client&#39;s library will convert it to the native array data type in your programming language.<br>Please refer to the rules that govern <a href=\"lua-api.md#data-type-conversion\">data type conversion</a> for more pertinent information.</p>\n<h2>Interacting with Valkey from a script</h2>\n<p>It is possible to call Valkey commands from a Lua script either via <a href=\"lua-api.md#server.call\"><code>server.call()</code></a> or <a href=\"lua-api.md#server.pcall\"><code>server.pcall()</code></a>.</p>\n<p>The two are nearly identical.<br>Both execute a Valkey command along with its provided arguments, if these represent a well-formed command.<br>However, the difference between the two functions lies in the manner in which runtime errors (such as syntax errors, for example) are handled.<br>Errors raised from calling <code>server.call()</code> function are returned directly to the client that had executed it.<br>Conversely, errors encountered when calling the <code>server.pcall()</code> function are returned to the script&#39;s execution context instead for possible handling.</p>\n<p>For example, consider the following:</p>\n<pre><code>&gt; EVAL &quot;return server.call(&#39;SET&#39;, KEYS[1], ARGV[1])&quot; 1 foo bar\nOK\n</code></pre>\n<p>The above script accepts one key name and one value as its input arguments.<br>When executed, the script calls the <code>SET</code> command to set the input key, <em>foo</em>, with the string value &quot;bar&quot;.</p>\n<h2>Script cache</h2>\n<p>Until this point, we&#39;ve used the <code>EVAL</code> command to run our script.</p>\n<p>Whenever we call <code>EVAL</code>, we also include the script&#39;s source code with the request.<br>Repeatedly calling <code>EVAL</code> to execute the same set of parameterized scripts, wastes both network bandwidth and also has some overheads in Valkey.<br>Naturally, saving on network and compute resources is key, so, instead, Valkey provides a caching mechanism for scripts.</p>\n<p>Every script you execute with <code>EVAL</code> is stored in a dedicated cache that the server keeps.<br>The cache&#39;s contents are organized by the scripts&#39; SHA1 digest sums, so the SHA1 digest sum of a script uniquely identifies it in the cache.<br>You can verify this behavior by running <code>EVAL</code> and calling <code>INFO</code> afterward.<br>You&#39;ll notice that the <em>used_memory_scripts_eval</em> and <em>number_of_cached_scripts</em> metrics grow with every new script that&#39;s executed.</p>\n<p>As mentioned above, dynamically-generated scripts are an anti-pattern.<br>Generating scripts during the application&#39;s runtime may, and probably will, exhaust the host&#39;s memory resources for caching them.<br>Instead, scripts should be as generic as possible and provide customized execution via their arguments.</p>\n<p>A script is loaded to the server&#39;s cache by calling the <code>SCRIPT LOAD</code> command and providing its source code.<br>The server doesn&#39;t execute the script, but instead just compiles and loads it to the server&#39;s cache.<br>Once loaded, you can execute the cached script with the SHA1 digest returned from the server.</p>\n<p>Here&#39;s an example of loading and then executing a cached script:</p>\n<pre><code>127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &#39;Immabe a cached script&#39;&quot;\n&quot;c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f&quot;\n127.0.0.1:6379&gt; EVALSHA c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f 0\n&quot;Immabe a cached script&quot;\n</code></pre>\n<h3>Cache volatility</h3>\n<p>The Valkey script cache is <strong>always volatile</strong>.<br>It isn&#39;t considered as a part of the database and is <strong>not persisted</strong>.<br>The cache may be cleared when the server restarts, during fail-over when a replica assumes the primary role, or explicitly by <code>SCRIPT FLUSH</code>.<br>That means that cached scripts are ephemeral, and the cache&#39;s contents can be lost at any time.</p>\n<p>Applications that use scripts should always call <code>EVALSHA</code> to execute them.<br>The server returns an error if the script&#39;s SHA1 digest is not in the cache.<br>For example:</p>\n<pre><code>127.0.0.1:6379&gt; EVALSHA ffffffffffffffffffffffffffffffffffffffff 0\n(error) NOSCRIPT No matching script\n</code></pre>\n<p>In this case, the application should first load it with <code>SCRIPT LOAD</code> and then call <code>EVALSHA</code> once more to run the cached script by its SHA1 sum.<br>Most of <a href=\"../clients/\">Valkey&#39; clients</a> already provide utility APIs for doing that automatically.<br>Please consult your client&#39;s documentation regarding the specific details.</p>\n<h3><code>EVALSHA</code> in the context of pipelining</h3>\n<p>Special care should be given executing <code>EVALSHA</code> in the context of a <a href=\"pipelining.md\">pipelined request</a>.<br>The commands in a pipelined request run in the order they are sent, but other clients&#39; commands may be interleaved for execution between these.<br>Because of that, the <code>NOSCRIPT</code> error can return from a pipelined request but can&#39;t be handled.</p>\n<p>Therefore, a client library&#39;s implementation should revert to using plain <code>EVAL</code> of parameterized in the context of a pipeline.</p>\n<h3>Script cache semantics</h3>\n<p>During normal operation, an application&#39;s scripts are meant to stay indefinitely in the cache (that is, until the server is restarted or the cache being flushed).<br>The underlying reasoning is that the script cache contents of a well-written application are unlikely to grow continuously.<br>Even large applications that use hundreds of cached scripts shouldn&#39;t be an issue in terms of cache memory usage.</p>\n<p>The only way to flush the script cache is by explicitly calling the <code>SCRIPT FLUSH</code> command.<br>Running the command will <em>completely flush</em> the scripts cache, removing all the scripts executed so far.<br>Typically, this is only needed when the instance is going to be instantiated for another customer or application in a cloud environment.</p>\n<p>Also, as already mentioned, restarting a Valkey instance flushes the non-persistent script cache.<br>However, from the point of view of the Valkey client, there are only two ways to make sure that a Valkey instance was not restarted between two different commands:</p>\n<ul>\n<li>The connection we have with the server is persistent and was never closed so far.</li>\n<li>The client explicitly checks the <code>run_id</code> field in the <code>INFO</code> command to ensure the server was not restarted and is still the same process.</li>\n</ul>\n<p>Practically speaking, it is much simpler for the client to assume that in the context of a given connection, cached scripts are guaranteed to be there unless the administrator explicitly invoked the <code>SCRIPT FLUSH</code> command.<br>The fact that the user can count on Valkey to retain cached scripts is semantically helpful in the context of pipelining.</p>\n<h2>The <code>SCRIPT</code> command</h2>\n<p>The Valkey <code>SCRIPT</code> provides several ways for controlling the scripting subsystem.<br>These are:</p>\n<ul>\n<li><p><code>SCRIPT FLUSH</code>: this command is the only way to force Valkey to flush the scripts cache.<br>It is most useful in environments where the same Valkey instance is reassigned to different uses.<br>It is also helpful for testing client libraries&#39; implementations of the scripting feature.</p>\n</li>\n<li><p><code>SCRIPT EXISTS</code>: given one or more SHA1 digests as arguments, this command returns an array of <em>1</em>&#39;s and <em>0</em>&#39;s.<br><em>1</em> means the specific SHA1 is recognized as a script already present in the scripting cache. <em>0</em>&#39;s meaning is that a script with this SHA1 wasn&#39;t loaded before (or at least never since the latest call to <code>SCRIPT FLUSH</code>).</p>\n</li>\n<li><p><code>SCRIPT LOAD script</code>: this command registers the specified script in the Valkey script cache.<br>It is a useful command in all the contexts where we want to ensure that <code>EVALSHA</code> doesn&#39;t not fail (for instance, in a pipeline or when called from a <a href=\"transactions.md\"><code>MULTI</code>/<code>EXEC</code> transaction</a>), without the need to execute the script.</p>\n</li>\n<li><p><code>SCRIPT SHOW</code>: this command shows the original source code for a script that is stored in the script cache.<br>It is useful to help users easily obtain scripts using signature.</p>\n</li>\n<li><p><code>SCRIPT KILL</code>: this command is the only way to interrupt a long-running script (a.k.a slow script), short of shutting down the server.<br>A script is deemed as slow once its execution&#39;s duration exceeds the configured <a href=\"programmability.md#maximum-execution-time\">maximum execution time</a> threshold.<br>The <code>SCRIPT KILL</code> command can be used only with scripts that did not modify the dataset during their execution (since stopping a read-only script does not violate the scripting engine&#39;s guaranteed atomicity).</p>\n</li>\n<li><p><code>SCRIPT DEBUG</code>: controls use of the built-in <a href=\"ldb.md\">Valkey Lua scripts debugger</a>.</p>\n</li>\n</ul>\n<h2>Script replication</h2>\n<p>In a primary-replica setup (see <a href=\"replication.md\">replication</a>), write commands performed by a script on the primary are also sent to replicas to maintain consistency.<br>When the script execution finishes, the sequence of commands that the script generated are wrapped into a <a href=\"transactions.md\"><code>MULTI</code>/<code>EXEC</code> transaction</a> and are sent to the replicas and written to the AOF file, if an AOF file is used. (See <a href=\"persistence.md\">Persistence</a>.)<br>This is called <em>effects replication</em>.</p>\n<p>In the past, it was also possible to use <em>verbatim replication</em> which means that a script was replicated as a whole, but this was removed in 7.0.</p>\n<p>The <a href=\"lua-api.md#server.replicate_commands\"><code>server.replicate_commands()</code></a> function is deprecated and has no effect, but it exists to avoid breaking existing scripts.</p>\n<h2>Debugging Eval scripts</h2>\n<p>Valkey has a built-in Lua debugger.<br>The Valkey Lua debugger is a remote debugger consisting of a server, which is Valkey itself, and a client, which is by default <a href=\"cli.md\"><code>valkey-cli</code></a>.</p>\n<p>The Lua debugger is described in the <a href=\"ldb.md\">Lua scripts debugging</a> section of the Valkey documentation.</p>\n<h2>Execution under low memory conditions</h2>\n<p>When memory usage in Valkey exceeds the <code>maxmemory</code> limit, the first write command encountered in the script that uses additional memory will cause the script to abort (unless <a href=\"lua-api.md#server.pcall\"><code>server.pcall</code></a> was used).</p>\n<p>However, an exception to the above is when the script&#39;s first write command does not use additional memory, as is the case with  (for example, <code>DEL</code> and <code>LREM</code>).<br>In this case, Valkey will allow all commands in the script to run to ensure atomicity.<br>If subsequent writes in the script consume additional memory, Valkey&#39; memory usage can exceed the threshold set by the <code>maxmemory</code> configuration directive.</p>\n<p>Another scenario in which a script can cause memory usage to cross the <code>maxmemory</code> threshold is when the execution begins when Valkey is slightly below <code>maxmemory</code>, so the script&#39;s first write command is allowed.<br>As the script executes, subsequent write commands consume more memory leading to the server using more RAM than the configured <code>maxmemory</code> directive.</p>\n<p>In those scenarios, you should consider setting the <code>maxmemory-policy</code> configuration directive to any values other than <code>noeviction</code>.<br>In addition, Lua scripts should be as fast as possible so that eviction can kick in between executions.</p>\n<p>Note that you can change this behaviour by using <a href=\"#eval-flags\">flags</a></p>\n<h2>Eval flags</h2>\n<p>Normally, when you run an Eval script, the server does not know how it accesses the database.<br>By default, Valkey assumes that all scripts read and write data.<br>However, starting with Redis OSS 7.0, there&#39;s a way to declare flags when creating a script in order to tell Valkey how it should behave.</p>\n<p>The way to do that is by using a Shebang statement on the first line of the script like so:</p>\n<pre><code>#!lua flags=no-writes,allow-stale\nlocal x = server.call(&#39;get&#39;,&#39;x&#39;)\nreturn x\n</code></pre>\n<p>Note that as soon as Valkey sees the <code>#!</code> comment, it&#39;ll treat the script as if it declares flags, even if no flags are defined,<br>it still has a different set of defaults compared to a script without a <code>#!</code> line.</p>\n<p>Another difference is that scripts without <code>#!</code> can run commands that access keys belonging to different cluster hash slots, but ones with <code>#!</code> inherit the default flags, so they cannot.</p>\n<p>Please refer to <a href=\"lua-api.md#script_flags\">Script flags</a> to learn about the various scripts and the defaults.</p>\n"
  },
  {
    "id": "lua-api",
    "topicName": "Lua API reference",
    "description": "Executing Lua in Valkey\n",
    "htmlContent": "<p>Valkey includes an embedded <a href=\"https://www.lua.org/\">Lua 5.1</a> interpreter.<br>The interpreter runs user-defined <a href=\"eval-intro.md\">ephemeral scripts</a> and <a href=\"functions-intro.md\">functions</a>. Scripts run in a sandboxed context and can only access specific Lua packages. This page describes the packages and APIs available inside the execution&#39;s context.</p>\n<h2>Sandbox context</h2>\n<p>The sandboxed Lua context attempts to prevent accidental misuse and reduce potential threats from the server&#39;s environment.</p>\n<p>Scripts should never try to access the Valkey server&#39;s underlying host systems.<br>That includes the file system, network, and any other attempt to perform a system call other than those supported by the API.</p>\n<p>Scripts should operate solely on data stored in Valkey and data provided as arguments to their execution.</p>\n<h3>Global variables and functions</h3>\n<p>The sandboxed Lua execution context blocks the declaration of global variables and functions.<br>The blocking of global variables is in place to ensure that scripts and functions don&#39;t attempt to maintain any runtime context other than the data stored in Valkey.<br>In the (somewhat uncommon) use case that a context needs to be maintain between executions,<br>you should store the context in Valkey&#39; keyspace.</p>\n<p>Valkey will return an error when trying to execute the following snippet:</p>\n<pre><code class=\"language-lua\">my_global_variable = &#39;some value&#39;\n</code></pre>\n<p>And similarly for the following global function declaration:</p>\n<pre><code class=\"language-lua\">function my_global_function()\n  -- Do something amazing\nend\n</code></pre>\n<p>You&#39;ll also get a similar error when your script attempts to access any global variables that are undefined in the runtime&#39;s context:</p>\n<pre><code class=\"language-lua\">-- The following will surely raise an error\nreturn an_undefined_global_variable\n</code></pre>\n<p>Instead, all variable and function definitions are required to be declared as local.<br>To do so, you&#39;ll need to prepend the <a href=\"https://www.lua.org/manual/5.1/manual.html#2.4.7\"><code>local</code></a> keyword to your declarations.<br>For example, the following snippet will be considered perfectly valid by Valkey:</p>\n<pre><code class=\"language-lua\">local my_local_variable = &#39;some value&#39;\n\nlocal function my_local_function()\n  -- Do something else, but equally amazing\nend\n</code></pre>\n<p><strong>Note:</strong><br>the sandbox attempts to prevent the use of globals.<br>Using Lua&#39;s debugging functionality or other approaches such as altering the meta table used for implementing the globals&#39; protection to circumvent the sandbox isn&#39;t hard.<br>However, it is difficult to circumvent the protection by accident.<br>If the user messes with the Lua global state, the consistency of AOF and replication can&#39;t be guaranteed.<br>In other words, just don&#39;t do it.</p>\n<h3>Imported Lua modules</h3>\n<p>Using imported Lua modules is not supported inside the sandboxed execution context.<br>The sandboxed execution context prevents the loading modules by disabling Lua&#39;s <a href=\"https://www.lua.org/pil/8.1.html\"><code>require</code> function</a>.</p>\n<p>The only libraries that Valkey ships with and that you can use in scripts are listed under the <a href=\"#runtime-libraries\">Runtime libraries</a> section.</p>\n<h2>Runtime globals</h2>\n<p>While the sandbox prevents users from declaring globals, the execution context is pre-populated with several of these.</p>\n<p>For some of them, a &quot;since version&quot; is specified.<br>The ones without &quot;since version&quot; specified are available in all maintained versions.</p>\n<h3><a name=\"the-keys-global-variable\"></a>The <code>KEYS</code> global variable</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p><strong>Important:</strong><br>to ensure the correct execution of scripts, both in standalone and clustered deployments, all names of keys that a function accesses must be explicitly provided as input key arguments.<br>The script <strong>should only</strong> access keys whose names are given as input arguments.<br>Scripts <strong>should never</strong> access keys with programmatically-generated names or based on the contents of data structures stored in the database.</p>\n<p>The <code>KEYS</code> global variable is available only for <a href=\"eval-intro.md\">ephemeral scripts</a>.<br>It is pre-populated with all key name input arguments.</p>\n<h3><a name=\"the-argv-global-variable\"></a>The <code>ARGV</code> global variable</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p>The <code>ARGV</code> global variable is available only in <a href=\"eval-intro.md\">ephemeral scripts</a>.<br>It is pre-populated with all regular input arguments.</p>\n<h3>The <code>server</code> singleton</h3>\n<ul>\n<li>Since version: 7.2.5</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <code>server</code> singleton is an object instance that&#39;s accessible from all scripts.<br>It provides the API to interact with Valkey from scripts.<br>Following is the API provided by the <code>server</code> object instance.</p>\n<p><strong>Note:</strong><br>For compatibility with Redis, Valkey also exposes a <code>redis</code> top-level object, that exposes the exact same set of APIs as the <code>server</code> object.<br>Valkey does not intend to drop compatibility for this <code>redis</code> API, but it is recommended to use the <code>server</code> object for newly developed scripts.</p>\n<h2><a name=\"server_object\"></a> <code>server</code> object fields (functions and variables)</h2>\n<h3><a name=\"server.call\"></a> <code>server.call(command [,arg...])</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <code>server.call()</code> function calls a given Valkey command and returns its reply.<br>Its inputs are the command and arguments, and once called, it executes the command in Valkey and returns the reply.</p>\n<p>For example, we can call the <code>ECHO</code> command from a script and return its reply like so:</p>\n<pre><code class=\"language-lua\">return server.call(&#39;ECHO&#39;, &#39;Echo, echo... eco... o...&#39;)\n</code></pre>\n<p>If and when <code>server.call()</code> triggers a runtime exception, the raw exception is raised back to the user as an error, automatically.<br>Therefore, attempting to execute the following ephemeral script will fail and generate a runtime exception because <code>ECHO</code> accepts exactly one argument:</p>\n<pre><code class=\"language-lua\">127.0.0.1:6379&gt; EVAL &quot;return server.call(&#39;ECHO&#39;, &#39;Echo,&#39;, &#39;echo... &#39;, &#39;eco... &#39;, &#39;o...&#39;)&quot; 0\n(error) ERR Wrong number of args calling Valkey command from script script: b0345693f4b77517a711221050e76d24ae60b7f7, on @user_script:1.\n</code></pre>\n<p>Note that the call can fail due to various reasons, see <a href=\"eval-intro.md#execution-under-low-memory-conditions\">Execution under low memory conditions</a> and <a href=\"#script_flags\">Script flags</a></p>\n<p>To handle Valkey runtime errors use <code>server.pcall()</code> instead.</p>\n<h3><a name=\"server.pcall\"></a> <code>server.pcall(command [,arg...])</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function enables handling runtime errors raised by the Valkey server.<br>The <code>server.pcall()</code> function  behaves exactly like <a href=\"#server.call\"><code>server.call()</code></a>, except that it:</p>\n<ul>\n<li>Always returns a reply.</li>\n<li>Never throws a runtime exception, and returns in its stead a <a href=\"#server.error_reply\"><code>server.error_reply</code></a> in case that a runtime exception is thrown by the server.</li>\n</ul>\n<p>The following demonstrates how to use <code>server.pcall()</code> to intercept and handle runtime exceptions from within the context of an ephemeral script.</p>\n<pre><code class=\"language-lua\">local reply = server.pcall(&#39;ECHO&#39;, unpack(ARGV))\nif reply[&#39;err&#39;] ~= nil then\n  -- Handle the error sometime, but for now just log it\n  server.log(server.LOG_WARNING, reply[&#39;err&#39;])\n  reply[&#39;err&#39;] = &#39;ERR Something is wrong, but no worries, everything is under control&#39;\nend\nreturn reply\n</code></pre>\n<p>Evaluating this script with more than one argument will return:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;...&quot; 0 hello world\n(error) ERR Something is wrong, but no worries, everything is under control\n</code></pre>\n<h3><a name=\"server.error_reply\"></a> <code>server.error_reply(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This is a helper function that returns an <a href=\"protocol.md#simply-errors\">error reply</a>.<br>The helper accepts a single string argument and returns a Lua table with the <code>err</code> field set to that string.</p>\n<p>The outcome of the following code is that <code>error1</code> and <code>error2</code> are identical for all intents and purposes:</p>\n<pre><code class=\"language-lua\">local text = &#39;ERR My very special error&#39;\nlocal reply1 = { err = text }\nlocal reply2 = server.error_reply(text)\n</code></pre>\n<p>Therefore, both forms are valid as means for returning an error reply from scripts:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { err = &#39;ERR My very special table error&#39; }&quot; 0\n(error) ERR My very special table error\n127.0.0.1:6379&gt; EVAL &quot;return server.error_reply(&#39;ERR My very special reply error&#39;)&quot; 0\n(error) ERR My very special reply error\n</code></pre>\n<p>For returning Valkey status replies refer to <a href=\"#server.status_reply\"><code>server.status_reply()</code></a>.<br>Refer to the <a href=\"#data-type-conversion\">Data type conversion</a> for returning other response types.</p>\n<p><strong>Note:</strong><br>By convention, Valkey uses the first word of an error string as a unique error code for specific errors or <code>ERR</code> for general-purpose errors.<br>Scripts are advised to follow this convention, as shown in the example above, but this is not mandatory.</p>\n<h3><a name=\"server.status_reply\"></a> <code>server.status_reply(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This is a helper function that returns a <a href=\"protocol.md#simple-strings\">simple string reply</a>.<br>&quot;OK&quot; is an example of a standard Valkey status reply.<br>The Lua API represents status replies as tables with a single field, <code>ok</code>, set with a simple status string.</p>\n<p>The outcome of the following code is that <code>status1</code> and <code>status2</code> are identical for all intents and purposes:</p>\n<pre><code class=\"language-lua\">local text = &#39;Frosty&#39;\nlocal status1 = { ok = text }\nlocal status2 = server.status_reply(text)\n</code></pre>\n<p>Therefore, both forms are valid as means for returning status replies from scripts:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { ok = &#39;TICK&#39; }&quot; 0\nTICK\n127.0.0.1:6379&gt; EVAL &quot;return server.status_reply(&#39;TOCK&#39;)&quot; 0\nTOCK\n</code></pre>\n<p>For returning Valkey error replies refer to <a href=\"#server.error_reply\"><code>server.error_reply()</code></a>.<br>Refer to the <a href=\"#data-type-conversion\">Data type conversion</a> for returning other response types.</p>\n<h3><a name=\"server.sha1hex\"></a> <code>server.sha1hex(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function returns the SHA1 hexadecimal digest of its single string argument.</p>\n<p>You can, for example, obtain the empty string&#39;s SHA1 digest:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return server.sha1hex(&#39;&#39;)&quot; 0\n&quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;\n</code></pre>\n<h3><a name=\"server.log\"></a> <code>server.log(level, message)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function writes to the Valkey server log.</p>\n<p>It expects two input arguments: the log level and a message.<br>The message is a string to write to the log file.<br>Log level can be on of these:</p>\n<ul>\n<li><code>server.LOG_DEBUG</code></li>\n<li><code>server.LOG_VERBOSE</code></li>\n<li><code>server.LOG_NOTICE</code></li>\n<li><code>server.LOG_WARNING</code></li>\n</ul>\n<p>These levels map to the server&#39;s log levels.<br>The log only records messages equal or greater in level than the server&#39;s <code>loglevel</code> configuration directive.</p>\n<p>The following snippet:</p>\n<pre><code class=\"language-lua\">server.log(server.LOG_WARNING, &#39;Something is terribly wrong&#39;)\n</code></pre>\n<p>will produce a line similar to the following in your server&#39;s log:</p>\n<pre><code>[32343] 22 Mar 15:21:39 # Something is terribly wrong\n</code></pre>\n<h3><a name=\"server.setresp\"></a> <code>server.setresp(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function allows the executing script to switch between <a href=\"protocol.md\">RESP</a> protocol versions for the replies returned by <a href=\"#server.call\"><code>server.call()</code></a> and <a href=\"#server.pcall\"><code>server.pcall()</code></a>.<br>It expects a single numerical argument as the protocol&#39;s version.<br>The default protocol version is <em>2</em>, but it can be switched to version <em>3</em>.</p>\n<p>Here&#39;s an example of switching to RESP3 replies:</p>\n<pre><code class=\"language-lua\">server.setresp(3)\n</code></pre>\n<p>Please refer to the <a href=\"#data-type-conversion\">Data type conversion</a> for more information about type conversions.</p>\n<h3><a name=\"server.set_repl\"></a> <code>server.set_repl(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p><strong>Note:</strong><br>Prior to Redis OSS 7.0, scripts were replicated verbatim by default.<br>Since Redis OSS 7.0 (and Valkey), script effects replication is the only replication mode available.</p>\n<p>The <code>server.set_repl()</code> function instructs the server how to treat subsequent write commands in terms of replication.<br>It accepts a single input argument that only be one of the following:</p>\n<ul>\n<li><code>server.REPL_ALL</code>: replicates the effects to the AOF and replicas.</li>\n<li><code>server.REPL_AOF</code>: replicates the effects to the AOF alone.</li>\n<li><code>server.REPL_REPLICA</code>: replicates the effects to the replicas alone.</li>\n<li><code>server.REPL_SLAVE</code>: same as <code>REPL_REPLICA</code>, maintained for backward compatibility.</li>\n<li><code>server.REPL_NONE</code>: disables effect replication entirely.</li>\n</ul>\n<p>By default, the scripting engine is initialized to the <code>server.REPL_ALL</code> setting when a script begins its execution.<br>You can call the <code>server.set_repl()</code> function at any time during the script&#39;s execution to switch between the different replication modes.</p>\n<p>A simple example follows:</p>\n<pre><code class=\"language-lua\">server.replicate_commands() -- Enable effects replication in versions lower than Redis OSS v7.0\nserver.call(&#39;SET&#39;, KEYS[1], ARGV[1])\nserver.set_repl(server.REPL_NONE)\nserver.call(&#39;SET&#39;, KEYS[2], ARGV[2])\nserver.set_repl(server.REPL_ALL)\nserver.call(&#39;SET&#39;, KEYS[3], ARGV[3])\n</code></pre>\n<p>If you run this script by calling <code>EVAL &quot;...&quot; 3 A B C 1 2 3</code>, the result will be that only the keys <em>A</em> and <em>C</em> are created on the replicas and AOF.</p>\n<h3><a name=\"server.replicate_commands\"></a> <code>server.replicate_commands()</code></h3>\n<ul>\n<li>Until version: 7.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p>This function switches the script&#39;s replication mode from verbatim replication to effects replication.<br>You can use it to override the default verbatim script replication mode used by Redis OSS until version 7.0.</p>\n<p><strong>Note:</strong><br>Verbatim script replication is no longer supported.<br>The only script replication mode supported is script effects&#39; replication.<br>For more information, please refer to <a href=\"eval-intro.md#replicating-commands-instead-of-scripts\"><code>Replicating commands instead of scripts</code></a></p>\n<h3><a name=\"server.breakpoint\"></a>  <code>server.breakpoint()</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p>This function triggers a breakpoint when using the <a href=\"ldb.md\">Valkey Lua debugger</a>.</p>\n<h3><a name=\"server.debug\"></a> <code>server.debug(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p>This function prints its argument in the <a href=\"ldb.md\">Valkey Lua debugger</a> console.</p>\n<h3><a name=\"server.acl_check_cmd\"></a> <code>server.acl_check_cmd(command [,arg...])</code></h3>\n<ul>\n<li>Since version: 7.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function is used for checking if the current user running the script has <a href=\"acl.md\">ACL</a> permissions to execute the given command with the given arguments.</p>\n<p>The return value is a boolean <code>true</code> in case the current user has permissions to execute the command (via a call to <a href=\"#server.call\">server.call</a> or <a href=\"#server.pcall\">server.pcall</a>) or <code>false</code> in case they don&#39;t.</p>\n<p>The function will raise an error if the passed command or its arguments are invalid.</p>\n<h3><a name=\"server.register_function\"></a> <code>server.register_function</code></h3>\n<ul>\n<li>Since version: 7.0.0</li>\n<li>Available in scripts: no</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function is only available from the context of the <code>FUNCTION LOAD</code> command.<br>When called, it registers a function to the loaded library.<br>The function can be called either with positional or named arguments.</p>\n<h4><a name=\"server.register_function_pos_args\"></a> positional arguments: <code>server.register_function(name, callback)</code></h4>\n<p>The first argument to <code>server.register_function</code> is a Lua string representing the function name.<br>The second argument to <code>server.register_function</code> is a Lua function.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LOAD &quot;#!lua name=mylib\\n server.register_function(&#39;noop&#39;, function() end)&quot;\n</code></pre>\n<h4><a name=\"server.register_function_named_args\"></a> Named arguments:  <code>server.register_function{function_name=name, callback=callback, flags={flag1, flag2, ..}, description=description}</code></h4>\n<p>The named arguments variant accepts the following arguments:</p>\n<ul>\n<li><em>function_name</em>: the function&#39;s name.</li>\n<li><em>callback</em>: the function&#39;s callback.</li>\n<li><em>flags</em>: an array of strings, each a function flag (optional).</li>\n<li><em>description</em>: function&#39;s description (optional).</li>\n</ul>\n<p>Both <em>function_name</em> and <em>callback</em> are mandatory.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LOAD &quot;#!lua name=mylib\\n server.register_function{function_name=&#39;noop&#39;, callback=function() end, flags={ &#39;no-writes&#39; }, description=&#39;Does nothing&#39;}&quot;\n</code></pre>\n<h4><a name=\"script_flags\"></a> Script flags</h4>\n<p><strong>Important:</strong><br>Use script flags with care, which may negatively impact if misused.<br>Note that the default for Eval scripts are different than the default for functions that are mentioned below, see <a href=\"eval-intro.md#eval-flags\">Eval Flags</a></p>\n<p>When you register a function or load an Eval script, the server does not know how it accesses the database.<br>By default, Valkey assumes that all scripts read and write data.<br>This results in the following behavior:</p>\n<ol>\n<li>They can read and write data.</li>\n<li>They can run in cluster mode, and are not able to run commands accessing keys of different hash slots.</li>\n<li>Execution against a stale replica is denied to avoid inconsistent reads.</li>\n<li>Execution under low memory is denied to avoid exceeding the configured threshold.</li>\n</ol>\n<p>You can use the following flags and instruct the server to treat the scripts&#39; execution differently:</p>\n<ul>\n<li><p><code>no-writes</code>: this flag indicates that the script only reads data but never writes.</p>\n<p>  By default, Valkey will deny the execution of flagged scripts (Functions and Eval scripts with <a href=\"eval-intro.md#eval-flags\">shebang</a>) against read-only replicas, as they may attempt to perform writes.<br>  Similarly, the server will not allow calling scripts with <code>FCALL_RO</code> / <code>EVAL_RO</code>.<br>  Lastly, when data persistence is at risk due to a disk error, execution is blocked as well.</p>\n<p>  Using this flag allows executing the script:</p>\n<ol>\n<li>With <code>FCALL_RO</code> / <code>EVAL_RO</code></li>\n<li>On read-only replicas.</li>\n<li>Even if there&#39;s a disk error (Valkey is unable to persist so it rejects writes).</li>\n<li>When over the memory limit since it implies the script doesn&#39;t increase memory consumption (see <code>allow-oom</code> below)</li>\n</ol>\n<p>  However, note that the server will return an error if the script attempts to call a write command.<br>  Also note that currently <code>PUBLISH</code>, <code>SPUBLISH</code> and <code>PFCOUNT</code> are also considered write commands in scripts, because they could attempt to propagate commands to replicas and AOF file.</p>\n<p>  For more information please refer to <a href=\"programmability.md#read-only_scripts\">Read-only scripts</a></p>\n</li>\n<li><p><code>allow-oom</code>: use this flag to allow a script to execute when the server is out of memory (OOM).</p>\n<p>  Unless used, Valkey will deny the execution of flagged scripts (Functions and Eval scripts with <a href=\"eval-intro.md#eval-flags\">shebang</a>) when in an OOM state.<br>  Furthermore, when you use this flag, the script can call any Valkey command, including commands that aren&#39;t usually allowed in this state.<br>  Specifying <code>no-writes</code> or using <code>FCALL_RO</code> / <code>EVAL_RO</code> also implies the script can run in OOM state (without specifying <code>allow-oom</code>)</p>\n</li>\n<li><p><code>allow-stale</code>: a flag that enables running the flagged scripts (Functions and Eval scripts with <a href=\"eval-intro.md#eval-flags\">shebang</a>) against a stale replica when the <code>replica-serve-stale-data</code> config is set to <code>no</code> .</p>\n<p>  Valkey can be set to prevent data consistency problems from using old data by having stale replicas return a runtime error.<br>  For scripts that do not access the data, this flag can be set to allow stale Valkey replicas to run the script.<br>  Note however that the script will still be unable to execute any command that accesses stale data.</p>\n</li>\n<li><p><code>no-cluster</code>: the flag causes the script to return an error in Valkey cluster mode.</p>\n<p>  Valkey allows scripts to be executed both in standalone and cluster modes.<br>  Setting this flag prevents executing the script against nodes in the cluster.</p>\n</li>\n<li><p><code>allow-cross-slot-keys</code>: The flag that allows a script to access keys from multiple slots.</p>\n<p>  Valkey typically prevents any single command from accessing keys that hash to multiple slots.<br>  This flag allows scripts to break this rule and access keys within the script that access multiple slots.<br>  Declared keys to the script are still always required to hash to a single slot.<br>  Accessing keys from multiple slots is discouraged as applications should be designed to only access keys from a single slot at a time, allowing slots to move between Valkey servers.</p>\n<p>  This flag has no effect when cluster mode is disabled.</p>\n</li>\n</ul>\n<p>Please refer to <a href=\"functions-intro.md#function-flags\">Function Flags</a> and <a href=\"eval-intro.md#eval-flags\">Eval Flags</a> for a detailed example.</p>\n<h3><a name=\"server.server_version\"></a> <code>server.SERVER_VERSION</code></h3>\n<ul>\n<li>Since version: 7.2.5</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>Returns the current Valkey server version as a Lua string.<br>The reply&#39;s format is <code>MM.mm.PP</code>, where:</p>\n<ul>\n<li><strong>MM:</strong> is the major version.</li>\n<li><strong>mm:</strong> is the minor version.</li>\n<li><strong>PP:</strong> is the patch level.</li>\n</ul>\n<h3><a name=\"server.redis_version\"></a> <code>server.REDIS_VERSION</code></h3>\n<ul>\n<li>Since version: 7.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>Returns the current Redis compatibility version as a Lua string.<br>The reply&#39;s format is <code>MM.mm.PP</code>, where:</p>\n<ul>\n<li><strong>MM:</strong> is the major version.</li>\n<li><strong>mm:</strong> is the minor version.</li>\n<li><strong>PP:</strong> is the patch level.</li>\n</ul>\n<h3><a name=\"server.redis_version_num\"></a> <code>server.SERVER_VERSION_NUM</code></h3>\n<ul>\n<li>Since version: 7.2.5</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>Returns the current Valkey server version as a number.<br>The reply is a hexadecimal value structured as <code>0x00MMmmPP</code>, where:</p>\n<ul>\n<li><strong>MM:</strong> is the major version.</li>\n<li><strong>mm:</strong> is the minor version.</li>\n<li><strong>PP:</strong> is the patch level.</li>\n</ul>\n<h3><a name=\"server.redis_version_num\"></a> <code>server.REDIS_VERSION_NUM</code></h3>\n<ul>\n<li>Since version: 7.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>Returns the current Redis compatibility version as a number.<br>The reply is a hexadecimal value structured as <code>0x00MMmmPP</code>, where:</p>\n<ul>\n<li><strong>MM:</strong> is the major version.</li>\n<li><strong>mm:</strong> is the minor version.</li>\n<li><strong>PP:</strong> is the patch level.</li>\n</ul>\n<h2>Data type conversion</h2>\n<p>Unless a runtime exception is raised, <code>server.call()</code> and <code>server.pcall()</code> return the reply from the executed command to the Lua script.<br>Valkey&#39;s replies from these functions are converted automatically into Lua&#39;s native data types.</p>\n<p>Similarly, when a Lua script returns a reply with the <code>return</code> keyword,<br>that reply is automatically converted to RESP protocol.</p>\n<p>Put differently: There&#39;s a one-to-one mapping between Valkey&#39;s replies and Lua&#39;s data types and a one-to-one mapping between Lua&#39;s data types and the <a href=\"protocol.md\">RESP Protocol</a> data types.<br>The underlying design is such that if a RESP type is converted into a Lua type and converted back into a RESP type, the result is the same as the initial value.</p>\n<p>Type conversion from Valkey replies (i.e. the replies from <code>server.call()</code> and <code>server.pcall()</code>) to Lua data types depends on the RESP protocol version used by the script.<br>The default protocol version during script executions is RESP2.<br>The script may switch the replies&#39; protocol versions by calling the <code>server.setresp()</code> function.</p>\n<p>Type conversion from a script&#39;s returned Lua data type depends on the user&#39;s choice of protocol (see the <code>HELLO</code> command).</p>\n<p>The following sections describe the type conversion rules between Lua and Valkey per the protocol&#39;s version.</p>\n<h3>RESP2 to Lua type conversion</h3>\n<p>The following type conversion rules apply to the execution&#39;s context by default as well as after calling <code>server.setresp(2)</code>:</p>\n<ul>\n<li><a href=\"protocol.md#integers\">RESP2 integer reply</a> -&gt; Lua number</li>\n<li><a href=\"protocol.md#bulk-strings\">RESP2 bulk string reply</a> -&gt; Lua string</li>\n<li><a href=\"protocol.md#arrays\">RESP2 array reply</a> -&gt; Lua table (may have other Valkey data types nested)</li>\n<li><a href=\"protocol.md#simple-strings\">RESP2 status reply</a> -&gt; Lua table with a single <em>ok</em> field containing the status string</li>\n<li><a href=\"protocol.md#simple-errors\">RESP2 error reply</a> -&gt; Lua table with a single <em>err</em> field containing the error string</li>\n<li><a href=\"protocol.md#nulls\">RESP2 null bulk reply and null multi bulk reply</a> -&gt; Lua false boolean type</li>\n</ul>\n<h2>Lua to RESP2 type conversion</h2>\n<p>The following type conversion rules apply by default as well as after the user had called <code>HELLO 2</code>:</p>\n<ul>\n<li>Lua number -&gt; <a href=\"protocol.md#integers\">RESP2 integer reply</a> (the number is converted into an integer)</li>\n<li>Lua string -&gt; <a href=\"protocol.md#bulk-strings\">RESP bulk string reply</a></li>\n<li>Lua table (indexed, non-associative array) -&gt; <a href=\"protocol.md#arrays\">RESP2 array reply</a> (truncated at the first Lua <code>nil</code> value encountered in the table, if any)</li>\n<li>Lua table with a single <em>ok</em> field -&gt; <a href=\"protocol.md#simple-strings\">RESP2 status reply</a></li>\n<li>Lua table with a single <em>err</em> field -&gt; <a href=\"protocol.md#simple-errors\">RESP2 error reply</a></li>\n<li>Lua boolean false -&gt; <a href=\"protocol.md#nulls\">RESP2 null bulk reply</a></li>\n</ul>\n<p>There is an additional Lua-to-Valkey conversion rule that has no corresponding Valkey-to-Lua conversion rule:</p>\n<ul>\n<li>Lua Boolean <code>true</code> -&gt; <a href=\"protocol.md#integers\">RESP2 integer reply</a> with value of 1.</li>\n</ul>\n<p>There are three additional rules to note about converting Lua to Valkey data types:</p>\n<ul>\n<li>Lua has a single numerical type, Lua numbers.<br>There is no distinction between integers and floats.<br>So we always convert Lua numbers into integer replies, removing the decimal part of the number, if any.<br><strong>If you want to return a Lua float, it should be returned as a string</strong>,<br>exactly like Valkey itself does (see, for instance, the <code>ZSCORE</code> command).</li>\n<li>There&#39;s <a href=\"https://www.lua.org/pil/19.1.html\">no simple way to have nils inside Lua arrays</a> due<br>to Lua&#39;s table semantics.<br>Therefore, when Valkey converts a Lua array to RESP, the conversion stops when it encounters a Lua <code>nil</code> value.</li>\n<li>When a Lua table is an associative array that contains keys and their respective values, the converted Valkey reply will <strong>not</strong> include them.</li>\n</ul>\n<p>Lua to RESP2 type conversion examples:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return 10&quot; 0\n(integer) 10\n\n127.0.0.1:6379&gt; EVAL &quot;return { 1, 2, { 3, &#39;Hello World!&#39; } }&quot; 0\n1) (integer) 1\n2) (integer) 2\n3) 1) (integer) 3\n   1) &quot;Hello World!&quot;\n\n127.0.0.1:6379&gt; EVAL &quot;return server.call(&#39;get&#39;,&#39;foo&#39;)&quot; 0\n&quot;bar&quot;\n</code></pre>\n<p>The last example demonstrates receiving and returning the exact return value of <code>server.call()</code> (or <code>server.pcall()</code>) in Lua as it would be returned if the command had been called directly.</p>\n<p>The following example shows how floats and arrays that cont nils and keys are handled:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { 1, 2, 3.3333, somekey = &#39;somevalue&#39;, &#39;foo&#39;, nil , &#39;bar&#39; }&quot; 0\n1) (integer) 1\n2) (integer) 2\n3) (integer) 3\n4) &quot;foo&quot;\n</code></pre>\n<p>As you can see, the float value of <em>3.333</em> gets converted to an integer <em>3</em>, the <em>somekey</em> key and its value are omitted, and the string &quot;bar&quot; isn&#39;t returned as there is a <code>nil</code> value that precedes it.</p>\n<h3>RESP3 to Lua type conversion</h3>\n<p>RESP3 is a newer version of the <a href=\"protocol.md\">protocol</a> used by Valkey.<br>It is available as an opt-in choice.</p>\n<p>An executing script may call the <a href=\"#server.setresp\"><code>server.setresp</code></a> function during its execution and switch the protocol version that&#39;s used for returning replies from Valkey&#39;s commands (that can be invoked via <a href=\"#server.call\"><code>server.call()</code></a> or <a href=\"#server.pcall\"><code>server.pcall()</code></a>).</p>\n<p>Once Valkey&#39;s replies are in RESP3 protocol, all of the <a href=\"#resp2-to-lua-type-conversion\">RESP2 to Lua conversion</a> rules apply, with the following additions:</p>\n<ul>\n<li><a href=\"protocol.md#maps\">Map reply</a> -&gt; Lua table with a single <em>map</em> field containing a Lua table representing the fields and values of the map.</li>\n<li><a href=\"protocol.md#sets\">Set reply</a> -&gt; Lua table with a single <em>set</em> field containing a Lua table representing the elements of the set as fields, each with the Lua Boolean value of <code>true</code>.</li>\n<li><a href=\"protocol.md#nulls\">Null</a> -&gt; Lua <code>nil</code>.</li>\n<li><a href=\"protocol.md#booleans\">True reply</a> -&gt; Lua true boolean value.</li>\n<li><a href=\"protocol.md#booleans\">False reply</a> -&gt; Lua false boolean value.</li>\n<li><a href=\"protocol.md#doubles\">Double reply</a> -&gt; Lua table with a single <code>double</code> field containing a Lua number representing the double value.</li>\n<li><a href=\"protocol.md#big-numbers\">Big number reply</a> -&gt; Lua table with a single <code>big_number</code> field containing a Lua string representing the big number value (since Redis OSS 7.0).</li>\n<li><a href=\"protocol.md#verbatim-strings\">Verbatim string reply</a> -&gt; Lua table with a single <code>verbatim_string</code> field containing a Lua table with two fields, <code>string</code> and <code>format</code>, representing the verbatim string and its format, respectively (since Redis OSS 7.0).</li>\n</ul>\n<h3>Lua to RESP3 type conversion</h3>\n<p>Regardless of the script&#39;s choice of protocol version set for replies with the [<code>server.setresp()</code> function] when it calls <code>server.call()</code> or <code>server.pcall()</code>, the user may opt-in to using RESP3 (with the <code>HELLO 3</code> command) for the connection.<br>Although the default protocol for incoming client connections is RESP2, the script should honor the user&#39;s preference and return adequately-typed RESP3 replies, so the following rules apply on top of those specified in the <a href=\"#lua-to-resp2-type-conversion\">Lua to RESP2 type conversion</a> section when that is the case.</p>\n<ul>\n<li>Lua Boolean -&gt; <a href=\"protocol.md#booleans\">RESP3 Boolean reply</a> (note that this is a change compared to the RESP2, in which returning a Boolean Lua <code>true</code> returned the number 1 to the Valkey client, and returning a <code>false</code> used to return a <code>null</code>.</li>\n<li>Lua table with a single <code>map</code> field set to an associative Lua table -&gt; <a href=\"protocol.md#maps\">RESP3 map reply</a>.</li>\n<li>Lua table with a single <code>set</code> field set to an associative Lua table -&gt; <a href=\"protocol.md#sets\">RESP3 set reply</a>. Values can be set to anything and are discarded anyway.</li>\n<li>Lua table with a single <code>double</code> field to an associative Lua table -&gt; <a href=\"protocol.md#doubles\">RESP3 double reply</a>.</li>\n<li>Lua nil -&gt; <a href=\"protocol.md#nulls\">RESP3 null</a>.</li>\n</ul>\n<p>However, if the connection is set use the RESP2 protocol, and even if the script replies with RESP3-typed responses, Valkey will automatically perform a RESP3 to RESP2 conversion of the reply as is the case for regular commands.<br>That means, for example, that returning the RESP3 map type to a RESP2 connection will result in the reply being converted to a flat RESP2 array that consists of alternating field names and their values, rather than a RESP3 map.</p>\n<h2>Additional notes about scripting</h2>\n<h3>Using <code>SELECT</code> inside scripts</h3>\n<p>You can call the <code>SELECT</code> command from your Lua scripts, like you can with any normal client connection.<br>The database selected by the Lua script only affects the execution context of the script, and does not modify the database that&#39;s selected by the client calling the script.</p>\n<h2>Runtime libraries</h2>\n<p>The Valkey Lua runtime context always comes with several pre-imported libraries.</p>\n<p>The following <a href=\"https://www.lua.org/manual/5.1/manual.html#5\">standard Lua libraries</a> are available to use:</p>\n<ul>\n<li>The <a href=\"https://www.lua.org/manual/5.1/manual.html#5.4\"><em>String Manipulation (string)</em> library</a></li>\n<li>The <a href=\"https://www.lua.org/manual/5.1/manual.html#5.5\"><em>Table Manipulation (table)</em> library</a></li>\n<li>The <a href=\"https://www.lua.org/manual/5.1/manual.html#5.6\"><em>Mathematical Functions (math)</em> library</a></li>\n<li>The <a href=\"#os-library\"><em>Operating System Facilities (os)</em> library</a></li>\n</ul>\n<p>In addition, the following external libraries are loaded and accessible to scripts:</p>\n<ul>\n<li>The <a href=\"#struct-library\"><em>struct</em> library</a></li>\n<li>The <a href=\"#cjson-library\"><em>cjson</em> library</a></li>\n<li>The <a href=\"#cmsgpack-library\"><em>cmsgpack</em> library</a></li>\n<li>The <a href=\"#bitop-library\"><em>bitop</em> library</a></li>\n</ul>\n<h3><a name=\"os-library\"></a> <em>os</em> library</h3>\n<ul>\n<li>Since version: 8.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p><em>os</em> provides a set of functions for dealing with date, time, and system commands.<br>More details can be found in the <a href=\"https://www.lua.org/manual/5.1/manual.html#5.8\">Operating System Facilities</a>.<br>Note that for sandbox security, currently only the following os functions is exposed:</p>\n<ul>\n<li><code>os.clock()</code></li>\n</ul>\n<h3><a name=\"struct-library\"></a> <em>struct</em> library</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p><em>struct</em> is a library for packing and unpacking C-like structures in Lua.<br>It provides the following functions:</p>\n<ul>\n<li><a href=\"#struct.pack\"><code>struct.pack()</code></a></li>\n<li><a href=\"#struct.unpack\"><code>struct.unpack()</code></a></li>\n<li><a href=\"#struct.size\"><code>struct.size()</code></a></li>\n</ul>\n<p>All of <em>struct</em>&#39;s functions expect their first argument to be a <a href=\"#struct-formats\">format string</a>.</p>\n<h4><a name=\"struct-formats\"></a> <em>struct</em> formats</h4>\n<p>The following are valid format strings for <em>struct</em>&#39;s functions:</p>\n<ul>\n<li><code>&gt;</code>: big endian</li>\n<li><code>&lt;</code>: little endian</li>\n<li><code>![num]</code>: alignment</li>\n<li><code>x</code>: padding</li>\n<li><code>b/B</code>: signed/unsigned byte</li>\n<li><code>h/H</code>: signed/unsigned short</li>\n<li><code>l/L</code>: signed/unsigned long</li>\n<li><code>T</code>: size_t</li>\n<li><code>i/In</code>: signed/unsigned integer with size <em>n</em> (defaults to the size of int)</li>\n<li><code>cn</code>: sequence of <em>n</em> chars (from/to a string); when packing, n == 0 means the<br>whole string; when unpacking, n == 0 means use the previously read number as<br>the string&#39;s length.</li>\n<li><code>s</code>: zero-terminated string</li>\n<li><code>f</code>: float</li>\n<li><code>d</code>: double</li>\n<li><code> </code> (space): ignored</li>\n</ul>\n<h4><a name=\"struct.pack\"></a> <code>struct.pack(x)</code></h4>\n<p>This function returns a struct-encoded string from values.<br>It accepts a <a href=\"#struct-formats\"><em>struct</em> format string</a> as its first argument, followed by the values that are to be encoded.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return struct.pack(&#39;HH&#39;, 1, 2)&quot; 0\n&quot;\\x01\\x00\\x02\\x00&quot;\n</code></pre>\n<h4><a name=\"struct.unpack\"></a> <code>struct.unpack(x)</code></h4>\n<p>This function returns the decoded values from a struct.<br>It accepts a <a href=\"#struct-formats\"><em>struct</em> format string</a> as its first argument, followed by encoded struct&#39;s string.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { struct.unpack(&#39;HH&#39;, ARGV[1]) }&quot; 0 &quot;\\x01\\x00\\x02\\x00&quot;\n1) (integer) 1\n2) (integer) 2\n3) (integer) 5\n</code></pre>\n<h4><a name=\"struct.size\"></a> <code>struct.size(x)</code></h4>\n<p>This function returns the size, in bytes, of a struct.<br>It accepts a <a href=\"#struct-formats\"><em>struct</em> format string</a> as its only argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return struct.size(&#39;HH&#39;)&quot; 0\n(integer) 4\n</code></pre>\n<h3><a name=\"cjson-library\"></a> <em>cjson</em> library</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <em>cjson</em> library provides fast <a href=\"https://json.org\">JSON</a> encoding and decoding from Lua.<br>It provides these functions.</p>\n<h4><a name=\"cjson.encode()\"></a> <code>cjson.encode(x)</code></h4>\n<p>This function returns a JSON-encoded string for the Lua data type provided as its argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return cjson.encode({ [&#39;foo&#39;] = &#39;bar&#39; })&quot; 0\n&quot;{\\&quot;foo\\&quot;:\\&quot;bar\\&quot;}&quot;\n</code></pre>\n<h4><a name=\"cjson.decode()\"></a> <code>cjson.decode(x)</code></h4>\n<p>This function returns a Lua data type from the JSON-encoded string provided as its argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return cjson.decode(ARGV[1])[&#39;foo&#39;]&quot; 0 &#39;{&quot;foo&quot;:&quot;bar&quot;}&#39;\n&quot;bar&quot;\n</code></pre>\n<h3><a name=\"cmsgpack-library\"></a> <em>cmsgpack</em> library</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <em>cmsgpack</em> library provides fast <a href=\"https://msgpack.org/index.html\">MessagePack</a> encoding and decoding from Lua.<br>It provides these functions.</p>\n<h4><a name=\"cmsgpack.pack()\"></a> <code>cmsgpack.pack(x)</code></h4>\n<p>This function returns the packed string encoding of the Lua data type it is given as an argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return cmsgpack.pack({&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;})&quot; 0\n&quot;\\x93\\xa3foo\\xa3bar\\xa3baz&quot;\n</code></pre>\n<h4><a name=\"cmsgpack.unpack()\"></a> <code>cmsgpack.unpack(x)</code></h4>\n<p>This function returns the unpacked values from decoding its input string argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return cmsgpack.unpack(ARGV[1])&quot; 0 &quot;\\x93\\xa3foo\\xa3bar\\xa3baz&quot;\n1) &quot;foo&quot;\n2) &quot;bar&quot;\n3) &quot;baz&quot;\n</code></pre>\n<h3><a name=\"bitop-library\"></a> <em>bit</em> library</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <em>bit</em> library provides bitwise operations on numbers.<br>Its documentation resides at <a href=\"https://bitop.luajit.org/api.html\">Lua BitOp documentation</a><br>It provides the following functions.</p>\n<h4><a name=\"bit.tobit()\"></a> <code>bit.tobit(x)</code></h4>\n<p>Normalizes a number to the numeric range for bit operations and returns it.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &#39;return bit.tobit(1)&#39; 0\n(integer) 1\n</code></pre>\n<h4><a name=\"bit.tohex()\"></a> <code>bit.tohex(x [,n])</code></h4>\n<p>Converts its first argument to a hex string. The number of hex digits is given by the absolute value of the optional second argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &#39;return bit.tohex(422342)&#39; 0\n&quot;000671c6&quot;\n</code></pre>\n<h4><a name=\"bit.bnot()\"></a> <code>bit.bnot(x)</code></h4>\n<p>Returns the bitwise <strong>not</strong> of its argument.</p>\n<h4><a name=\"bit.ops\"></a> <code>bit.bnot(x)</code> <code>bit.bor(x1 [,x2...])</code>, <code>bit.band(x1 [,x2...])</code> and <code>bit.bxor(x1 [,x2...])</code></h4>\n<p>Returns either the bitwise <strong>or</strong>, bitwise <strong>and</strong>, or bitwise <strong>xor</strong> of all of its arguments.<br>Note that more than two arguments are allowed.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &#39;return bit.bor(1,2,4,8,16,32,64,128)&#39; 0\n(integer) 255\n</code></pre>\n<h4><a name=\"bit.shifts\"></a> <code>bit.lshift(x, n)</code>, <code>bit.rshift(x, n)</code> and <code>bit.arshift(x, n)</code></h4>\n<p>Returns either the bitwise logical <strong>left-shift</strong>, bitwise logical <strong>right-shift</strong>, or bitwise <strong>arithmetic right-shift</strong> of its first argument by the number of bits given by the second argument.</p>\n<h4><a name=\"bit.ro\"></a> <code>bit.rol(x, n)</code> and <code>bit.ror(x, n)</code></h4>\n<p>Returns either the bitwise <strong>left rotation</strong>, or bitwise <strong>right rotation</strong> of its first argument by the number of bits given by the second argument.<br>Bits shifted out on one side are shifted back in on the other side.</p>\n<h4><a name=\"bit.bswap()\"></a> <code>bit.bswap(x)</code></h4>\n<p>Swaps the bytes of its argument and returns it.<br>This can be used to convert little-endian 32-bit numbers to big-endian 32-bit numbers and vice versa.</p>\n"
  },
  {
    "id": "functions-intro",
    "topicName": "Functions",
    "description": "Scripting with functions stored on the server\n",
    "htmlContent": "<p>Valkey Functions is an API for managing code to be executed on the server.<br>This feature is as a complement to <a href=\"eval-intro.md\">EVAL scripts</a>.</p>\n<h2>What&#39;s wrong with EVAL?</h2>\n<p>There&#39;s nothing wrong with <code>EVAL</code>, but there are some differences between EVAL scripts and Functions.<br>With the <a href=\"../commands/eval.md\"><code>EVAL</code></a> command, scripts are sent to the server for immediate execution.<br>The core use cases for <code>EVAL</code> scripts is executing part of your application logic inside Valkey, efficiently and atomically.<br>Such script can perform conditional updates across multiple keys, possibly combining several different data types.</p>\n<p>Using <code>EVAL</code> requires that the application sends the entire script for execution every time.<br>Because this results in network and script compilation overheads, Valkey provides an optimization in the form of the <a href=\"../commands/evalsha.md\"><code>EVALSHA</code></a> command.<br>By first calling <a href=\"../commands/script-load.md\"><code>SCRIPT LOAD</code></a> to obtain the script&#39;s SHA1, the application can invoke it repeatedly afterward with its digest alone.</p>\n<p>Valkey only caches the loaded scripts.<br>That means that the script cache can become lost at any time, such as after calling <code>SCRIPT FLUSH</code>, after restarting the server, or when failing over to a replica.<br>The application is responsible for reloading scripts during runtime if any are missing.<br>The underlying assumption is that scripts are a part of the application and not maintained by the Valkey server.</p>\n<p>This approach suits many light-weight scripting use cases, but introduces several difficulties once an application becomes complex and relies more heavily on scripting, namely:</p>\n<ol>\n<li>All client application instances must maintain a copy of all scripts. That means having some mechanism that applies script updates to all of the application&#39;s instances.</li>\n<li>Calling cached scripts within the context of a <a href=\"transactions.md\">transaction</a> increases the probability of the transaction failing because of a missing script. Being more likely to fail makes using cached scripts as building blocks of workflows less attractive.</li>\n<li>SHA1 digests are not readable for humans, making debugging the system hard (e.g. in a <a href=\"../commands/monitor.md\"><code>MONITOR</code></a> session).</li>\n<li>When used naively, <code>EVAL</code> promotes an anti-pattern in which the client application renders verbatim scripts instead of responsibly using the <a href=\"lua-api.md#runtime-globals\"><code>KEYS</code> and <code>ARGV</code> Lua APIs</a>.</li>\n<li>Because they are ephemeral, a script can&#39;t call another script. This makes sharing and reusing code between scripts nearly impossible, short of client-side preprocessing.</li>\n</ol>\n<p>To address these needs while avoiding breaking changes to already-established and well-liked ephemeral scripts, functions were introduced in version 7.0.</p>\n<h2>What are Valkey Functions?</h2>\n<p>Functions provide the same core functionality as scripts but are first-class artifacts of the database.<br>Valkey manages functions as an integral part of the database and ensures their availability via data persistence and replication.<br>Because functions are part of the database and therefore declared before use, applications aren&#39;t required to load them during runtime nor risk aborted transactions.<br>An application that uses functions depends only on their APIs rather than on the embedded script logic in the database.</p>\n<p>Whereas ephemeral scripts are considered a part of the application&#39;s domain, functions extend the database server itself with user-provided logic.<br>They can be loaded at startup and be used repeatedly by various applications and clients.<br>Functions are also persisted to the AOF file and replicated from primary to replicas, so they are as durable as the data itself.<br>When Valkey is used as an ephemeral cache, additional mechanisms (described below) are required to make functions more durable.</p>\n<p>Functions also simplify development by enabling code sharing.<br>Every function has a user-defined name and belongs to a library, and a library can consist of multiple functions.<br>The library&#39;s contents are immutable, and selective updates of its functions aren&#39;t allowed.<br>Instead, libraries are updated as a whole with all of their functions together in one operation.<br>This allows calling functions from other functions within the same library, or sharing code between functions by using a common code in library-internal methods, that can also take language native arguments.</p>\n<p>Like all other operations in Valkey, the execution of a function is atomic.<br>A function&#39;s execution blocks all server activities during its entire time, similarly to the semantics of <a href=\"transactions.md\">transactions</a>.<br>These semantics mean that all of the script&#39;s effects either have yet to happen or had already happened.<br>The blocking semantics of an executed function apply to all connected clients at all times.<br>Because running a function blocks the Valkey server, functions are meant to finish executing quickly, so you should avoid using long-running functions.</p>\n<p>Functions are written in <a href=\"lua-api.md\">Lua 5.1</a>.<br>Valkey functions can use all of Lua&#39;s available capabilities to ephemeral scripts,<br>with the only exception being the <a href=\"ldb.md\">Valkey Lua scripts debugger</a>.</p>\n<h2>Loading libraries and functions</h2>\n<p>Let&#39;s explore Valkey Functions via some tangible examples and Lua snippets.</p>\n<p>At this point, if you&#39;re unfamiliar with Lua in general and specifically in Valkey, you may benefit from reviewing some of the examples in <a href=\"eval-intro.md\">Introduction to Eval Scripts</a> and <a href=\"lua-api.md\">Lua API</a> pages for a better grasp of the language.</p>\n<p>Every Valkey function belongs to a library.<br>Loading a library to the database is done with the <a href=\"../commands/function-load.md\"><code>FUNCTION LOAD</code></a> command.<br>The library source code must start with a Shebang line that provides metadata about the library, like the language (always &quot;lua&quot;) and the library name.<br>The Shebang format is:</p>\n<pre><code>#!lua name=&lt;library name&gt;\n</code></pre>\n<p>Let&#39;s try loading an empty library:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LOAD &quot;#!lua name=mylib\\n&quot;\n(error) ERR No functions registered\n</code></pre>\n<p>The error is expected, as there are no functions in the loaded library. Every library needs to include at least one registered function to load successfully.<br>A registered function is named and acts as an entry point to the library.<br>When the target execution engine handles the <code>FUNCTION LOAD</code> command, it registers the library&#39;s functions.</p>\n<p>The Lua engine compiles and evaluates the library source code when loaded, and expects functions to be registered by calling the <code>server.register_function()</code> API.</p>\n<p>The following snippet demonstrates a simple library registering a single function named <em>knockknock</em>, returning a string reply:</p>\n<pre><code class=\"language-lua\">#!lua name=mylib\nserver.register_function(\n  &#39;knockknock&#39;,\n  function() return &#39;Who\\&#39;s there?&#39; end\n)\n</code></pre>\n<p>In the example above, we provide two arguments about the function to Lua&#39;s <code>server.register_function()</code> API: its registered name and a callback.</p>\n<p>We can load our library and use <code>FCALL</code> to call the registered function:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LOAD &quot;#!lua name=mylib\\nserver.register_function(&#39;knockknock&#39;, function() return &#39;Who\\\\&#39;s there?&#39; end)&quot;\nmylib\n127.0.0.1:6379&gt; FCALL knockknock 0\n&quot;Who&#39;s there?&quot;\n</code></pre>\n<p>Notice that the <code>FUNCTION LOAD</code> command returns the name of the loaded library, this name can later be used <code>FUNCTION LIST</code> and <code>FUNCTION DELETE</code>.</p>\n<p>We&#39;ve provided <a href=\"../commands/fcall.md\"><code>FCALL</code></a> with two arguments: the function&#39;s registered name and the numeric value <code>0</code>. This numeric value indicates the number of key names that follow it (the same way <code>EVAL</code> and <code>EVALSHA</code> works).</p>\n<p>We&#39;ll explain immediately how key names and additional arguments are available to the function. As this simple example doesn&#39;t involve keys, we simply use 0 for now.</p>\n<h2>Input keys and regular arguments</h2>\n<p>Before we move to the following example, it is vital to understand the distinction Valkey makes between arguments that are names of keys and those that aren&#39;t.</p>\n<p>While key names in Valkey are just strings, unlike any other string values, these represent keys in the database.<br>The name of a key is a fundamental concept in Valkey and is the basis for operating the Valkey Cluster.</p>\n<p><strong>Important:</strong><br>To ensure the correct execution of Valkey Functions, both in standalone and clustered deployments, all names of keys that a function accesses must be explicitly provided as input key arguments.</p>\n<p>Any input to the function that isn&#39;t the name of a key is a regular input argument.</p>\n<p>Now, let&#39;s pretend that our application stores some of its data in Hashes.<br>We want an <a href=\"../commands/hset.md\"><code>HSET</code></a>-like way to set and update fields in said Hashes and store the last modification time in a new field named <code>_last_modified_</code>.<br>We can implement a function to do all that.</p>\n<p>Our function will call <a href=\"../commands/time.md\"><code>TIME</code></a> to get the server&#39;s clock reading and update the target Hash with the new fields&#39; values and the modification&#39;s timestamp.<br>The function we&#39;ll implement accepts the following input arguments: the Hash&#39;s key name and the field-value pairs to update.</p>\n<p>The Lua API for Valkey Functions makes these inputs accessible as the first and second arguments to the function&#39;s callback.<br>The callback&#39;s first argument is a Lua table populated with all key names inputs to the function.<br>Similarly, the callback&#39;s second argument consists of all regular arguments.</p>\n<p>The following is a possible implementation for our function and its library registration:</p>\n<pre><code class=\"language-lua\">#!lua name=mylib\n\nlocal function my_hset(keys, args)\n  local hash = keys[1]\n  local time = server.call(&#39;TIME&#39;)[1]\n  return server.call(&#39;HSET&#39;, hash, &#39;_last_modified_&#39;, time, unpack(args))\nend\n\nserver.register_function(&#39;my_hset&#39;, my_hset)\n</code></pre>\n<p>If we create a new file named <em>mylib.lua</em> that consists of the library&#39;s definition, we can load it like so (without stripping the source code of helpful whitespaces):</p>\n<pre><code class=\"language-bash\">$ cat mylib.lua | valkey-cli -x FUNCTION LOAD REPLACE\n</code></pre>\n<p>We&#39;ve added the <code>REPLACE</code> modifier to the call to <code>FUNCTION LOAD</code> to tell Valkey that we want to overwrite the existing library definition.<br>Otherwise, we would have gotten an error from Valkey complaining that the library already exists.</p>\n<p>Now that the library&#39;s updated code is loaded to Valkey, we can proceed and call our function:</p>\n<pre><code>127.0.0.1:6379&gt; FCALL my_hset 1 myhash myfield &quot;some value&quot; another_field &quot;another value&quot;\n(integer) 3\n127.0.0.1:6379&gt; HGETALL myhash\n1) &quot;_last_modified_&quot;\n2) &quot;1640772721&quot;\n3) &quot;myfield&quot;\n4) &quot;some value&quot;\n5) &quot;another_field&quot;\n6) &quot;another value&quot;\n</code></pre>\n<p>In this case, we had invoked <code>FCALL</code> with <em>1</em> as the number of key name arguments.<br>That means that the function&#39;s first input argument is a name of a key (and is therefore included in the callback&#39;s <code>keys</code> table).<br>After that first argument, all following input arguments are considered regular arguments and constitute the <code>args</code> table passed to the callback as its second argument.</p>\n<h2>Expanding the library</h2>\n<p>We can add more functions to our library to benefit our application.<br>The additional metadata field we&#39;ve added to the Hash shouldn&#39;t be included in responses when accessing the Hash&#39;s data.<br>On the other hand, we do want to provide the means to obtain the modification timestamp for a given Hash key.</p>\n<p>We&#39;ll add two new functions to our library to accomplish these objectives:</p>\n<ol>\n<li>The <code>my_hgetall</code> Valkey Function will return all fields and their respective values from a given Hash key name, excluding the metadata (i.e., the <code>_last_modified_</code> field).</li>\n<li>The <code>my_hlastmodified</code> Valkey Function will return the modification timestamp for a given Hash key name.</li>\n</ol>\n<p>The library&#39;s source code could look something like the following:</p>\n<pre><code class=\"language-lua\">#!lua name=mylib\n\nlocal function my_hset(keys, args)\n  local hash = keys[1]\n  local time = server.call(&#39;TIME&#39;)[1]\n  return server.call(&#39;HSET&#39;, hash, &#39;_last_modified_&#39;, time, unpack(args))\nend\n\nlocal function my_hgetall(keys, args)\n  server.setresp(3)\n  local hash = keys[1]\n  local res = server.call(&#39;HGETALL&#39;, hash)\n  res[&#39;map&#39;][&#39;_last_modified_&#39;] = nil\n  return res\nend\n\nlocal function my_hlastmodified(keys, args)\n  local hash = keys[1]\n  return server.call(&#39;HGET&#39;, hash, &#39;_last_modified_&#39;)\nend\n\nserver.register_function(&#39;my_hset&#39;, my_hset)\nserver.register_function(&#39;my_hgetall&#39;, my_hgetall)\nserver.register_function(&#39;my_hlastmodified&#39;, my_hlastmodified)\n</code></pre>\n<p>While all of the above should be straightforward, note that the <code>my_hgetall</code> also calls <a href=\"lua-api.md#server.setresp\"><code>server.setresp(3)</code></a>.<br>That means that the function expects <a href=\"protocol.md\">RESP3</a> replies after calling <code>server.call()</code>, which, unlike the default RESP2 protocol, returns the replies as maps (associative arrays).<br>Doing so allows the function to delete (or set to <code>nil</code> as is the case with Lua tables) specific fields from the reply, and in our case, the <code>_last_modified_</code> field.</p>\n<p>Assuming you&#39;ve saved the library&#39;s implementation in the <em>mylib.lua</em> file, you can replace it with:</p>\n<pre><code class=\"language-bash\">$ cat mylib.lua | valkey-cli -x FUNCTION LOAD REPLACE\n</code></pre>\n<p>Once loaded, you can call the library&#39;s functions with <code>FCALL</code>:</p>\n<pre><code>127.0.0.1:6379&gt; FCALL my_hgetall 1 myhash\n1) &quot;myfield&quot;\n2) &quot;some value&quot;\n3) &quot;another_field&quot;\n4) &quot;another value&quot;\n127.0.0.1:6379&gt; FCALL my_hlastmodified 1 myhash\n&quot;1640772721&quot;\n</code></pre>\n<p>You can also get the library&#39;s details with the <code>FUNCTION LIST</code> command:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LIST\n1) 1) &quot;library_name&quot;\n   2) &quot;mylib&quot;\n   3) &quot;engine&quot;\n   4) &quot;LUA&quot;\n   5) &quot;functions&quot;\n   6) 1) 1) &quot;name&quot;\n         2) &quot;my_hset&quot;\n         3) &quot;description&quot;\n         4) (nil)\n         5) &quot;flags&quot;\n         6) (empty array)\n      2) 1) &quot;name&quot;\n         2) &quot;my_hgetall&quot;\n         3) &quot;description&quot;\n         4) (nil)\n         5) &quot;flags&quot;\n         6) (empty array)\n      3) 1) &quot;name&quot;\n         2) &quot;my_hlastmodified&quot;\n         3) &quot;description&quot;\n         4) (nil)\n         5) &quot;flags&quot;\n         6) (empty array)\n</code></pre>\n<p>You can see that it is easy to update our library with new capabilities.</p>\n<h2>Reusing code in the library</h2>\n<p>On top of bundling functions together into database-managed software artifacts, libraries also facilitate code sharing.<br>We can add to our library an error handling helper function called from other functions.<br>The helper function <code>check_keys()</code> verifies that the input <em>keys</em> table has a single key.<br>Upon success it returns <code>nil</code>, otherwise it returns an <a href=\"lua-api.md#server.error_reply\">error reply</a>.</p>\n<p>The updated library&#39;s source code would be:</p>\n<pre><code class=\"language-lua\">#!lua name=mylib\n\nlocal function check_keys(keys)\n  local error = nil\n  local nkeys = table.getn(keys)\n  if nkeys == 0 then\n    error = &#39;Hash key name not provided&#39;\n  elseif nkeys &gt; 1 then\n    error = &#39;Only one key name is allowed&#39;\n  end\n\n  if error ~= nil then\n    server.log(server.LOG_WARNING, error);\n    return server.error_reply(error)\n  end\n  return nil\nend\n\nlocal function my_hset(keys, args)\n  local error = check_keys(keys)\n  if error ~= nil then\n    return error\n  end\n\n  local hash = keys[1]\n  local time = server.call(&#39;TIME&#39;)[1]\n  return server.call(&#39;HSET&#39;, hash, &#39;_last_modified_&#39;, time, unpack(args))\nend\n\nlocal function my_hgetall(keys, args)\n  local error = check_keys(keys)\n  if error ~= nil then\n    return error\n  end\n\n  server.setresp(3)\n  local hash = keys[1]\n  local res = server.call(&#39;HGETALL&#39;, hash)\n  res[&#39;map&#39;][&#39;_last_modified_&#39;] = nil\n  return res\nend\n\nlocal function my_hlastmodified(keys, args)\n  local error = check_keys(keys)\n  if error ~= nil then\n    return error\n  end\n\n  local hash = keys[1]\n  return server.call(&#39;HGET&#39;, keys[1], &#39;_last_modified_&#39;)\nend\n\nserver.register_function(&#39;my_hset&#39;, my_hset)\nserver.register_function(&#39;my_hgetall&#39;, my_hgetall)\nserver.register_function(&#39;my_hlastmodified&#39;, my_hlastmodified)\n</code></pre>\n<p>After you&#39;ve replaced the library in Valkey with the above, you can immediately try out the new error handling mechanism:</p>\n<pre><code>127.0.0.1:6379&gt; FCALL my_hset 0 myhash nope nope\n(error) Hash key name not provided\n127.0.0.1:6379&gt; FCALL my_hgetall 2 myhash anotherone\n(error) Only one key name is allowed\n</code></pre>\n<p>And your Valkey log file should have lines in it that are similar to:</p>\n<pre><code>...\n20075:M 1 Jan 2022 16:53:57.688 # Hash key name not provided\n20075:M 1 Jan 2022 16:54:01.309 # Only one key name is allowed\n</code></pre>\n<h2>Functions in cluster</h2>\n<p>As noted above, Valkey automatically handles propagation of loaded functions to replicas.<br>In a <a href=\"cluster-tutorial.md\">cluster</a>, it is necessary to load functions to all primaries.</p>\n<p>As one of the goals of functions is to live separately from the client application, this should not be part of the Valkey client library responsibilities. Instead, <code>valkey-cli --cluster-only-primaries --cluster call host:port FUNCTION LOAD ...</code> can be used to execute the load command on all primary nodes.</p>\n<p>Also, note that <code>valkey-cli --cluster add-node</code> automatically takes care to propagate the loaded functions from one of the existing nodes to the new node.</p>\n<h2>Functions and ephemeral Valkey instances</h2>\n<p>In some cases there may be a need to start a fresh Valkey server with a set of functions pre-loaded. Common reasons for that could be:</p>\n<ul>\n<li>Starting Valkey in a new environment</li>\n<li>Re-starting an ephemeral (cache-only) Valkey, that uses functions</li>\n</ul>\n<p>In such cases, we need to make sure that the pre-loaded functions are available before Valkey accepts inbound user connections and commands.</p>\n<p>To do that, it is possible to use <code>valkey-cli --functions-rdb</code> to extract the functions from an existing server. This generates an RDB file that can be loaded by Valkey at startup.</p>\n<h2>Function flags</h2>\n<p>Valkey needs to have some information about how a function is going to behave when executed, in order to properly enforce resource usage policies and maintain data consistency.</p>\n<p>For example, Valkey needs to know that a certain function is read-only before permitting it to execute using <code>FCALL_RO</code> on a read-only replica.</p>\n<p>By default, Valkey assumes that all functions may perform arbitrary read or write operations. Function Flags make it possible to declare more specific function behavior at the time of registration. Let&#39;s see how this works.</p>\n<p>In our previous example, we defined two functions that only read data. We can try executing them using <code>FCALL_RO</code> against a read-only replica.</p>\n<pre><code>127.0.0.1:6379&gt; FCALL_RO my_hgetall 1 myhash\n(error) ERR Can not execute a function with write flag using fcall_ro.\n</code></pre>\n<p>Valkey returns this error because a function can, in theory, perform both read and write operations on the database.<br>As a safeguard and by default, Valkey assumes that the function does both, so it blocks its execution.<br>The server will reply with this error in the following cases:</p>\n<ol>\n<li>Executing a function with <code>FCALL</code> against a read-only replica.</li>\n<li>Using <code>FCALL_RO</code> to execute a function.</li>\n<li>A disk error was detected (Valkey is unable to persist so it rejects writes).</li>\n</ol>\n<p>In these cases, you can add the <code>no-writes</code> flag to the function&#39;s registration, disable the safeguard and allow them to run.<br>To register a function with flags use the <a href=\"lua-api.md#server.register_function_named_args\">named arguments</a> variant of <code>server.register_function</code>.</p>\n<p>The updated registration code snippet from the library looks like this:</p>\n<pre><code class=\"language-lua\">server.register_function(&#39;my_hset&#39;, my_hset)\nserver.register_function{\n  function_name=&#39;my_hgetall&#39;,\n  callback=my_hgetall,\n  flags={ &#39;no-writes&#39; }\n}\nserver.register_function{\n  function_name=&#39;my_hlastmodified&#39;,\n  callback=my_hlastmodified,\n  flags={ &#39;no-writes&#39; }\n}\n</code></pre>\n<p>Once we&#39;ve replaced the library, Valkey allows running both <code>my_hgetall</code> and <code>my_hlastmodified</code> with <code>FCALL_RO</code> against a read-only replica:</p>\n<pre><code>127.0.0.1:6379&gt; FCALL_RO my_hgetall 1 myhash\n1) &quot;myfield&quot;\n2) &quot;some value&quot;\n3) &quot;another_field&quot;\n4) &quot;another value&quot;\n127.0.0.1:6379&gt; FCALL_RO my_hlastmodified 1 myhash\n&quot;1640772721&quot;\n</code></pre>\n<p>For the complete documentation flags, please refer to <a href=\"lua-api.md#script_flags\">Script flags</a>.</p>\n"
  },
  {
    "id": "programmability",
    "topicName": "Programmability",
    "description": "Extending Valkey with Lua and Valkey Functions\n",
    "htmlContent": "<p>Valkey provides a programming interface that lets you execute custom scripts on the server itself.<br>You can use <a href=\"functions-intro.md\">Functions</a> to create, manage and run scripts.<br>You can also use <a href=\"eval-intro.md\">Lua scripting with the EVAL command</a> to program the server.</p>\n<h2>Background</h2>\n<p>Valkey is a <em>&quot;domain-specific language for abstract data types&quot;</em>.<br>The language that Valkey speaks consists of its <a href=\"../commands/\">commands</a>.<br>Most the commands specialize at manipulating core <a href=\"data-types.md\">data types</a> in different ways.<br>In many cases, these commands provide all the functionality that a developer requires for managing application data in Valkey.</p>\n<p>The term <strong>programmability</strong> in Valkey means having the ability to execute arbitrary user-defined logic by the server.<br>We refer to such pieces of logic as <strong>scripts</strong>.<br>In our case, scripts enable processing the data where it lives, a.k.a <em>data locality</em>.<br>Furthermore, the responsible embedding of programmatic workflows in the Valkey server can help in reducing network traffic and improving overall performance.<br>Developers can use this capability for implementing robust, application-specific APIs.<br>Such APIs can encapsulate business logic and maintain a data model across multiple keys and different data structures.</p>\n<p>User scripts are executed in Valkey by an embedded, sandboxed scripting engine.<br>Presently, Valkey supports a single scripting engine, the <a href=\"https://www.lua.org/\">Lua 5.1</a> interpreter.</p>\n<p>Please refer to the <a href=\"lua-api.md\">Valkey Lua API Reference</a> page for complete documentation.</p>\n<h2>Running scripts</h2>\n<p>Valkey provides two means for running scripts.</p>\n<p>Firstly, the <code>EVAL</code> command enables running server-side scripts.<br>Eval scripts provide a quick and straightforward way to have Valkey run your scripts ad-hoc.<br>However, using them means that the scripted logic is a part of your application (not an extension of the Valkey server).<br>Every applicative instance that runs a script must have the script&#39;s source code readily available for loading at any time.<br>That is because scripts are only cached by the server and are volatile.<br>As your application grows, this approach can become harder to develop and maintain.</p>\n<p>Secondly, added in v7.0, Valkey Functions are essentially scripts that are first-class database elements.<br>As such, functions decouple scripting from application logic and enable independent development, testing, and deployment of scripts.<br>To use functions, they need to be loaded first, and then they are available for use by all connected clients.<br>In this case, loading a function to the database becomes an administrative deployment task (such as loading a Valkey module, for example), which separates the script from the application.</p>\n<p>Please refer to the following pages for more information:</p>\n<ul>\n<li><a href=\"eval-intro.md\">Valkey Eval Scripts</a></li>\n<li><a href=\"functions-intro.md\">Valkey Functions</a></li>\n</ul>\n<p>When running a script or a function, Valkey guarantees its atomic execution.<br>The script&#39;s execution blocks all server activities during its entire time, similarly to the semantics of <a href=\"transactions.md\">transactions</a>.<br>These semantics mean that all of the script&#39;s effects either have yet to happen or had already happened.<br>The blocking semantics of an executed script apply to all connected clients at all times.</p>\n<p>Note that the potential downside of this blocking approach is that executing slow scripts is not a good idea.<br>It is not hard to create fast scripts because scripting&#39;s overhead is very low.<br>However, if you intend to use a slow script in your application, be aware that all other clients are blocked and can&#39;t execute any command while it is running.</p>\n<h2>Read-only scripts</h2>\n<p>A read-only script is a script that only executes commands that don&#39;t modify any keys within Valkey.<br>Read-only scripts can be executed either by adding the <code>no-writes</code> <a href=\"lua-api.md#script_flags\">flag</a> to the script or by executing the script with one of the read-only script command variants: <code>EVAL_RO</code>, <code>EVALSHA_RO</code>, or <code>FCALL_RO</code>.<br>They have the following properties:</p>\n<ul>\n<li>They can always be executed on replicas.</li>\n<li>They can always be killed by the <code>SCRIPT KILL</code> command. </li>\n<li>They never fail with OOM error when Valkey is over the memory limit.</li>\n<li>They are not blocked during write pauses, such as those that occur during coordinated failovers.</li>\n<li>They cannot execute any command that may modify the data set.</li>\n<li>Currently <code>PUBLISH</code>, <code>SPUBLISH</code> and <code>PFCOUNT</code> are also considered write commands in scripts, because they could attempt to propagate commands to replicas and AOF file.</li>\n</ul>\n<p>In addition to the benefits provided by all read-only scripts, the read-only script commands have the following advantages:</p>\n<ul>\n<li>They can be used to configure an ACL user to only be able to execute read-only scripts.</li>\n<li>Many clients also better support routing the read-only script commands to replicas for applications that want to use replicas for read scaling.</li>\n</ul>\n<h4>Read-only script history</h4>\n<p>Read-only scripts and read-only script commands were introduced in Redis OSS 7.0</p>\n<ul>\n<li>Before Redis OSS 7.0.1 <code>PUBLISH</code>, <code>SPUBLISH</code> and <code>PFCOUNT</code> were not considered write commands in scripts</li>\n<li>Before Redis OSS 7.0.1 the <code>no-writes</code> <a href=\"lua-api.md#script_flags\">flag</a> did not imply <code>allow-oom</code></li>\n<li>Before Redis OSS 7.0.1 the <code>no-writes</code> flag did not permit the script to run during write pauses.</li>\n</ul>\n<p>The recommended approach is to use the standard scripting commands with the <code>no-writes</code> flag unless you need one of the previously mentioned features.</p>\n<h2>Sandboxed script context</h2>\n<p>Valkey places the engine that executes user scripts inside a sandbox.<br>The sandbox attempts to prevent accidental misuse and reduce potential threats from the server&#39;s environment.</p>\n<p>Scripts should never try to access the Valkey server&#39;s underlying host systems, such as the file system, network, or attempt to perform any other system call other than those supported by the API.</p>\n<p>Scripts should operate solely on data stored in Valkey and data provided as arguments to their execution.</p>\n<h2>Maximum execution time</h2>\n<p>Scripts are subject to a maximum execution time (set by default to five seconds).<br>This default timeout is enormous since a script usually runs in less than a millisecond.<br>The limit is in place to handle accidental infinite loops created during development.</p>\n<p>It is possible to modify the maximum time a script can be executed with millisecond precision,<br>either via <code>valkey.conf</code> or by using the <code>CONFIG SET</code> command.<br>The configuration parameter affecting max execution time is called <code>busy-reply-threshold</code>.</p>\n<p>When a script reaches the timeout threshold, it isn&#39;t terminated by Valkey automatically.<br>Doing so would violate the contract between Valkey and the scripting engine that ensures that scripts are atomic.<br>Interrupting the execution of a script has the potential of leaving the dataset with half-written changes.</p>\n<p>Therefore, when a script executes longer than the configured timeout, the following happens:</p>\n<ul>\n<li>Valkey logs that a script is running for too long.</li>\n<li>It starts accepting commands again from other clients but will reply with a BUSY error to all the clients sending normal commands. The only commands allowed in this state are <code>SCRIPT KILL</code>, <code>FUNCTION KILL</code>, and <code>SHUTDOWN NOSAVE</code>.</li>\n<li>It is possible to terminate a script that only executes read-only commands using the <code>SCRIPT KILL</code> and <code>FUNCTION KILL</code> commands. These commands do not violate the scripting semantic as no data was written to the dataset by the script yet.</li>\n<li>If the script had already performed even a single write operation, the only command allowed is <code>SHUTDOWN NOSAVE</code> that stops the server without saving the current data set on disk (basically, the server is aborted).</li>\n</ul>\n"
  },
  {
    "id": "replication",
    "topicName": "Replication",
    "description": "How Valkey supports high availability and failover with replication",
    "htmlContent": "<p>At the base of Valkey replication (excluding the high availability features provided as an additional layer by Valkey Cluster or Valkey Sentinel) there is a <em>leader follower</em> (primary-replica) replication that is simple to use and configure. It allows replica Valkey instances to be exact copies of primary instances. The replica will automatically reconnect to the primary every time the link breaks, and will attempt to be an exact copy of it <em>regardless</em> of what happens to the primary.</p>\n<p>This system works using three main mechanisms:</p>\n<ol>\n<li>When a primary and a replica instances are well-connected, the primary keeps the replica updated by sending a stream of commands to the replica to replicate the effects on the dataset happening in the primary side due to: client writes, keys expired or evicted, any other action changing the primary dataset.</li>\n<li>When the link between the primary and the replica breaks, for network issues or because a timeout is sensed in the primary or the replica, the replica reconnects and attempts to proceed with a partial resynchronization: it means that it will try to just obtain the part of the stream of commands it missed during the disconnection.</li>\n<li>When a partial resynchronization is not possible, the replica will ask for a full resynchronization. This will involve a more complex process in which the primary needs to create a snapshot of all its data, send it to the replica, and then continue sending the stream of commands as the dataset changes.</li>\n</ol>\n<p>Valkey uses by default asynchronous replication, which being low latency and<br>high performance, is the natural replication mode for the vast majority of Valkey<br>use cases. However, Valkey replicas asynchronously acknowledge the amount of data<br>they received periodically with the primary. So the primary does not wait every time<br>for a command to be processed by the replicas, however it knows, if needed, what<br>replica already processed what command. This allows having optional synchronous replication.</p>\n<p>Synchronous replication of certain data can be requested by the clients using<br>the <code>WAIT</code> command. However <code>WAIT</code> is only able to ensure there are the<br>specified number of acknowledged copies in the other Valkey instances, it does not<br>turn a set of Valkey instances into a CP system with strong consistency: acknowledged<br>writes can still be lost during a failover, depending on the exact configuration<br>of the Valkey persistence. However with <code>WAIT</code> the probability of losing a write<br>after a failure event is greatly reduced to certain hard to trigger failure<br>modes.</p>\n<p>You can check the Valkey Sentinel or Valkey Cluster documentation for more information<br>about high availability and failover. The rest of this document mainly describes the basic characteristics of Valkey basic replication.</p>\n<h3>Important facts about Valkey replication</h3>\n<ul>\n<li>Valkey uses asynchronous replication, with asynchronous replica-to-primary acknowledges of the amount of data processed.</li>\n<li>A primary can have multiple replicas.</li>\n<li>Replicas are able to accept connections from other replicas. Aside from connecting a number of replicas to the same primary, replicas can also be connected to other replicas in a cascading-like structure. All the sub-replicas will receive exactly the same replication stream from the primary.</li>\n<li>Valkey replication is non-blocking on the primary side. This means that the primary will continue to handle queries when one or more replicas perform the initial synchronization or a partial resynchronization.</li>\n<li>Replication is also largely non-blocking on the replica side. While the replica is performing the initial synchronization, it can handle queries using the old version of the dataset, assuming you configured Valkey to do so in valkey.conf.  Otherwise, you can configure Valkey replicas to return an error to clients if the replication stream is down. However, after the initial sync, the old dataset must be deleted and the new one must be loaded. The replica will block incoming connections during this brief window (that can be as long as many seconds for very large datasets). You can configure Valkey so that the deletion of the old data set happens in a different thread, however loading the new initial dataset will still happen in the main thread and block the replica.</li>\n<li>Replication can be used both for scalability, to have multiple replicas for read-only queries (for example, slow O(N) operations can be offloaded to replicas), or simply for improving data safety and high availability.</li>\n<li>You can use replication to avoid the cost of having the primary writing the full dataset to disk: a typical technique involves configuring your primary&#39;s <code>valkey.conf</code> to avoid persisting to disk at all, then connect a replica configured to save from time to time, or with AOF enabled. However, this setup must be handled with care, since a restarting primary will start with an empty dataset: if the replica tries to sync with it, the replica will be emptied as well.</li>\n</ul>\n<h2>Safety of replication when primary has persistence turned off</h2>\n<p>In setups where Valkey replication is used, it is strongly advised to have<br>persistence turned on in the primary and in the replicas. When this is not possible,<br>for example because of latency concerns due to very slow disks, instances should<br>be configured to <strong>avoid restarting automatically</strong> after a reboot.</p>\n<p>To better understand why primaries with persistence turned off configured to<br>auto restart are dangerous, check the following failure mode where data<br>is wiped from the primary and all its replicas:</p>\n<ol>\n<li>We have a setup with node A acting as primary, with persistence turned down, and nodes B and C replicating from node A.</li>\n<li>Node A crashes, however it has some auto-restart system, that restarts the process. However since persistence is turned off, the node restarts with an empty data set.</li>\n<li>Nodes B and C will replicate from node A, which is empty, so they&#39;ll effectively destroy their copy of the data.</li>\n</ol>\n<p>When Valkey Sentinel is used for high availability, also turning off persistence<br>on the primary, together with auto restart of the process, is dangerous. For example, the primary can restart fast enough for Sentinel to not detect a failure, so that the failure mode described above happens.</p>\n<p>Every time data safety is important, and replication is used with primary configured without persistence, auto restart of instances should be disabled.</p>\n<h2>How Valkey replication works</h2>\n<p>Every Valkey primary has a replication ID: it is a large pseudo random string<br>that marks a given story of the dataset. Each primary also takes an offset that<br>increments for every byte of replication stream that it is produced to be<br>sent to replicas, to update the state of the replicas with the new changes<br>modifying the dataset. The replication offset is incremented even if no replica<br>is actually connected, so basically every given pair of:</p>\n<pre><code>Replication ID, offset\n</code></pre>\n<p>Identifies an exact version of the dataset of a primary.</p>\n<p>When replicas connect to primaries, they use the <code>PSYNC</code> command to send<br>their old primary replication ID and the offsets they processed so far. This way<br>the primary can send just the incremental part needed. However if there is not<br>enough <em>backlog</em> in the primary buffers, or if the replica is referring to a<br>history (replication ID) which is no longer known, then a full resynchronization<br>happens: in this case the replica will get a full copy of the dataset, from scratch.</p>\n<p>This is how a full synchronization works in more details:</p>\n<p>The primary starts a background saving process to produce an RDB file. At the same time it starts to buffer all new write commands received from the clients. When the background saving is complete, the primary transfers the database file to the replica, which saves it on disk, and then loads it into memory. The primary will then send all buffered commands to the replica. This is done as a stream of commands and is in the same format of the Valkey protocol itself.</p>\n<p>You can try it yourself via telnet. Connect to the Valkey port while the<br>server is doing some work and issue the <code>SYNC</code> command. You&#39;ll see a bulk<br>transfer and then every command received by the primary will be re-issued<br>in the telnet session. Actually <code>SYNC</code> is an old protocol no longer used by<br>newer Valkey instances, but is still there for backward compatibility: it does<br>not allow partial resynchronizations, so now <code>PSYNC</code> is used instead.</p>\n<p>As already said, replicas are able to automatically reconnect when the primary-replica link goes down for some reason. If the primary receives multiple concurrent replica synchronization requests, it performs a single background save in to serve all of them.</p>\n<h2>Replication ID explained</h2>\n<p>In the previous section we said that if two instances have the same replication<br>ID and replication offset, they have exactly the same data. However it is useful<br>to understand what exactly is the replication ID, and why instances have actually<br>two replication IDs: the main ID and the secondary ID.</p>\n<p>A replication ID basically marks a given <em>history</em> of the data set. Every time<br>an instance restarts from scratch as a primary, or a replica is promoted to primary,<br>a new replication ID is generated for this instance. The replicas connected to<br>a primary will inherit its replication ID after the handshake. So two instances<br>with the same ID are related by the fact that they hold the same data, but<br>potentially at a different time. It is the offset that works as a logical time<br>to understand, for a given history (replication ID), who holds the most updated<br>data set.</p>\n<p>For instance, if two instances A and B have the same replication ID, but one<br>with offset 1000 and one with offset 1023, it means that the first lacks certain<br>commands applied to the data set. It also means that A, by applying just a few<br>commands, may reach exactly the same state of B.</p>\n<p>The reason why Valkey instances have two replication IDs is because of replicas<br>that are promoted to primaries. After a failover, the promoted replica requires<br>to still remember what was its past replication ID, because such replication ID<br>was the one of the former primary. In this way, when other replicas will sync<br>with the new primary, they will try to perform a partial resynchronization using the<br>old primary replication ID. This will work as expected, because when the replica<br>is promoted to primary, it sets its secondary ID to its main ID, remembering what<br>was the offset when this ID switch happened. Later it will select a new random<br>replication ID, because a new history begins. When handling the new replicas<br>connecting, the primary will match their IDs and offsets both with the current<br>ID and the secondary ID (up to a given offset, for safety). In short this means<br>that after a failover, replicas connecting to the newly promoted primary don&#39;t have<br>to perform a full sync.</p>\n<p>In case you wonder why a replica promoted to primary needs to change its<br>replication ID after a failover: it is possible that the old primary is still<br>working as a primary because of some network partition: retaining the same<br>replication ID would violate the fact that the same ID and same offset of any<br>two random instances mean they have the same data set.</p>\n<h2>Diskless replication</h2>\n<p>Normally a full resynchronization requires creating an RDB file on disk,<br>then reloading the same RDB from disk to feed the replicas with the data.</p>\n<p>With slow disks this can be a very stressing operation for the primary.<br>Valkey has support for diskless<br>replication. In this setup the child process directly sends the<br>RDB over the wire to replicas, without using the disk as intermediate storage.</p>\n<h2>Configuration</h2>\n<p>To configure basic Valkey replication is trivial: just add the following line to the replica configuration file:</p>\n<pre><code>replicaof 192.168.1.1 6379\n</code></pre>\n<p>Of course you need to replace 192.168.1.1 6379 with your primary IP address (or<br>hostname) and port. Alternatively, you can call the <code>REPLICAOF</code> command and the<br>primary host will start a sync with the replica.</p>\n<p>There are also a few parameters for tuning the replication backlog taken<br>in memory by the primary to perform the partial resynchronization. See the example<br><code>valkey.conf</code> shipped with the Valkey distribution for more information.</p>\n<p>Diskless replication can be enabled using the <code>repl-diskless-sync</code> configuration<br>parameter. The delay to start the transfer to wait for more replicas to<br>arrive after the first one is controlled by the <code>repl-diskless-sync-delay</code><br>parameter. Please refer to the example <code>valkey.conf</code> file in the Valkey distribution<br>for more details.</p>\n<h2>Read-only replica</h2>\n<p>Replicas are read-only by default.<br>This behavior is controlled by the <code>replica-read-only</code> option in the valkey.conf file, and can be enabled and disabled at runtime using <code>CONFIG SET</code>.</p>\n<p>Read-only replicas will reject all write commands, so that it is not possible to write to a replica because of a mistake. This does not mean that the feature is intended to expose a replica instance to the internet or more generally to a network where untrusted clients exist, because administrative commands like <code>DEBUG</code> or <code>CONFIG</code> are still enabled. The <a href=\"security.md\">Security</a> page describes how to secure a Valkey instance.</p>\n<p>You may wonder why it is possible to revert the read-only setting<br>and have replica instances that can be targeted by write operations.<br>The answer is that writable replicas exist only for historical reasons.<br>Using writable replicas can result in inconsistency between the primary and the replica, so it is not recommended to use writable replicas.<br>To understand in which situations this can be a problem, we need to understand how replication works.<br>Changes on the primary is replicated by propagating regular Valkey commands to the replica.<br>When a key expires on the primary, this is propagated as a DEL command.<br>If a key which exists on the primary but is deleted, expired or has a different type on the replica compared to the primary will react differently to commands like DEL, INCR or RPOP propagated from the primary than intended.<br>The propagated command may fail on the replica or result in a different outcome.<br>To minimize the risks (if you insist on using writable replicas) we suggest you follow these recommendations:</p>\n<ul>\n<li><p>Don&#39;t write to keys in a writable replica that are also used on the primary.<br>(This can be hard to guarantee if you don&#39;t have control over all the clients that write to the primary.)</p>\n</li>\n<li><p>Don&#39;t configure an instance as a writable replica as an intermediary step when upgrading a set of instances in a running system.<br>In general, don&#39;t configure an instance as a writable replica if it can ever be promoted to a primary if you want to guarantee data consistency.</p>\n</li>\n</ul>\n<p>Historically, there were some use cases that were considered legitimate for writable replicas.<br>As of version 7.0, these use cases are now all obsolete and the same can be achieved by other means.<br>For example:</p>\n<ul>\n<li><p>Computing slow Set or Sorted set operations and storing the result in temporary local keys using commands like <code>SUNIONSTORE</code> and <code>ZINTERSTORE</code>.<br>Instead, use commands that return the result without storing it, such as <code>SUNION</code> and <code>ZINTER</code>.</p>\n</li>\n<li><p>Using the <code>SORT</code> command (which is not considered a read-only command because of the optional STORE option and therefore cannot be used on a read-only replica).<br>Instead, use <code>SORT_RO</code>, which is a read-only command.</p>\n</li>\n<li><p>Using <code>EVAL</code> and <code>EVALSHA</code> are also not considered read-only commands, because the Lua script may call write commands.<br>Instead, use <code>EVAL_RO</code> and <code>EVALSHA_RO</code> where the Lua script can only call read-only commands.</p>\n</li>\n</ul>\n<p>While writes to a replica will be discarded if the replica and the primary resync or if the replica is restarted, there is no guarantee that they will sync automatically.</p>\n<p>Before version 4.0, writable replicas were incapable of expiring keys with a time to live set.<br>This means that if you use <code>EXPIRE</code> or other commands that set a maximum TTL for a key, the key will leak, and while you may no longer see it while accessing it with read commands, you will see it in the count of keys and it will still use memory.<br>Valkey is able to evict keys with TTL as primaries do, with the exceptions of keys written in DB numbers greater than 63 (but by default Valkey instances only have 16 databases).<br>Note though that even in versions greater than 4.0, using <code>EXPIRE</code> on a key that could ever exists on the primary can cause inconsistency between the replica and the primary.</p>\n<p>Also note that replica writes are only local, and are not propagated to sub-replicas attached to the instance. Sub-replicas instead will always receive the replication stream identical to the one sent by the top-level primary to the intermediate replicas. So for example in the following setup:</p>\n<pre><code>A ---&gt; B ---&gt; C\n</code></pre>\n<p>Even if <code>B</code> is writable, C will not see <code>B</code> writes and will instead have identical dataset as the primary instance <code>A</code>.</p>\n<h2>Setting a replica to authenticate to a primary</h2>\n<p>If your primary has a password via <code>requirepass</code>, it&#39;s trivial to configure the<br>replica to use that password in all sync operations.</p>\n<p>To do it on a running instance, use <code>valkey-cli</code> and type:</p>\n<pre><code>config set primaryauth &lt;password&gt;\n</code></pre>\n<p>To set it permanently, add this to your config file:</p>\n<pre><code>primaryauth &lt;password&gt;\n</code></pre>\n<h2>Allow writes only with N attached replicas</h2>\n<p>You can configure a Valkey primary to<br>accept write queries only if at least N replicas are currently connected to the<br>primary.</p>\n<p>However, because Valkey uses asynchronous replication it is not possible to ensure<br>the replica actually received a given write, so there is always a window for data<br>loss.</p>\n<p>This is how the feature works:</p>\n<ul>\n<li>Valkey replicas ping the primary every second, acknowledging the amount of replication stream processed.</li>\n<li>Valkey primaries will remember the last time it received a ping from every replica.</li>\n<li>The user can configure a minimum number of replicas that have a lag not greater than a maximum number of seconds.</li>\n</ul>\n<p>If there are at least N replicas, with a lag less than M seconds, then the write will be accepted.</p>\n<p>You may think of it as a best effort data safety mechanism, where consistency is not ensured for a given write, but at least the time window for data loss is restricted to a given number of seconds. In general bound data loss is better than unbound one.</p>\n<p>If the conditions are not met, the primary will instead reply with an error and the write will not be accepted.</p>\n<p>There are two configuration parameters for this feature:</p>\n<ul>\n<li>min-replicas-to-write <code>&lt;number of replicas&gt;</code></li>\n<li>min-replicas-max-lag <code>&lt;number of seconds&gt;</code></li>\n</ul>\n<p>For more information, please check the example <code>valkey.conf</code> file shipped with the<br>Valkey source distribution.</p>\n<h2>How Valkey replication deals with expires on keys</h2>\n<p>Valkey expires allow keys to have a limited time to live (TTL). Such a feature depends<br>on the ability of an instance to count the time, however Valkey replicas correctly<br>replicate keys with expires, even when such keys are altered using Lua<br>scripts.</p>\n<p>To implement such a feature Valkey cannot rely on the ability of the primary and<br>replica to have synced clocks, since this is a problem that cannot be solved<br>and would result in race conditions and diverging data sets, so Valkey<br>uses three main techniques to make the replication of expired keys<br>able to work:</p>\n<ol>\n<li>Replicas don&#39;t expire keys, instead they wait for primaries to expire the keys. When a primary expires a key (or evicts it because of LRU), it synthesizes a <code>DEL</code> command which is transmitted to all the replicas.</li>\n<li>However because of primary-driven expire, sometimes replicas may still have in memory keys that are already logically expired, since the primary was not able to provide the <code>DEL</code> command in time. To deal with that the replica uses its logical clock to report that a key does not exist <strong>only for read operations</strong> that don&#39;t violate the consistency of the data set (as new commands from the primary will arrive). In this way replicas avoid reporting logically expired keys that are still existing. In practical terms, an HTML fragments cache that uses replicas to scale will avoid returning items that are already older than the desired time to live.</li>\n<li>During Lua scripts executions no key expiries are performed. As a Lua script runs, conceptually the time in the primary is frozen, so that a given key will either exist or not for all the time the script runs. This prevents keys expiring in the middle of a script, and is needed to send the same script to the replica in a way that is guaranteed to have the same effects in the data set.</li>\n</ol>\n<p>Once a replica is promoted to a primary it will start to expire keys independently, and will not require any help from its old primary.</p>\n<h2>Configuring replication in Docker and NAT</h2>\n<p>When Docker, or other types of containers using port forwarding, or Network Address Translation is used, Valkey replication needs some extra care, especially when using Valkey Sentinel or other systems where the primary <code>INFO</code> or <code>ROLE</code> commands output is scanned to discover replicas&#39; addresses.</p>\n<p>The problem is that the <code>ROLE</code> command, and the replication section of<br>the <code>INFO</code> output, when issued into a primary instance, will show replicas<br>as having the IP address they use to connect to the primary, which, in<br>environments using NAT may be different compared to the logical address of the<br>replica instance (the one that clients should use to connect to replicas).</p>\n<p>Similarly the replicas will be listed with the listening port configured<br>into <code>valkey.conf</code>, that may be different from the forwarded port in case<br>the port is remapped.</p>\n<p>To fix both issues, it is possible to force<br>a replica to announce an arbitrary pair of IP and port to the primary.<br>The two configurations directives to use are:</p>\n<pre><code>replica-announce-ip 5.5.5.5\nreplica-announce-port 1234\n</code></pre>\n<p>And are documented in the example <code>valkey.conf</code> of recent Valkey distributions.</p>\n<h2>The INFO and ROLE command</h2>\n<p>There are two Valkey commands that provide a lot of information on the current<br>replication parameters of primary and replica instances. One is <code>INFO</code>. If the<br>command is called with the <code>replication</code> argument as <code>INFO replication</code> only<br>information relevant to the replication are displayed. Another more<br>computer-friendly command is <code>ROLE</code>, that provides the replication status of<br>primaries and replicas together with their replication offsets, list of connected<br>replicas and so forth.</p>\n<h2>Partial sync after restarts and failovers</h2>\n<p>When an instance is promoted to primary after a failover,<br>it will still be able to perform a partial resynchronization with the replicas<br>of the old primary. To do so, the replica remembers the old replication ID and<br>offset of its former primary, so can provide part of the backlog to the connecting<br>replicas even if they ask for the old replication ID.</p>\n<p>However the new replication ID of the promoted replica will be different, since it<br>constitutes a different history of the data set. For example, the primary can<br>return available and can continue accepting writes for some time, so using the<br>same replication ID in the promoted replica would violate the rule that a<br>replication ID and offset pair identifies only a single data set.</p>\n<p>Moreover, replicas - when powered off gently and restarted - are able to store<br>in the <code>RDB</code> file the information needed to resync with their<br>primary. This is useful in case of upgrades. When this is needed, it is better to<br>use the <code>SHUTDOWN</code> command in order to perform a <code>save &amp; quit</code> operation on the<br>replica.</p>\n<p>It is not possible to partially sync a replica that restarted via the<br>AOF file. However the instance may be turned to RDB persistence before shutting<br>down it, than can be restarted, and finally AOF can be enabled again.</p>\n<h2><code>Maxmemory</code> on replicas</h2>\n<p>By default, a replica will ignore <code>maxmemory</code> (unless it is promoted to a primary after a failover or manually).<br>It means that the eviction of keys will be handled by the primary, sending the DEL commands to the replica as keys evict in the primary side.</p>\n<p>This behavior ensures that primaries and replicas stay consistent, which is usually what you want.<br>However, if your replica is writable, or you want the replica to have a different memory setting, and you are sure all the writes performed to the replica are idempotent, then you may change this default (but be sure to understand what you are doing).</p>\n<p>Note that since the replica by default does not evict, it may end up using more memory than what is set via <code>maxmemory</code> (since there are certain buffers that may be larger on the replica, or data structures may sometimes take more memory and so forth).<br>Make sure you monitor your replicas, and make sure they have enough memory to never hit a real out-of-memory condition before the primary hits the configured <code>maxmemory</code> setting.</p>\n<p>To change this behavior, you can allow a replica to not ignore the <code>maxmemory</code>. The configuration directives to use is:</p>\n<pre><code>replica-ignore-maxmemory no\n</code></pre>\n"
  },
  {
    "id": "sentinel",
    "topicName": "High availability with Valkey Sentinel",
    "description": "High availability for non-clustered Valkey",
    "htmlContent": "<h2>Usage</h2>\n<p><strong><code>valkey-sentinel</code></strong> <em>/path/to/sentinel.conf</em></p>\n<p><strong><code>valkey-server</code></strong> <em>/path/to/sentinel.conf</em> <strong><code>--sentinel</code></strong></p>\n<h2>Description</h2>\n<p>Valkey Sentinel provides high availability for Valkey when not using <a href=\"cluster-tutorial.md\">Valkey Cluster</a>. </p>\n<p>Valkey Sentinel also provides other collateral tasks such as monitoring,<br>notifications and acts as a configuration provider for clients.</p>\n<p>This is the full list of Sentinel capabilities at a macroscopic level (i.e. the <em>big picture</em>):</p>\n<ul>\n<li><strong>Monitoring</strong>. Sentinel constantly checks if your primary and replica instances are working as expected.</li>\n<li><strong>Notification</strong>. Sentinel can notify the system administrator, or other computer programs, via the API, that something is wrong with one of the monitored Valkey instances.</li>\n<li><strong>Automatic failover</strong>. If a primary is not working as expected, Sentinel can start a failover process where a replica is promoted to primary, the other additional replicas are reconfigured to use the new primary, and the applications using the Valkey server are informed about the new address to use when connecting.</li>\n<li><strong>Configuration provider</strong>. Sentinel acts as a source of authority for clients service discovery: clients connect to Sentinels in order to ask for the address of the current Valkey primary responsible for a given service. If a failover occurs, Sentinels will report the new address.</li>\n</ul>\n<h2>Sentinel as a distributed system</h2>\n<p>Valkey Sentinel is a distributed system:</p>\n<p>Sentinel itself is designed to run in a configuration where there are multiple Sentinel processes cooperating together. The advantage of having multiple Sentinel processes cooperating are the following:</p>\n<ol>\n<li>Failure detection is performed when multiple Sentinels agree about the fact a given primary is no longer available. This lowers the probability of false positives.</li>\n<li>Sentinel works even if not all the Sentinel processes are working, making the system robust against failures. There is no fun in having a failover system which is itself a single point of failure, after all.</li>\n</ol>\n<p>The sum of Sentinels, Valkey instances (primaries and replicas) and clients<br>connecting to Sentinel and Valkey, are also a larger distributed system with<br>specific properties. In this document concepts will be introduced gradually<br>starting from basic information needed in order to understand the basic<br>properties of Sentinel, to more complex information (that are optional) in<br>order to understand how exactly Sentinel works.</p>\n<h2>Sentinel quick start</h2>\n<p>Valkey Sentinel is included in Valkey.</p>\n<h3>Running Sentinel</h3>\n<p>If you are using the <code>valkey-sentinel</code> executable (or if you have a symbolic<br>link with that name to the <code>valkey-server</code> executable) you can run Sentinel<br>with the following command line:</p>\n<pre><code>valkey-sentinel /path/to/sentinel.conf\n</code></pre>\n<p>Otherwise you can use directly the <code>valkey-server</code> executable starting it in<br>Sentinel mode:</p>\n<pre><code>valkey-server /path/to/sentinel.conf --sentinel\n</code></pre>\n<p>Both ways work the same.</p>\n<p>However <strong>it is mandatory</strong> to use a configuration file when running Sentinel, as this file will be used by the system in order to save the current state that will be reloaded in case of restarts. Sentinel will simply refuse to start if no configuration file is given or if the configuration file path is not writable.</p>\n<p>Sentinels by default run <strong>listening for connections to TCP port 26379</strong>, so<br>for Sentinels to work, port 26379 of your servers <strong>must be open</strong> to receive<br>connections from the IP addresses of the other Sentinel instances.<br>Otherwise Sentinels can&#39;t talk and can&#39;t agree about what to do, so failover<br>will never be performed.</p>\n<h3>Fundamental things to know about Sentinel before deploying</h3>\n<ol>\n<li>You need at least three Sentinel instances for a robust deployment.</li>\n<li>The three Sentinel instances should be placed into computers or virtual machines that are believed to fail in an independent way. So for example different physical servers or Virtual Machines executed on different availability zones.</li>\n<li>Sentinel + Valkey distributed system does not guarantee that acknowledged writes are retained during failures, since Valkey uses asynchronous replication. However there are ways to deploy Sentinel that make the window to lose writes limited to certain moments, while there are other less secure ways to deploy it.</li>\n<li>You need Sentinel support in your clients. Popular client libraries have Sentinel support, but not all.</li>\n<li>There is no HA setup which is safe if you don&#39;t test from time to time in development environments, or even better, if you can in production environments, if they work. You may have a misconfiguration that will become apparent only when it&#39;s too late (at 3am when your primary stops working).</li>\n<li><strong>Sentinel, Docker, or other forms of Network Address Translation or Port Mapping should be mixed with care</strong>: Docker performs port remapping, breaking Sentinel auto discovery of other Sentinel processes and the list of replicas for a primary. Check the <a href=\"#sentinel-docker-nat-and-possible-issues\">section about <em>Sentinel and Docker</em></a> later in this document for more information.</li>\n</ol>\n<h3>Configuring Sentinel</h3>\n<p>The Valkey source distribution contains a file called <code>sentinel.conf</code><br>that is a self-documented example configuration file you can use to<br>configure Sentinel, however a typical minimal configuration file looks like the<br>following:</p>\n<pre><code>sentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 60000\nsentinel failover-timeout mymaster 180000\nsentinel parallel-syncs mymaster 1\n\nsentinel monitor resque 192.168.1.3 6380 4\nsentinel down-after-milliseconds resque 10000\nsentinel failover-timeout resque 180000\nsentinel parallel-syncs resque 5\n</code></pre>\n<p>You only need to specify the primaries to monitor, giving to each separated<br>primary (that may have any number of replicas) a different name. There is no<br>need to specify replicas, which are auto-discovered. Sentinel will update the<br>configuration automatically with additional information about replicas (in<br>order to retain the information in case of restart). The configuration is<br>also rewritten every time a replica is promoted to primary during a failover<br>and every time a new Sentinel is discovered.</p>\n<p>The example configuration above basically monitors two sets of Valkey<br>instances, each composed of a primary and an undefined number of replicas.<br>One set of instances is called <code>mymaster</code>, and the other <code>resque</code>.</p>\n<p>The meaning of the arguments of <code>sentinel monitor</code> statements is the following:</p>\n<pre><code>sentinel monitor &lt;primary-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;\n</code></pre>\n<p>For the sake of clarity, let&#39;s check line by line what the configuration<br>options mean:</p>\n<p>The first line is used to tell Valkey to monitor a primary called <em>mymaster</em>,<br>that is at address 127.0.0.1 and port 6379, with a quorum of 2. Everything<br>is pretty obvious but the <strong>quorum</strong> argument:</p>\n<ul>\n<li>The <strong>quorum</strong> is the number of Sentinels that need to agree about the fact the primary is not reachable, in order to really mark the primary as failing, and eventually start a failover procedure if possible.</li>\n<li>However <strong>the quorum is only used to detect the failure</strong>. In order to actually perform a failover, one of the Sentinels need to be elected leader for the failover and be authorized to proceed. This only happens with the vote of the <strong>majority of the Sentinel processes</strong>.</li>\n</ul>\n<p>So for example if you have 5 Sentinel processes, and the quorum for a given<br>primary is set to the value of 2, this is what happens:</p>\n<ul>\n<li>If two Sentinels agree at the same time about the primary being unreachable, one of the two will try to start a failover.</li>\n<li>If there are at least a total of three Sentinels reachable, the failover will be authorized and will actually start.</li>\n</ul>\n<p>In practical terms this means during failures <strong>Sentinel never starts a failover if the majority of Sentinel processes are unable to talk</strong> (aka no failover in the minority partition).</p>\n<h3>Other Sentinel options</h3>\n<p>The other options are almost always in the form:</p>\n<pre><code>sentinel &lt;option_name&gt; &lt;primary_name&gt; &lt;option_value&gt;\n</code></pre>\n<p>And are used for the following purposes:</p>\n<ul>\n<li><code>down-after-milliseconds</code> is the time in milliseconds an instance should not<br>be reachable (either does not reply to our PINGs or it is replying with an<br>error) for a Sentinel starting to think it is down.</li>\n<li><code>parallel-syncs</code> sets the number of replicas that can be reconfigured to use<br>the new primary after a failover at the same time. The lower the number, the<br>more time it will take for the failover process to complete, however if the<br>replicas are configured to serve old data, you may not want all the replicas to<br>re-synchronize with the primary at the same time. While the replication<br>process is mostly non blocking for a replica, there is a moment when it stops to<br>load the bulk data from the primary. You may want to make sure only one replica<br>at a time is not reachable by setting this option to the value of 1.</li>\n</ul>\n<p>Additional options are described in the rest of this document and<br>documented in the example <code>sentinel.conf</code> file shipped with the Valkey<br>distribution.</p>\n<p>Configuration parameters can be modified at runtime:</p>\n<ul>\n<li>Master-specific configuration parameters are modified using <code>SENTINEL SET</code>.</li>\n<li>Global configuration parameters are modified using <code>SENTINEL CONFIG SET</code>.</li>\n</ul>\n<p>See the <a href=\"#reconfiguring-sentinel-at-runtime\"><em>Reconfiguring Sentinel at runtime</em> section</a> for more information.</p>\n<h3>Example Sentinel deployments</h3>\n<p>Now that you know the basic information about Sentinel, you may wonder where<br>you should place your Sentinel processes, how many Sentinel processes you need<br>and so forth. This section shows a few example deployments.</p>\n<p>We use ASCII art in order to show you configuration examples in a <em>graphical</em><br>format, this is what the different symbols means:</p>\n<pre><code>+--------------------+\n| This is a computer |\n| or VM that fails   |\n| independently. We  |\n| call it a &quot;box&quot;    |\n+--------------------+\n</code></pre>\n<p>We write inside the boxes what they are running:</p>\n<pre><code>+--------------------+\n| Valkey primary M1   |\n| Valkey Sentinel S1 |\n+--------------------+\n</code></pre>\n<p>Different boxes are connected by lines, to show that they are able to talk:</p>\n<pre><code>+-------------+               +-------------+\n| Sentinel S1 |---------------| Sentinel S2 |\n+-------------+               +-------------+\n</code></pre>\n<p>Network partitions are shown as interrupted lines using slashes:</p>\n<pre><code>+-------------+                +-------------+\n| Sentinel S1 |------ // ------| Sentinel S2 |\n+-------------+                +-------------+\n</code></pre>\n<p>Also note that:</p>\n<ul>\n<li>Primaries are called M1, M2, M3, ..., Mn.</li>\n<li>Replicas are called R1, R2, R3, ..., Rn (R stands for <em>replica</em>).</li>\n<li>Sentinels are called S1, S2, S3, ..., Sn.</li>\n<li>Clients are called C1, C2, C3, ..., Cn.</li>\n<li>When an instance changes role because of Sentinel actions, we put it inside square brackets, so [M1] means an instance that is now a primary because of Sentinel intervention.</li>\n</ul>\n<p>Note that we will never show <strong>setups where just two Sentinels are used</strong>, since<br>Sentinels always need <strong>to talk with the majority</strong> in order to start a<br>failover.</p>\n<h4>Example 1: just two Sentinels, DON&#39;T DO THIS</h4>\n<pre><code>+----+         +----+\n| M1 |---------| R1 |\n| S1 |         | S2 |\n+----+         +----+\n\nConfiguration: quorum = 1\n</code></pre>\n<ul>\n<li>In this setup, if the primary M1 fails, R1 will be promoted since the two Sentinels can reach agreement about the failure (obviously with quorum set to 1) and can also authorize a failover because the majority is two. So apparently it could superficially work, however check the next points to see why this setup is broken.</li>\n<li>If the box where M1 is running stops working, also S1 stops working. The Sentinel running in the other box S2 will not be able to authorize a failover, so the system will become not available.</li>\n</ul>\n<p>Note that a majority is needed in order to order different failovers, and later propagate the latest configuration to all the Sentinels. Also note that the ability to failover in a single side of the above setup, without any agreement, would be very dangerous:</p>\n<pre><code>+----+           +------+\n| M1 |----//-----| [M1] |\n| S1 |           | S2   |\n+----+           +------+\n</code></pre>\n<p>In the above configuration we created two primaries (assuming S2 could failover<br>without authorization) in a perfectly symmetrical way. Clients may write<br>indefinitely to both sides, and there is no way to understand when the<br>partition heals what configuration is the right one, in order to prevent<br>a <em>permanent split brain condition</em>.</p>\n<p>So please <strong>deploy at least three Sentinels in three different boxes</strong> always.</p>\n<h4>Example 2: basic setup with three boxes</h4>\n<p>This is a very simple setup, that has the advantage to be simple to tune<br>for additional safety. It is based on three boxes, each box running both<br>a Valkey process and a Sentinel process.</p>\n<pre><code>       +----+\n       | M1 |\n       | S1 |\n       +----+\n          |\n+----+    |    +----+\n| R2 |----+----| R3 |\n| S2 |         | S3 |\n+----+         +----+\n\nConfiguration: quorum = 2\n</code></pre>\n<p>If the primary M1 fails, S2 and S3 will agree about the failure and will<br>be able to authorize a failover, making clients able to continue.</p>\n<p>In every Sentinel setup, as Valkey uses asynchronous replication, there is<br>always the risk of losing some writes because a given acknowledged write<br>may not be able to reach the replica which is promoted to primary. However in<br>the above setup there is a higher risk due to clients being partitioned away<br>with an old primary, like in the following picture:</p>\n<pre><code>         +----+\n         | M1 |\n         | S1 | &lt;- C1 (writes will be lost)\n         +----+\n            |\n            /\n            /\n+------+    |    +----+\n| [M2] |----+----| R3 |\n| S2   |         | S3 |\n+------+         +----+\n</code></pre>\n<p>In this case a network partition isolated the old primary M1, so the<br>replica R2 is promoted to primary. However clients, like C1, that are<br>in the same partition as the old primary, may continue to write data<br>to the old primary. This data will be lost forever since when the partition<br>will heal, the primary will be reconfigured as a replica of the new primary,<br>discarding its data set.</p>\n<p>This problem can be mitigated using the following Valkey replication<br>feature, that allows to stop accepting writes if a primary detects that<br>it is no longer able to transfer its writes to the specified number of replicas.</p>\n<pre><code>min-replicas-to-write 1\nmin-replicas-max-lag 10\n</code></pre>\n<p>With the above configuration (please see the self-commented <code>valkey.conf</code> example in the Valkey distribution for more information) a Valkey instance, when acting as a primary, will stop accepting writes if it can&#39;t write to at least 1 replica. Since replication is asynchronous <em>not being able to write</em> actually means that the replica is either disconnected, or is not sending us asynchronous acknowledges for more than the specified <code>max-lag</code> number of seconds.</p>\n<p>Using this configuration, the old Valkey primary M1 in the above example, will become unavailable after 10 seconds. When the partition heals, the Sentinel configuration will converge to the new one, the client C1 will be able to fetch a valid configuration and will continue with the new primary.</p>\n<p>However there is no free lunch. With this refinement, if the two replicas are<br>down, the primary will stop accepting writes. It&#39;s a trade off.</p>\n<h4>Example 3: Sentinel in the client boxes</h4>\n<p>Sometimes we have only two Valkey boxes available, one for the primary and<br>one for the replica. The configuration in the example 2 is not viable in<br>that case, so we can resort to the following, where Sentinels are placed<br>where clients are:</p>\n<pre><code>            +----+         +----+\n            | M1 |----+----| R1 |\n            |    |    |    |    |\n            +----+    |    +----+\n                      |\n         +------------+------------+\n         |            |            |\n         |            |            |\n      +----+        +----+      +----+\n      | C1 |        | C2 |      | C3 |\n      | S1 |        | S2 |      | S3 |\n      +----+        +----+      +----+\n\n      Configuration: quorum = 2\n</code></pre>\n<p>In this setup, the point of view Sentinels is the same as the clients: if<br>a primary is reachable by the majority of the clients, it is fine.<br>C1, C2, C3 here are generic clients, it does not mean that C1 identifies<br>a single client connected to Valkey. It is more likely something like<br>an application server, a Rails app, or something like that.</p>\n<p>If the box where M1 and S1 are running fails, the failover will happen<br>without issues, however it is easy to see that different network partitions<br>will result in different behaviors. For example Sentinel will not be able<br>to setup if the network between the clients and the Valkey servers is<br>disconnected, since the Valkey primary and replica will both be unavailable.</p>\n<p>Note that if C3 gets partitioned with M1 (hardly possible with<br>the network described above, but more likely possible with different<br>layouts, or because of failures at the software layer), we have a similar<br>issue as described in Example 2, with the difference that here we have<br>no way to break the symmetry, since there is just a replica and a primary, so<br>the primary can&#39;t stop accepting queries when it is disconnected from its replica,<br>otherwise the primary would never be available during replica failures.</p>\n<p>So this is a valid setup but the setup in the Example 2 has advantages<br>such as the HA system of Valkey running in the same boxes as Valkey itself<br>which may be simpler to manage, and the ability to put a bound on the amount<br>of time a primary in the minority partition can receive writes.</p>\n<h4>Example 4: Sentinel client side with less than three clients</h4>\n<p>The setup described in the Example 3 cannot be used if there are less than<br>three boxes in the client side (for example three web servers). In this<br>case we need to resort to a mixed setup like the following:</p>\n<pre><code>            +----+         +----+\n            | M1 |----+----| R1 |\n            | S1 |    |    | S2 |\n            +----+    |    +----+\n                      |\n               +------+-----+\n               |            |\n               |            |\n            +----+        +----+\n            | C1 |        | C2 |\n            | S3 |        | S4 |\n            +----+        +----+\n\n      Configuration: quorum = 3\n</code></pre>\n<p>This is similar to the setup in Example 3, but here we run four Sentinels<br>in the four boxes we have available. If the primary M1 becomes unavailable<br>the other three Sentinels will perform the failover.</p>\n<p>In theory this setup works removing the box where C2 and S4 are running, and<br>setting the quorum to 2. However it is unlikely that we want HA in the<br>Valkey side without having high availability in our application layer.</p>\n<h3>Sentinel, Docker, NAT, and possible issues</h3>\n<p>Docker uses a technique called port mapping: programs running inside Docker<br>containers may be exposed with a different port compared to the one the<br>program believes to be using. This is useful in order to run multiple<br>containers using the same ports, at the same time, in the same server.</p>\n<p>Docker is not the only software system where this happens, there are other<br>Network Address Translation setups where ports may be remapped, and sometimes<br>not ports but also IP addresses.</p>\n<p>Remapping ports and addresses creates issues with Sentinel in two ways:</p>\n<ol>\n<li>Sentinel auto-discovery of other Sentinels no longer works, since it is based on <em>hello</em> messages where each Sentinel announce at which port and IP address they are listening for connection. However Sentinels have no way to understand that an address or port is remapped, so it is announcing an information that is not correct for other Sentinels to connect.</li>\n<li>Replicas are listed in the <code>INFO</code> output of a Valkey primary in a similar way: the address is detected by the primary checking the remote peer of the TCP connection, while the port is advertised by the replica itself during the handshake, however the port may be wrong for the same reason as exposed in point 1.</li>\n</ol>\n<p>Since Sentinels auto detect replicas using primaries <code>INFO</code> output information,<br>the detected replicas will not be reachable, and Sentinel will never be able to<br>failover the primary, since there are no good replicas from the point of view of<br>the system, so there is currently no way to monitor with Sentinel a set of<br>primary and replica instances deployed with Docker, <strong>unless you instruct Docker<br>to map the port 1:1</strong>.</p>\n<p>For the first problem, in case you want to run a set of Sentinel<br>instances using Docker with forwarded ports (or any other NAT setup where ports<br>are remapped), you can use the following two Sentinel configuration directives<br>in order to force Sentinel to announce a specific set of IP and port:</p>\n<pre><code>sentinel announce-ip &lt;ip&gt;\nsentinel announce-port &lt;port&gt;\n</code></pre>\n<p>Note that Docker has the ability to run in <em>host networking mode</em> (check the <code>--net=host</code> option for more information). This should create no issues since ports are not remapped in this setup.</p>\n<h3>IP Addresses and DNS names</h3>\n<p>Older versions of Sentinel did not support host names and required IP addresses to be specified everywhere.<br>Starting with version 6.2, Sentinel has <em>optional</em> support for host names.</p>\n<p><strong>This capability is disabled by default. If you&#39;re going to enable DNS/hostnames support, please note:</strong></p>\n<ol>\n<li>The name resolution configuration on your Valkey and Sentinel nodes must be reliable and be able to resolve addresses quickly. Unexpected delays in address resolution may have a negative impact on Sentinel.</li>\n<li>You should use hostnames everywhere and avoid mixing hostnames and IP addresses. To do that, use <code>replica-announce-ip &lt;hostname&gt;</code> and <code>sentinel announce-ip &lt;hostname&gt;</code> for all Valkey and Sentinel instances, respectively.</li>\n</ol>\n<p>Enabling the <code>resolve-hostnames</code> global configuration allows Sentinel to accept host names:</p>\n<ul>\n<li>As part of a <code>sentinel monitor</code> command</li>\n<li>As a replica address, if the replica uses a host name value for <code>replica-announce-ip</code></li>\n</ul>\n<p>Sentinel will accept host names as valid inputs and resolve them, but will still refer to IP addresses when announcing an instance, updating configuration files, etc.</p>\n<p>Enabling the <code>announce-hostnames</code> global configuration makes Sentinel use host names instead. This affects replies to clients, values written in configuration files, the <code>REPLICAOF</code> command issued to replicas, etc.</p>\n<p>This behavior may not be compatible with all Sentinel clients, that may explicitly expect an IP address.</p>\n<p>Using host names may be useful when clients use TLS to connect to instances and require a name rather than an IP address in order to perform certificate ASN matching.</p>\n<h2>A quick tutorial</h2>\n<p>In the next sections of this document, all the details about <a href=\"#sentinel-api\"><em>Sentinel API</em></a>,<br>configuration and semantics will be covered incrementally. However for people<br>that want to play with the system ASAP, this section is a tutorial that shows<br>how to configure and interact with 3 Sentinel instances.</p>\n<p>Here we assume that the instances are executed at port 5000, 5001, 5002.<br>We also assume that you have a running Valkey primary at port 6379 with a<br>replica running at port 6380. We will use the IPv4 loopback address 127.0.0.1<br>everywhere during the tutorial, assuming you are running the simulation<br>on your personal computer.</p>\n<p>The three Sentinel configuration files should look like the following:</p>\n<pre><code>port 5000\nsentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 5000\nsentinel failover-timeout mymaster 60000\nsentinel parallel-syncs mymaster 1\n</code></pre>\n<p>The other two configuration files will be identical but using 5001 and 5002<br>as port numbers.</p>\n<p>A few things to note about the above configuration:</p>\n<ul>\n<li>The primary set is called <code>mymaster</code>. It identifies the primary and its replicas. Since each <em>primary set</em> has a different name, Sentinel can monitor different sets of primaries and replicas at the same time.</li>\n<li>The quorum was set to the value of 2 (last argument of <code>sentinel monitor</code> configuration directive).</li>\n<li>The <code>down-after-milliseconds</code> value is 5000 milliseconds, that is 5 seconds, so primaries will be detected as failing as soon as we don&#39;t receive any reply from our pings within this amount of time.</li>\n</ul>\n<p>Once you start the three Sentinels, you&#39;ll see a few messages they log, like:</p>\n<pre><code>+monitor master mymaster 127.0.0.1 6379 quorum 2\n</code></pre>\n<p>This is a Sentinel event, and you can receive this kind of events via Pub/Sub<br>if you <code>SUBSCRIBE</code> to the event name as specified later in <a href=\"#pubsub-messages\"><em>Pubsub Messages</em> section</a>.</p>\n<p>Sentinel generates and logs different events during failure detection and<br>failover.</p>\n<h2>Asking Sentinel about the state of a primary</h2>\n<p>The most obvious thing to do with Sentinel to get started, is check if the<br>primary it is monitoring is doing well:</p>\n<pre><code>$ valkey-cli -p 5000\n127.0.0.1:5000&gt; sentinel master mymaster\n 1) &quot;name&quot;\n 2) &quot;mymaster&quot;\n 3) &quot;ip&quot;\n 4) &quot;127.0.0.1&quot;\n 5) &quot;port&quot;\n 6) &quot;6379&quot;\n 7) &quot;runid&quot;\n 8) &quot;953ae6a589449c13ddefaee3538d356d287f509b&quot;\n 9) &quot;flags&quot;\n10) &quot;master&quot;\n11) &quot;link-pending-commands&quot;\n12) &quot;0&quot;\n13) &quot;link-refcount&quot;\n14) &quot;1&quot;\n15) &quot;last-ping-sent&quot;\n16) &quot;0&quot;\n17) &quot;last-ok-ping-reply&quot;\n18) &quot;735&quot;\n19) &quot;last-ping-reply&quot;\n20) &quot;735&quot;\n21) &quot;down-after-milliseconds&quot;\n22) &quot;5000&quot;\n23) &quot;info-refresh&quot;\n24) &quot;126&quot;\n25) &quot;role-reported&quot;\n26) &quot;master&quot;\n27) &quot;role-reported-time&quot;\n28) &quot;532439&quot;\n29) &quot;config-epoch&quot;\n30) &quot;1&quot;\n31) &quot;num-slaves&quot;\n32) &quot;1&quot;\n33) &quot;num-other-sentinels&quot;\n34) &quot;2&quot;\n35) &quot;quorum&quot;\n36) &quot;2&quot;\n37) &quot;failover-timeout&quot;\n38) &quot;60000&quot;\n39) &quot;parallel-syncs&quot;\n40) &quot;1&quot;\n</code></pre>\n<p>As you can see, it prints a number of information about the primary. There are<br>a few that are of particular interest for us:</p>\n<ol>\n<li><code>num-other-sentinels</code> is 2, so we know the Sentinel already detected two more Sentinels for this primary. If you check the logs you&#39;ll see the <code>+sentinel</code> events generated.</li>\n<li><code>flags</code> is just <code>master</code>. If the primary was down we could expect to see <code>s_down</code> or <code>o_down</code> flag as well here.</li>\n<li><code>num-slaves</code> is correctly set to 1, so Sentinel also detected that there is an attached replica to our primary.</li>\n</ol>\n<p>In order to explore more about this instance, you may want to try the following<br>two commands:</p>\n<pre><code>SENTINEL replicas mymaster\nSENTINEL sentinels mymaster\n</code></pre>\n<p>The first will provide similar information about the replicas connected to the<br>primary, and the second about the other Sentinels.</p>\n<h2>Obtaining the address of the current primary</h2>\n<p>As we already specified, Sentinel also acts as a configuration provider for<br>clients that want to connect to a set of primary and replicas. Because of<br>possible failovers or reconfigurations, clients have no idea about who is<br>the currently active primary for a given set of instances, so Sentinel exports<br>an API to ask this question:</p>\n<pre><code>127.0.0.1:5000&gt; SENTINEL get-master-addr-by-name mymaster\n1) &quot;127.0.0.1&quot;\n2) &quot;6379&quot;\n</code></pre>\n<h3>Testing the failover</h3>\n<p>At this point our toy Sentinel deployment is ready to be tested. We can<br>just kill our primary and check if the configuration changes. To do so<br>we can just do:</p>\n<pre><code>valkey-cli -p 6379 DEBUG sleep 30\n</code></pre>\n<p>This command will make our primary no longer reachable, sleeping for 30 seconds.<br>It basically simulates a primary hanging for some reason.</p>\n<p>If you check the Sentinel logs, you should be able to see a lot of action:</p>\n<ol>\n<li>Each Sentinel detects the primary is down with an <code>+sdown</code> event.</li>\n<li>This event is later escalated to <code>+odown</code>, which means that multiple Sentinels agree about the fact the primary is not reachable.</li>\n<li>Sentinels vote a Sentinel that will start the first failover attempt.</li>\n<li>The failover happens.</li>\n</ol>\n<p>If you ask again what is the current primary address for <code>mymaster</code>, eventually<br>we should get a different reply this time:</p>\n<pre><code>127.0.0.1:5000&gt; SENTINEL get-master-addr-by-name mymaster\n1) &quot;127.0.0.1&quot;\n2) &quot;6380&quot;\n</code></pre>\n<p>So far so good... At this point you may jump to create your Sentinel deployment<br>or can read more to understand all the Sentinel commands and internals.</p>\n<h2>Sentinel API</h2>\n<p>Sentinel provides an API in order to inspect its state, check the health<br>of monitored primaries and replicas, subscribe in order to receive specific<br>notifications, and change the Sentinel configuration at run time.</p>\n<p>By default Sentinel runs using TCP port 26379 (note that 6379 is the normal<br>Valkey port). Sentinels accept commands using the Valkey protocol, so you can<br>use <code>valkey-cli</code> or any other unmodified Valkey client in order to talk with<br>Sentinel.</p>\n<p>It is possible to directly query a Sentinel to check what is the state of<br>the monitored Valkey instances from its point of view, to see what other<br>Sentinels it knows, and so forth. Alternatively, using Pub/Sub, it is possible<br>to receive <em>push style</em> notifications from Sentinels, every time some event<br>happens, like a failover, or an instance entering an error condition, and<br>so forth.</p>\n<h3>Sentinel commands</h3>\n<p>The <code>SENTINEL</code> command is the main API for Sentinel. The following is the list of its subcommands (minimal version is noted for where applicable):</p>\n<ul>\n<li><strong>SENTINEL CONFIG GET <code>&lt;name&gt;</code></strong> (<code>&gt;= 6.2</code>) Get the current value of a global Sentinel configuration parameter. The specified name may be a wildcard, similar to the Valkey <code>CONFIG GET</code> command.</li>\n<li><strong>SENTINEL CONFIG SET <code>&lt;name&gt;</code> <code>&lt;value&gt;</code></strong> (<code>&gt;= 6.2</code>) Set the value of a global Sentinel configuration parameter.</li>\n<li><strong>SENTINEL CKQUORUM <code>&lt;primary name&gt;</code></strong> Check if the current Sentinel configuration is able to reach the quorum needed to failover a primary, and the majority needed to authorize the failover. This command should be used in monitoring systems to check if a Sentinel deployment is ok.</li>\n<li><strong>SENTINEL FLUSHCONFIG</strong> Force Sentinel to rewrite its configuration on disk, including the current Sentinel state. Normally Sentinel rewrites the configuration every time something changes in its state (in the context of the subset of the state which is persisted on disk across restart). However sometimes it is possible that the configuration file is lost because of operation errors, disk failures, package upgrade scripts or configuration managers. In those cases a way to force Sentinel to rewrite the configuration file is handy. This command works even if the previous configuration file is completely missing.</li>\n<li><strong>SENTINEL FAILOVER <code>&lt;primary name&gt;</code></strong> Force a failover as if the primary was not reachable, and without asking for agreement to other Sentinels (however a new version of the configuration will be published so that the other Sentinels will update their configurations).</li>\n<li><strong>SENTINEL GET-MASTER-ADDR-BY-NAME <code>&lt;primary name&gt;</code></strong> Return the ip and port number of the primary with that name. If a failover is in progress or terminated successfully for this primary it returns the address and port of the promoted replica.</li>\n<li><strong>SENTINEL INFO-CACHE</strong> Return cached <code>INFO</code> output from primaries and replicas.</li>\n<li><strong>SENTINEL IS-MASTER-DOWN-BY-ADDR <ip> <port> <current-epoch> <runid></strong> Check if the primary specified by ip:port is down from current Sentinel&#39;s point of view. This command is mostly for internal use.</li>\n<li><strong>SENTINEL MASTER <code>&lt;primary name&gt;</code></strong> Show the state and info of the specified primary.</li>\n<li><strong>SENTINEL MASTERS</strong> Show a list of monitored primaries and their state.</li>\n<li><strong>SENTINEL MONITOR</strong> Start Sentinel&#39;s monitoring. Refer to the <a href=\"#reconfiguring-sentinel-at-runtime\"><em>Reconfiguring Sentinel at Runtime</em> section</a> for more information.</li>\n<li><strong>SENTINEL MYID</strong> (<code>&gt;= 6.2</code>) Return the ID of the Sentinel instance.</li>\n<li><strong>SENTINEL PENDING-SCRIPTS</strong> This command returns information about pending scripts.</li>\n<li><strong>SENTINEL REMOVE</strong> Stop Sentinel&#39;s monitoring. Refer to the <a href=\"#reconfiguring-sentinel-at-runtime\"><em>Reconfiguring Sentinel at Runtime</em> section</a> for more information.</li>\n<li><strong>SENTINEL REPLICAS <code>&lt;primary name&gt;</code></strong> Show a list of replicas for this primary, and their state.</li>\n<li><strong>SENTINEL SENTINELS <code>&lt;primary name&gt;</code></strong> Show a list of sentinel instances for this primary, and their state.</li>\n<li><strong>SENTINEL SET</strong> Set Sentinel&#39;s monitoring configuration. Refer to the <a href=\"#reconfiguring-sentinel-at-runtime\"><em>Reconfiguring Sentinel at Runtime</em> section</a> for more information.</li>\n<li><strong>SENTINEL SIMULATE-FAILURE (crash-after-election|crash-after-promotion|help)</strong> This command simulates different Sentinel crash scenarios.</li>\n<li><strong>SENTINEL RESET <code>&lt;pattern&gt;</code></strong> This command will reset all the primaries with matching name. The pattern argument is a glob-style pattern. The reset process clears any previous state in a primary (including a failover in progress), and removes every replica and sentinel already discovered and associated with the primary.</li>\n</ul>\n<p>For connection management and administration purposes, Sentinel supports the following subset of Valkey&#39;s commands:</p>\n<ul>\n<li><strong>ACL</strong> (<code>&gt;= 6.2</code>) This command manages the Sentinel Access Control List. For more information refer to the <a href=\"acl.md\">ACL</a> documentation page and the <a href=\"#sentinel-access-control-list-authentication\"><em>Sentinel Access Control List authentication</em></a>.</li>\n<li><strong>AUTH</strong> Authenticate a client connection. For more information refer to the <code>AUTH</code> command and the <a href=\"#configuring-sentinel-instances-with-authentication\"><em>Configuring Sentinel instances with authentication</em> section</a>.</li>\n<li><strong>CLIENT</strong> This command manages client connections. For more information refer to its subcommands&#39; pages.</li>\n<li><strong>COMMAND</strong> (<code>&gt;= 6.2</code>) This command returns information about commands. For more information refer to the <code>COMMAND</code> command and its various subcommands.</li>\n<li><strong>HELLO</strong> (<code>&gt;= 6.0</code>) Switch the connection&#39;s protocol. For more information refer to the <code>HELLO</code> command.</li>\n<li><strong>INFO</strong> Return information and statistics about the Sentinel server. For more information see the <code>INFO</code> command.</li>\n<li><strong>PING</strong> This command simply returns PONG.</li>\n<li><strong>ROLE</strong> This command returns the string &quot;sentinel&quot; and a list of monitored primaries. For more information refer to the <code>ROLE</code> command.</li>\n<li><strong>SHUTDOWN</strong> Shut down the Sentinel instance.</li>\n</ul>\n<p>Lastly, Sentinel also supports the <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code> and <code>PUNSUBSCRIBE</code> commands. Refer to the <a href=\"#pubsub-messages\"><em>Pub/Sub Messages</em> section</a> for more details.</p>\n<h3>Reconfiguring Sentinel at Runtime</h3>\n<p>Sentinel provides an API in order to add, remove, or change the configuration of a given primary. Note that if you have multiple sentinels you should apply the changes to all to your instances for Valkey Sentinel to work properly. This means that changing the configuration of a single Sentinel does not automatically propagate the changes to the other Sentinels in the network.</p>\n<p>The following is a list of <code>SENTINEL</code> subcommands used in order to update the configuration of a Sentinel instance.</p>\n<ul>\n<li><strong>SENTINEL MONITOR <code>&lt;name&gt;</code> <code>&lt;ip&gt;</code> <code>&lt;port&gt;</code> <code>&lt;quorum&gt;</code></strong> This command tells the Sentinel to start monitoring a new primary with the specified name, ip, port, and quorum. It is identical to the <code>sentinel monitor</code> configuration directive in <code>sentinel.conf</code> configuration file, with the difference that you can&#39;t use a hostname in as <code>ip</code>, but you need to provide an IPv4 or IPv6 address.</li>\n<li><strong>SENTINEL REMOVE <code>&lt;name&gt;</code></strong> is used in order to remove the specified primary: the primary will no longer be monitored, and will totally be removed from the internal state of the Sentinel, so it will no longer listed by <code>SENTINEL masters</code> and so forth.</li>\n<li><strong>SENTINEL SET <code>&lt;name&gt;</code> [<code>&lt;option&gt;</code> <code>&lt;value&gt;</code> ...]</strong> The SET command is very similar to the <code>CONFIG SET</code> command of Valkey, and is used in order to change configuration parameters of a specific primary. Multiple option / value pairs can be specified (or none at all). All the configuration parameters that can be configured via <code>sentinel.conf</code> are also configurable using the SET command.</li>\n</ul>\n<p>The following is an example of <code>SENTINEL SET</code> command in order to modify the <code>down-after-milliseconds</code> configuration of a primary called <code>objects-cache</code>:</p>\n<pre><code>SENTINEL SET objects-cache-master down-after-milliseconds 1000\n</code></pre>\n<p>As already stated, <code>SENTINEL SET</code> can be used to set all the configuration parameters that are settable in the startup configuration file. Moreover it is possible to change just the primary quorum configuration without removing and re-adding the primary with <code>SENTINEL REMOVE</code> followed by <code>SENTINEL MONITOR</code>, but simply using:</p>\n<pre><code>SENTINEL SET objects-cache-master quorum 5\n</code></pre>\n<p>Note that there is no equivalent GET command since <code>SENTINEL MASTER</code> provides all the configuration parameters in a simple to parse format (as a field/value pairs array).</p>\n<p>Sentinel also allows getting and setting global configuration parameters which were only supported in the configuration file prior to that.</p>\n<ul>\n<li><strong>SENTINEL CONFIG GET <code>&lt;name&gt;</code></strong> Get the current value of a global Sentinel configuration parameter. The specified name may be a wildcard, similar to the Valkey <code>CONFIG GET</code> command.</li>\n<li><strong>SENTINEL CONFIG SET <code>&lt;name&gt;</code> <code>&lt;value&gt;</code></strong> Set the value of a global Sentinel configuration parameter.</li>\n</ul>\n<p>Global parameters that can be manipulated include:</p>\n<ul>\n<li><code>resolve-hostnames</code>, <code>announce-hostnames</code>. See <a href=\"#ip-addresses-and-dns-names\"><em>IP addresses and DNS names</em></a>.</li>\n<li><code>announce-ip</code>, <code>announce-port</code>. See <a href=\"#sentinel-docker-nat-and-possible-issues\"><em>Sentinel, Docker, NAT, and possible issues</em></a>.</li>\n<li><code>sentinel-user</code>, <code>sentinel-pass</code>. See <a href=\"#configuring-sentinel-instances-with-authentication\"><em>Configuring Sentinel instances with authentication</em></a>.</li>\n</ul>\n<h3>Adding or removing Sentinels</h3>\n<p>Adding a new Sentinel to your deployment is a simple process because of the<br>auto-discover mechanism implemented by Sentinel. All you need to do is to<br>start the new Sentinel configured to monitor the currently active primary.<br>Within 10 seconds the Sentinel will acquire the list of other Sentinels and<br>the set of replicas attached to the primary.</p>\n<p>If you need to add multiple Sentinels at once, it is suggested to add it<br>one after the other, waiting for all the other Sentinels to already know<br>about the first one before adding the next. This is useful in order to still<br>guarantee that majority can be achieved only in one side of a partition,<br>in the chance failures should happen in the process of adding new Sentinels.</p>\n<p>This can be easily achieved by adding every new Sentinel with a 30 seconds delay, and during absence of network partitions.</p>\n<p>At the end of the process it is possible to use the command<br><code>SENTINEL MASTER &lt;primary name&gt;</code> in order to check if all the Sentinels agree about<br>the total number of Sentinels monitoring the primary.</p>\n<p>Removing a Sentinel is a bit more complex: <strong>Sentinels never forget already seen<br>Sentinels</strong>, even if they are not reachable for a long time, since we don&#39;t<br>want to dynamically change the majority needed to authorize a failover and<br>the creation of a new configuration number. So in order to remove a Sentinel<br>the following steps should be performed in absence of network partitions:</p>\n<ol>\n<li>Stop the Sentinel process of the Sentinel you want to remove.</li>\n<li>Send a <code>SENTINEL RESET *</code> command to all the other Sentinel instances (instead of <code>*</code> you can use the exact primary name if you want to reset just a single primary). One after the other, waiting at least 30 seconds between instances.</li>\n<li>Check that all the Sentinels agree about the number of Sentinels currently active, by inspecting the output of <code>SENTINEL MASTER &lt;primary name&gt;</code> of every Sentinel.</li>\n</ol>\n<h3>Removing the old primary or unreachable replicas</h3>\n<p>Sentinels never forget about replicas of a given primary, even when they are<br>unreachable for a long time. This is useful, because Sentinels should be able<br>to correctly reconfigure a returning replica after a network partition or a<br>failure event.</p>\n<p>Moreover, after a failover, the failed over primary is virtually added as a<br>replica of the new primary, this way it will be reconfigured to replicate with<br>the new primary as soon as it will be available again.</p>\n<p>However sometimes you want to remove a replica (that may be the old primary)<br>forever from the list of replicas monitored by Sentinels.</p>\n<p>In order to do this, you need to send a <code>SENTINEL RESET &lt;primary name&gt;</code> command<br>to all the Sentinels: they&#39;ll refresh the list of replicas within the next<br>10 seconds, only adding the ones listed as correctly replicating from the<br>current primary <code>INFO</code> output.</p>\n<h3>Pubsub messages</h3>\n<p>A client can use a Sentinel as a Valkey-compatible Pub/Sub server<br>(but you can&#39;t use <code>PUBLISH</code>) in order to <code>SUBSCRIBE</code> or <code>PSUBSCRIBE</code> to<br>channels and get notified about specific events.</p>\n<p>The channel name is the same as the name of the event. For instance the<br>channel named <code>+sdown</code> will receive all the notifications related to instances<br>entering an <code>SDOWN</code> (SDOWN means the instance is no longer reachable from<br>the point of view of the Sentinel you are querying) condition.</p>\n<p>To get all the messages simply subscribe using <code>PSUBSCRIBE *</code>.</p>\n<p>The following is a list of channels and message formats you can receive using<br>this API. The first word is the channel / event name, the rest is the format of the data.</p>\n<p>Note: where <em>instance details</em> is specified it means that the following arguments are provided to identify the target instance:</p>\n<pre><code>&lt;instance-type&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;primary-name&gt; &lt;primary-ip&gt; &lt;primary-port&gt;\n</code></pre>\n<p>The part identifying the primary (from the @ argument to the end) is optional<br>and is only specified if the instance is not a primary itself.</p>\n<ul>\n<li><strong>+reset-master</strong> <code>&lt;instance details&gt;</code> -- The primary was reset.</li>\n<li><strong>+slave</strong> <code>&lt;instance details&gt;</code> -- A new replica was detected and attached.</li>\n<li><strong>+failover-state-reconf-slaves</strong> <code>&lt;instance details&gt;</code> -- Failover state changed to <code>reconf-slaves</code> state.</li>\n<li><strong>+failover-detected</strong> <code>&lt;instance details&gt;</code> -- A failover started by another Sentinel or any other external entity was detected (An attached replica turned into a primary).</li>\n<li><strong>+slave-reconf-sent</strong> <code>&lt;instance details&gt;</code> -- The leader sentinel sent the <code>REPLICAOF</code> command to this instance in order to reconfigure it for the new replica.</li>\n<li><strong>+slave-reconf-inprog</strong> <code>&lt;instance details&gt;</code> -- The replica being reconfigured showed to be a replica of the new primary ip:port pair, but the synchronization process is not yet complete.</li>\n<li><strong>+slave-reconf-done</strong> <code>&lt;instance details&gt;</code> -- The replica is now synchronized with the new primary.</li>\n<li><strong>-dup-sentinel</strong> <code>&lt;instance details&gt;</code> -- One or more sentinels for the specified primary were removed as duplicated (this happens for instance when a Sentinel instance is restarted).</li>\n<li><strong>+sentinel</strong> <code>&lt;instance details&gt;</code> -- A new sentinel for this primary was detected and attached.</li>\n<li><strong>+sdown</strong> <code>&lt;instance details&gt;</code> -- The specified instance is now in Subjectively Down state.</li>\n<li><strong>-sdown</strong> <code>&lt;instance details&gt;</code> -- The specified instance is no longer in Subjectively Down state.</li>\n<li><strong>+odown</strong> <code>&lt;instance details&gt;</code> -- The specified instance is now in Objectively Down state.</li>\n<li><strong>-odown</strong> <code>&lt;instance details&gt;</code> -- The specified instance is no longer in Objectively Down state.</li>\n<li><strong>+new-epoch</strong> <code>&lt;instance details&gt;</code> -- The current epoch was updated.</li>\n<li><strong>+try-failover</strong> <code>&lt;instance details&gt;</code> -- New failover in progress, waiting to be elected by the majority.</li>\n<li><strong>+elected-leader</strong> <code>&lt;instance details&gt;</code> -- Won the election for the specified epoch, can do the failover.</li>\n<li><strong>+failover-state-select-slave</strong> <code>&lt;instance details&gt;</code> -- New failover state is <code>select-slave</code>: we are trying to find a suitable replica for promotion.</li>\n<li><strong>no-good-slave</strong> <code>&lt;instance details&gt;</code> -- There is no good replica to promote. Currently we&#39;ll try after some time, but probably this will change and the state machine will abort the failover at all in this case.</li>\n<li><strong>selected-slave</strong> <code>&lt;instance details&gt;</code> -- We found the specified good replica to promote.</li>\n<li><strong>failover-state-send-slaveof-noone</strong> <code>&lt;instance details&gt;</code> -- We are trying to reconfigure the promoted replica as primary, waiting for it to switch.</li>\n<li><strong>failover-end-for-timeout</strong> <code>&lt;instance details&gt;</code> -- The failover terminated for timeout, replicas will eventually be configured to replicate with the new primary anyway.</li>\n<li><strong>failover-end</strong> <code>&lt;instance details&gt;</code> -- The failover terminated with success. All the replicas appear to be reconfigured to replicate with the new primary.</li>\n<li><strong>switch-master</strong> <code>&lt;primary name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;</code> -- The primary new IP and address is the specified one after a configuration change. This is <strong>the message most external users are interested in</strong>.</li>\n<li><strong>+tilt</strong> -- Tilt mode entered.</li>\n<li><strong>-tilt</strong> -- Tilt mode exited.</li>\n</ul>\n<h3>Handling of -BUSY state</h3>\n<p>The -BUSY error is returned by a Valkey instance when a Lua script is running for<br>more time than the configured Lua script time limit. When this happens before<br>triggering a fail over Valkey Sentinel will try to send a <code>SCRIPT KILL</code><br>command, that will only succeed if the script was read-only.</p>\n<p>If the instance is still in an error condition after this try, it will<br>eventually be failed over.</p>\n<h2>Replicas priority</h2>\n<p>Valkey instances have a configuration parameter called <code>replica-priority</code>.<br>This information is exposed by Valkey replica instances in their <code>INFO</code> output,<br>and Sentinel uses it in order to pick a replica among the ones that can be<br>used in order to failover a primary:</p>\n<ol>\n<li>If the replica priority is set to 0, the replica is never promoted to primary.</li>\n<li>Replicas with a <em>lower</em> priority number are preferred by Sentinel.</li>\n</ol>\n<p>For example if there is a replica S1 in the same data center of the current<br>primary, and another replica S2 in another data center, it is possible to set<br>S1 with a priority of 10 and S2 with a priority of 100, so that if the primary<br>fails and both S1 and S2 are available, S1 will be preferred.</p>\n<p>For more information about the way replicas are selected, please check the <a href=\"#replica-selection-and-priority\"><em>Replica selection and priority</em> section</a> of this documentation.</p>\n<h3>Sentinel and Valkey authentication</h3>\n<p>When the primary is configured to require authentication from clients,<br>as a security measure, replicas need to also be aware of the credentials in<br>order to authenticate with the primary and create the primary-replica connection<br>used for the asynchronous replication protocol.</p>\n<h2>Valkey Access Control List authentication</h2>\n<p>User authentication and permission is managed with the <a href=\"acl.md\">Access Control List (ACL)</a>.</p>\n<p>In order for Sentinels to connect to Valkey server instances when they are<br>configured with ACL, the Sentinel configuration must include the<br>following directives:</p>\n<pre><code>sentinel auth-user &lt;primary-name&gt; &lt;username&gt;\nsentinel auth-pass &lt;primary-name&gt; &lt;password&gt;\n</code></pre>\n<p>Where <code>&lt;username&gt;</code> and <code>&lt;password&gt;</code> are the username and password for accessing the group&#39;s instances. These credentials should be provisioned on all of the group&#39;s Valkey instances with the minimal control permissions. For example:</p>\n<pre><code>127.0.0.1:6379&gt; ACL SETUSER sentinel-user ON &gt;somepassword allchannels +multi +slaveaof +ping +exec +subscribe +config|rewrite +role +publish +info +client|setname +client|kill +script|kill\n</code></pre>\n<h3>Valkey password-only authentication</h3>\n<p>Before ACL was introduced, authentication could be achieved using the following configuration directives:</p>\n<ul>\n<li><code>requirepass</code> in the primary, in order to set the authentication password, and to make sure the instance will not process requests for non authenticated clients.</li>\n<li><code>masterauth</code> in the replicas in order for the replicas to authenticate with the primary in order to correctly replicate data from it.</li>\n</ul>\n<p>When Sentinel is used, there is not a single primary, since after a failover<br>replicas may play the role of primaries, and old primaries can be reconfigured in<br>order to act as replicas, so what you want to do is to set the above directives<br>in all your instances, both primaries and replicas.</p>\n<p>This is also usually a sane setup since you don&#39;t want to protect<br>data only in the primary, having the same data accessible in the replicas.</p>\n<p>However, in the uncommon case where you need a replica that is accessible<br>without authentication, you can still do it by setting up <strong>a replica priority<br>of zero</strong>, to prevent this replica from being promoted to primary, and<br>configuring in this replica only the <code>masterauth</code> directive, without<br>using the <code>requirepass</code> directive, so that data will be readable by<br>unauthenticated clients.</p>\n<p>In order for Sentinels to connect to Valkey server instances when they are<br>configured with <code>requirepass</code>, the Sentinel configuration must include the<br><code>sentinel auth-pass</code> directive, in the format:</p>\n<pre><code>sentinel auth-pass &lt;primary-name&gt; &lt;password&gt;\n</code></pre>\n<h2>Configuring Sentinel instances with authentication</h2>\n<p>Sentinel instances themselves can be secured by requiring clients to authenticate via the <code>AUTH</code> command. Starting with Redis OSS 6.2, the <a href=\"acl.md\">Access Control List (ACL)</a> is available, whereas older versions support password-only authentication.</p>\n<p>Note that Sentinel&#39;s authentication configuration should be <strong>applied to each of the instances</strong> in your deployment, and <strong>all instances should use the same configuration</strong>. Furthermore, ACL and password-only authentication should not be used together.</p>\n<h3>Sentinel Access Control List authentication</h3>\n<p>The first step in securing a Sentinel instance with ACL is preventing any unauthorized access to it. To do that, you&#39;ll need to disable the default superuser (or at the very least set it up with a strong password) and create a new one and allow it access to Pub/Sub channels:</p>\n<pre><code>127.0.0.1:5000&gt; ACL SETUSER admin ON &gt;admin-password allchannels +@all\nOK\n127.0.0.1:5000&gt; ACL SETUSER default off\nOK\n</code></pre>\n<p>The default user is used by Sentinel to connect to other instances. You can provide the credentials of another superuser with the following configuration directives:</p>\n<pre><code>sentinel sentinel-user &lt;username&gt;\nsentinel sentinel-pass &lt;password&gt;\n</code></pre>\n<p>Where <code>&lt;username&gt;</code> and <code>&lt;password&gt;</code> are the Sentinel&#39;s superuser and password, respectively (e.g. <code>admin</code> and <code>admin-password</code> in the example above).</p>\n<p>Lastly, for authenticating incoming client connections, you can create a Sentinel restricted user profile such as the following:</p>\n<pre><code>127.0.0.1:5000&gt; ACL SETUSER sentinel-user ON &gt;user-password -@all +auth +client|getname +client|id +client|setname +command +hello +ping +role +sentinel|get-master-addr-by-name +sentinel|master +sentinel|myid +sentinel|replicas +sentinel|sentinels\n</code></pre>\n<p>Refer to the documentation of your Sentinel client of choice for further information.</p>\n<h3>Sentinel password-only authentication</h3>\n<p>To use Sentinel with password-only authentication, add the <code>requirepass</code> configuration directive to <strong>all</strong> your Sentinel instances as follows:</p>\n<pre><code>requirepass &quot;your_password_here&quot;\n</code></pre>\n<p>When configured this way, Sentinels will do two things:</p>\n<ol>\n<li>A password will be required from clients in order to send commands to Sentinels. This is obvious since this is how such configuration directive works in Valkey in general.</li>\n<li>Moreover the same password configured to access the local Sentinel, will be used by this Sentinel instance in order to authenticate to all the other Sentinel instances it connects to.</li>\n</ol>\n<p>This means that <strong>you will have to configure the same <code>requirepass</code> password in all the Sentinel instances</strong>. This way every Sentinel can talk with every other Sentinel without any need to configure for each Sentinel the password to access all the other Sentinels, that would be very impractical.</p>\n<p>Before using this configuration, make sure your client library can send the <code>AUTH</code> command to Sentinel instances.</p>\n<h3>Sentinel clients implementation</h3>\n<hr>\n<p>Sentinel requires explicit client support, unless the system is configured to execute a script that performs a transparent redirection of all the requests to the new primary instance (virtual IP or other similar systems). The topic of client libraries implementation is covered in the document <a href=\"sentinel-clients.md\">Sentinel clients guidelines</a>.</p>\n<h2>More advanced concepts</h2>\n<p>In the following sections we&#39;ll cover a few details about how Sentinel works,<br>without resorting to implementation details and algorithms that will be<br>covered in the final part of this document.</p>\n<h3>SDOWN and ODOWN failure state</h3>\n<p>Valkey Sentinel has two different concepts of <em>being down</em>, one is called<br>a <em>Subjectively Down</em> condition (SDOWN) and is a down condition that is<br>local to a given Sentinel instance. Another is called <em>Objectively Down</em><br>condition (ODOWN) and is reached when enough Sentinels (at least the<br>number configured as the <code>quorum</code> parameter of the monitored primary) have<br>an SDOWN condition, and get feedback from other Sentinels using<br>the <code>SENTINEL is-master-down-by-addr</code> command.</p>\n<p>From the point of view of a Sentinel an SDOWN condition is reached when it<br>does not receive a valid reply to PING requests for the number of seconds<br>specified in the configuration as <code>is-master-down-after-milliseconds</code><br>parameter.</p>\n<p>An acceptable reply to PING is one of the following:</p>\n<ul>\n<li>PING replied with +PONG.</li>\n<li>PING replied with -LOADING error.</li>\n<li>PING replied with -MASTERDOWN error.</li>\n</ul>\n<p>Any other reply (or no reply at all) is considered non valid.<br>However note that <strong>a logical primary that advertises itself as a replica in<br>the INFO output is considered to be down</strong>.</p>\n<p>Note that SDOWN requires that no acceptable reply is received for the whole<br>interval configured, so for instance if the interval is 30000 milliseconds<br>(30 seconds) and we receive an acceptable ping reply every 29 seconds, the<br>instance is considered to be working.</p>\n<p>SDOWN is not enough to trigger a failover: it only means a single Sentinel<br>believes a Valkey instance is not available. To trigger a failover, the<br>ODOWN state must be reached.</p>\n<p>To switch from SDOWN to ODOWN no strong consensus algorithm is used, but<br>just a form of gossip: if a given Sentinel gets reports that a primary<br>is not working from enough Sentinels <strong>in a given time range</strong>, the SDOWN is<br>promoted to ODOWN. If this acknowledge is later missing, the flag is cleared.</p>\n<p>A more strict authorization that uses an actual majority is required in<br>order to really start the failover, but no failover can be triggered without<br>reaching the ODOWN state.</p>\n<p>The ODOWN condition <strong>only applies to primaries</strong>. For other kind of instances<br>Sentinel doesn&#39;t require to act, so the ODOWN state is never reached for replicas<br>and other sentinels, but only SDOWN is.</p>\n<p>However SDOWN has also semantic implications. For example a replica in SDOWN<br>state is not selected to be promoted by a Sentinel performing a failover.</p>\n<h2>Sentinels and replicas auto discovery</h2>\n<p>Sentinels stay connected with other Sentinels in order to reciprocally<br>check the availability of each other, and to exchange messages. However you<br>don&#39;t need to configure a list of other Sentinel addresses in every Sentinel<br>instance you run, as Sentinel uses the Valkey instances Pub/Sub capabilities<br>in order to discover the other Sentinels that are monitoring the same primaries<br>and replicas.</p>\n<p>This feature is implemented by sending <em>hello messages</em> into the channel named<br><code>__sentinel__:hello</code>.</p>\n<p>Similarly you don&#39;t need to configure what is the list of the replicas attached<br>to a primary, as Sentinel will auto discover this list querying Valkey.</p>\n<ul>\n<li>Every Sentinel publishes a message to every monitored primary and replica Pub/Sub channel <code>__sentinel__:hello</code>, every two seconds, announcing its presence with ip, port, runid.</li>\n<li>Every Sentinel is subscribed to the Pub/Sub channel <code>__sentinel__:hello</code> of every primary and replica, looking for unknown sentinels. When new sentinels are detected, they are added as sentinels of this primary.</li>\n<li>Hello messages also include the full current configuration of the primary. If the receiving Sentinel has a configuration for a given primary which is older than the one received, it updates to the new configuration immediately.</li>\n<li>Before adding a new sentinel to a primary a Sentinel always checks if there is already a sentinel with the same runid or the same address (ip and port pair). In that case all the matching sentinels are removed, and the new added.</li>\n</ul>\n<h2>Sentinel reconfiguration of instances outside the failover procedure</h2>\n<p>Even when no failover is in progress, Sentinels will always try to set the<br>current configuration on monitored instances. Specifically:</p>\n<ul>\n<li>Replicas (according to the current configuration) that claim to be primaries, will be configured as replicas to replicate with the current primary.</li>\n<li>Replicas connected to a wrong primary, will be reconfigured to replicate with the right primary.</li>\n</ul>\n<p>For Sentinels to reconfigure replicas, the wrong configuration must be observed for some time, that is greater than the period used to broadcast new configurations.</p>\n<p>This prevents Sentinels with a stale configuration (for example because they just rejoined from a partition) will try to change the replicas configuration before receiving an update.</p>\n<p>Also note how the semantics of always trying to impose the current configuration makes the failover more resistant to partitions:</p>\n<ul>\n<li>Masters failed over are reconfigured as replicas when they return available.</li>\n<li>Replicas partitioned away during a partition are reconfigured once reachable.</li>\n</ul>\n<p>The important lesson to remember about this section is: <strong>Sentinel is a system where each process will always try to impose the last logical configuration to the set of monitored instances</strong>.</p>\n<h3>Replica selection and priority</h3>\n<p>When a Sentinel instance is ready to perform a failover, since the primary<br>is in <code>ODOWN</code> state and the Sentinel received the authorization to failover<br>from the majority of the Sentinel instances known, a suitable replica needs<br>to be selected.</p>\n<p>The replica selection process evaluates the following information about replicas:</p>\n<ol>\n<li>Disconnection time from the primary.</li>\n<li>Replica priority.</li>\n<li>Replication offset processed.</li>\n<li>Run ID.</li>\n</ol>\n<p>A replica that is found to be disconnected from the primary for more than ten<br>times the configured primary timeout (down-after-milliseconds option), plus<br>the time the primary is also not available from the point of view of the<br>Sentinel doing the failover, is considered to be not suitable for the failover<br>and is skipped.</p>\n<p>In more rigorous terms, a replica whose the <code>INFO</code> output suggests it has been<br>disconnected from the primary for more than:</p>\n<pre><code>(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state\n</code></pre>\n<p>Is considered to be unreliable and is disregarded entirely.</p>\n<p>The replica selection only considers the replicas that passed the above test,<br>and sorts it based on the above criteria, in the following order.</p>\n<ol>\n<li>The replicas are sorted by <code>replica-priority</code> as configured in the <code>valkey.conf</code> file of the Valkey instance. A lower priority will be preferred.</li>\n<li>If the priority is the same, the replication offset processed by the replica is checked, and the replica that received more data from the primary is selected.</li>\n<li>If multiple replicas have the same priority and processed the same data from the primary, a further check is performed, selecting the replica with the lexicographically smaller run ID. Having a lower run ID is not a real advantage for a replica, but is useful in order to make the process of replica selection more deterministic, instead of resorting to select a random replica.</li>\n</ol>\n<p>In most cases, <code>replica-priority</code> does not need to be set explicitly so all<br>instances will use the same default value. If there is a particular fail-over<br>preference, <code>replica-priority</code> must be set on all instances, including primaries,<br>as a primary may become a replica at some future point in time - and it will then<br>need the proper <code>replica-priority</code> settings.</p>\n<p>A Valkey instance can be configured with a special <code>replica-priority</code> of zero<br>in order to be <strong>never selected</strong> by Sentinels as the new primary.<br>However a replica configured in this way will still be reconfigured by<br>Sentinels in order to replicate with the new primary after a failover, the<br>only difference is that it will never become a primary itself.</p>\n<h2>Algorithms and internals</h2>\n<p>In the following sections we will explore the details of Sentinel behavior.<br>It is not strictly needed for users to be aware of all the details, but a<br>deep understanding of Sentinel may help to deploy and operate Sentinel in<br>a more effective way.</p>\n<h3>Quorum</h3>\n<p>The previous sections showed that every primary monitored by Sentinel is associated to a configured <strong>quorum</strong>. It specifies the number of Sentinel processes<br>that need to agree about the unreachability or error condition of the primary in<br>order to trigger a failover.</p>\n<p>However, after the failover is triggered, in order for the failover to actually be performed, <strong>at least a majority of Sentinels must authorize the Sentinel to<br>failover</strong>. Sentinel never performs a failover in the partition where a<br>minority of Sentinels exist.</p>\n<p>Let&#39;s try to make things a bit more clear:</p>\n<ul>\n<li>Quorum: the number of Sentinel processes that need to detect an error condition in order for a primary to be flagged as <strong>ODOWN</strong>.</li>\n<li>The failover is triggered by the <strong>ODOWN</strong> state.</li>\n<li>Once the failover is triggered, the Sentinel trying to failover is required to ask for authorization to a majority of Sentinels (or more than the majority if the quorum is set to a number greater than the majority).</li>\n</ul>\n<p>The difference may seem subtle but is actually quite simple to understand and use.  For example if you have 5 Sentinel instances, and the quorum is set to 2, a failover will be triggered as soon as 2 Sentinels believe that the primary is not reachable, however one of the two Sentinels will be able to failover only if it gets authorization at least from 3 Sentinels.</p>\n<p>If instead the quorum is configured to 5, all the Sentinels must agree about the primary error condition, and the authorization from all Sentinels is required in order to failover.</p>\n<p>This means that the quorum can be used to tune Sentinel in two ways:</p>\n<ol>\n<li>If a quorum is set to a value smaller than the majority of Sentinels we deploy, we are basically making Sentinel more sensitive to primary failures, triggering a failover as soon as even just a minority of Sentinels is no longer able to talk with the primary.</li>\n<li>If a quorum is set to a value greater than the majority of Sentinels, we are making Sentinel able to failover only when there are a very large number (larger than majority) of well connected Sentinels which agree about the primary being down.</li>\n</ol>\n<h3>Configuration epochs</h3>\n<p>Sentinels require to get authorizations from a majority in order to start a<br>failover for a few important reasons:</p>\n<p>When a Sentinel is authorized, it gets a unique <strong>configuration epoch</strong> for the primary it is failing over. This is a number that will be used to version the new configuration after the failover is completed. Because a majority agreed that a given version was assigned to a given Sentinel, no other Sentinel will be able to use it. This means that every configuration of every failover is versioned with a unique version. We&#39;ll see why this is so important.</p>\n<p>Moreover Sentinels have a rule: if a Sentinel voted another Sentinel for the failover of a given primary, it will wait some time to try to failover the same primary again. This delay is the <code>2 * failover-timeout</code> you can configure in <code>sentinel.conf</code>. This means that Sentinels will not try to failover the same primary at the same time, the first to ask to be authorized will try, if it fails another will try after some time, and so forth.</p>\n<p>Valkey Sentinel guarantees the <em>liveness</em> property that if a majority of Sentinels are able to talk, eventually one will be authorized to failover if the primary is down.</p>\n<p>Valkey Sentinel also guarantees the <em>safety</em> property that every Sentinel will failover the same primary using a different <em>configuration epoch</em>.</p>\n<h3>Configuration propagation</h3>\n<p>Once a Sentinel is able to failover a primary successfully, it will start to broadcast the new configuration so that the other Sentinels will update their information about a given primary.</p>\n<p>For a failover to be considered successful, it requires that the Sentinel was able to send the <code>REPLICAOF NO ONE</code> command to the selected replica, and that the switch to primary was later observed in the <code>INFO</code> output of the primary.</p>\n<p>At this point, even if the reconfiguration of the replicas is in progress, the failover is considered to be successful, and all the Sentinels are required to start reporting the new configuration.</p>\n<p>The way a new configuration is propagated is the reason why we need that every<br>Sentinel failover is authorized with a different version number (configuration epoch).</p>\n<p>Every Sentinel continuously broadcast its version of the configuration of a primary using Valkey Pub/Sub messages, both in the primary and all the replicas.  At the same time all the Sentinels wait for messages to see what is the configuration<br>advertised by the other Sentinels.</p>\n<p>Configurations are broadcast in the <code>__sentinel__:hello</code> Pub/Sub channel.</p>\n<p>Because every configuration has a different version number, the greater version<br>always wins over smaller versions.</p>\n<p>So for example the configuration for the primary <code>mymaster</code> start with all the<br>Sentinels believing the primary is at 192.168.1.50:6379. This configuration<br>has version 1. After some time a Sentinel is authorized to failover with version 2. If the failover is successful, it will start to broadcast a new configuration, let&#39;s say 192.168.1.50:9000, with version 2. All the other instances will see this configuration and will update their configuration accordingly, since the new configuration has a greater version.</p>\n<p>This means that Sentinel guarantees a second liveness property: a set of<br>Sentinels that are able to communicate will all converge to the same configuration with the higher version number.</p>\n<p>Basically if the net is partitioned, every partition will converge to the higher<br>local configuration. In the special case of no partitions, there is a single<br>partition and every Sentinel will agree about the configuration.</p>\n<h3>Consistency under partitions</h3>\n<p>Valkey Sentinel configurations are eventually consistent, so every partition will<br>converge to the higher configuration available.<br>However in a real-world system using Sentinel there are three different players:</p>\n<ul>\n<li>Valkey instances.</li>\n<li>Sentinel instances.</li>\n<li>Clients.</li>\n</ul>\n<p>In order to define the behavior of the system we have to consider all three.</p>\n<p>The following is a simple network where there are 3 nodes, each running<br>a Valkey instance, and a Sentinel instance:</p>\n<pre><code>            +--------------+\n            | Sentinel 1   |----- Client A\n            | Valkey 1 (M) |\n            +--------------+\n                    |\n                    |\n+--------------+    |          +-------------+\n| Sentinel 2   |----+-- // ----| Sentinel 3  |----- Client B\n| Valkey 2 (S) |               | Valkey 3 (M)|\n+--------------+               +-------------+\n</code></pre>\n<p>In this system the original state was that Valkey 3 was the primary, while<br>Valkey 1 and 2 were replicas. A partition occurred isolating the old primary.<br>Sentinels 1 and 2 started a failover promoting Sentinel 1 as the new primary.</p>\n<p>The Sentinel properties guarantee that Sentinel 1 and 2 now have the new<br>configuration for the primary. However Sentinel 3 has still the old configuration<br>since it lives in a different partition.</p>\n<p>We know that Sentinel 3 will get its configuration updated when the network<br>partition will heal, however what happens during the partition if there<br>are clients partitioned with the old primary?</p>\n<p>Clients will be still able to write to Valkey 3, the old primary. When the<br>partition will rejoin, Valkey 3 will be turned into a replica of Valkey 1, and<br>all the data written during the partition will be lost.</p>\n<p>Depending on your configuration you may want or not that this scenario happens:</p>\n<ul>\n<li>If you are using Valkey as a cache, it could be handy that Client B is still able to write to the old primary, even if its data will be lost.</li>\n<li>If you are using Valkey as a store, this is not good and you need to configure the system in order to partially prevent this problem.</li>\n</ul>\n<p>Since Valkey is asynchronously replicated, there is no way to totally prevent data loss in this scenario, however you can bound the divergence between Valkey 3 and Valkey 1<br>using the following Valkey configuration option:</p>\n<pre><code>min-replicas-to-write 1\nmin-replicas-max-lag 10\n</code></pre>\n<p>With the above configuration (please see the self-commented <code>valkey.conf</code> example in the Valkey distribution for more information) a Valkey instance, when acting as a primary, will stop accepting writes if it can&#39;t write to at least 1 replica. Since replication is asynchronous <em>not being able to write</em> actually means that the replica is either disconnected, or is not sending us asynchronous acknowledges for more than the specified <code>max-lag</code> number of seconds.</p>\n<p>Using this configuration the Valkey 3 in the above example will become unavailable after 10 seconds. When the partition heals, the Sentinel 3 configuration will converge to<br>the new one, and Client B will be able to fetch a valid configuration and continue.</p>\n<p>In general Valkey + Sentinel as a whole are an <strong>eventually consistent system</strong> where the merge function is <strong>last failover wins</strong>, and the data from old primaries are discarded to replicate the data of the current primary, so there is always a window for losing acknowledged writes. This is due to Valkey asynchronous<br>replication and the discarding nature of the &quot;virtual&quot; merge function of the system. Note that this is not a limitation of Sentinel itself, and if you orchestrate the failover with a strongly consistent replicated state machine, the same properties will still apply. There are only two ways to avoid losing acknowledged writes:</p>\n<ol>\n<li>Use synchronous replication (and a proper consensus algorithm to run a replicated state machine).</li>\n<li>Use an eventually consistent system where different versions of the same object can be merged.</li>\n</ol>\n<p>Valkey (like it&#39;s predecessor Redis OSS) is currently not able to use any of the above systems, and using them is currently outside the development goals. However, there are proxies implementing solution &quot;2&quot; on top of Redis OSS stores such as SoundCloud <a href=\"https://github.com/soundcloud/roshi\">Roshi</a>, or Netflix <a href=\"https://github.com/Netflix/dynomite\">Dynomite</a>.</p>\n<h2>Sentinel persistent state</h2>\n<p>Sentinel state is persisted in the sentinel configuration file. For example<br>every time a new configuration is received, or created (leader Sentinels), for<br>a primary, the configuration is persisted on disk together with the configuration<br>epoch. This means that it is safe to stop and restart Sentinel processes.</p>\n<h3>TILT mode</h3>\n<p>Valkey Sentinel is heavily dependent on the computer time: for instance in<br>order to understand if an instance is available it remembers the time of the<br>latest successful reply to the PING command, and compares it with the current<br>time to understand how old it is.</p>\n<p>However if the computer time changes in an unexpected way, or if the computer<br>is very busy, or the process blocked for some reason, Sentinel may start to<br>behave in an unexpected way.</p>\n<p>The TILT mode is a special &quot;protection&quot; mode that a Sentinel can enter when<br>something odd is detected that can lower the reliability of the system.<br>The Sentinel timer interrupt is normally called 10 times per second, so we<br>expect that more or less 100 milliseconds will elapse between two calls<br>to the timer interrupt.</p>\n<p>What a Sentinel does is to register the previous time the timer interrupt<br>was called, and compare it with the current call: if the time difference<br>is negative or unexpectedly big (2 seconds or more) the TILT mode is entered<br>(or if it was already entered the exit from the TILT mode postponed).</p>\n<p>When in TILT mode the Sentinel will continue to monitor everything, but:</p>\n<ul>\n<li>It stops acting at all.</li>\n<li>It starts to reply negatively to <code>SENTINEL is-master-down-by-addr</code> requests as the ability to detect a failure is no longer trusted.</li>\n</ul>\n<p>If everything appears to be normal for 30 seconds, the TILT mode is exited.</p>\n<p>In the Sentinel TILT mode, if we send the INFO command, we could get the following response:</p>\n<pre><code>$ valkey-cli -p 26379\n127.0.0.1:26379&gt; info\n(Other information from Sentinel server skipped.)\n\n# Sentinel\nsentinel_masters:1\nsentinel_tilt:0\nsentinel_tilt_since_seconds:-1\nsentinel_running_scripts:0\nsentinel_scripts_queue_length:0\nsentinel_simulate_failure_flags:0\nmaster0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=0,sentinels=1\n</code></pre>\n<p>The field &quot;sentinel_tilt_since_seconds&quot; indicates how many seconds the Sentinel already is in the TILT mode.<br>If it is not in TILT mode, the value will be -1.</p>\n<p>Note that in some ways TILT mode could be replaced using the monotonic clock<br>API that many kernels offer. However it is not still clear if this is a good<br>solution since the current system avoids issues in case the process is just<br>suspended or not executed by the scheduler for a long time.</p>\n<p><strong>A note about the words &quot;master&quot; and &quot;slave&quot; used in this man page</strong>: If not for backward compatibility, the Valkey project no longer uses the words &quot;master&quot; and &quot;slave&quot;. Unfortunately in this command these words are part of the protocol, so we&#39;ll be able to remove such occurrences only when this API will be naturally deprecated.</p>\n"
  },
  {
    "id": "cluster-tutorial",
    "topicName": "Cluster tutorial",
    "description": "Horizontal scaling with Valkey Cluster",
    "htmlContent": "<p>Valkey scales horizontally with a deployment topology called Valkey Cluster.<br>This topic will teach you how to set up, test, and operate Valkey Cluster in production.<br>You will learn about the availability and consistency characteristics of Valkey Cluster from the end user&#39;s point of view.</p>\n<p>If you plan to run a production Valkey Cluster deployment or want to understand better how Valkey Cluster works internally, consult the <a href=\"cluster-spec.md\">Valkey Cluster specification</a>.</p>\n<h2>Valkey Cluster 101</h2>\n<p>Valkey Cluster provides a way to run a Valkey installation where data is automatically sharded across multiple Valkey nodes.<br>Valkey Cluster also provides some degree of availability during partitions&mdash;in practical terms, the ability to continue operations when some nodes fail or are unable to communicate.<br>However, the cluster will become unavailable in the event of larger failures (for example, when the majority of primaries are unavailable).</p>\n<p>So, with Valkey Cluster, you get the ability to:</p>\n<ul>\n<li>Automatically split your dataset among multiple nodes.</li>\n<li>Continue operations when a subset of the nodes are experiencing failures or are unable to communicate with the rest of the cluster.</li>\n</ul>\n<h4>Valkey Cluster TCP ports</h4>\n<p>Every Valkey Cluster node requires two open TCP connections: a Valkey TCP port used to serve clients, e.g., 6379, and second port known as the <em>cluster bus port</em>.<br>By default, the cluster bus port is set by adding 10000 to the data port (e.g., 16379); however, you can override this in the <code>cluster-port</code> configuration.</p>\n<p>Cluster bus is a node-to-node communication channel that uses a binary protocol, which is more suited to exchanging information between nodes due to<br>little bandwidth and processing time.<br>Nodes use the cluster bus for failure detection, configuration updates, failover authorization, and so forth.<br>Clients should never try to communicate with the cluster bus port, but rather use the Valkey command port.<br>However, make sure you open both ports in your firewall, otherwise Valkey cluster nodes won&#39;t be able to communicate.</p>\n<p>For a Valkey Cluster to work properly you need, for each node:</p>\n<ol>\n<li>The client communication port (usually 6379) used to communicate with clients and be open to all the clients that need to reach the cluster, plus all the other cluster nodes that use the client port for key migrations.</li>\n<li>The cluster bus port must be reachable from all the other cluster nodes.</li>\n</ol>\n<p>If you don&#39;t open both TCP ports, your cluster will not work as expected.</p>\n<h4>Valkey Cluster and Docker</h4>\n<p>Currently, Valkey Cluster does not support NATted environments and in general<br>environments where IP addresses or TCP ports are remapped.</p>\n<p>Docker uses a technique called <em>port mapping</em>: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.<br>This is useful for running multiple containers using the same ports, at the same time, in the same server.</p>\n<p>To make Docker compatible with Valkey Cluster, you need to use Docker&#39;s <em>host networking mode</em>.<br>Please see the <code>--net=host</code> option in the <a href=\"https://docs.docker.com/engine/userguide/networking/dockernetworks/\">Docker documentation</a> for more information.</p>\n<h4>Valkey Cluster data sharding</h4>\n<p>Valkey Cluster does not use consistent hashing, but a different form of sharding<br>where every key is conceptually part of what we call a <strong>hash slot</strong>.</p>\n<p>There are 16384 hash slots in Valkey Cluster, and to compute the hash<br>slot for a given key, we simply take the CRC16 of the key modulo<br>16384.</p>\n<p>Every node in a Valkey Cluster is responsible for a subset of the hash slots,<br>so, for example, you may have a cluster with 3 nodes, where:</p>\n<ul>\n<li>Node A contains hash slots from 0 to 5500.</li>\n<li>Node B contains hash slots from 5501 to 11000.</li>\n<li>Node C contains hash slots from 11001 to 16383.</li>\n</ul>\n<p>This makes it easy to add and remove cluster nodes. For example, if<br>I want to add a new node D, I need to move some hash slots from nodes A, B, C<br>to D. Similarly, if I want to remove node A from the cluster, I can just<br>move the hash slots served by A to B and C. Once node A is empty,<br>I can remove it from the cluster completely.</p>\n<p>Moving hash slots from a node to another does not require stopping<br>any operations; therefore, adding and removing nodes, or changing the percentage of hash slots held by a node, requires no downtime.</p>\n<p>Valkey Cluster supports multiple key operations as long as all of the keys involved in a single command execution (or whole transaction, or Lua script<br>execution) belong to the same hash slot. The user can force multiple keys<br>to be part of the same hash slot by using a feature called <em>hash tags</em>.</p>\n<p>Hash tags are documented in the Valkey Cluster specification, but the gist is<br>that if there is a substring between {} brackets in a key, only what is<br>inside the string is hashed. For example, the keys <code>user:{123}:profile</code> and <code>user:{123}:account</code> are guaranteed to be in the same hash slot because they share the same hash tag. As a result, you can operate on these two keys in the same multi-key operation.</p>\n<h4>Valkey Cluster primary-replica model</h4>\n<p>To remain available when a subset of primary nodes are failing or are<br>not able to communicate with the majority of nodes, Valkey Cluster uses a<br>primary-replica model where every hash slot has from 1 (the primary itself) to N<br>replicas (N-1 additional replica nodes).</p>\n<p>In our example cluster with nodes A, B, C, if node B fails the cluster is not<br>able to continue, since we no longer have a way to serve hash slots in the<br>range 5501-11000.</p>\n<p>However, when the cluster is created (or at a later time), we add a replica<br>node to every primary, so that the final cluster is composed of A, B, C<br>that are primary nodes, and A1, B1, C1 that are replica nodes.<br>This way, the system can continue if node B fails.</p>\n<p>Node B1 replicates B, and B fails, the cluster will promote node B1 as the new<br>primary and will continue to operate correctly.</p>\n<p>However, note that if nodes B and B1 fail at the same time, Valkey Cluster will not be able to continue to operate.</p>\n<h4>Valkey Cluster consistency guarantees</h4>\n<p>Valkey Cluster does not guarantee <strong>strong consistency</strong>. In practical<br>terms this means that under certain conditions it is possible that Valkey<br>Cluster will lose writes that were acknowledged by the system to the client.</p>\n<p>The first reason why Valkey Cluster can lose writes is because it uses<br>asynchronous replication. This means that during writes the following<br>happens:</p>\n<ul>\n<li>Your client writes to the primary B.</li>\n<li>The primary B replies OK to your client.</li>\n<li>The primary B propagates the write to its replicas B1, B2 and B3.</li>\n</ul>\n<p>As you can see, B does not wait for an acknowledgement from B1, B2, B3 before<br>replying to the client, since this would be a prohibitive latency penalty<br>for Valkey, so if your client writes something, B acknowledges the write,<br>but crashes before being able to send the write to its replicas, one of the<br>replicas (that did not receive the write) can be promoted to primary, losing<br>the write forever.</p>\n<p>This is very similar to what happens with most databases that are<br>configured to flush data to disk every second, so it is a scenario you<br>are already able to reason about because of past experiences with traditional<br>database systems not involving distributed systems. Similarly you can<br>improve consistency by forcing the database to flush data to disk before<br>replying to the client, but this usually results in prohibitively low<br>performance. That would be the equivalent of synchronous replication in<br>the case of Valkey Cluster.</p>\n<p>Basically, there is a trade-off to be made between performance and consistency.</p>\n<p>Valkey Cluster has support for synchronous writes when absolutely needed,<br>implemented via the <code>WAIT</code> command. This makes losing writes a lot less<br>likely. However, note that Valkey Cluster does not implement strong consistency<br>even when synchronous replication is used: it is always possible, under more<br>complex failure scenarios, that a replica that was not able to receive the write<br>will be elected as primary.</p>\n<p>There is another notable scenario where Valkey Cluster will lose writes, that<br>happens during a network partition where a client is isolated with a minority<br>of instances including at least a primary.</p>\n<p>Take as an example our 6 nodes cluster composed of A, B, C, A1, B1, C1,<br>with 3 primaries and 3 replicas. There is also a client, that we will call Z1.</p>\n<p>After a partition occurs, it is possible that in one side of the<br>partition we have A, C, A1, B1, C1, and in the other side we have B and Z1.</p>\n<p>Z1 is still able to write to B, which will accept its writes. If the<br>partition heals in a very short time, the cluster will continue normally.<br>However, if the partition lasts enough time for B1 to be promoted to primary<br>on the majority side of the partition, the writes that Z1 has sent to B<br>in the meantime will be lost.</p>\n<p><strong>Note:</strong><br>There is a <strong>maximum window</strong> to the amount of writes Z1 will be able<br>to send to B: if enough time has elapsed for the majority side of the<br>partition to elect a replica as primary, every primary node in the minority<br>side will have stopped accepting writes.</p>\n<p>This amount of time is a very important configuration directive of Valkey<br>Cluster, and is called the <strong>node timeout</strong>.</p>\n<p>After node timeout has elapsed, a primary node is considered to be failing,<br>and can be replaced by one of its replicas.<br>Similarly, after node timeout has elapsed without a primary node to be able<br>to sense the majority of the other primary nodes, it enters an error state<br>and stops accepting writes.</p>\n<h2>Valkey Cluster configuration parameters</h2>\n<p>We are about to create an example cluster deployment.<br>Before we continue, let&#39;s introduce the configuration parameters that Valkey Cluster introduces<br>in the <code>valkey.conf</code> file.</p>\n<ul>\n<li><strong>cluster-enabled <code>&lt;yes/no&gt;</code></strong>: If yes, enables Valkey Cluster support in a specific Valkey instance. Otherwise the instance starts as a standalone instance as usual.</li>\n<li><strong>cluster-config-file <code>&lt;filename&gt;</code></strong>: Note that despite the name of this option, this is not a user editable configuration file, but the file where a Valkey Cluster node automatically persists the cluster configuration (the state, basically) every time there is a change, in order to be able to re-read it at startup. The file lists things like the other nodes in the cluster, their state, persistent variables, and so forth. Often this file is rewritten and flushed on disk as a result of some message reception.</li>\n<li><strong>cluster-node-timeout <code>&lt;milliseconds&gt;</code></strong>: The maximum amount of time a Valkey Cluster node can be unavailable, without it being considered as failing. If a primary node is not reachable for more than the specified amount of time, it will be failed over by its replicas. This parameter controls other important things in Valkey Cluster. Notably, every node that can&#39;t reach the majority of primary nodes for the specified amount of time, will stop accepting queries.</li>\n<li><strong>cluster-replica-validity-factor <code>&lt;factor&gt;</code></strong>: If set to zero, a replica will always consider itself valid, and will therefore always try to failover a primary, regardless of the amount of time the link between the primary and the replica remained disconnected. If the value is positive, a maximum disconnection time is calculated as the <em>node timeout</em> value multiplied by the factor provided with this option, and if the node is a replica, it will not try to start a failover if the primary link was disconnected for more than the specified amount of time. For example, if the node timeout is set to 5 seconds and the validity factor is set to 10, a replica disconnected from the primary for more than 50 seconds will not try to failover its primary. Note that any value different than zero may result in Valkey Cluster being unavailable after a primary failure if there is no replica that is able to failover it. In that case the cluster will return to being available only when the original primary rejoins the cluster.</li>\n<li><strong>cluster-migration-barrier <code>&lt;count&gt;</code></strong>: Minimum number of replicas a primary will remain connected with, for another replica to migrate to a primary which is no longer covered by any replica. See the appropriate section about replica migration in this tutorial for more information.</li>\n<li><strong>cluster-require-full-coverage <code>&lt;yes/no&gt;</code></strong>: If this is set to yes, as it is by default, the cluster stops accepting writes if some percentage of the key space is not covered by any node. If the option is set to no, the cluster will still serve queries even if only requests about a subset of keys can be processed.</li>\n<li><strong>cluster-allow-reads-when-down <code>&lt;yes/no&gt;</code></strong>: If this is set to no, as it is by default, a node in a Valkey Cluster will stop serving all traffic when the cluster is marked as failed, either when a node can&#39;t reach a quorum of primaries or when full coverage is not met. This prevents reading potentially inconsistent data from a node that is unaware of changes in the cluster. This option can be set to yes to allow reads from a node during the fail state, which is useful for applications that want to prioritize read availability but still want to prevent inconsistent writes. It can also be used for when using Valkey Cluster with only one or two shards, as it allows the nodes to continue serving writes when a primary fails but automatic failover is impossible.</li>\n</ul>\n<h2>Create and use a Valkey Cluster</h2>\n<p>To create and use a Valkey Cluster, follow these steps:</p>\n<ul>\n<li><a href=\"#create-a-valkey-cluster\">Create a Valkey Cluster</a></li>\n<li><a href=\"#interact-with-the-cluster\">Interact with the cluster</a></li>\n<li><a href=\"#write-an-example-app-with-redis-rb-cluster\">Write an example app with redis-rb-cluster</a></li>\n<li><a href=\"#reshard-the-cluster\">Reshard the cluster</a></li>\n<li><a href=\"#a-more-interesting-example-application\">A more interesting example application</a></li>\n<li><a href=\"#test-the-failover\">Test the failover</a></li>\n<li><a href=\"#manual-failover\">Manual failover</a></li>\n<li><a href=\"#add-a-new-node\">Add a new node</a></li>\n<li><a href=\"#remove-a-node\">Remove a node</a></li>\n<li><a href=\"#replica-migration\">Replica migration</a></li>\n<li><a href=\"#upgrade-nodes-in-a-valkey-cluster\">Upgrade nodes in a Valkey Cluster</a></li>\n<li><a href=\"#migrate-to-valkey-cluster\">Migrate to Valkey Cluster</a></li>\n</ul>\n<p>But, first, familiarize yourself with the requirements for creating a cluster.</p>\n<h4>Requirements to create a Valkey Cluster</h4>\n<p>To create a cluster, the first thing you need is to have a few empty Valkey instances running in <em>cluster mode</em>. </p>\n<p>At minimum, set the following directives in the <code>valkey.conf</code> file:</p>\n<pre><code>port 7000\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\nappendonly yes\n</code></pre>\n<p>To enable cluster mode, set the <code>cluster-enabled</code> directive to <code>yes</code>.<br>Every instance also contains the path of a file where the<br>configuration for this node is stored, which by default is <code>nodes.conf</code>.<br>This file is never touched by humans; it is simply generated at startup<br>by the Valkey Cluster instances, and updated every time it is needed.</p>\n<p>Note that the <strong>minimal cluster</strong> that works as expected must contain<br>at least three primary nodes. For deployment, we strongly recommend<br>a six-node cluster, with three primaries and three replicas.</p>\n<p>You can test this locally by creating the following directories named<br>after the port number of the instance you&#39;ll run inside any given directory.</p>\n<p>For example:</p>\n<pre><code>mkdir cluster-test\ncd cluster-test\nmkdir 7000 7001 7002 7003 7004 7005\n</code></pre>\n<p>Create a <code>valkey.conf</code> file inside each of the directories, from 7000 to 7005.<br>As a template for your configuration file just use the small example above,<br>but make sure to replace the port number <code>7000</code> with the right port number<br>according to the directory name.</p>\n<p>You can start each instance as follows, each running in a separate terminal tab:</p>\n<pre><code>cd 7000\nvalkey-server ./valkey.conf\n</code></pre>\n<p>You&#39;ll see from the logs that every node assigns itself a new ID:</p>\n<pre><code>[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&#39;m 97a3a64667477371c4479320d683e4c8db5858b1\n</code></pre>\n<p>This ID will be used forever by this specific instance in order for the instance<br>to have a unique name in the context of the cluster. Every node<br>remembers every other node using this IDs, and not by IP or port.<br>IP addresses and ports may change, but the unique node identifier will never<br>change for all the life of the node. We call this identifier simply <strong>Node ID</strong>.</p>\n<h4>Create a Valkey Cluster</h4>\n<p>Now that we have a number of instances running, you need to create your cluster by writing some meaningful configuration to the nodes.</p>\n<p>You can configure and execute individual instances manually or use the create-cluster script.<br>Let&#39;s go over how you do it manually.</p>\n<p>To create the cluster, run:</p>\n<pre><code>valkey-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\\n127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\\n--cluster-replicas 1\n</code></pre>\n<p>The command used here is <strong>create</strong>, since we want to create a new cluster.<br>The option <code>--cluster-replicas 1</code> means that we want a replica for every primary created.</p>\n<p>The other arguments are the list of addresses of the instances I want to use<br>to create the new cluster.</p>\n<p><code>valkey-cli</code> will propose a configuration. Accept the proposed configuration by typing <strong>yes</strong>.<br>The cluster will be configured and <em>joined</em>, which means that instances will be<br>bootstrapped into talking with each other. Finally, if everything has gone well, you&#39;ll see a message like this:</p>\n<pre><code>[OK] All 16384 slots covered\n</code></pre>\n<p>This means that there is at least one primary instance serving each of the<br>16384 available slots.</p>\n<p>If you don&#39;t want to create a Valkey Cluster by configuring and executing<br>individual instances manually as explained above, there is a much simpler<br>system (but you&#39;ll not learn the same amount of operational details).</p>\n<p>Find the <code>utils/create-cluster</code> directory in the Valkey distribution.<br>There is a script called <code>create-cluster</code> inside (same name as the directory<br>it is contained into), it&#39;s a simple bash script. In order to start<br>a 6 nodes cluster with 3 primaries and 3 replicas just type the following<br>commands:</p>\n<ol>\n<li><code>create-cluster start</code></li>\n<li><code>create-cluster create</code></li>\n</ol>\n<p>Reply to <code>yes</code> in step 2 when the <code>valkey-cli</code> utility wants you to accept<br>the cluster layout.</p>\n<p>You can now interact with the cluster, the first node will start at port 30001<br>by default. When you are done, stop the cluster with:</p>\n<ol start=\"3\">\n<li><code>create-cluster stop</code></li>\n</ol>\n<p>Please read the <code>README</code> inside this directory for more information on how<br>to run the script.</p>\n<h4>Interact with the cluster</h4>\n<p>To connect to Valkey Cluster, you&#39;ll need a cluster-aware Valkey client.<br>See the documentation for your <a href=\"../clients/\">client of choice</a> to determine its cluster support.</p>\n<p>You can also test your Valkey Cluster using the <code>valkey-cli</code> command line utility:</p>\n<pre><code>$ valkey-cli -c -p 7000\n127.0.0.1:7000&gt; set foo bar\n-&gt; Redirected to slot [12182] located at 127.0.0.1:7002\nOK\n127.0.0.1:7002&gt; set hello world\n-&gt; Redirected to slot [866] located at 127.0.0.1:7000\nOK\n127.0.0.1:7000&gt; get foo\n-&gt; Redirected to slot [12182] located at 127.0.0.1:7002\n&quot;bar&quot;\n127.0.0.1:7002&gt; get hello\n-&gt; Redirected to slot [866] located at 127.0.0.1:7000\n&quot;world&quot;\n</code></pre>\n<p><strong>Note:</strong><br>If you created the cluster using the script, your nodes may listen<br>on different ports, starting from 30001 by default.</p>\n<p>The <code>valkey-cli</code> cluster support is very basic, so it always uses the fact that<br>Valkey Cluster nodes are able to redirect a client to the right node.<br>A serious client is able to do better than that, and cache the map between<br>hash slots and nodes addresses, to directly use the right connection to the<br>right node. The map is refreshed only when something changed in the cluster<br>configuration, for example after a failover or after the system administrator<br>changed the cluster layout by adding or removing nodes.</p>\n<h4>Write an example app with redis-rb-cluster</h4>\n<p>Before going forward showing how to operate the Valkey Cluster, doing things<br>like a failover, or a resharding, we need to create some example application<br>or at least to be able to understand the semantics of a simple Valkey Cluster<br>client interaction.</p>\n<p>In this way we can run an example and at the same time try to make nodes<br>failing, or start a resharding, to see how Valkey Cluster behaves under real<br>world conditions. It is not very helpful to see what happens while nobody<br>is writing to the cluster.</p>\n<p>This section explains some basic usage of<br><a href=\"https://github.com/antirez/redis-rb-cluster\">redis-rb-cluster</a> showing two<br>examples.<br>The first is the following, and is the<br><a href=\"https://github.com/antirez/redis-rb-cluster/blob/master/example.rb\"><code>example.rb</code></a><br>file inside the redis-rb-cluster distribution:</p>\n<pre><code class=\"language-ruby\">require &#39;./cluster&#39;\n\nif ARGV.length != 2\n    startup_nodes = [\n        {:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7000},\n        {:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7001}\n    ]\nelse\n    startup_nodes = [\n        {:host =&gt; ARGV[0], :port =&gt; ARGV[1].to_i}\n    ]\nend\n\nrc = RedisCluster.new(startup_nodes,32,:timeout =&gt; 0.1)\n\nlast = false\n\nwhile not last\n    begin\n        last = rc.get(&quot;__last__&quot;)\n        last = 0 if !last\n    rescue =&gt; e\n        puts &quot;error #{e.to_s}&quot;\n        sleep 1\n    end\nend\n\n((last.to_i+1)..1000000000).each{|x|\n    begin\n        rc.set(&quot;foo#{x}&quot;,x)\n        puts rc.get(&quot;foo#{x}&quot;)\n        rc.set(&quot;__last__&quot;,x)\n    rescue =&gt; e\n        puts &quot;error #{e.to_s}&quot;\n    end\n    sleep 0.1\n}\n</code></pre>\n<p>The application does a very simple thing, it sets keys in the form <code>foo&lt;number&gt;</code> to <code>number</code>, one after the other. So if you run the program the result is the<br>following stream of commands:</p>\n<ul>\n<li>SET foo0 0</li>\n<li>SET foo1 1</li>\n<li>SET foo2 2</li>\n<li>And so forth...</li>\n</ul>\n<p>The program looks more complex than it should usually as it is designed to<br>show errors on the screen instead of exiting with an exception, so every<br>operation performed with the cluster is wrapped by <code>begin</code> <code>rescue</code> blocks.</p>\n<p>The <strong>line 14</strong> is the first interesting line in the program. It creates the<br>Valkey Cluster object, using as argument a list of <em>startup nodes</em>, the maximum<br>number of connections this object is allowed to take against different nodes,<br>and finally the timeout after a given operation is considered to be failed.</p>\n<p>The startup nodes don&#39;t need to be all the nodes of the cluster. The important<br>thing is that at least one node is reachable. Also note that redis-rb-cluster<br>updates this list of startup nodes as soon as it is able to connect with the<br>first node. You should expect such a behavior with any other serious client.</p>\n<p>Now that we have the Valkey Cluster object instance stored in the <strong>rc</strong> variable,<br>we are ready to use the object like if it was a normal Valkey object instance.</p>\n<p>This is exactly what happens in <strong>line 18 to 26</strong>: when we restart the example<br>we don&#39;t want to start again with <code>foo0</code>, so we store the counter inside<br>Valkey itself. The code above is designed to read this counter, or if the<br>counter does not exist, to assign it the value of zero.</p>\n<p>However note how it is a while loop, as we want to try again and again even<br>if the cluster is down and is returning errors. Normal applications don&#39;t need<br>to be so careful.</p>\n<p><strong>Lines between 28 and 37</strong> start the main loop where the keys are set or<br>an error is displayed.</p>\n<p>Note the <code>sleep</code> call at the end of the loop. In your tests you can remove<br>the sleep if you want to write to the cluster as fast as possible (relatively<br>to the fact that this is a busy loop without real parallelism of course, so<br>you&#39;ll get the usually 10k ops/second in the best of the conditions).</p>\n<p>Normally writes are slowed down in order for the example application to be<br>easier to follow by humans.</p>\n<p>Starting the application produces the following output:</p>\n<pre><code>ruby ./example.rb\n1\n2\n3\n4\n5\n6\n7\n8\n9\n^C (I stopped the program here)\n</code></pre>\n<p>This is not a very interesting program and we&#39;ll use a better one in a moment<br>but we can already see what happens during a resharding when the program<br>is running.</p>\n<h4>Reshard the cluster</h4>\n<p>Now we are ready to try a cluster resharding. To do this, please<br>keep the example.rb program running, so that you can see if there is some<br>impact on the program running. Also, you may want to comment the <code>sleep</code><br>call to have some more serious write load during resharding.</p>\n<p>Resharding basically means to move hash slots from a set of nodes to another<br>set of nodes.<br>Like cluster creation, it is accomplished using the valkey-cli utility.</p>\n<p>To start a resharding, just type:</p>\n<pre><code>valkey-cli --cluster reshard 127.0.0.1:7000\n</code></pre>\n<p>You only need to specify a single node, valkey-cli will find the other nodes<br>automatically.</p>\n<p>Currently valkey-cli is only able to reshard with the administrator support,<br>you can&#39;t just say move 5% of slots from this node to the other one (but<br>this is pretty trivial to implement). So it starts with questions. The first<br>is how much of a resharding do you want to do:</p>\n<pre><code>How many slots do you want to move (from 1 to 16384)?\n</code></pre>\n<p>We can try to reshard 1000 hash slots, that should already contain a non<br>trivial amount of keys if the example is still running without the sleep<br>call.</p>\n<p>Then valkey-cli needs to know what is the target of the resharding, that is,<br>the node that will receive the hash slots.<br>I&#39;ll use the first primary node, that is, 127.0.0.1:7000, but I need<br>to specify the Node ID of the instance. This was already printed in a<br>list by valkey-cli, but I can always find the ID of a node with the following<br>command if I need:</p>\n<pre><code>$ valkey-cli -p 7000 cluster nodes | grep myself\n97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460\n</code></pre>\n<p>Ok so my target node is 97a3a64667477371c4479320d683e4c8db5858b1.</p>\n<p>Now you&#39;ll get asked from what nodes you want to take those keys.<br>I&#39;ll just type <code>all</code> in order to take a bit of hash slots from all the<br>other primary nodes.</p>\n<p>After the final confirmation you&#39;ll see a message for every slot that<br>valkey-cli is going to move from a node to another, and a dot will be printed<br>for every actual key moved from one side to the other.</p>\n<p>While the resharding is in progress you should be able to see your<br>example program running unaffected. You can stop and restart it multiple times<br>during the resharding if you want.</p>\n<p>At the end of the resharding, you can test the health of the cluster with<br>the following command:</p>\n<pre><code>valkey-cli --cluster check 127.0.0.1:7000\n</code></pre>\n<p>All the slots will be covered as usual, but this time the primary at<br>127.0.0.1:7000 will have more hash slots, something around 6461.</p>\n<p>Resharding can be performed automatically without the need to manually<br>enter the parameters in an interactive way. This is possible using a command<br>line like the following:</p>\n<pre><code>valkey-cli --cluster reshard &lt;host&gt;:&lt;port&gt; --cluster-from &lt;node-id&gt; --cluster-to &lt;node-id&gt; --cluster-slots &lt;number of slots&gt; --cluster-yes\n</code></pre>\n<p>This allows to build some automatism if you are likely to reshard often,<br>however currently there is no way for <code>valkey-cli</code> to automatically<br>rebalance the cluster checking the distribution of keys across the cluster<br>nodes and intelligently moving slots as needed. This feature will be added<br>in the future.</p>\n<p>The <code>--cluster-yes</code> option instructs the cluster manager to automatically answer<br>&quot;yes&quot; to the command&#39;s prompts, allowing it to run in a non-interactive mode.<br>Note that this option can also be activated by setting the<br><code>REDISCLI_CLUSTER_YES</code> environment variable.</p>\n<h4>A more interesting example application</h4>\n<p>The example application we wrote early is not very good.<br>It writes to the cluster in a simple way without even checking if what was<br>written is the right thing.</p>\n<p>From our point of view the cluster receiving the writes could just always<br>write the key <code>foo</code> to <code>42</code> to every operation, and we would not notice at<br>all.</p>\n<p>So in the <code>redis-rb-cluster</code> repository, there is a more interesting application<br>that is called <code>consistency-test.rb</code>. It uses a set of counters, by default 1000, and sends <code>INCR</code> commands in order to increment the counters.</p>\n<p>However instead of just writing, the application does two additional things:</p>\n<ul>\n<li>When a counter is updated using <code>INCR</code>, the application remembers the write.</li>\n<li>It also reads a random counter before every write, and check if the value is what we expected it to be, comparing it with the value it has in memory.</li>\n</ul>\n<p>What this means is that this application is a simple <strong>consistency checker</strong>,<br>and is able to tell you if the cluster lost some write, or if it accepted<br>a write that we did not receive acknowledgment for. In the first case we&#39;ll<br>see a counter having a value that is smaller than the one we remember, while<br>in the second case the value will be greater.</p>\n<p>Running the consistency-test application produces a line of output every<br>second:</p>\n<pre><code>$ ruby consistency-test.rb\n925 R (0 err) | 925 W (0 err) |\n5030 R (0 err) | 5030 W (0 err) |\n9261 R (0 err) | 9261 W (0 err) |\n13517 R (0 err) | 13517 W (0 err) |\n17780 R (0 err) | 17780 W (0 err) |\n22025 R (0 err) | 22025 W (0 err) |\n25818 R (0 err) | 25818 W (0 err) |\n</code></pre>\n<p>The line shows the number of <strong>R</strong>eads and <strong>W</strong>rites performed, and the<br>number of errors (query not accepted because of errors since the system was<br>not available).</p>\n<p>If some inconsistency is found, new lines are added to the output.<br>This is what happens, for example, if I reset a counter manually while<br>the program is running:</p>\n<pre><code>$ valkey-cli -h 127.0.0.1 -p 7000 set key_217 0\nOK\n\n(in the other tab I see...)\n\n94774 R (0 err) | 94774 W (0 err) |\n98821 R (0 err) | 98821 W (0 err) |\n102886 R (0 err) | 102886 W (0 err) | 114 lost |\n107046 R (0 err) | 107046 W (0 err) | 114 lost |\n</code></pre>\n<p>When I set the counter to 0 the real value was 114, so the program reports<br>114 lost writes (<code>INCR</code> commands that are not remembered by the cluster).</p>\n<p>This program is much more interesting as a test case, so we&#39;ll use it<br>to test the Valkey Cluster failover.</p>\n<h4>Test the failover</h4>\n<p>To trigger the failover, the simplest thing we can do (that is also<br>the semantically simplest failure that can occur in a distributed system)<br>is to crash a single process, in our case a single primary.</p>\n<p><strong>Note:</strong><br>During this test, you should take a tab open with the consistency test<br>application running.</p>\n<p>We can identify a primary and crash it with the following command:</p>\n<pre><code>$ valkey-cli -p 7000 cluster nodes | grep master\n3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383\n97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422\n</code></pre>\n<p>Ok, so 7000, 7001, and 7002 are primaries. Let&#39;s crash node 7002 with the<br><strong>DEBUG SEGFAULT</strong> command:</p>\n<pre><code>$ valkey-cli -p 7002 debug segfault\nError: Server closed the connection\n</code></pre>\n<p>Now we can look at the output of the consistency test to see what it reported.</p>\n<pre><code>18849 R (0 err) | 18849 W (0 err) |\n23151 R (0 err) | 23151 W (0 err) |\n27302 R (0 err) | 27302 W (0 err) |\n\n... many error warnings here ...\n\n29659 R (578 err) | 29660 W (577 err) |\n33749 R (578 err) | 33750 W (577 err) |\n37918 R (578 err) | 37919 W (577 err) |\n42077 R (578 err) | 42078 W (577 err) |\n</code></pre>\n<p>As you can see during the failover the system was not able to accept 578 reads and 577 writes, however no inconsistency was created in the database. This may<br>sound unexpected as in the first part of this tutorial we stated that Valkey<br>Cluster can lose writes during the failover because it uses asynchronous<br>replication. What we did not say is that this is not very likely to happen<br>because Valkey sends the reply to the client, and the commands to replicate<br>to the replicas, about at the same time, so there is a very small window to<br>lose data. However the fact that it is hard to trigger does not mean that it<br>is impossible, so this does not change the consistency guarantees provided<br>by Valkey cluster.</p>\n<p>We can now check what is the cluster setup after the failover (note that<br>in the meantime I restarted the crashed instance so that it rejoins the<br>cluster as a replica):</p>\n<pre><code>$ valkey-cli -p 7000 cluster nodes\n3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected\na211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected\n97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422\n3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383\n3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected\n</code></pre>\n<p>Now the primaries are running on ports 7000, 7001 and 7005. What was previously<br>a primary, that is the Valkey instance running on port 7002, is now a replica of<br>7005.</p>\n<p>The output of the <code>CLUSTER NODES</code> command may look intimidating, but it is actually pretty simple, and is composed of the following tokens:</p>\n<ul>\n<li>Node ID</li>\n<li>ip:port</li>\n<li>flags: master, replica, myself, fail, ...</li>\n<li>if it is a replica, the Node ID of the master</li>\n<li>Time of the last pending PING still waiting for a reply.</li>\n<li>Time of the last PONG received.</li>\n<li>Configuration epoch for this node (see the Cluster specification).</li>\n<li>Status of the link to this node.</li>\n<li>Slots served...</li>\n</ul>\n<h4>Manual failover</h4>\n<p>Sometimes it is useful to force a failover without actually causing any problem<br>on a primary. For example, to upgrade the Valkey process of one of the<br>primary nodes it is a good idea to failover it to turn it into a replica<br>with minimal impact on availability.</p>\n<p>Manual failovers are supported by Valkey Cluster using the <code>CLUSTER FAILOVER</code><br>command, that must be executed in one of the replicas of the primary you want<br>to failover.</p>\n<p>Manual failovers are special and are safer compared to failovers resulting from<br>actual primary failures. They occur in a way that avoids data loss in the<br>process, by switching clients from the original primary to the new primary only<br>when the system is sure that the new primary processed all the replication stream<br>from the old one.</p>\n<p>This is what you see in the replica log when you perform a manual failover:</p>\n<pre><code># Manual failover user request accepted.\n# Received replication offset for paused primary manual failover: 347540\n# All primary replication stream processed, manual failover can start.\n# Start of election delayed for 0 milliseconds (rank #0, offset 347540).\n# Starting a failover election for epoch 7545.\n# Failover election won: I&#39;m the new primary.\n</code></pre>\n<p>Clients sending write commands to the primary are blocked during the failover.<br>When the primary sends its replication offset to the replica, the replica<br>waits to reach the offset on its side. When the replication offset is reached,<br>the failover starts, and the old primary is informed about the configuration<br>switch. When the switch is complete, the clients are unblocked on the old<br>primary and they are redirected to the new primary.</p>\n<p><strong>Note:</strong><br>To promote a replica to primary, it must first be known as a replica by a majority of the primaries in the cluster.<br>  Otherwise, it cannot win the failover election.<br>  If the replica has just been added to the cluster (see <a href=\"#add-a-new-node-as-a-replica\">Add a new node as a replica</a>), you may need to wait a while before sending the <code>CLUSTER FAILOVER</code> command, to make sure the primaries in cluster are aware of the new replica.</p>\n<h4>Add a new node</h4>\n<p>Adding a new node is basically the process of adding an empty node and then<br>moving some data into it, in case it is a new primary, or telling it to<br>setup as a replica of a known node, in case it is a replica.</p>\n<p>We&#39;ll show both, starting with the addition of a new primary instance.</p>\n<p>In both cases the first step to perform is <strong>adding an empty node</strong>.</p>\n<p>This is as simple as to start a new node in port 7006 (we already used<br>from 7000 to 7005 for our existing 6 nodes) with the same configuration<br>used for the other nodes, except for the port number, so what you should<br>do in order to conform with the setup we used for the previous nodes:</p>\n<ul>\n<li>Create a new tab in your terminal application.</li>\n<li>Enter the <code>cluster-test</code> directory.</li>\n<li>Create a directory named <code>7006</code>.</li>\n<li>Create a valkey.conf file inside, similar to the one used for the other nodes but using 7006 as port number.</li>\n<li>Finally start the server with <code>../valkey-server ./valkey.conf</code></li>\n</ul>\n<p>At this point the server should be running.</p>\n<p>Now we can use <strong>valkey-cli</strong> as usual in order to add the node to<br>the existing cluster.</p>\n<pre><code>valkey-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000\n</code></pre>\n<p>As you can see I used the <strong>add-node</strong> command specifying the address of the<br>new node as first argument, and the address of a random existing node in the<br>cluster as second argument.</p>\n<p>In practical terms valkey-cli here did very little to help us, it just<br>sent a <code>CLUSTER MEET</code> message to the node, something that is also possible<br>to accomplish manually. However valkey-cli also checks the state of the<br>cluster before to operate, so it is a good idea to perform cluster operations<br>always via valkey-cli even when you know how the internals work.</p>\n<p>Now we can connect to the new node to see if it really joined the cluster:</p>\n<pre><code>valkey 127.0.0.1:7006&gt; cluster nodes\n3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921\n3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected\nf093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected\na211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected\n97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422\n3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383\n</code></pre>\n<p>Note that since this node is already connected to the cluster it is already<br>able to redirect client queries correctly and is generally speaking part of<br>the cluster. However it has two peculiarities compared to the other primaries:</p>\n<ul>\n<li>It holds no data as it has no assigned hash slots.</li>\n<li>Because it is a primary without assigned slots, it does not participate in the election process when a replica wants to become a primary.</li>\n</ul>\n<p>Now it is possible to assign hash slots to this node using the resharding<br>feature of <code>valkey-cli</code>.<br>It is basically useless to show this as we already<br>did in a previous section, there is no difference, it is just a resharding<br>having as a target the empty node.</p>\n<h5>Add a new node as a replica</h5>\n<p>Adding a new replica can be performed in two ways. The obvious one is to<br>use valkey-cli again, but with the --cluster-replica option, like this:</p>\n<pre><code>valkey-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-replica\n</code></pre>\n<p>Note that the command line here is exactly like the one we used to add<br>a new primary, so we are not specifying to which primary we want to add<br>the replica. In this case, what happens is that valkey-cli will add the new<br>node as replica of a random primary among the primaries with fewer replicas.</p>\n<p>However you can specify exactly what primary you want to target with your<br>new replica with the following command line:</p>\n<pre><code>valkey-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-replica --cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\n</code></pre>\n<p>This way we assign the new replica to a specific primary.</p>\n<p>A more manual way to add a replica to a specific primary is to add the new<br>node as an empty primary, and then turn it into a replica using the<br><code>CLUSTER REPLICATE</code> command. This also works if the node was added as a replica<br>but you want to move it as a replica of a different primary.</p>\n<p>For example in order to add a replica for the node 127.0.0.1:7005 that is<br>currently serving hash slots in the range 11423-16383, that has a Node ID<br>3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e, all I need to do is to connect<br>with the new node (already added as empty primary) and send the command:</p>\n<pre><code>valkey 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\n</code></pre>\n<p>That&#39;s it. Now we have a new replica for this set of hash slots, and all<br>the other nodes in the cluster already know (after a few seconds needed to<br>update their config). We can verify with the following command:</p>\n<pre><code>$ valkey-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\nf093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 replica 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 replica 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected\n</code></pre>\n<p>The node 3c3a0c... now has two replicas, running on ports 7002 (the existing one) and 7006 (the new one).</p>\n<h4>Remove a node</h4>\n<p>To remove a replica node just use the <code>del-node</code> command of valkey-cli:</p>\n<pre><code>valkey-cli --cluster del-node 127.0.0.1:7000 `&lt;node-id&gt;`\n</code></pre>\n<p>The first argument is just a random node in the cluster, the second argument<br>is the ID of the node you want to remove.</p>\n<p>You can remove a primary node in the same way as well, <strong>however in order to<br>remove a primary node it must be empty</strong>. If the primary is not empty you need<br>to reshard data away from it to all the other primary nodes before.</p>\n<p>An alternative to remove a primary node is to perform a manual failover of it<br>over one of its replicas and remove the node after it turned into a replica of the<br>new primary. Obviously this does not help when you want to reduce the actual<br>number of primaries in your cluster, in that case, a resharding is needed.</p>\n<p>There is a special scenario where you want to remove a failed node.<br>You should not use the <code>del-node</code> command because it tries to connect to all nodes and you will encounter a &quot;connection refused&quot; error.<br>Instead, you can use the <code>call</code> command:</p>\n<pre><code>valkey-cli --cluster call 127.0.0.1:7000 cluster forget `&lt;node-id&gt;`\n</code></pre>\n<p>This command will execute <code>CLUSTER FORGET</code> command on every node. </p>\n<h4>Replica migration</h4>\n<p>In Valkey Cluster, you can reconfigure a replica to replicate with a<br>different primary at any time just using this command:</p>\n<pre><code>CLUSTER REPLICATE &lt;master-node-id&gt;\n</code></pre>\n<p>However there is a special scenario where you want replicas to move from one<br>primary to another one automatically, without the help of the system administrator.<br>The automatic reconfiguration of replicas is called <em>replicas migration</em> and is<br>able to improve the reliability of a Valkey Cluster.</p>\n<p><strong>Note:</strong><br>You can read the details of replicas migration in the <a href=\"cluster-spec.md\">Valkey Cluster Specification</a>, here we&#39;ll only provide some information about the<br>general idea and what you should do in order to benefit from it.</p>\n<p>The reason why you may want to let your cluster replicas to move from one primary<br>to another under certain condition, is that usually the Valkey Cluster is as<br>resistant to failures as the number of replicas attached to a given primary.</p>\n<p>For example a cluster where every primary has a single replica can&#39;t continue<br>operations if the primary and its replica fail at the same time, simply because<br>there is no other instance to have a copy of the hash slots the primary was<br>serving. However while net-splits are likely to isolate a number of nodes<br>at the same time, many other kind of failures, like hardware or software failures<br>local to a single node, are a very notable class of failures that are unlikely<br>to happen at the same time, so it is possible that in your cluster where<br>every primary has a replica, the replica is killed at 4am, and the primary is killed<br>at 6am. This still will result in a cluster that can no longer operate.</p>\n<p>To improve reliability of the system we have the option to add additional<br>replicas to every primary, but this is expensive. Replica migration allows to<br>add more replicas to just a few primaries. So you have 10 primaries with 1 replica<br>each, for a total of 20 instances. However you add, for example, 3 instances<br>more as replicas of some of your primaries, so certain primaries will have more<br>than a single replica.</p>\n<p>With replicas migration what happens is that if a primary is left without<br>replicas, a replica from a primary that has multiple replicas will migrate to<br>the <em>orphaned</em> primary. So after your replica goes down at 4am as in the example<br>we made above, another replica will take its place, and when the primary<br>will fail as well at 5am, there is still a replica that can be elected so that<br>the cluster can continue to operate.</p>\n<p>So what you should know about replicas migration in short?</p>\n<ul>\n<li>The cluster will try to migrate a replica from the primary that has the greatest number of replicas in a given moment.</li>\n<li>To benefit from replica migration you have just to add a few more replicas to a single primary in your cluster, it does not matter what primary.</li>\n<li>There is a configuration parameter that controls the replica migration feature that is called <code>cluster-migration-barrier</code>: you can read more about it in the example <code>valkey.conf</code> file provided with Valkey Cluster.</li>\n</ul>\n<h4>Upgrade nodes in a Valkey Cluster</h4>\n<p>Upgrading replica nodes is easy since you just need to stop the node and restart<br>it with an updated version of Valkey. If there are clients scaling reads using<br>replica nodes, they should be able to reconnect to a different replica if a given<br>one is not available.</p>\n<p>Upgrading primaries is a bit more complex. The suggested procedure is to trigger<br>a manual failover to turn the old primary into a replica and then upgrading it.</p>\n<p>A complete rolling upgrade of all nodes in a cluster can be performed by<br>repeating the following procedure for each shard (a primary and its replicas):</p>\n<ol>\n<li><p>Add one or more upgraded nodes as new replicas to the primary. This step is<br>optional but it ensures that the number of replicas is not compromised during<br>the rolling upgrade. To add a new node, use <a href=\"../commands/cluster-meet.md\"><code>CLUSTER MEET</code></a> and <a href=\"../commands/cluster-replicate.md\"><code>CLUSTER REPLICATE</code></a> or use <code>valkey-cli</code> as<br>described under <a href=\"#add-a-new-node-as-a-replica\">Add a new node as a replica</a>.</p>\n<p>An alternative is to upgrade one replica at a time and have fewer replicas<br>online during the upgrade.</p>\n</li>\n<li><p>Upgrade the old replicas you want to keep by restarting them with the updated<br>version of Valkey. If you&#39;re replacing all the old nodes with new nodes, you<br>can skip this step.</p>\n</li>\n<li><p>Select one of the upgraded replicas to be the new primary. Wait until this<br>replica has caught up the replication offset with the primary. You can use<br><a href=\"../commands/info.md\"><code>INFO REPLICATION</code></a> and check for the line<br><code>master_link_status:up</code> to be present. This indicates that the initial sync<br>with the primary is complete.</p>\n<p>After the initial full sync, the replica might still lag behind in<br>replication. Send <code>INFO REPLICATION</code> to the primary and the replica and<br>compare the field <code>master_repl_offset</code> returned by both nodes. If the offsets<br>match, it means that all writes have been replicated. However, if the primary<br>receives a constant stream of writes, it&#39;s possible that the offsets will<br>never be equal. In this step, you can accept a small difference. It&#39;s usually<br>enough to wait for some seconds to minimize the difference.</p>\n</li>\n<li><p>Check that the new replica is known by all nodes in the cluster, or at least<br>by the primaries in the cluster. You can send <a href=\"../commands/cluster-nodes.md\"><code>CLUSTER NODES</code></a> to each of the nodes in the cluster and<br>check that they all are aware of the new node. Wait for some time and repeat<br>the check if necessary.</p>\n</li>\n<li><p>Trigger a manual failover by sending <a href=\"../commands/cluster-failover.md\"><code>CLUSTER FAILOVER</code></a> to the replica node selected to<br>become the new primary. See the <a href=\"#manual-failover\">Manual failover</a> section<br>in this document for more information.</p>\n</li>\n<li><p>Wait for the failover to complete. To check, you can use<br><a href=\"../commands/role.md\"><code>ROLE</code></a>, <a href=\"../commands/info.md\"><code>INFO REPLICATION</code></a><br>(which indicates <code>role:master</code> after successful failover) or <a href=\"../commands/cluster-nodes.md\"><code>CLUSTER NODES</code></a> to verify that the state of the cluster<br>has changed shortly after the command was sent.</p>\n</li>\n<li><p>Take the old primary (now a replica) out of service, or upgrade it and add it<br>again as a replica. Remove additional replicas kept for redundancy during the<br>upgrade, if any.</p>\n</li>\n</ol>\n<p>Repeat this sequence for each shard (each primary and its replicas) until all<br>nodes in the cluster have been upgraded.</p>\n<h4>Migrate to Valkey Cluster</h4>\n<p>Users willing to migrate to Valkey Cluster may have just a single primary, or<br>may already using a preexisting sharding setup, where keys<br>are split among N nodes, using some in-house algorithm or a sharding algorithm<br>implemented by their client library or Valkey proxy.</p>\n<p>In both cases it is possible to migrate to Valkey Cluster easily, however<br>what is the most important detail is if multiple-keys operations are used<br>by the application, and how. There are three different cases:</p>\n<ol>\n<li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys, are not used. Keys are accessed independently (even if accessed via transactions or Lua scripts grouping multiple commands, about the same key, together).</li>\n<li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys are used but only with keys having the same <strong>hash tag</strong>, which means that the keys used together all have a <code>{...}</code> sub-string that happens to be identical. For example the following multiple keys operation is defined in the context of the same hash tag: <code>SUNION {user:1000}.foo {user:1000}.bar</code>.</li>\n<li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys are used with key names not having an explicit, or the same, hash tag.</li>\n</ol>\n<p>The third case is not handled by Valkey Cluster: the application requires to<br>be modified in order to not use multi keys operations or only use them in<br>the context of the same hash tag.</p>\n<p>Case 1 and 2 are covered, so we&#39;ll focus on those two cases, that are handled<br>in the same way, so no distinction will be made in the documentation.</p>\n<p>Assuming you have your preexisting data set split into N primaries, where<br>N=1 if you have no preexisting sharding, the following steps are needed<br>in order to migrate your data set to Valkey Cluster:</p>\n<ol>\n<li>Stop your clients. No automatic live-migration to Valkey Cluster is currently possible. You may be able to do it orchestrating a live migration in the context of your application / environment.</li>\n<li>Generate an append only file for all of your N primaries using the <code>BGREWRITEAOF</code> command, and waiting for the AOF file to be completely generated.</li>\n<li>Save your AOF files from aof-1 to aof-N somewhere. At this point you can stop your old instances if you wish (this is useful since in non-virtualized deployments you often need to reuse the same computers).</li>\n<li>Create a Valkey Cluster composed of N primaries and zero replicas. You&#39;ll add replicas later. Make sure all your nodes are using the append only file for persistence.</li>\n<li>Stop all the cluster nodes, substitute their append only file with your pre-existing append only files, aof-1 for the first node, aof-2 for the second node, up to aof-N.</li>\n<li>Restart your Valkey Cluster nodes with the new AOF files. They&#39;ll complain that there are keys that should not be there according to their configuration.</li>\n<li>Use <code>valkey-cli --cluster fix</code> command in order to fix the cluster so that keys will be migrated according to the hash slots each node is authoritative or not.</li>\n<li>Use <code>valkey-cli --cluster check</code> at the end to make sure your cluster is ok.</li>\n<li>Restart your clients modified to use a Valkey Cluster aware client library.</li>\n</ol>\n<p>There is an alternative way to import data from external instances to a Valkey<br>Cluster, which is to use the <code>valkey-cli --cluster import</code> command.</p>\n<p>The command moves all the keys of a running instance (deleting the keys from<br>the source instance) to the specified pre-existing Valkey Cluster. </p>\n<p><strong>Note:</strong><br>If not for backward compatibility, the Valkey project no longer uses the words &quot;master&quot; and &quot;slave&quot;. Unfortunately in this command these words are part of the protocol, so we&#39;ll be able to remove such occurrences only when this API will be naturally deprecated.</p>\n<h2>Learn more</h2>\n<ul>\n<li><a href=\"cluster-spec.md\">Valkey Cluster specification</a></li>\n<li><a href=\"https://docs.docker.com/engine/userguide/networking/dockernetworks/\">Docker documentation</a></li>\n</ul>\n"
  },
  {
    "id": "cluster-spec",
    "topicName": "Cluster specification",
    "description": "Detailed specification for Valkey cluster\n",
    "htmlContent": "<p>Welcome to the <strong>Valkey Cluster Specification</strong>. Here you&#39;ll find information<br>about the algorithms and design rationales of Valkey Cluster. This document is a work<br>in progress as it is continuously synchronized with the actual implementation<br>of Valkey.</p>\n<h2>Main properties and rationales of the design</h2>\n<h3>Valkey Cluster goals</h3>\n<p>Valkey Cluster is a distributed implementation of Valkey with the following goals in order of importance in the design:</p>\n<ul>\n<li>High performance and linear scalability up to 1000 nodes. There are no proxies, asynchronous replication is used, and no merge operations are performed on values.</li>\n<li>Acceptable degree of write safety: the system tries (in a best-effort way) to retain all the writes originating from clients connected with the majority of the primary nodes. Usually there are small windows where acknowledged writes can be lost. Windows to lose acknowledged writes are larger when clients are in a minority partition.</li>\n<li>Availability: Valkey Cluster is able to survive partitions where the majority of the primary nodes are reachable and there is at least one reachable replica for every primary node that is no longer reachable. Moreover using <em>replicas migration</em>, primaries no longer replicated by any replica will receive one from a primary which is covered by multiple replicas.</li>\n</ul>\n<h3>Implemented subset</h3>\n<p>Valkey Cluster implements all the single key commands available in the<br>non-distributed version of Valkey. Commands performing complex multi-key<br>operations like set unions and intersections are implemented for cases where<br>all of the keys involved in the operation hash to the same slot.</p>\n<p>Valkey Cluster implements a concept called <strong>hash tags</strong> that can be used<br>to force certain keys to be stored in the same hash slot. However, during<br>manual resharding, multi-key operations may become unavailable for some time<br>while single-key operations are always available.</p>\n<p>Valkey Cluster does not support multiple databases like the standalone version<br>of Valkey. We only support database <code>0</code>; the <code>SELECT</code> command is not allowed.</p>\n<h2>Client and Server roles in the Valkey cluster protocol</h2>\n<p>In Valkey Cluster, nodes are responsible for holding the data,<br>and taking the state of the cluster, including mapping keys to the right nodes.<br>Cluster nodes are also able to auto-discover other nodes, detect non-working<br>nodes, and promote replica nodes to primary when needed in order<br>to continue to operate when a failure occurs.</p>\n<p>To perform their tasks all the cluster nodes are connected using a<br>TCP bus and a binary protocol, called the <strong>Valkey Cluster Bus</strong>.<br>Every node is connected to every other node in the cluster using the cluster<br>bus. Nodes use a gossip protocol to propagate information about the cluster<br>in order to discover new nodes, to send ping packets to make sure all the<br>other nodes are working properly, and to send cluster messages needed to<br>signal specific conditions. The cluster bus is also used in order to<br>propagate Pub/Sub messages across the cluster and to orchestrate manual<br>failovers when requested by users (manual failovers are failovers which<br>are not initiated by the Valkey Cluster failure detector, but by the<br>system administrator directly).</p>\n<p>Since cluster nodes are not able to proxy requests, clients may be redirected<br>to other nodes using redirection errors <code>-MOVED</code> and <code>-ASK</code>.<br>The client is in theory free to send requests to all the nodes in the cluster,<br>getting redirected if needed, so the client is not required to hold the<br>state of the cluster. However clients that are able to cache the map between<br>keys and nodes can improve the performance in a sensible way.</p>\n<h3>Write safety</h3>\n<p>Valkey Cluster uses asynchronous replication between nodes, and <strong>last failover wins</strong> implicit merge function. This means that the last elected primary dataset eventually replaces all the other replicas. There is always a window of time when it is possible to lose writes during partitions. However these windows are very different in the case of a client that is connected to the majority of primaries, and a client that is connected to the minority of primaries.</p>\n<p>Valkey Cluster tries harder to retain writes that are performed by clients connected to the majority of primaries, compared to writes performed in the minority side.<br>The following are examples of scenarios that lead to loss of acknowledged<br>writes received in the majority partitions during failures:</p>\n<ol>\n<li><p>A write may reach a primary, but while the primary may be able to reply to the client, the write may not be propagated to replicas via the asynchronous replication used between primary and replica nodes. If the primary dies without the write reaching the replicas, the write is lost forever if the primary is unreachable for a long enough period that one of its replicas is promoted. This is usually hard to observe in the case of a total, sudden failure of a primary node since primaries try to reply to clients (with the acknowledge of the write) and replicas (propagating the write) at about the same time. However it is a real world failure mode.</p>\n</li>\n<li><p>Another theoretically possible failure mode where writes are lost is the following:</p>\n</li>\n</ol>\n<ul>\n<li>A primary is unreachable because of a partition.</li>\n<li>It gets failed over by one of its replicas.</li>\n<li>After some time it may be reachable again.</li>\n<li>A client with an out-of-date routing table may write to the old primary before it is converted into a replica (of the new primary) by the cluster.</li>\n</ul>\n<p>The second failure mode is unlikely to happen because primary nodes are unable to communicate with the majority of the other primaries for enough time to be failed over will no longer accept writes, and when the partition is fixed writes are still refused for a small amount of time to allow other nodes to inform about configuration changes. This failure mode also requires that the client&#39;s routing table has not yet been updated.</p>\n<p>Writes targeting the minority side of a partition have a larger window in which to get lost. For example, Valkey Cluster loses a non-trivial number of writes on partitions where there is a minority of primaries and at least one or more clients, since all the writes sent to the primaries may potentially get lost if the primaries are failed over in the majority side.</p>\n<p>Specifically, for a primary to be failed over it must be unreachable by the majority of primaries for at least <code>NODE_TIMEOUT</code>, so if the partition is fixed before that time, no writes are lost. When the partition lasts for more than <code>NODE_TIMEOUT</code>, all the writes performed in the minority side up to that point may be lost. However the minority side of a Valkey Cluster will start refusing writes as soon as <code>NODE_TIMEOUT</code> time has elapsed without contact with the majority, so there is a maximum window after which the minority becomes no longer available. Hence, no writes are accepted or lost after that time.</p>\n<h3>Availability</h3>\n<p>Valkey Cluster is not available in the minority side of the partition. In the majority side of the partition assuming that there are at least the majority of primaries and a replica for every unreachable primary, the cluster becomes available again after <code>NODE_TIMEOUT</code> time plus a few more seconds required for a replica to get elected and failover its primary (failovers are usually executed in a matter of 1 or 2 seconds).</p>\n<p>This means that Valkey Cluster is designed to survive failures of a few nodes in the cluster, but it is not a suitable solution for applications that require availability in the event of large net splits.</p>\n<p>In the example of a cluster composed of N primary nodes where every node has a single replica, the majority side of the cluster will remain available as long as a single node is partitioned away, and will remain available with a probability of <code>1-(1/(N*2-1))</code> when two nodes are partitioned away (after the first node fails we are left with <code>N*2-1</code> nodes in total, and the probability of the only primary without a replica to fail is <code>1/(N*2-1))</code>.</p>\n<p>For example, in a cluster with 5 nodes and a single replica per node, there is a <code>1/(5*2-1) = 11.11%</code> probability that after two nodes are partitioned away from the majority, the cluster will no longer be available.</p>\n<p>Thanks to a Valkey Cluster feature called <strong>replicas migration</strong> the Cluster<br>availability is improved in many real world scenarios by the fact that<br>replicas migrate to orphaned primaries (primaries no longer having replicas).<br>So at every successful failure event, the cluster may reconfigure the replicas<br>layout in order to better resist the next failure.</p>\n<h3>Performance</h3>\n<p>In Valkey Cluster nodes don&#39;t proxy commands to the right node in charge for a given key, but instead they redirect clients to the right nodes serving a given portion of the key space.</p>\n<p>Eventually clients obtain an up-to-date representation of the cluster and which node serves which subset of keys, so during normal operations clients directly contact the right nodes in order to send a given command.</p>\n<p>Because of the use of asynchronous replication, nodes do not wait for other nodes&#39; acknowledgment of writes (if not explicitly requested using the <code>WAIT</code> command).</p>\n<p>Also, because multi-key commands are only limited to <em>near</em> keys, data is never moved between nodes except when resharding.</p>\n<p>Normal operations are handled exactly as in the case of a single Valkey instance. This means that in a Valkey Cluster with N primary nodes you can expect the same performance as a single Valkey instance multiplied by N as the design scales linearly. At the same time the query is usually performed in a single round trip, since clients usually retain persistent connections with the nodes, so latency figures are also the same as the single standalone Valkey node case.</p>\n<p>Very high performance and scalability while preserving weak but<br>reasonable forms of data safety and availability is the main goal of<br>Valkey Cluster.</p>\n<h3>Why merge operations are avoided</h3>\n<p>The Valkey Cluster design avoids conflicting versions of the same key-value pair in multiple nodes as in the case of the Valkey data model this is not always desirable. Values in Valkey are often very large; it is common to see lists or sorted sets with millions of elements. Also data types are semantically complex. Transferring and merging these kind of values can be a major bottleneck and/or may require the non-trivial involvement of application-side logic, additional memory to store meta-data, and so forth.</p>\n<p>There are no strict technological limits here. CRDTs or synchronously replicated<br>state machines can model complex data types similar to Valkey. However, the<br>actual run time behavior of such systems would not be similar to Valkey Cluster.<br>Valkey Cluster was designed in order to cover the exact use cases of the<br>non-clustered Valkey deployment.</p>\n<h2>Overview of Valkey Cluster main components</h2>\n<h3>Key distribution model</h3>\n<p>The cluster&#39;s key space is split into 16384 slots, effectively setting an upper limit<br>for the cluster size of 16384 primary nodes (however, the suggested max size of<br>nodes is on the order of ~ 1000 nodes).</p>\n<p>Each primary node in a cluster handles a subset of the 16384 hash slots.<br>The cluster is <strong>stable</strong> when there is no cluster reconfiguration in<br>progress (i.e. where hash slots are being moved from one node to another).<br>When the cluster is stable, a single hash slot will be served by a single node<br>(however the serving node can have one or more replicas that will replace it in the case of net splits or failures,<br>and that can be used in order to scale read operations where reading stale data is acceptable).</p>\n<p>The base algorithm used to map keys to hash slots is the following<br>(read the next paragraph for the hash tag exception to this rule):</p>\n<pre><code>HASH_SLOT = CRC16(key) mod 16384\n</code></pre>\n<p>The CRC16 is specified as follows:</p>\n<ul>\n<li>Name: XMODEM (also known as ZMODEM or CRC-16/ACORN)</li>\n<li>Width: 16 bit</li>\n<li>Poly: 1021 (That is actually x^16 + x^12 + x^5 + 1)</li>\n<li>Initialization: 0000</li>\n<li>Reflect Input byte: False</li>\n<li>Reflect Output CRC: False</li>\n<li>Xor constant to output CRC: 0000</li>\n<li>Output for &quot;123456789&quot;: 31C3</li>\n</ul>\n<p>14 out of 16 CRC16 output bits are used (this is why there is<br>a modulo 16384 operation in the formula above).</p>\n<p>In our tests CRC16 behaved remarkably well in distributing different kinds of<br>keys evenly across the 16384 slots.</p>\n<p><strong>Note</strong>: A reference implementation of the CRC16 algorithm used is available in the Appendix A of this document.</p>\n<h3>Hash tags</h3>\n<p>There is an exception for the computation of the hash slot that is used in order<br>to implement <strong>hash tags</strong>. Hash tags are a way to ensure that multiple keys<br>are allocated in the same hash slot. This is used in order to implement<br>multi-key operations in Valkey Cluster.</p>\n<p>To implement hash tags, the hash slot for a key is computed in a<br>slightly different way in certain conditions.<br>If the key contains a &quot;{...}&quot; pattern only the substring between<br><code>{</code> and <code>}</code> is hashed in order to obtain the hash slot. However since it is<br>possible that there are multiple occurrences of <code>{</code> or <code>}</code> the algorithm is<br>well specified by the following rules:</p>\n<ul>\n<li>IF the key contains a <code>{</code> character.</li>\n<li>AND IF there is a <code>}</code> character to the right of <code>{</code>.</li>\n<li>AND IF there are one or more characters between the first occurrence of <code>{</code> and the first occurrence of <code>}</code>.</li>\n</ul>\n<p>Then instead of hashing the key, only what is between the first occurrence of <code>{</code> and the following first occurrence of <code>}</code> is hashed.</p>\n<p>Examples:</p>\n<ul>\n<li>The two keys <code>{user1000}.following</code> and <code>{user1000}.followers</code> will hash to the same hash slot since only the substring <code>user1000</code> will be hashed in order to compute the hash slot.</li>\n<li>For the key <code>foo{}{bar}</code> the whole key will be hashed as usually since the first occurrence of <code>{</code> is followed by <code>}</code> on the right without characters in the middle.</li>\n<li>For the key <code>foo{{bar}}zap</code> the substring <code>{bar</code> will be hashed, because it is the substring between the first occurrence of <code>{</code> and the first occurrence of <code>}</code> on its right.</li>\n<li>For the key <code>foo{bar}{zap}</code> the substring <code>bar</code> will be hashed, since the algorithm stops at the first valid or invalid (without bytes inside) match of <code>{</code> and <code>}</code>.</li>\n<li>What follows from the algorithm is that if the key starts with <code>{}</code>, it is guaranteed to be hashed as a whole. This is useful when using binary data as key names.</li>\n</ul>\n<h4>Glob-style patterns</h4>\n<p>Commands accepting a glob-style pattern, including <code>KEYS</code>, <code>SCAN</code> and <code>SORT</code>, are optimized for patterns that imply a single slot.<br>This means that if all keys that can match a pattern must belong to a specific slot, only this slot is searched for keys matching the pattern.<br>The pattern slot optimization is introduced in Valkey 8.0.</p>\n<p>The optimization kicks in when the pattern meets the following conditions:</p>\n<ul>\n<li>the pattern contains a hashtag,</li>\n<li>there are no wildcards or escape characters before the hashtag, and</li>\n<li>the hashtag within curly braces doesn&#39;t contain any wildcards or escape characters.</li>\n</ul>\n<p>For example, <code>SCAN 0 MATCH {abc}*</code> can successfully recognize the hashtag and scans only the slot corresponding to <code>abc</code>.<br>However, the patterns <code>*{abc}</code>, <code>{a*c}</code>, or <code>{a\\*bc}</code> cannot recognize the hashtag, so all slots need to be scanned.</p>\n<h4>Hash slot example code</h4>\n<p>Adding the hash tags exception, the following is an implementation of the <code>HASH_SLOT</code> function in Ruby and C language.</p>\n<p>Ruby example code:</p>\n<pre><code>def HASH_SLOT(key)\n    s = key.index &quot;{&quot;\n    if s\n        e = key.index &quot;}&quot;,s+1\n        if e &amp;&amp; e != s+1\n            key = key[s+1..e-1]\n        end\n    end\n    crc16(key) % 16384\nend\n</code></pre>\n<p>C example code:</p>\n<pre><code>unsigned int HASH_SLOT(char *key, int keylen) {\n    int s, e; /* start-end indexes of { and } */\n\n    /* Search the first occurrence of &#39;{&#39;. */\n    for (s = 0; s &lt; keylen; s++)\n        if (key[s] == &#39;{&#39;) break;\n\n    /* No &#39;{&#39; ? Hash the whole key. This is the base case. */\n    if (s == keylen) return crc16(key,keylen) &amp; 16383;\n\n    /* &#39;{&#39; found? Check if we have the corresponding &#39;}&#39;. */\n    for (e = s+1; e &lt; keylen; e++)\n        if (key[e] == &#39;}&#39;) break;\n\n    /* No &#39;}&#39; or nothing between {} ? Hash the whole key. */\n    if (e == keylen || e == s+1) return crc16(key,keylen) &amp; 16383;\n\n    /* If we are here there is both a { and a } on its right. Hash\n     * what is in the middle between { and }. */\n    return crc16(key+s+1,e-s-1) &amp; 16383;\n}\n</code></pre>\n<h3>Cluster node attributes</h3>\n<p>Every node has a unique name in the cluster. The node name is the<br>hex representation of a 160 bit random number, obtained the first time a<br>node is started (usually using /dev/urandom).<br>The node will save its ID in the node configuration file, and will use the<br>same ID forever, or at least as long as the node configuration file is not<br>deleted by the system administrator, or a <em>hard reset</em> is requested<br>via the <code>CLUSTER RESET</code> command.</p>\n<p>The node ID is used to identify every node across the whole cluster.<br>It is possible for a given node to change its IP address without any need<br>to also change the node ID. The cluster is also able to detect the change<br>in IP/port and reconfigure using the gossip protocol running over the cluster<br>bus.</p>\n<p>The node ID is not the only information associated with each node, but is<br>the only one that is always globally consistent. Every node has also the<br>following set of information associated. Some information is about the<br>cluster configuration detail of this specific node, and is eventually<br>consistent across the cluster. Some other information, like the last time<br>a node was pinged, is instead local to each node.</p>\n<p>Every node maintains the following information about other nodes that it is<br>aware of in the cluster: The node ID, IP and port of the node, a set of<br>flags, what is the primary of the node if it is flagged as <code>replica</code>, last time<br>the node was pinged and the last time the pong was received, the current<br><em>configuration epoch</em> of the node (explained later in this specification),<br>the link state and finally the set of hash slots served.</p>\n<p>A detailed <a href=\"../commands/cluster-nodes.md\">explanation of all the node fields</a> is described in the <code>CLUSTER NODES</code> documentation.</p>\n<p>The <code>CLUSTER NODES</code> command can be sent to any node in the cluster and provides the state of the cluster and the information for each node according to the local view the queried node has of the cluster.</p>\n<p>The following is sample output of the <code>CLUSTER NODES</code> command sent to a primary<br>node in a small cluster of three nodes.</p>\n<pre><code>$ valkey-cli cluster nodes\nd1861060fe6a534d42d8a19aeb36600e18785e04 127.0.0.1:6379 myself - 0 1318428930 1 connected 0-1364\n3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 2 connected 1365-2729\nd289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 3 connected 2730-4095\n</code></pre>\n<p>In the above listing the different fields are in order: node id, address:port, flags, last ping sent, last pong received, configuration epoch, link state, slots. Details about the above fields will be covered as soon as we talk of specific parts of Valkey Cluster.</p>\n<h3>The cluster bus</h3>\n<p>Every Valkey Cluster node has an additional TCP port for receiving<br>incoming connections from other Valkey Cluster nodes. This port will be derived by adding 10000 to the data port or it can be specified with the cluster-port config. </p>\n<p>Example 1:</p>\n<p>If a Valkey node is listening for client connections on port 6379,<br>and you do not add cluster-port parameter in valkey.conf,<br>the Cluster bus port 16379 will be opened.</p>\n<p>Example 2:</p>\n<p>If a Valkey node is listening for client connections on port 6379,<br>and you set cluster-port 20000 in valkey.conf,<br>the Cluster bus port 20000 will be opened.</p>\n<p>Node-to-node communication happens exclusively using the Cluster bus and<br>the Cluster bus protocol: a binary protocol composed of frames<br>of different types and sizes. The Cluster bus binary protocol is not<br>publicly documented since it is not intended for external software devices<br>to talk with Valkey Cluster nodes using this protocol. However you can<br>obtain more details about the Cluster bus protocol by reading the<br><code>cluster.h</code> and <code>cluster.c</code> files in the Valkey Cluster source code.</p>\n<h3>Cluster topology</h3>\n<p>Valkey Cluster is a full mesh where every node is connected with every other node using a TCP connection.</p>\n<p>In a cluster of N nodes, every node has N-1 outgoing TCP connections, and N-1 incoming connections.</p>\n<p>These TCP connections are kept alive all the time and are not created on demand.<br>When a node expects a pong reply in response to a ping in the cluster bus, before waiting long enough to mark the node as unreachable, it will try to<br>refresh the connection with the node by reconnecting from scratch.</p>\n<p>While Valkey Cluster nodes form a full mesh, <strong>nodes use a gossip protocol and<br>a configuration update mechanism in order to avoid exchanging too many<br>messages between nodes during normal conditions</strong>, so the number of messages<br>exchanged is not exponential.</p>\n<h3>Node handshake</h3>\n<p>Nodes always accept connections on the cluster bus port, and even reply to<br>pings when received, even if the pinging node is not trusted.<br>However, all other packets will be discarded by the receiving node if the<br>sending node is not considered part of the cluster.</p>\n<p>A node will accept another node as part of the cluster only in two ways:</p>\n<ul>\n<li><p>If a node presents itself with a <code>MEET</code> message (<code>CLUSTER MEET</code> command). A meet message is exactly<br>like a <code>PING</code> message, but forces the receiver to accept the node as part of<br>the cluster. Nodes will send <code>MEET</code> messages to other nodes <strong>only if</strong> the system administrator requests this via <code>CLUSTER MEET ip port</code>.</p>\n</li>\n<li><p>A node will also register another node as part of the cluster if a node that is already trusted will gossip about this other node. So if A knows B, and B knows C, eventually B will send gossip messages to A about C. When this happens, A will register C as part of the network, and will try to connect with C.</p>\n</li>\n</ul>\n<p>This means that as long as we join nodes in any connected graph, they&#39;ll eventually form a fully connected graph automatically. This means that the cluster is able to auto-discover other nodes, but only if there is a trusted relationship that was forced by the system administrator.</p>\n<p>This mechanism makes the cluster more robust but prevents different Valkey clusters from accidentally mixing after change of IP addresses or other network related events.</p>\n<h2>Redirection and resharding</h2>\n<h3>MOVED Redirection</h3>\n<p>A Valkey client is free to send queries to every node in the cluster, including<br>replica nodes. The node will analyze the query, and if it is acceptable<br>(that is, only a single key is mentioned in the query, or the multiple keys<br>mentioned are all to the same hash slot) it will lookup what<br>node is responsible for the hash slot where the key or keys belong.</p>\n<p>If the hash slot is served by the node, the query is simply processed, otherwise<br>the node will check its internal hash slot to node map, and will reply<br>to the client with a MOVED error, like in the following example:</p>\n<pre><code>GET x\n-MOVED 3999 127.0.0.1:6381\n</code></pre>\n<p>The error includes the hash slot of the key (3999) and the endpoint:port of the instance that can serve the query.<br>The client needs to reissue the query to the specified node&#39;s endpoint address and port.<br>The endpoint can be either an IP address, a hostname, or it can be empty (e.g. <code>-MOVED 3999 :6380</code>).<br>An empty endpoint indicates that the server node has an unknown endpoint, and the client should send the next request to the same endpoint as the current request but with the provided port. </p>\n<p>Note that even if the client waits a long time before reissuing the query,<br>and in the meantime the cluster configuration changed, the destination node<br>will reply again with a MOVED error if the hash slot 3999 is now served by<br>another node. The same happens if the contacted node had no updated information.</p>\n<p>So while from the point of view of the cluster nodes are identified by<br>IDs we try to simplify our interface with the client just exposing a map<br>between hash slots and Valkey nodes identified by endpoint:port pairs.</p>\n<p>The client is not required to, but should try to memorize that hash slot<br>3999 is served by 127.0.0.1:6381. This way once a new command needs to<br>be issued it can compute the hash slot of the target key and have a<br>greater chance of choosing the right node.</p>\n<p>An alternative is to just refresh the whole client-side cluster layout<br>using the <code>CLUSTER SHARDS</code>, or the deprecated <code>CLUSTER SLOTS</code>, command<br>when a MOVED redirection is received. When a redirection is encountered, it<br>is likely multiple slots were reconfigured rather than just one, so updating<br>the client configuration as soon as possible is often the best strategy.</p>\n<p>Note that when the Cluster is stable (no ongoing changes in the configuration),<br>eventually all the clients will obtain a map of hash slots -&gt; nodes, making<br>the cluster efficient, with clients directly addressing the right nodes<br>without redirections, proxies or other single point of failure entities.</p>\n<p>A client <strong>must be also able to handle -ASK redirections</strong> that are described<br>later in this document, otherwise it is not a complete Valkey Cluster client.</p>\n<h3>Live resharding</h3>\n<p>Valkey Cluster supports the ability to add and remove nodes while the cluster<br>is running. Adding or removing a node is abstracted into the same<br>operation: moving a hash slot from one node to another. This means<br>that the same basic mechanism can be used in order to rebalance the cluster, add<br>or remove nodes, and so forth.</p>\n<ul>\n<li>To add a new node to the cluster an empty node is added to the cluster and some set of hash slots are moved from existing nodes to the new node.</li>\n<li>To remove a node from the cluster the hash slots assigned to that node are moved to other existing nodes.</li>\n<li>To rebalance the cluster a given set of hash slots are moved between nodes.</li>\n</ul>\n<p>The core of the implementation is the ability to move hash slots around.<br>From a practical point of view a hash slot is just a set of keys, so<br>what Valkey Cluster really does during <em>resharding</em> is to move keys from<br>an instance to another instance. Moving a hash slot means moving all the keys<br>that happen to hash into this hash slot.</p>\n<p>To understand how this works we need to show the <code>CLUSTER</code> subcommands<br>that are used to manipulate the slots translation table in a Valkey Cluster node.</p>\n<p>The following subcommands are available (among others not useful in this case):</p>\n<ul>\n<li><code>CLUSTER ADDSLOTS</code> slot1 [slot2] ... [slotN]</li>\n<li><code>CLUSTER DELSLOTS</code> slot1 [slot2] ... [slotN]</li>\n<li><code>CLUSTER ADDSLOTSRANGE</code> start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]</li>\n<li><code>CLUSTER DELSLOTSRANGE</code> start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]</li>\n<li><code>CLUSTER SETSLOT</code> slot NODE node</li>\n<li><code>CLUSTER SETSLOT</code> slot MIGRATING node</li>\n<li><code>CLUSTER SETSLOT</code> slot IMPORTING node</li>\n</ul>\n<p>The first four commands, <code>ADDSLOTS</code>, <code>DELSLOTS</code>, <code>ADDSLOTSRANGE</code> and <code>DELSLOTSRANGE</code>, are simply used to assign<br>(or remove) slots to a Valkey node. Assigning a slot means to tell a given<br>primary node that it will be in charge of storing and serving content for<br>the specified hash slot.</p>\n<p>After the hash slots are assigned they will propagate across the cluster<br>using the gossip protocol, as specified later in the<br><em>configuration propagation</em> section.</p>\n<p>The <code>ADDSLOTS</code> and <code>ADDSLOTSRANGE</code> commands are usually used when a new cluster is created<br>from scratch to assign each primary node a subset of all the 16384 hash<br>slots available.</p>\n<p>The <code>DELSLOTS</code>  and <code>DELSLOTSRANGE</code> are mainly used for manual modification of a cluster configuration<br>or for debugging tasks: in practice it is rarely used.</p>\n<p>The <code>SETSLOT</code> subcommand is used to assign a slot to a specific node ID if<br>the <code>SETSLOT &lt;slot&gt; NODE</code> form is used. Otherwise the slot can be set in the<br>two special states <code>MIGRATING</code> and <code>IMPORTING</code>. Those two special states<br>are used in order to migrate a hash slot from one node to another.</p>\n<ul>\n<li>When a slot is set as MIGRATING, the node will accept all queries that<br>are about this hash slot, but only if the key in question<br>exists, otherwise the query is forwarded using a <code>-ASK</code> redirection to the<br>node that is target of the migration.</li>\n<li>When a slot is set as IMPORTING, the node will accept all queries that<br>are about this hash slot, but only if the request is<br>preceded by an <code>ASKING</code> command. If the <code>ASKING</code> command was not given<br>by the client, the query is redirected to the real hash slot owner via<br>a <code>-MOVED</code> redirection error, as would happen normally.</li>\n</ul>\n<p>Let&#39;s make this clearer with an example of hash slot migration.<br>Assume that we have two Valkey primary nodes, called A and B.<br>We want to move hash slot 8 from A to B, so we issue commands like this:</p>\n<ul>\n<li>We send B: CLUSTER SETSLOT 8 IMPORTING A</li>\n<li>We send A: CLUSTER SETSLOT 8 MIGRATING B</li>\n</ul>\n<p>All the other nodes will continue to point clients to node &quot;A&quot; every time<br>they are queried with a key that belongs to hash slot 8, so what happens<br>is that:</p>\n<ul>\n<li>All queries about existing keys are processed by &quot;A&quot;.</li>\n<li>All queries about non-existing keys in A are processed by &quot;B&quot;, because &quot;A&quot; will redirect clients to &quot;B&quot;.</li>\n</ul>\n<p>This way we no longer create new keys in &quot;A&quot;.<br>In the meantime, <code>valkey-cli</code> used during reshardings<br>and Valkey Cluster configuration will migrate existing keys in<br>hash slot 8 from A to B.<br>This is performed using the following command:</p>\n<pre><code>CLUSTER GETKEYSINSLOT slot count\n</code></pre>\n<p>The above command will return <code>count</code> keys in the specified hash slot.<br>For keys returned, <code>valkey-cli</code> sends node &quot;A&quot; a <code>MIGRATE</code> command, that<br>will migrate the specified keys from A to B in an atomic way (both instances<br>are locked for the time (usually very small time) needed to migrate keys so<br>there are no race conditions). This is how <code>MIGRATE</code> works:</p>\n<pre><code>MIGRATE target_host target_port &quot;&quot; target_database id timeout KEYS key1 key2 ...\n</code></pre>\n<p><code>MIGRATE</code> will connect to the target instance, send a serialized version of<br>the key, and once an OK code is received, the old key from its own dataset<br>will be deleted. From the point of view of an external client a key exists<br>either in A or B at any given time.</p>\n<p>In Valkey Cluster there is no need to specify a database other than 0, but<br><code>MIGRATE</code> is a general command that can be used for other tasks not<br>involving Valkey Cluster.<br><code>MIGRATE</code> is optimized to be as fast as possible even when moving complex<br>keys such as long lists, but in Valkey Cluster reconfiguring the<br>cluster where big keys are present is not considered a wise procedure if<br>there are latency constraints in the application using the database.</p>\n<p>When the migration process is finally finished, the <code>SETSLOT &lt;slot&gt; NODE &lt;node-id&gt;</code> command is sent to the two nodes involved in the migration in order to<br>set the slots to their normal state again. The same command is usually<br>sent to all other nodes to avoid waiting for the natural<br>propagation of the new configuration across the cluster.</p>\n<h4>Replication of <code>CLUSTER SETSLOT</code></h4>\n<p>Starting from Valkey 8.0, the <code>CLUSTER SETSLOT</code> command is replicated if the replicas are running Valkey version 8.0+.<br>The primary node waits up to 2 seconds, by default, for all healthy replicas to acknowledge the replication.<br>If not all health replicas acknowledge the replication within this time frame, the primary aborts the command,<br>and the client receives a <code>NOREPLICAS Not enough good replicas to write</code> error.<br>Operators can retry the command or customize the timeout using the <code>TIMEOUT</code> parameter to further increase the<br>reliability of live resharding:</p>\n<pre><code>CLUSTER SETSLOT slot [MIGRATING|IMPORTING|NODE] node-id [TIMEOUT timeout]\n</code></pre>\n<p>The <code>timeout</code> is specified in seconds, where a value of 0 indicates an indefinite wait time.</p>\n<p>Replicating the slot information and ensuring acknowledgement from health replicas significantly reduces<br>the likelihood of losing replication states if the primary fails after executing the command.<br>For example, consider a scenario where the target primary node <code>B</code> is finalizing a slot migration.<br>Before the <code>SETSLOT</code> command is replicated to its replica node <code>B</code>, <code>B</code> might send a cluster <code>PONG</code><br>message to the source primary node <code>A</code>, promoting <code>A</code> to relinquish its ownership of the slot in question.<br>If <code>B</code> crashes right after this point, the replica node <code>B</code>, which could be elected as the new primary,<br>would not be aware of the slot ownership transfer without the successful replication of <code>SETSLOT</code>.<br>This would leave the slot without an owner, leading to potential data loss and cluster topology inconsistency.</p>\n<h4>Election in empty shards</h4>\n<p>Starting from Valkey 8.0, Valkey clusters introduce the ability to elect a primary in empty shards.<br>This behavior ensures that even when a shard is in the process of receiving its first slot,<br>a primary can be elected. This prevents scenarios where there would be no primary available in the<br>empty shard to handle redirected requests from the official slot owner,<br>thereby maintaining availability during the live resharding.</p>\n<h3>ASK redirection</h3>\n<p>In the previous section, we briefly talked about ASK redirection. Why can&#39;t<br>we simply use MOVED redirection? Because while MOVED means that<br>we think the hash slot is permanently served by a different node and the<br>next queries should be tried against the specified node. ASK means to<br>send only the next query to the specified node.</p>\n<p>This is needed because the next query about hash slot 8 can be about a<br>key that is still in A, so we always want the client to try A and<br>then B if needed. Since this happens only for one hash slot out of 16384<br>available, the performance hit on the cluster is acceptable.</p>\n<p>We need to force that client behavior, so to make sure<br>that clients will only try node B after A was tried, node B will only<br>accept queries of a slot that is set as IMPORTING if the client sends the<br>ASKING command before sending the query.</p>\n<p>Basically the ASKING command sets a one-time flag on the client that forces<br>a node to serve a query about an IMPORTING slot.</p>\n<p>The full semantics of ASK redirection from the point of view of the client is as follows:</p>\n<ul>\n<li>If ASK redirection is received, send only the query that was redirected to the specified node but continue sending subsequent queries to the old node.</li>\n<li>Start the redirected query with the ASKING command.</li>\n<li>Don&#39;t yet update local client tables to map hash slot 8 to B.</li>\n</ul>\n<p>Once hash slot 8 migration is completed, A will send a MOVED message and<br>the client may permanently map hash slot 8 to the new endpoint and port pair.<br>Note that if a buggy client performs the map earlier this is not<br>a problem since it will not send the ASKING command before issuing the query,<br>so B will redirect the client to A using a MOVED redirection error.</p>\n<p>Slots migration is explained in similar terms but with different wording<br>(for the sake of redundancy in the documentation) in the <code>CLUSTER SETSLOT</code><br>command documentation.</p>\n<p>Starting from Valkey 8.0, when the primary in either the source or target shard fails during live resharding,<br>the primary in the other shard will automatically attempt to update its migrating/importing state to correctly pair<br>with the newly elected primary. If this update is successful, the ASK redirection will continue functioning without<br>requiring administrator intervention. In the event that slot migration fails, administrators can manually resume<br>the interrupted slot migration by running the command <code>valkey-cli --cluster fix &lt;ip:port&gt;</code>.</p>\n<p>Additionally, since Valkey 8.0, replicas are now able to return <code>ASK</code> redirects during slot migrations.<br>This capability was previously unavailable, as replicas were not aware of ongoing slot migrations in earlier versions.<br>See the <a href=\"../commands/readonly.md\">READONLY</a> command.</p>\n<h3>Client connections and redirection handling</h3>\n<p>To be efficient, Valkey Cluster clients maintain a map of the current slot<br>configuration. However, this configuration is not <em>required</em> to be up to date.<br>When contacting the wrong node results in a redirection, the client<br>can update its internal slot map accordingly.</p>\n<p>Clients usually need to fetch a complete list of slots and mapped node<br>addresses in two different situations:</p>\n<ul>\n<li>At startup, to populate the initial slots configuration</li>\n<li>When the client receives a <code>MOVED</code> redirection</li>\n</ul>\n<p>Note that a client may handle the <code>MOVED</code> redirection by updating just the<br>moved slot in its table; however this is usually not efficient because often<br>the configuration of multiple slots will be modified at once. For example, if a<br>replica is promoted to primary, all of the slots served by the old primary will<br>be remapped). It is much simpler to react to a <code>MOVED</code> redirection by<br>fetching the full map of slots to nodes from scratch.</p>\n<p>Client can issue a <code>CLUSTER SLOTS</code> command to retrieve an array of slot<br>ranges and the associated primary and replica nodes serving the specified ranges.</p>\n<p>The following is an example of output of <code>CLUSTER SLOTS</code>:</p>\n<pre><code>127.0.0.1:7000&gt; cluster slots\n1) 1) (integer) 5461\n   2) (integer) 10922\n   3) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7001\n   4) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7004\n2) 1) (integer) 0\n   2) (integer) 5460\n   3) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7000\n   4) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7003\n3) 1) (integer) 10923\n   2) (integer) 16383\n   3) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7002\n   4) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7005\n</code></pre>\n<p>The first two sub-elements of every element of the returned array are the<br>start and end slots of the range. The additional elements represent address-port<br>pairs. The first address-port pair is the primary serving the slot, and the<br>additional address-port pairs are the replicas serving the same slot. Replicas<br>will be listed only when not in an error condition (i.e., when their FAIL flag is not set).</p>\n<p>The first element in the output above says that slots from 5461 to 10922<br>(start and end included) are served by 127.0.0.1:7001, and it is possible<br>to scale read-only load contacting the replica at 127.0.0.1:7004.</p>\n<p><code>CLUSTER SLOTS</code> is not guaranteed to return ranges that cover the full<br>16384 slots if the cluster is misconfigured, so clients should initialize the<br>slots configuration map filling the target nodes with NULL objects, and<br>report an error if the user tries to execute commands about keys<br>that belong to unassigned slots.</p>\n<p>Before returning an error to the caller when a slot is found to<br>be unassigned, the client should try to fetch the slots configuration<br>again to check if the cluster is now configured properly.</p>\n<h3>Multi-keys operations</h3>\n<p>Using hash tags, clients are free to use multi-key operations.<br>For example the following operation is valid:</p>\n<pre><code>MSET {user:1000}.name Angela {user:1000}.surname White\n</code></pre>\n<p>Multi-key operations may become unavailable when a resharding of the<br>hash slot the keys belong to is in progress.</p>\n<p>More specifically, even during a resharding the multi-key operations targeting<br>keys that all exist and all still hash to the same slot (either the source or<br>destination node) are still available.</p>\n<p>Operations on keys that don&#39;t exist or are - during the resharding - split<br>between the source and destination nodes, will generate a <code>-TRYAGAIN</code> error.<br>The client can try the operation after some time, or report back the error.</p>\n<p>As soon as migration of the specified hash slot has terminated, all<br>multi-key operations are available again for that hash slot.</p>\n<h3>Scaling reads using replica nodes</h3>\n<p>Normally replica nodes will redirect clients to the authoritative primary for<br>the hash slot involved in a given command, however clients can use replicas<br>in order to scale reads using the <code>READONLY</code> command.</p>\n<p><code>READONLY</code> tells a Valkey Cluster replica node that the client is ok reading<br>possibly stale data and is not interested in running write queries.</p>\n<p>When the connection is in readonly mode, the cluster will send a redirection<br>to the client only if the operation involves keys not served<br>by the replica&#39;s primary node. This may happen because:</p>\n<ol>\n<li>The client sent a command about hash slots never served by the primary of this replica.</li>\n<li>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</li>\n</ol>\n<p>When this happens the client should update its hash slot map as explained in<br>the previous sections.</p>\n<p>The readonly state of the connection can be cleared using the <code>READWRITE</code> command.</p>\n<h2>Fault Tolerance</h2>\n<h3>Heartbeat and gossip messages</h3>\n<p>Valkey Cluster nodes continuously exchange ping and pong packets. Those two kinds of packets have the same structure, and both carry important configuration information. The only actual difference is the message type field. We&#39;ll refer to the sum of ping and pong packets as <em>heartbeat packets</em>.</p>\n<p>Usually nodes send ping packets that will trigger the receivers to reply with pong packets. However this is not necessarily true. It is possible for nodes to just send pong packets to send information to other nodes about their configuration, without triggering a reply. This is useful, for example, in order to broadcast a new configuration as soon as possible.</p>\n<p>Usually a node will ping a few random nodes every second so that the total number of ping packets sent (and pong packets received) by each node is a constant amount regardless of the number of nodes in the cluster.</p>\n<p>However every node makes sure to ping every other node that hasn&#39;t sent a ping or received a pong for longer than half the <code>NODE_TIMEOUT</code> time. Before <code>NODE_TIMEOUT</code> has elapsed, nodes also try to reconnect the TCP link with another node to make sure nodes are not believed to be unreachable only because there is a problem in the current TCP connection.</p>\n<p>The number of messages globally exchanged can be sizable if <code>NODE_TIMEOUT</code> is set to a small figure and the number of nodes (N) is very large, since every node will try to ping every other node for which they don&#39;t have fresh information every half the <code>NODE_TIMEOUT</code> time.</p>\n<p>For example in a 100 node cluster with a node timeout set to 60 seconds, every node will try to send 99 pings every 30 seconds, with a total amount of pings of 3.3 per second. Multiplied by 100 nodes, this is 330 pings per second in the total cluster.</p>\n<p>There are ways to lower the number of messages, however there have been no<br>reported issues with the bandwidth currently used by Valkey Cluster failure<br>detection, so for now the obvious and direct design is used. Note that even<br>in the above example, the 330 packets per second exchanged are evenly<br>divided among 100 different nodes, so the traffic each node receives<br>is acceptable.</p>\n<h3>Heartbeat packet content</h3>\n<p>Ping and pong packets contain a header that is common to all types of packets (for instance packets to request a failover vote), and a special gossip section that is specific to Ping and Pong packets.</p>\n<p>The common header has the following information:</p>\n<ul>\n<li>Node ID, a 160 bit pseudorandom string that is assigned the first time a node is created and remains the same for all the life of a Valkey Cluster node.</li>\n<li>The <code>currentEpoch</code> and <code>configEpoch</code> fields of the sending node that are used to mount the distributed algorithms used by Valkey Cluster (this is explained in detail in the next sections). If the node is a replica the <code>configEpoch</code> is the last known <code>configEpoch</code> of its primary.</li>\n<li>The node flags, indicating if the node is a replica, a primary, and other single-bit node information.</li>\n<li>A bitmap of the hash slots served by the sending node, or if the node is a replica, a bitmap of the slots served by its primary.</li>\n<li>The sender TCP base port that is the port used by Valkey to accept client commands.</li>\n<li>The cluster port that is the port used by Valkey for node-to-node communication.</li>\n<li>The state of the cluster from the point of view of the sender (down or ok).</li>\n<li>The primary node ID of the sending node, if it is a replica.</li>\n</ul>\n<p>Ping and pong packets also contain a gossip section. This section offers to the receiver a view of what the sender node thinks about other nodes in the cluster. The gossip section only contains information about a few random nodes among the set of nodes known to the sender. The number of nodes mentioned in a gossip section is proportional to the cluster size.</p>\n<p>For every node added in the gossip section the following fields are reported:</p>\n<ul>\n<li>Node ID.</li>\n<li>IP and port of the node.</li>\n<li>Node flags.</li>\n</ul>\n<p>Gossip sections allow receiving nodes to get information about the state of other nodes from the point of view of the sender. This is useful both for failure detection and to discover other nodes in the cluster.</p>\n<h3>Failure detection</h3>\n<p>Valkey Cluster failure detection is used to recognize when a primary or replica node is no longer reachable by the majority of nodes and then respond by promoting a replica to the role of primary. When replica promotion is not possible the cluster is put in an error state to stop receiving queries from clients.</p>\n<p>As already mentioned, every node takes a list of flags associated with other known nodes. There are two flags that are used for failure detection that are called <code>PFAIL</code> and <code>FAIL</code>. <code>PFAIL</code> means <em>Possible failure</em>, and is a non-acknowledged failure type. <code>FAIL</code> means that a node is failing and that this condition was confirmed by a majority of primaries within a fixed amount of time.</p>\n<p><strong>PFAIL flag:</strong></p>\n<p>A node flags another node with the <code>PFAIL</code> flag when the node is not reachable for more than <code>NODE_TIMEOUT</code> time. Both primary and replica nodes can flag another node as <code>PFAIL</code>, regardless of its type.</p>\n<p>The concept of non-reachability for a Valkey Cluster node is that we have an <strong>active ping</strong> (a ping that we sent for which we have yet to get a reply) pending for longer than <code>NODE_TIMEOUT</code>. For this mechanism to work the <code>NODE_TIMEOUT</code> must be large compared to the network round trip time. In order to add reliability during normal operations, nodes will try to reconnect with other nodes in the cluster as soon as half of the <code>NODE_TIMEOUT</code> has elapsed without a reply to a ping. This mechanism ensures that connections are kept alive so broken connections usually won&#39;t result in false failure reports between nodes.</p>\n<p><strong>FAIL flag:</strong></p>\n<p>The <code>PFAIL</code> flag alone is just local information every node has about other nodes, but it is not sufficient to trigger a replica promotion. For a node to be considered down the <code>PFAIL</code> condition needs to be escalated to a <code>FAIL</code> condition.</p>\n<p>As outlined in the node heartbeats section of this document, every node sends gossip messages to every other node including the state of a few random known nodes. Every node eventually receives a set of node flags for every other node. This way every node has a mechanism to signal other nodes about failure conditions they have detected.</p>\n<p>A <code>PFAIL</code> condition is escalated to a <code>FAIL</code> condition when the following set of conditions are met:</p>\n<ul>\n<li>Some node, that we&#39;ll call A, has another node B flagged as <code>PFAIL</code>.</li>\n<li>Node A collected, via gossip sections, information about the state of B from the point of view of the majority of primaries in the cluster.</li>\n<li>The majority of primaries signaled the <code>PFAIL</code> or <code>FAIL</code> condition within <code>NODE_TIMEOUT * FAIL_REPORT_VALIDITY_MULT</code> time. (The validity factor is set to 2 in the current implementation, so this is just two times the <code>NODE_TIMEOUT</code> time).</li>\n</ul>\n<p>If all the above conditions are true, Node A will:</p>\n<ul>\n<li>Mark the node as <code>FAIL</code>.</li>\n<li>Send a <code>FAIL</code> message (as opposed to a <code>FAIL</code> condition within a heartbeat message) to all the reachable nodes.</li>\n</ul>\n<p>The <code>FAIL</code> message will force every receiving node to mark the node in <code>FAIL</code> state, whether or not it already flagged the node in <code>PFAIL</code> state.</p>\n<p>Note that <em>the FAIL flag is mostly one way</em>. That is, a node can go from <code>PFAIL</code> to <code>FAIL</code>, but a <code>FAIL</code> flag can only be cleared in the following situations:</p>\n<ul>\n<li>The node is already reachable and is a replica. In this case the <code>FAIL</code> flag can be cleared as replicas are not failed over.</li>\n<li>The node is already reachable and is a primary not serving any slot. In this case the <code>FAIL</code> flag can be cleared as primaries without slots do not really participate in the cluster and are waiting to be configured in order to join the cluster.</li>\n<li>The node is already reachable and is a primary, but a long time (N times the <code>NODE_TIMEOUT</code>) has elapsed without any detectable replica promotion. It&#39;s better for it to rejoin the cluster and continue in this case.</li>\n</ul>\n<p>It is useful to note that while the <code>PFAIL</code> -&gt; <code>FAIL</code> transition uses a form of agreement, the agreement used is weak:</p>\n<ol>\n<li>Nodes collect views of other nodes over some time period, so even if the majority of primary nodes need to &quot;agree&quot;, actually this is just state that we collected from different nodes at different times and we are not sure, nor we require, that at a given moment the majority of primaries agreed. However we discard failure reports which are old, so the failure was signaled by the majority of primaries within a window of time.</li>\n<li>While every node detecting the <code>FAIL</code> condition will force that condition on other nodes in the cluster using the <code>FAIL</code> message, there is no way to ensure the message will reach all the nodes. For instance a node may detect the <code>FAIL</code> condition and because of a partition will not be able to reach any other node.</li>\n</ol>\n<p>However the Valkey Cluster failure detection has a liveness requirement: eventually all the nodes should agree about the state of a given node. There are two cases that can originate from split brain conditions. Either some minority of nodes believe the node is in <code>FAIL</code> state, or a minority of nodes believe the node is not in <code>FAIL</code> state. In both the cases eventually the cluster will have a single view of the state of a given node:</p>\n<p><strong>Case 1</strong>: If a majority of primaries have flagged a node as <code>FAIL</code>, because of failure detection and the <em>chain effect</em> it generates, every other node will eventually flag the primary as <code>FAIL</code>, since in the specified window of time enough failures will be reported.</p>\n<p><strong>Case 2</strong>: When only a minority of primaries have flagged a node as <code>FAIL</code>, the replica promotion will not happen (as it uses a more formal algorithm that makes sure everybody knows about the promotion eventually) and every node will clear the <code>FAIL</code> state as per the <code>FAIL</code> state clearing rules above (i.e. no promotion after N times the <code>NODE_TIMEOUT</code> has elapsed).</p>\n<p><strong>The <code>FAIL</code> flag is only used as a trigger to run the safe part of the algorithm</strong> for the replica promotion. In theory a replica may act independently and start a replica promotion when its primary is not reachable, and wait for the primaries to refuse to provide the acknowledgment if the primary is actually reachable by the majority. However the added complexity of the <code>PFAIL -&gt; FAIL</code> state, the weak agreement, and the <code>FAIL</code> message forcing the propagation of the state in the shortest amount of time in the reachable part of the cluster, have practical advantages. Because of these mechanisms, usually all the nodes will stop accepting writes at about the same time if the cluster is in an error state. This is a desirable feature from the point of view of applications using Valkey Cluster. Also erroneous election attempts initiated by replicas that can&#39;t reach its primary due to local problems (the primary is otherwise reachable by the majority of other primary nodes) are avoided.</p>\n<h2>Configuration handling, propagation, and failovers</h2>\n<h3>Cluster current epoch</h3>\n<p>Valkey Cluster uses a concept similar to the Raft algorithm &quot;term&quot;. In Valkey Cluster the term is called epoch instead, and it is used in order to give incremental versioning to events. When multiple nodes provide conflicting information, it becomes possible for another node to understand which state is the most up to date.</p>\n<p>The <code>currentEpoch</code> is a 64 bit unsigned number.</p>\n<p>At node creation every Valkey Cluster node, both replicas and primary nodes, set the <code>currentEpoch</code> to 0.</p>\n<p>Every time a packet is received from another node, if the epoch of the sender (part of the cluster bus messages header) is greater than the local node epoch, the <code>currentEpoch</code> is updated to the sender epoch.</p>\n<p>Because of these semantics, eventually all the nodes will agree to the greatest <code>currentEpoch</code> in the cluster.</p>\n<p>This information is used when the state of the cluster is changed and a node seeks agreement in order to perform some action.</p>\n<p>Currently this happens only during replica promotion, as described in the next section. Basically the epoch is a logical clock for the cluster and dictates that given information wins over one with a smaller epoch.</p>\n<h3>Configuration epoch</h3>\n<p>Every primary always advertises its <code>configEpoch</code> in ping and pong packets along with a bitmap advertising the set of slots it serves.</p>\n<p>The <code>configEpoch</code> is set to zero in primaries when a new node is created.</p>\n<p>A new <code>configEpoch</code> is created during replica election. Replicas trying to replace<br>failing primaries increment their epoch and try to get authorization from<br>a majority of primaries. When a replica is authorized, a new unique <code>configEpoch</code><br>is created and the replica turns into a primary using the new <code>configEpoch</code>.</p>\n<p>As explained in the next sections the <code>configEpoch</code> helps to resolve conflicts when different nodes claim divergent configurations (a condition that may happen because of network partitions and node failures).</p>\n<p>Replica nodes also advertise the <code>configEpoch</code> field in ping and pong packets, but in the case of replicas the field represents the <code>configEpoch</code> of its primary as of the last time they exchanged packets. This allows other instances to detect when a replica has an old configuration that needs to be updated (primary nodes will not grant votes to replicas with an old configuration).</p>\n<p>Every time the <code>configEpoch</code> changes for some known node, it is permanently stored in the nodes.conf file by all the nodes that receive this information. The same also happens for the <code>currentEpoch</code> value. These two variables are guaranteed to be saved and <code>fsync-ed</code> to disk when updated before a node continues its operations.</p>\n<p>The <code>configEpoch</code> values generated using a simple algorithm during failovers<br>are guaranteed to be new, incremental, and unique.</p>\n<h3>Replica election and promotion</h3>\n<p>Replica election and promotion is handled by replica nodes, with the help of the primary nodes that vote for the replica to promote.<br>A replica election happens when a primary is in <code>FAIL</code> state from the point of view of at least one of its replicas that has the prerequisites in order to become a primary.</p>\n<p>In order for a replica to promote itself to primary, it needs to start an election and win it. All the replicas for a given primary can start an election if the primary is in <code>FAIL</code> state, however only one replica will win the election and promote itself to primary.</p>\n<p>A replica starts an election when the following conditions are met:</p>\n<ul>\n<li>The replica&#39;s primary is in <code>FAIL</code> state.</li>\n<li>The primary was serving a non-zero number of slots.</li>\n<li>The replica replication link was disconnected from the primary for no longer than a given amount of time, in order to ensure the promoted replica&#39;s data is reasonably fresh. This time is user configurable.</li>\n</ul>\n<p>In order to be elected, the first step for a replica is to increment its <code>currentEpoch</code> counter, and request votes from primary instances.</p>\n<p>Votes are requested by the replica by broadcasting a <code>FAILOVER_AUTH_REQUEST</code> packet to every primary node of the cluster. Then it waits for a maximum time of two times the <code>NODE_TIMEOUT</code> for replies to arrive (but always for at least 2 seconds).</p>\n<p>Once a primary has voted for a given replica, replying positively with a <code>FAILOVER_AUTH_ACK</code>, it can no longer vote for another replica of the same primary for a period of <code>NODE_TIMEOUT * 2</code>. In this period it will not be able to reply to other authorization requests for the same primary. This is not needed to guarantee safety, but useful for preventing multiple replicas from getting elected (even if with a different <code>configEpoch</code>) at around the same time, which is usually not wanted.</p>\n<p>A replica discards any <code>AUTH_ACK</code> replies with an epoch that is less than the <code>currentEpoch</code> at the time the vote request was sent. This ensures it doesn&#39;t count votes intended for a previous election.</p>\n<p>Once the replica receives ACKs from the majority of primaries, it wins the election.<br>Otherwise if the majority is not reached within the period of two times <code>NODE_TIMEOUT</code> (but always at least 2 seconds), the election is aborted and a new one will be tried again after <code>NODE_TIMEOUT * 4</code> (and always at least 4 seconds).</p>\n<h3>Replica rank</h3>\n<p>As soon as a primary is in <code>FAIL</code> state, a replica waits a short period of time before trying to get elected. That delay is computed as follows:</p>\n<pre><code>DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds +\n        REPLICA_RANK * 1000 milliseconds.\n</code></pre>\n<p>The fixed delay ensures that we wait for the <code>FAIL</code> state to propagate across the cluster, otherwise the replica may try to get elected while the primaries are still unaware of the <code>FAIL</code> state, refusing to grant their vote.</p>\n<p>The random delay is used to desynchronize replicas so they&#39;re unlikely to start an election at the same time.</p>\n<p>The <code>REPLICA_RANK</code> is the rank of this replica regarding the amount of replication data it has processed from the primary.<br>Replicas exchange messages when the primary is failing in order to establish a (best effort) rank:<br>the replica with the most updated replication offset is at rank 0, the second most updated at rank 1, and so forth.<br>In this way the most updated replicas try to get elected before others.</p>\n<p>Rank order is not strictly enforced; if a replica of higher rank fails to be<br>elected, the others will try shortly.</p>\n<p>Once a replica wins the election, it obtains a new unique and incremental <code>configEpoch</code> which is higher than that of any other existing primary. It starts advertising itself as primary in ping and pong packets, providing the set of served slots with a <code>configEpoch</code> that will win over the past ones.</p>\n<p>In order to speedup the reconfiguration of other nodes, a pong packet is broadcast to all the nodes of the cluster. Currently unreachable nodes will eventually be reconfigured when they receive a ping or pong packet from another node or will receive an <code>UPDATE</code> packet from another node if the information it publishes via heartbeat packets are detected to be out of date.</p>\n<p>The other nodes will detect that there is a new primary serving the same slots served by the old primary but with a greater <code>configEpoch</code>, and will upgrade their configuration. Replicas of the old primary (or the failed over primary if it rejoins the cluster) will not just upgrade the configuration but will also reconfigure to replicate from the new primary. How nodes rejoining the cluster are configured is explained in the next sections.</p>\n<h3>Masters reply to replica vote request</h3>\n<p>In the previous section, we discussed how replicas try to get elected. This section explains what happens from the point of view of a primary that is requested to vote for a given replica.</p>\n<p>Masters receive requests for votes in form of <code>FAILOVER_AUTH_REQUEST</code> requests from replicas.</p>\n<p>For a vote to be granted the following conditions need to be met:</p>\n<ol>\n<li>A primary only votes a single time for a given epoch, and refuses to vote for older epochs: every primary has a lastVoteEpoch field and will refuse to vote again as long as the <code>currentEpoch</code> in the auth request packet is not greater than the lastVoteEpoch. When a primary replies positively to a vote request, the lastVoteEpoch is updated accordingly, and safely stored on disk.</li>\n<li>A primary votes for a replica only if the replica&#39;s primary is flagged as <code>FAIL</code>.</li>\n<li>Auth requests with a <code>currentEpoch</code> that is less than the primary <code>currentEpoch</code> are ignored. Because of this the primary reply will always have the same <code>currentEpoch</code> as the auth request. If the same replica asks again to be voted, incrementing the <code>currentEpoch</code>, it is guaranteed that an old delayed reply from the primary can not be accepted for the new vote.</li>\n</ol>\n<p>Example of the issue caused by not using rule number 3:</p>\n<p>Primary <code>currentEpoch</code> is 5, lastVoteEpoch is 1 (this may happen after a few failed elections)</p>\n<ul>\n<li>Replica <code>currentEpoch</code> is 3.</li>\n<li>Replica tries to be elected with epoch 4 (3+1), primary replies with an ok with <code>currentEpoch</code> 5, however the reply is delayed.</li>\n<li>Replica will try to be elected again, at a later time, with epoch 5 (4+1), the delayed reply reaches the replica with <code>currentEpoch</code> 5, and is accepted as valid.</li>\n</ul>\n<ol start=\"4\">\n<li>Primaries don&#39;t vote for a replica of the same primary before <code>NODE_TIMEOUT * 2</code> has elapsed if a replica of that primary was already voted for. This is not strictly required as it is not possible for two replicas to win the election in the same epoch. However, in practical terms it ensures that when a replica is elected it has plenty of time to inform the other replicas and avoid the possibility that another replica will win a new election, performing an unnecessary second failover.</li>\n<li>Primaries make no effort to select the best replica in any way. If the replica&#39;s primary is in <code>FAIL</code> state and the primary did not vote in the current term, a positive vote is granted. The best replica is the most likely to start an election and win it before the other replicas, since it will usually be able to start the voting process earlier because of its <em>higher rank</em> as explained in the previous section.</li>\n<li>When a primary refuses to vote for a given replica there is no negative response, the request is simply ignored.</li>\n<li>Primaries don&#39;t vote for replicas sending a <code>configEpoch</code> that is less than any <code>configEpoch</code> in the primary table for the slots claimed by the replica. Remember that the replica sends the <code>configEpoch</code> of its primary, and the bitmap of the slots served by its primary. This means that the replica requesting the vote must have a configuration for the slots it wants to failover that is newer or equal the one of the primary granting the vote.</li>\n</ol>\n<h3>Practical example of configuration epoch usefulness during partitions</h3>\n<p>This section illustrates how the epoch concept is used to make the replica promotion process more resistant to partitions.</p>\n<ul>\n<li>A primary is no longer reachable indefinitely. The primary has three replicas A, B, C.</li>\n<li>Replica A wins the election and is promoted to primary.</li>\n<li>A network partition makes A not available for the majority of the cluster.</li>\n<li>Replica B wins the election and is promoted as primary.</li>\n<li>A partition makes B not available for the majority of the cluster.</li>\n<li>The previous partition is fixed, and A is available again.</li>\n</ul>\n<p>At this point B is down and A is available again with a role of primary (actually <code>UPDATE</code> messages would reconfigure it promptly, but here we assume all <code>UPDATE</code> messages were lost). At the same time, replica C will try to get elected in order to fail over B. This is what happens:</p>\n<ol>\n<li>C will try to get elected and will succeed, since for the majority of primaries its primary is actually down. It will obtain a new incremental <code>configEpoch</code>.</li>\n<li>A will not be able to claim to be the primary for its hash slots, because the other nodes already have the same hash slots associated with a higher configuration epoch (the one of B) compared to the one published by A.</li>\n<li>So, all the nodes will upgrade their table to assign the hash slots to C, and the cluster will continue its operations.</li>\n</ol>\n<p>As you&#39;ll see in the next sections, a stale node rejoining a cluster<br>will usually get notified as soon as possible about the configuration change<br>because as soon as it pings any other node, the receiver will detect it<br>has stale information and will send an <code>UPDATE</code> message.</p>\n<h3>Hash slots configuration propagation</h3>\n<p>An important part of Valkey Cluster is the mechanism used to propagate the information about which cluster node is serving a given set of hash slots. This is vital to both the startup of a fresh cluster and the ability to upgrade the configuration after a replica was promoted to serve the slots of its failing primary.</p>\n<p>The same mechanism allows nodes partitioned away for an indefinite amount of<br>time to rejoin the cluster in a sensible way.</p>\n<p>There are two ways hash slot configurations are propagated:</p>\n<ol>\n<li>Heartbeat messages. The sender of a ping or pong packet always adds information about the set of hash slots it (or its primary, if it is a replica) serves.</li>\n<li><code>UPDATE</code> messages. Since in every heartbeat packet there is information about the sender <code>configEpoch</code> and set of hash slots served, if a receiver of a heartbeat packet finds the sender information is stale, it will send a packet with new information, forcing the stale node to update its info.</li>\n</ol>\n<p>The receiver of a heartbeat or <code>UPDATE</code> message uses certain simple rules in<br>order to update its table mapping hash slots to nodes. When a new Valkey Cluster node is created, its local hash slot table is simply initialized to <code>NULL</code> entries so that each hash slot is not bound or linked to any node. This looks similar to the following:</p>\n<pre><code>0 -&gt; NULL\n1 -&gt; NULL\n2 -&gt; NULL\n...\n16383 -&gt; NULL\n</code></pre>\n<p>The first rule followed by a node in order to update its hash slot table is the following:</p>\n<p><strong>Rule 1</strong>: If a hash slot is unassigned (set to <code>NULL</code>), and a known node claims it, I&#39;ll modify my hash slot table and associate the claimed hash slots to it.</p>\n<p>So if we receive a heartbeat from node A claiming to serve hash slots 1 and 2 with a configuration epoch value of 3, the table will be modified to:</p>\n<pre><code>0 -&gt; NULL\n1 -&gt; A [3]\n2 -&gt; A [3]\n...\n16383 -&gt; NULL\n</code></pre>\n<p>When a new cluster is created, a system administrator needs to manually assign (using the <code>CLUSTER ADDSLOTS</code> command, via the valkey-cli command line tool, or by any other means) the slots served by each primary node only to the node itself, and the information will rapidly propagate across the cluster.</p>\n<p>However this rule is not enough. We know that hash slot mapping can change<br>during two events:</p>\n<ol>\n<li>A replica replaces its primary during a failover.</li>\n<li>A slot is resharded from a node to a different one.</li>\n</ol>\n<p>For now let&#39;s focus on failovers. When a replica fails over its primary, it obtains<br>a configuration epoch which is guaranteed to be greater than the one of its<br>primary (and more generally greater than any other configuration epoch<br>generated previously). For example node B, which is a replica of A, may failover<br>A with configuration epoch of 4. It will start to send heartbeat packets<br>(the first time mass-broadcasting cluster-wide) and because of the following<br>second rule, receivers will update their hash slot tables:</p>\n<p><strong>Rule 2</strong>: If a hash slot is already assigned, and a known node is advertising it using a <code>configEpoch</code> that is greater than the <code>configEpoch</code> of the primary currently associated with the slot, it&#39;ll rebind the hash slot to the new node.</p>\n<p>So after receiving messages from B that claim to serve hash slots 1 and 2 with configuration epoch of 4, the receivers will update their table in the following way:</p>\n<pre><code>0 -&gt; NULL\n1 -&gt; B [4]\n2 -&gt; B [4]\n...\n16383 -&gt; NULL\n</code></pre>\n<p>Liveness property: because of the second rule, eventually all nodes in the cluster will agree that the owner of a slot is the one with the greatest <code>configEpoch</code> among the nodes advertising it.</p>\n<p>This mechanism in Valkey Cluster is called <strong>last failover wins</strong>.</p>\n<p>The same happens during resharding. When a node importing a hash slot completes<br>the import operation, its configuration epoch is incremented to make sure the<br>change will be propagated throughout the cluster.</p>\n<h3>UPDATE messages, a closer look</h3>\n<p>With the previous section in mind, it is easier to see how update messages<br>work. Node A may rejoin the cluster after some time. It will send heartbeat<br>packets where it claims it serves hash slots 1 and 2 with configuration epoch<br>of 3. All the receivers with updated information will instead see that<br>the same hash slots are associated with node B having a higher configuration<br>epoch. Because of this they&#39;ll send an <code>UPDATE</code> message to A with the new<br>configuration for the slots. A will update its configuration because of the<br><strong>rule 2</strong> above.</p>\n<h3>How nodes rejoin the cluster</h3>\n<p>The same basic mechanism is used when a node rejoins a cluster.<br>Continuing with the example above, node A will be notified<br>that hash slots 1 and 2 are now served by B. Assuming that these two were<br>the only hash slots served by A, the count of hash slots served by A will<br>drop to 0! So A will <strong>reconfigure to be a replica of the new primary</strong>.</p>\n<p>The actual rule followed is a bit more complex than this. In general it may<br>happen that A rejoins after a lot of time, in the meantime it may happen that<br>hash slots originally served by A are served by multiple nodes, for example<br>hash slot 1 may be served by B, and hash slot 2 by C.</p>\n<p>So the actual <em>Valkey Cluster node role switch rule</em> is: <strong>A primary node will change its configuration to replicate (be a replica of) the node that stole its last hash slot</strong>.</p>\n<p>During reconfiguration, eventually the number of served hash slots will drop to zero, and the node will reconfigure accordingly. Note that in the base case this just means that the old primary will be a replica of the replica that replaced it after a failover. However in the general form the rule covers all possible cases.</p>\n<p>Replicas do exactly the same: they reconfigure to replicate the node that<br>stole the last hash slot of its former primary.</p>\n<h3>Replica migration</h3>\n<p>Valkey Cluster implements a concept called <em>replica migration</em> in order to<br>improve the availability of the system. The idea is that in a cluster with<br>a primary-replica setup, if the map between replicas and primaries is fixed<br>availability is limited over time if multiple independent failures of single<br>nodes happen.</p>\n<p>For example in a cluster where every primary has a single replica, the cluster<br>can continue operations as long as either the primary or the replica fail, but not<br>if both fail the same time. However there is a class of failures that are<br>the independent failures of single nodes caused by hardware or software issues<br>that can accumulate over time. For example:</p>\n<ul>\n<li>Master A has a single replica A1.</li>\n<li>Master A fails. A1 is promoted as new primary.</li>\n<li>Three hours later A1 fails in an independent manner (unrelated to the failure of A). No other replica is available for promotion since node A is still down. The cluster cannot continue normal operations.</li>\n</ul>\n<p>If the map between primaries and replicas is fixed, the only way to make the cluster<br>more resistant to the above scenario is to add replicas to every primary, however<br>this is costly as it requires more instances of Valkey to be executed, more<br>memory, and so forth.</p>\n<p>An alternative is to create an asymmetry in the cluster, and let the cluster<br>layout automatically change over time. For example the cluster may have three<br>primaries A, B, C. A and B have a single replica each, A1 and B1. However, the primary<br>C is different and has two replicas: C1 and C2.</p>\n<p>Replica migration is the process of automatic reconfiguration of a replica<br>in order to <em>migrate</em> to a primary that has no longer coverage (no working<br>replicas). With replica migration the scenario mentioned above turns into the<br>following:</p>\n<ul>\n<li>Master A fails. A1 is promoted.</li>\n<li>C2 migrates as replica of A1, that is otherwise not backed by any replica.</li>\n<li>Three hours later A1 fails as well.</li>\n<li>C2 is promoted as a new primary to replace A1.</li>\n<li>The cluster can continue the operations.</li>\n</ul>\n<h3>Replica migration algorithm</h3>\n<p>The migration algorithm does not use any form of agreement since the replica<br>layout in a Valkey Cluster is not part of the cluster configuration that needs<br>to be consistent and/or versioned with config epochs. Instead it uses an<br>algorithm to avoid mass-migration of replicas when a primary is not backed.<br>The algorithm guarantees that eventually (once the cluster configuration is<br>stable) every primary will be backed by at least one replica.</p>\n<p>This is how the algorithm works. To start we need to define what is a<br><em>good replica</em> in this context: a good replica is a replica not in <code>FAIL</code> state<br>from the point of view of a given node.</p>\n<p>The execution of the algorithm is triggered in every replica that detects that<br>there is at least a single primary without good replicas. However among all the<br>replicas detecting this condition, only a subset should act. This subset is<br>actually often a single replica unless different replicas have in a given moment<br>a slightly different view of the failure state of other nodes.</p>\n<p>The <em>acting replica</em> is the replica among the primaries with the maximum number<br>of attached replicas, that is not in FAIL state and has the smallest node ID.</p>\n<p>So for example if there are 10 primaries with 1 replica each, and 2 primaries with<br>5 replicas each, the replica that will try to migrate is - among the 2 primaries<br>having 5 replicas - the one with the lowest node ID. Given that no agreement<br>is used, it is possible that when the cluster configuration is not stable,<br>a race condition occurs where multiple replicas believe themselves to be<br>the non-failing replica with the lower node ID (it is unlikely for this to happen<br>in practice). If this happens, the result is multiple replicas migrating to the<br>same primary, which is harmless. If the race happens in a way that will leave<br>the ceding primary without replicas, as soon as the cluster is stable again<br>the algorithm will be re-executed again and will migrate a replica back to<br>the original primary.</p>\n<p>Eventually every primary will be backed by at least one replica. However,<br>the normal behavior is that a single replica migrates from a primary with<br>multiple replicas to an orphaned primary.</p>\n<p>The algorithm is controlled by a user-configurable parameter called<br><code>cluster-migration-barrier</code>: the number of good replicas a primary<br>must be left with before a replica can migrate away. For example, if this<br>parameter is set to 2, a replica can try to migrate only if its primary remains<br>with two working replicas.</p>\n<h3>configEpoch conflicts resolution algorithm</h3>\n<p>When new <code>configEpoch</code> values are created via replica promotion during<br>failovers, they are guaranteed to be unique.</p>\n<p>However there are two distinct events where new configEpoch values are<br>created in an unsafe way, just incrementing the local <code>currentEpoch</code> of<br>the local node and hoping there are no conflicts at the same time.<br>Both the events are system-administrator triggered:</p>\n<ol>\n<li><code>CLUSTER FAILOVER</code> command with <code>TAKEOVER</code> option is able to manually promote a replica node into a primary <em>without the majority of primaries being available</em>. This is useful, for example, in multi data center setups.</li>\n<li>Migration of slots for cluster rebalancing also generates new configuration epochs inside the local node without agreement for performance reasons.</li>\n</ol>\n<p>Specifically, during manual resharding, when a hash slot is migrated from<br>a node A to a node B, the resharding program will force B to upgrade<br>its configuration to an epoch which is the greatest found in the cluster,<br>plus 1 (unless the node is already the one with the greatest configuration<br>epoch), without requiring agreement from other nodes.<br>Usually a real world resharding involves moving several hundred hash slots<br>(especially in small clusters). Requiring an agreement to generate new<br>configuration epochs during resharding, for each hash slot moved, is<br>inefficient. Moreover it requires a fsync in each of the cluster nodes<br>every time in order to store the new configuration. Because of the way it is<br>performed instead, we only need a new config epoch when the first hash slot is moved,<br>making it much more efficient in production environments.</p>\n<p>However because of the two cases above, it is possible (though unlikely) to end<br>with multiple nodes having the same configuration epoch. A resharding operation<br>performed by the system administrator, and a failover happening at the same<br>time (plus a lot of bad luck) could cause <code>currentEpoch</code> collisions if<br>they are not propagated fast enough.</p>\n<p>Moreover, software bugs and filesystem corruptions can also contribute<br>to multiple nodes having the same configuration epoch.</p>\n<p>When primaries serving different hash slots have the same <code>configEpoch</code>, there<br>are no issues. It is more important that replicas failing over a primary have<br>unique configuration epochs.</p>\n<p>That said, manual interventions or resharding may change the cluster<br>configuration in different ways. The Valkey Cluster main liveness property<br>requires that slot configurations always converge, so under every circumstance<br>we really want all the primary nodes to have a different <code>configEpoch</code>.</p>\n<p>In order to enforce this, <strong>a conflict resolution algorithm</strong> is used in the<br>event that two nodes end up with the same <code>configEpoch</code>.</p>\n<ul>\n<li>IF a primary node detects another primary node is advertising itself with<br>the same <code>configEpoch</code>.</li>\n<li>AND IF the node has a lexicographically smaller Node ID compared to the other node claiming the same <code>configEpoch</code>.</li>\n<li>THEN it increments its <code>currentEpoch</code> by 1, and uses it as the new <code>configEpoch</code>.</li>\n</ul>\n<p>If there are any set of nodes with the same <code>configEpoch</code>, all the nodes but the one with the greatest Node ID will move forward, guaranteeing that, eventually, every node will pick a unique configEpoch regardless of what happened.</p>\n<p>This mechanism also guarantees that after a fresh cluster is created, all<br>nodes start with a different <code>configEpoch</code> (even if this is not actually<br>used) since <code>valkey-cli</code> makes sure to use <code>CLUSTER SET-CONFIG-EPOCH</code> at startup.<br>However if for some reason a node is left misconfigured, it will update<br>its configuration to a different configuration epoch automatically.</p>\n<h3>Node resets</h3>\n<p>Nodes can be software reset (without restarting them) in order to be reused<br>in a different role or in a different cluster. This is useful in normal<br>operations, in testing, and in cloud environments where a given node can<br>be reprovisioned to join a different set of nodes to enlarge or create a new<br>cluster.</p>\n<p>In Valkey Cluster nodes are reset using the <code>CLUSTER RESET</code> command. The<br>command is provided in two variants:</p>\n<ul>\n<li><code>CLUSTER RESET SOFT</code></li>\n<li><code>CLUSTER RESET HARD</code></li>\n</ul>\n<p>The command must be sent directly to the node to reset. If no reset type is<br>provided, a soft reset is performed.</p>\n<p>The following is a list of operations performed by a reset:</p>\n<ol>\n<li>Soft and hard reset: If the node is a replica, it is turned into a primary, and its dataset is discarded. If the node is a primary and contains keys the reset operation is aborted.</li>\n<li>Soft and hard reset: All the slots are released, and the manual failover state is reset.</li>\n<li>Soft and hard reset: All the other nodes in the nodes table are removed, so the node no longer knows any other node.</li>\n<li>Hard reset only: <code>currentEpoch</code>, <code>configEpoch</code>, and <code>lastVoteEpoch</code> are set to 0.</li>\n<li>Hard reset only: the Node ID is changed to a new random ID.</li>\n</ol>\n<p>Master nodes with non-empty data sets can&#39;t be reset (since normally you want to reshard data to the other nodes). However, under special conditions when this is appropriate (e.g. when a cluster is totally destroyed with the intent of creating a new one), <code>FLUSHALL</code> must be executed before proceeding with the reset.</p>\n<h3>Removing nodes from a cluster</h3>\n<p>It is possible to practically remove a node from an existing cluster by<br>resharding all its data to other nodes (if it is a primary node) and<br>shutting it down. However, the other nodes will still remember its node<br>ID and address, and will attempt to connect with it.</p>\n<p>For this reason, when a node is removed we want to also remove its entry<br>from all the other nodes tables. This is accomplished by using the<br><code>CLUSTER FORGET &lt;node-id&gt;</code> command.</p>\n<p>The command does two things:</p>\n<ol>\n<li>It removes the node with the specified node ID from the nodes table.</li>\n<li>It sets a 60 second ban which prevents a node with the same node ID from being re-added.</li>\n</ol>\n<p>The second operation is needed because Valkey Cluster uses gossip in order to auto-discover nodes, so removing the node X from node A, could result in node B gossiping about node X to A again. Because of the 60 second ban, the Valkey Cluster administration tools have 60 seconds in order to remove the node from all the nodes, preventing the re-addition of the node due to auto discovery.</p>\n<p>Further information is available in the <code>CLUSTER FORGET</code> documentation.</p>\n<h2>Publish/Subscribe</h2>\n<p>In a Valkey Cluster, clients can subscribe to every node, and can also<br>publish to every other node. The cluster will make sure that published<br>messages are forwarded as needed.</p>\n<p>The clients can send SUBSCRIBE to any node and can also send PUBLISH to any node.<br>It will simply broadcast each published message to all other nodes.</p>\n<p>Redis OSS 7.0 and later features sharded pub/sub, in which shard channels are assigned to slots by the same algorithm used to assign keys to slots.<br>A shard message must be sent to a node that owns the slot the shard channel is hashed to.<br>The cluster makes sure the published shard messages are forwarded to all nodes in the shard, so clients can subscribe to a shard channel by connecting to either the primary responsible for the slot, or to any of its replicas.</p>\n<h2>Appendix</h2>\n<h3>Appendix A: CRC16 reference implementation in ANSI C</h3>\n<pre><code>/*\n * Copyright 2001-2010 Georges Menie (www.menie.org)\n * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)\n * All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the University of California, Berkeley nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&#39;&#39; AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* CRC16 implementation according to CCITT standards.\n *\n * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the\n * following parameters:\n *\n * Name                       : &quot;XMODEM&quot;, also known as &quot;ZMODEM&quot;, &quot;CRC-16/ACORN&quot;\n * Width                      : 16 bit\n * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)\n * Initialization             : 0000\n * Reflect Input byte         : False\n * Reflect Output CRC         : False\n * Xor constant to output CRC : 0000\n * Output for &quot;123456789&quot;     : 31C3\n */\n\nstatic const uint16_t crc16tab[256]= {\n    0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,\n    0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,\n    0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,\n    0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,\n    0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,\n    0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,\n    0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,\n    0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,\n    0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,\n    0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,\n    0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,\n    0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,\n    0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,\n    0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,\n    0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,\n    0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,\n    0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,\n    0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,\n    0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,\n    0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,\n    0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,\n    0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,\n    0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,\n    0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,\n    0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,\n    0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,\n    0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,\n    0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,\n    0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,\n    0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,\n    0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,\n    0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0\n};\n\nuint16_t crc16(const char *buf, int len) {\n    int counter;\n    uint16_t crc = 0;\n    for (counter = 0; counter &lt; len; counter++)\n            crc = (crc&lt;&lt;8) ^ crc16tab[((crc&gt;&gt;8) ^ *buf++)&amp;0x00FF];\n    return crc;\n}\n</code></pre>\n"
  },
  {
    "id": "admin",
    "topicName": "Administration",
    "description": "Advice for configuring and managing Valkey in production",
    "htmlContent": "<h2>Valkey setup tips</h2>\n<h3>Linux</h3>\n<ul>\n<li><p>Deploy Valkey using the Linux operating system.<br>Valkey is also regularly tested on macOS and FreeBSD, and from time to time on other OpenBSD, NetBSD, DragonFlyBSD and Solaris-derived systems.<br>However, Linux is where most of the stress testing is performed, and where most production deployments are run.</p>\n</li>\n<li><p>Set the Linux kernel overcommit memory setting to 1. Add <code>vm.overcommit_memory = 1</code> to <code>/etc/sysctl.conf</code>. Then, reboot or run the command <code>sysctl vm.overcommit_memory=1</code> to activate the setting. See <a href=\"faq.md#background-saving-fails-with-a-fork-error-on-linux\">FAQ: Background saving fails with a fork() error on Linux?</a> for details. </p>\n</li>\n<li><p>To ensure the Linux kernel feature Transparent Huge Pages does not impact Valkey memory usage and latency, run the command: <code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code> to disable it. See <a href=\"latency.md#latency-induced-by-transparent-huge-pages\">Latency Diagnosis - Latency induced by transparent huge pages</a> for additional context.</p>\n</li>\n</ul>\n<h3>Memory</h3>\n<ul>\n<li><p>Ensured that swap is enabled and that your swap file size is equal to amount of memory on your system. If Linux does not have swap set up, and your Valkey instance accidentally consumes too much memory, Valkey can crash when it is out of memory, or the Linux kernel OOM killer can kill the Valkey process. When swapping is enabled, you can detect latency spikes and act on them.</p>\n</li>\n<li><p>Set an explicit <code>maxmemory</code> option limit in your instance to make sure that it will report errors instead of failing when the system memory limit is near to be reached. Note that <code>maxmemory</code> should be set by calculating the overhead for Valkey, other than data, and the fragmentation overhead. So if you think you have 10 GB of free memory, set it to 8 or 9.</p>\n</li>\n<li><p>If you are using Valkey in a write-heavy application, while saving an RDB file on disk or rewriting the AOF log, Valkey can use up to 2 times the memory normally used. The additional memory used is proportional to the number of memory pages modified by writes during the saving process, so it is often proportional to the number of keys (or aggregate types items) touched during this time. Make sure to size your memory accordingly.</p>\n</li>\n<li><p>See the <code>LATENCY DOCTOR</code> and <code>MEMORY DOCTOR</code> commands to assist in troubleshooting.</p>\n</li>\n</ul>\n<h3>Imaging</h3>\n<ul>\n<li>When running under daemontools, use <code>daemonize no</code>.</li>\n</ul>\n<h3>Replication</h3>\n<ul>\n<li><p>Set up a non-trivial replication backlog in proportion to the amount of memory Valkey is using. The backlog allows replicas to sync with the primary instance much more easily.</p>\n</li>\n<li><p>If you use replication, Valkey performs RDB saves even if persistence is disabled. (This does not apply to diskless replication.) If you don&#39;t have disk usage on the primary, enable diskless replication.</p>\n</li>\n<li><p>If you are using replication, ensure that either your primary has persistence enabled, or that it does not automatically restart on crashes. Replicas will try to maintain an exact copy of the primary, so if a primary restarts with an empty data set, replicas will be wiped as well.</p>\n</li>\n</ul>\n<h3>Security</h3>\n<ul>\n<li>By default, Valkey does not require any authentication and listens to all the network interfaces. This is a big security issue if you leave Valkey exposed on the internet or other places where attackers can reach it. Please check our <a href=\"security.md\">security page</a> and the <a href=\"quickstart.md\">quick start</a> for information about how to secure Valkey.</li>\n</ul>\n<h2>Running Valkey on EC2</h2>\n<ul>\n<li>Use HVM based instances, not PV based instances.</li>\n<li>The use of Valkey persistence with EC2 EBS volumes needs to be handled with care because sometimes EBS volumes have high latency characteristics.</li>\n<li>You may want to try diskless replication if you have issues when replicas are synchronizing with the primary.</li>\n</ul>\n<h2>Upgrading or restarting a Valkey instance without downtime</h2>\n<p>Valkey is designed to be a long-running process in your server. You can modify many configuration options without a restart using the <code>CONFIG SET</code> command. You can also switch from AOF to RDB snapshots persistence, or the other way around, without restarting Valkey. Check the output of the <code>CONFIG GET *</code> command for more information.</p>\n<p>From time to time, a restart is required, for example, to upgrade the Valkey process to a newer version, or when you need to modify a configuration parameter that is currently not supported by the <code>CONFIG</code> command.</p>\n<p>Follow these steps to avoid downtime.</p>\n<ul>\n<li><p>Set up your new Valkey instance as a replica for your current Valkey instance. In order to do so, you need a different server, or a server that has enough RAM to keep two instances of Valkey running at the same time.</p>\n</li>\n<li><p>If you use a single server, ensure that the replica is started on a different port than the primary instance, otherwise the replica cannot start.</p>\n</li>\n<li><p>Wait for the replication initial synchronization to complete. Check the replica&#39;s log file.</p>\n</li>\n<li><p>Using <code>INFO</code>, ensure the primary and replica have the same number of keys. Use <code>valkey-cli</code> to check that the replica is working as expected and is replying to your commands.</p>\n</li>\n<li><p>Allow writes to the replica using <code>CONFIG SET replica-read-only no</code>.</p>\n</li>\n<li><p>Configure all your clients to use the new instance (the replica). Note that you may want to use the <code>CLIENT PAUSE</code> command to ensure that no client can write to the old primary during the switch.</p>\n</li>\n<li><p>Once you confirm that the primary is no longer receiving any queries (you can check this using the <code>MONITOR</code> command), elect the replica to primary using the <code>REPLICAOF NO ONE</code> command, and then shut down your primary.</p>\n</li>\n</ul>\n<p>If you are using <a href=\"sentinel.md\">Valkey Sentinel</a> or <a href=\"cluster-tutorial.md\">Valkey Cluster</a>, the simplest way to upgrade to newer versions is to upgrade one replica after the other. Then you can perform a manual failover to promote one of the upgraded replicas to primary, and finally promote the last replica.</p>\n"
  },
  {
    "id": "security",
    "topicName": "Security",
    "description": "Security model and features in Valkey",
    "htmlContent": "<p>This document provides an introduction to the topic of security from the point of<br>view of Valkey. It covers the access control provided by Valkey, code security concerns,<br>attacks that can be triggered from the outside by selecting malicious inputs, and<br>other similar topics. </p>\n<p>For security-related contacts, open an issue on GitHub, or when you feel it<br>is really important to preserve the security of the communication, use the<br>GPG key at the end of this document.</p>\n<h2>Security model</h2>\n<p>Valkey is designed to be accessed by trusted clients inside trusted environments.<br>This means that usually it is not a good idea to expose the Valkey instance<br>directly to the internet or, in general, to an environment where untrusted<br>clients can directly access the Valkey TCP port or UNIX socket.</p>\n<p>For instance, in the common context of a web application implemented using Valkey<br>as a database, cache, or messaging system, the clients inside the front-end<br>(web side) of the application will query Valkey to generate pages or<br>to perform operations requested or triggered by the web application user.</p>\n<p>In this case, the web application mediates access between Valkey and<br>untrusted clients (the user browsers accessing the web application).</p>\n<p>In general, untrusted access to Valkey should<br>always be mediated by a layer implementing ACLs, validating user input,<br>and deciding what operations to perform against the Valkey instance.</p>\n<h2>Network security</h2>\n<p>Access to the Valkey port should be denied to everybody but trusted clients<br>in the network, so the servers running Valkey should be directly accessible<br>only by the computers implementing the application using Valkey.</p>\n<p>In the common case of a single computer directly exposed to the internet, such<br>as a virtualized Linux instance (Linode, EC2, ...), the Valkey port should be<br>firewalled to prevent access from the outside. Clients will still be able to<br>access Valkey using the loopback interface.</p>\n<p>Note that it is possible to bind Valkey to a single interface by adding a line<br>like the following to the <strong>valkey.conf</strong> file:</p>\n<pre><code>bind 127.0.0.1\n</code></pre>\n<p>Failing to protect the Valkey port from the outside can have a big security<br>impact because of the nature of Valkey. For instance, a single <code>FLUSHALL</code> command can be used by an external attacker to delete the whole data set.</p>\n<h2>Protected mode</h2>\n<p>Unfortunately, many users fail to protect Valkey instances from being accessed<br>from external networks. Many instances are simply left exposed on the<br>internet with public IPs. Valkey enters a special mode called <strong>protected mode</strong> when it is<br>executed with the default configuration (binding all the interfaces) and<br>without any password in order to access it. In this mode, Valkey only replies to queries from the<br>loopback interfaces, and replies to clients connecting from other<br>addresses with an error that explains the problem and how to configure<br>Valkey properly.</p>\n<p>We expect protected mode to seriously decrease the security issues caused<br>by unprotected Valkey instances executed without proper administration. However,<br>the system administrator can still ignore the error given by Valkey and<br>disable protected mode or manually bind all the interfaces.</p>\n<h2>Authentication</h2>\n<p>Valkey provides two ways to authenticate clients.<br>The recommended authentication method is via Access Control Lists, allowing named users to be created and assigned fine-grained permissions.<br>Read more about Access Control Lists <a href=\"acl.md\">here</a>.</p>\n<p>The legacy authentication method is enabled by editing the <strong>valkey.conf</strong> file, and providing a database password using the <code>requirepass</code> setting.<br>This password is then used by all clients.</p>\n<p>When the <code>requirepass</code> setting is enabled, Valkey will refuse any query by<br>unauthenticated clients. A client can authenticate itself by sending the<br><strong>AUTH</strong> command followed by the password.</p>\n<p>The password is set by the system administrator in clear text inside the<br>valkey.conf file. It should be long enough to prevent brute force attacks<br>for two reasons:</p>\n<ul>\n<li>Valkey is very fast at serving queries. Many passwords per second can be tested by an external client.</li>\n<li>The Valkey password is stored in the <strong>valkey.conf</strong> file and inside the client configuration. Since the system administrator does not need to remember it, the password can be very long.</li>\n</ul>\n<p>The goal of the authentication layer is to optionally provide a layer of<br>redundancy. If firewalling or any other system implemented to protect Valkey<br>from external attackers fail, an external client will still not be able to<br>access the Valkey instance without knowledge of the authentication password.</p>\n<p>Since the <code>AUTH</code> command, like every other Valkey command, is sent unencrypted, it<br>does not protect against an attacker that has enough access to the network to<br>perform eavesdropping.</p>\n<h2>TLS support</h2>\n<p>Valkey has optional support for TLS on all communication channels, including<br>client connections, replication links, and the Valkey Cluster bus protocol.</p>\n<h2>Attacks triggered by malicious inputs from external clients</h2>\n<p>There is a class of attacks that an attacker can trigger from the outside even<br>without external access to the instance. For example, an attacker might insert data into Valkey that triggers pathological (worst case)<br>algorithm complexity on data structures implemented inside Valkey internals.</p>\n<p>An attacker could supply, via a web form, a set of strings that<br>are known to hash to the same bucket in a hash table in order to turn the<br>O(1) expected time (the average time) to the O(N) worst case. This can consume more<br>CPU than expected and ultimately cause a Denial of Service.</p>\n<p>To prevent this specific attack, Valkey uses a per-execution, pseudo-random<br>seed to the hash function.</p>\n<p>Valkey implements the SORT command using the qsort algorithm. Currently,<br>the algorithm is not randomized, so it is possible to trigger a quadratic<br>worst-case behavior by carefully selecting the right set of inputs.</p>\n<h2>String escaping and NoSQL injection</h2>\n<p>The Valkey protocol has no concept of string escaping, so injection<br>is impossible under normal circumstances using a normal client library.<br>The protocol uses prefixed-length strings and is completely binary safe.</p>\n<p>Since Lua scripts executed by the <code>EVAL</code> and <code>EVALSHA</code> commands follow the<br>same rules, those commands are also safe.</p>\n<p>While it would be a strange use case, the application should avoid composing the body of the Lua script from strings obtained from untrusted sources.</p>\n<h2>Code security</h2>\n<p>Internally, Valkey uses all the well-known practices for writing secure code to<br>prevent buffer overflows, format bugs, and other memory corruption issues.</p>\n<p>Valkey does not require root privileges to run. It is recommended to<br>run it as an unprivileged <em>valkey</em> user that is only used for this purpose.</p>\n"
  },
  {
    "id": "encryption",
    "topicName": "TLS",
    "description": "Valkey TLS support",
    "htmlContent": "<p>SSL/TLS is supported by Valkey as an optional feature<br>that needs to be enabled at compile time.</p>\n<h2>Getting Started</h2>\n<h3>Building</h3>\n<p>To build with TLS support you&#39;ll need OpenSSL development libraries (e.g.<br><code>libssl-dev</code> on Debian/Ubuntu).</p>\n<p>Build Valkey with the following command:</p>\n<pre><code class=\"language-sh\">make BUILD_TLS=yes\n</code></pre>\n<h3>Tests</h3>\n<p>To run Valkey test suite with TLS, you&#39;ll need TLS support for TCL (i.e.<br><code>tcl-tls</code> package on Debian/Ubuntu).</p>\n<ol>\n<li><p>Run <code>./utils/gen-test-certs.sh</code> to generate a root CA and a server<br>certificate.</p>\n</li>\n<li><p>Run <code>./runtest --tls</code> or <code>./runtest-cluster --tls</code> to run Valkey and Valkey<br>Cluster tests in TLS mode.</p>\n</li>\n</ol>\n<h3>Running manually</h3>\n<p>To manually run a Valkey server with TLS mode (assuming <code>gen-test-certs.sh</code> was<br>invoked so sample certificates/keys are available):</p>\n<pre><code>./src/valkey-server --tls-port 6379 --port 0 \\\n    --tls-cert-file ./tests/tls/valkey.crt \\\n    --tls-key-file ./tests/tls/valkey.key \\\n    --tls-ca-cert-file ./tests/tls/ca.crt\n</code></pre>\n<p>To connect to this Valkey server with <code>valkey-cli</code>:</p>\n<pre><code>./src/valkey-cli --tls \\\n    --cert ./tests/tls/valkey.crt \\\n    --key ./tests/tls/valkey.key \\\n    --cacert ./tests/tls/ca.crt\n</code></pre>\n<h3>Certificate configuration</h3>\n<p>In order to support TLS, Valkey must be configured with a X.509 certificate and a<br>private key. In addition, it is necessary to specify a CA certificate bundle<br>file or path to be used as a trusted root when validating certificates. To<br>support DH based ciphers, a DH params file can also be configured. For example:</p>\n<pre><code>tls-cert-file /path/to/valkey.crt\ntls-key-file /path/to/valkey.key\ntls-ca-cert-file /path/to/ca.crt\ntls-dh-params-file /path/to/valkey.dh\n</code></pre>\n<h3>TLS listening port</h3>\n<p>The <code>tls-port</code> configuration directive enables accepting SSL/TLS connections on<br>the specified port. This is <strong>in addition</strong> to listening on <code>port</code> for TCP<br>connections, so it is possible to access Valkey on different ports using TLS and<br>non-TLS connections simultaneously.</p>\n<p>You may specify <code>port 0</code> to disable the non-TLS port completely. To enable only<br>TLS on the default Valkey port, use:</p>\n<pre><code>port 0\ntls-port 6379\n</code></pre>\n<h3>Client certificate authentication</h3>\n<p>By default, Valkey uses mutual TLS and requires clients to authenticate with a<br>valid certificate (authenticated against trusted root CAs specified by<br><code>ca-cert-file</code> or <code>ca-cert-dir</code>).</p>\n<p>You may use <code>tls-auth-clients no</code> to disable client authentication.</p>\n<h3>Replication</h3>\n<p>A Valkey primary server handles connecting clients and replica servers in the same<br>way, so the above <code>tls-port</code> and <code>tls-auth-clients</code> directives apply to<br>replication links as well.</p>\n<p>On the replica server side, it is necessary to specify <code>tls-replication yes</code> to<br>use TLS for outgoing connections to the primary.</p>\n<h3>Cluster</h3>\n<p>When Valkey Cluster is used, use <code>tls-cluster yes</code> in order to enable TLS for the<br>cluster bus and cross-node connections.</p>\n<h3>Sentinel</h3>\n<p>Sentinel inherits its networking configuration from the common Valkey<br>configuration, so all of the above applies to Sentinel as well.</p>\n<p>When connecting to primary servers, Sentinel will use the <code>tls-replication</code><br>directive to determine if a TLS or non-TLS connection is required.</p>\n<p>In addition, the very same <code>tls-replication</code> directive will determine whether Sentinel&#39;s<br>port, that accepts connections from other Sentinels, will support TLS as well. That is,<br>Sentinel will be configured with <code>tls-port</code> if and only if <code>tls-replication</code> is enabled. </p>\n<h3>Additional configuration</h3>\n<p>Additional TLS configuration is available to control the choice of TLS protocol<br>versions, ciphers and cipher suites, etc. Please consult the self documented<br><code>valkey.conf</code> for more information.</p>\n<h3>Performance considerations</h3>\n<p>TLS adds a layer to the communication stack with overheads due to writing/reading to/from an SSL connection, encryption/decryption and integrity checks. Consequently, using TLS results in a decrease of the achievable throughput per Valkey instance.</p>\n"
  },
  {
    "id": "persistence",
    "topicName": "Persistence",
    "description": "How Valkey writes data to disk",
    "htmlContent": "<p>Persistence refers to the writing of data to durable storage, such as a solid-state disk (SSD). Valkey provides a range of persistence options. These include:</p>\n<ul>\n<li><strong>RDB</strong> (Valkey Database): RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</li>\n<li><strong>AOF</strong> (Append Only File): AOF persistence logs every write operation received by the server. These operations can then be replayed again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Valkey protocol itself.</li>\n<li><strong>No persistence</strong>: You can disable persistence completely. This is sometimes used when caching.</li>\n<li><strong>RDB + AOF</strong>: You can also combine both AOF and RDB in the same instance.</li>\n</ul>\n<p>To learn more about how to evaluate your Valkey persistence strategy, read on.</p>\n<h2>RDB advantages</h2>\n<ul>\n<li>RDB is a very compact single-file point-in-time representation of your Valkey data. RDB files are perfect for backups. For instance you may want to archive your RDB files every hour for the latest 24 hours, and to save an RDB snapshot every day for 30 days. This allows you to easily restore different versions of the data set in case of disasters.</li>\n<li>RDB is very good for disaster recovery, being a single compact file that can be transferred to far data centers, or onto Amazon S3 (possibly encrypted).</li>\n<li>RDB maximizes Valkey performances since the only work the Valkey parent process needs to do in order to persist is forking a child that will do all the rest. The parent process will never perform disk I/O or alike.</li>\n<li>RDB allows faster restarts with big datasets compared to AOF.</li>\n<li>On replicas, RDB supports <a href=\"replication.md#partial-resynchronizations-after-restarts-and-failovers\">partial resynchronizations after restarts and failovers</a>.</li>\n</ul>\n<h2>RDB disadvantages</h2>\n<ul>\n<li>RDB is NOT good if you need to minimize the chance of data loss in case Valkey stops working (for example after a power outage). You can configure different <em>save points</em> where an RDB is produced (for instance after at least five minutes and 100 writes against the data set, you can have multiple save points). However you&#39;ll usually create an RDB snapshot every five minutes or more, so in case of Valkey stopping working without a correct shutdown for any reason you should be prepared to lose the latest minutes of data.</li>\n<li>RDB needs to fork() often in order to persist on disk using a child process. fork() can be time consuming if the dataset is big, and may result in Valkey stopping serving clients for some milliseconds or even for one second if the dataset is very big and the CPU performance is not great. AOF also needs to fork() but less frequently and you can tune how often you want to rewrite your logs without any trade-off on durability.</li>\n</ul>\n<h2>AOF advantages</h2>\n<ul>\n<li>Using AOF Valkey is much more durable: you can have different fsync policies: no fsync at all, fsync every second, fsync at every query. With the default policy of fsync every second, write performance is still great. fsync is performed using a background thread and the main thread will try hard to perform writes when no fsync is in progress, so you can only lose one second worth of writes.</li>\n<li>The AOF log is an append-only log, so there are no seeks, nor corruption problems if there is a power outage. Even if the log ends with a half-written command for some reason (disk full or other reasons) the valkey-check-aof tool is able to fix it easily.</li>\n<li>Valkey is able to automatically rewrite the AOF in background when it gets too big. The rewrite is completely safe as while Valkey continues appending to the old file, a completely new one is produced with the minimal set of operations needed to create the current data set, and once this second file is ready Valkey switches the two and starts appending to the new one.</li>\n<li>AOF contains a log of all the operations one after the other in an easy to understand and parse format. You can even easily export an AOF file. For instance even if you&#39;ve accidentally flushed everything using the <code>FLUSHALL</code> command, as long as no rewrite of the log was performed in the meantime, you can still save your data set just by stopping the server, removing the latest command, and restarting Valkey again.</li>\n</ul>\n<h2>AOF disadvantages</h2>\n<ul>\n<li>AOF files are usually bigger than the equivalent RDB files for the same dataset.</li>\n<li>AOF can be slower than RDB depending on the exact fsync policy. In general with fsync set to <em>every second</em> performance is still very high, and with fsync disabled it should be exactly as fast as RDB even under high load. Still RDB is able to provide more guarantees about the maximum latency even in the case of a huge write load.</li>\n</ul>\n<h2>Ok, so what should I use?</h2>\n<p>The general indication you should use both persistence methods is if<br>you want a degree of data safety comparable to what PostgreSQL can provide you.</p>\n<p>If you care a lot about your data, but still can live with a few minutes of<br>data loss in case of disasters, you can simply use RDB alone.</p>\n<p>There are many users using AOF alone, but we discourage it since to have an<br>RDB snapshot from time to time is a great idea for doing database backups,<br>for faster restarts, and in the event of bugs in the AOF engine.</p>\n<p>The following sections will illustrate a few more details about the two persistence models.</p>\n<h2>Snapshotting</h2>\n<p>By default Valkey saves snapshots of the dataset on disk, in a binary<br>file called <code>dump.rdb</code>. You can configure Valkey to have it save the<br>dataset every N seconds if there are at least M changes in the dataset,<br>or you can manually call the <code>SAVE</code> or <code>BGSAVE</code> commands.</p>\n<p>For example, this configuration will make Valkey automatically dump the<br>dataset to disk every 60 seconds if at least 1000 keys changed:</p>\n<pre><code>save 60 1000\n</code></pre>\n<p>This strategy is known as <em>snapshotting</em>.</p>\n<h2>No persistence</h2>\n<p>If you prefer <strong>not</strong> to have persistence (for example when using a Valkey instance solely as a cache) that is also a possibility.</p>\n<p>RDB snapshotting is enabled by default. To disable it, set the <code>save</code> configuration parameter to the empty string <code>&quot;&quot;</code> and remove any excess <code>save</code> lines that are present in the current configuration file.</p>\n<pre><code>save &quot;&quot;\n</code></pre>\n<p>Alternatively, you can also use the <code>--save &quot;&quot;</code> argument on the <code>valkey-server</code> binary.</p>\n<h3>How it works</h3>\n<p>Whenever Valkey needs to dump the dataset to disk, this is what happens:</p>\n<ul>\n<li><p>Valkey <a href=\"https://linux.die.net/man/2/fork\">forks</a>. We now have a child<br>and a parent process.</p>\n</li>\n<li><p>The child starts to write the dataset to a temporary RDB file.</p>\n</li>\n<li><p>When the child is done writing the new RDB file, it replaces the old<br>one.</p>\n</li>\n</ul>\n<p>This method allows Valkey to benefit from copy-on-write semantics.</p>\n<h2>Append-only file</h2>\n<p>Snapshotting is not very durable. If your computer running Valkey stops,<br>your power line fails, or you accidentally <code>kill -9</code> your instance, the<br>latest data written to Valkey will be lost.  While this may not be a big<br>deal for some applications, there are use cases for full durability, and<br>in these cases Valkey snapshotting alone is not a viable option.</p>\n<p>The <em>append-only file</em> is an alternative, fully-durable strategy for<br>Valkey.</p>\n<p>You can turn on the AOF in your configuration file:</p>\n<pre><code>appendonly yes\n</code></pre>\n<p>From now on, every time Valkey receives a command that changes the<br>dataset (e.g. <code>SET</code>) it will append it to the AOF.  When you restart<br>Valkey it will re-play the AOF to rebuild the state.</p>\n<p>Valkey uses a multi part AOF mechanism.<br>That is, the original single AOF file is split into base file (at most one) and incremental files (there may be more than one).<br>The base file represents an initial (RDB or AOF format) snapshot of the data present when the AOF is <a href=\"#log-rewriting\">rewritten</a>.<br>The incremental files contains incremental changes since the last base AOF file was created. All these files are put in a separate directory and are tracked by a manifest file.</p>\n<h3>Log rewriting</h3>\n<p>The AOF gets bigger and bigger as write operations are<br>performed.  For example, if you are incrementing a counter 100 times,<br>you&#39;ll end up with a single key in your dataset containing the final<br>value, but 100 entries in your AOF. 99 of those entries are not needed<br>to rebuild the current state.</p>\n<p>The rewrite is completely safe.<br>While Valkey continues appending to the old file,<br>a completely new one is produced with the minimal set of operations needed to create the current data set,<br>and once this second file is ready Valkey switches the two and starts appending to the new one.</p>\n<p>Valkey supports an interesting feature: it is able to rebuild the AOF in the background without interrupting service to clients.<br>Whenever you issue a <code>BGREWRITEAOF</code>, Valkey will write the shortest sequence of commands needed to rebuild the current dataset in memory.<br>Valkey will automatically trigger log rewriting automatically (see the example configuration file for more information).</p>\n<p>When an AOF rewrite is scheduled, the Valkey parent process opens a new incremental AOF file to continue writing.<br>The child process executes the rewrite logic and generates a new base AOF.<br>Valkey will use a temporary manifest file to track the newly generated base file and incremental file.<br>When they are ready, Valkey will perform an atomic replacement operation to make this temporary manifest file take effect.<br>In order to avoid the problem of creating many incremental files in case of repeated failures and retries of an AOF rewrite,<br>Valkey introduces an AOF rewrite limiting mechanism to ensure that failed AOF rewrites are retried at a slower and slower rate.</p>\n<h3>How durable is the append only file?</h3>\n<p>You can configure how many times Valkey will<br><a href=\"https://linux.die.net/man/2/fsync\"><code>fsync</code></a> data on disk. There are<br>three options:</p>\n<ul>\n<li><code>appendfsync always</code>: <code>fsync</code> every time new commands are appended to the AOF. Very very slow, very safe. Note that the commands are appended to the AOF after a batch of commands from multiple clients or a pipeline are executed, so it means a single write and a single fsync (before sending the replies).</li>\n<li><code>appendfsync everysec</code>: <code>fsync</code> every second. Fast enough and you may lose 1 second of data if there is a disaster.</li>\n<li><code>appendfsync no</code>: Never <code>fsync</code>, just put your data in the hands of the Operating System. The faster and less safe method. Normally Linux will flush data every 30 seconds with this configuration, but it&#39;s up to the kernel&#39;s exact tuning.</li>\n</ul>\n<p>The suggested (and default) policy is to <code>fsync</code> every second. It is<br>both fast and relatively safe. The <code>always</code> policy is very slow in<br>practice, but it supports group commit, so if there are multiple parallel<br>writes Valkey will try to perform a single <code>fsync</code> operation.</p>\n<h3>What should I do if my AOF gets truncated?</h3>\n<p>It is possible the server crashed while writing the AOF file, or the<br>volume where the AOF file is stored was full at the time of writing. When this happens the<br>AOF still contains consistent data representing a given point-in-time version<br>of the dataset (that may be old up to one second with the default AOF fsync<br>policy), but the last command in the AOF could be truncated.<br>The latest major versions of Valkey will be able to load the AOF anyway, just<br>discarding the last non well formed command in the file. In this case the<br>server will emit a log like the following:</p>\n<pre><code>* Reading RDB preamble from AOF file...\n* Reading the remaining AOF tail...\n# !!! Warning: short read while loading the AOF file !!!\n# !!! Truncating the AOF at offset 439 !!!\n# AOF loaded anyway because aof-load-truncated is enabled\n</code></pre>\n<p>You can change the default configuration to force Valkey to stop in such<br>cases if you want, but the default configuration is to continue regardless of<br>the fact the last command in the file is not well-formed, in order to guarantee<br>availability after a restart.</p>\n<p>Older versions of Valkey may not recover, and may require the following steps:</p>\n<ul>\n<li><p>Make a backup copy of your AOF file.</p>\n</li>\n<li><p>Fix the original file using the <code>valkey-check-aof</code> tool that ships with Valkey:</p>\n<pre><code>$ valkey-check-aof --fix &lt;filename&gt;\n</code></pre>\n</li>\n<li><p>Optionally use <code>diff -u</code> to check what is the difference between two files.</p>\n</li>\n<li><p>Restart the server with the fixed file.</p>\n</li>\n</ul>\n<h3>What should I do if my AOF gets corrupted?</h3>\n<p>If the AOF file is not just truncated, but corrupted with invalid byte<br>sequences in the middle, things are more complex. Valkey will complain<br>at startup and will abort:</p>\n<pre><code>* Reading the remaining AOF tail...\n# Bad file format reading the append only file: make a backup of your AOF file, then use ./valkey-check-aof --fix &lt;filename&gt;\n</code></pre>\n<p>The best thing to do is to run the <code>valkey-check-aof</code> utility, initially without<br>the <code>--fix</code> option, then understand the problem, jump to the given<br>offset in the file, and see if it is possible to manually repair the file:<br>The AOF uses the same format of the Valkey protocol and is quite simple to fix<br>manually. Otherwise it is possible to let the utility fix the file for us, but<br>in that case all the AOF portion from the invalid part to the end of the<br>file may be discarded, leading to a massive amount of data loss if the<br>corruption happened to be in the initial part of the file.</p>\n<h3>How it works</h3>\n<p>Log rewriting uses the same copy-on-write trick already in use for<br>snapshotting.  This is how it works:</p>\n<p><strong>Valkey multi-part AOF</strong></p>\n<ul>\n<li><p>Valkey <a href=\"https://linux.die.net/man/2/fork\">forks</a>, so now we have a child<br>and a parent process.</p>\n</li>\n<li><p>The child starts writing the new base AOF in a temporary file.</p>\n</li>\n<li><p>The parent opens a new increments AOF file to continue writing updates.<br>If the rewriting fails, the old base and increment files (if there are any) plus this newly opened increment file represent the complete updated dataset,<br>so we are safe.</p>\n</li>\n<li><p>When the child is done rewriting the base file, the parent gets a signal,<br>and uses the newly opened increment file and child generated base file to build a temp manifest,<br>and persist it.</p>\n</li>\n<li><p>Profit! Now Valkey does an atomic exchange of the manifest files so that the result of this AOF rewrite takes effect. Valkey also cleans up the old base file and any unused increment files.</p>\n</li>\n</ul>\n<h3>How I can switch to AOF, if I&#39;m currently using dump.rdb snapshots?</h3>\n<p>If you want to enable AOF in a server that is currently using RDB snapshots, you need to convert the data by enabling AOF via CONFIG command on the live server first.</p>\n<p><strong>IMPORTANT:</strong> not following this procedure (e.g. just changing the config and restarting the server) can result in data loss!</p>\n<p>Preparations:</p>\n<ul>\n<li>Make a backup of your latest dump.rdb file.</li>\n<li>Transfer this backup to a safe place.</li>\n</ul>\n<p>Switch to AOF on live database:</p>\n<ul>\n<li>Enable AOF: <code>valkey-cli config set appendonly yes</code></li>\n<li>Optionally disable RDB: <code>valkey-cli config set save &quot;&quot;</code></li>\n<li>Make sure writes are appended to the append only file correctly.</li>\n<li><strong>IMPORTANT:</strong> Update your <code>valkey.conf</code> (potentially through <code>CONFIG REWRITE</code>) and ensure that it matches the configuration above.<br>If you forget this step, when you restart the server, the configuration changes will be lost and the server will start again with the old configuration, resulting in a loss of your data.</li>\n</ul>\n<p>Next time you restart the server:</p>\n<ul>\n<li>Before restarting the server, wait for AOF rewrite to finish persisting the data.<br>You can do that by watching <code>INFO persistence</code>, waiting for <code>aof_rewrite_in_progress</code> and <code>aof_rewrite_scheduled</code> to be <code>0</code>, and validating that <code>aof_last_bgrewrite_status</code> is <code>ok</code>.</li>\n<li>After restarting the server, check that your database contains the same number of keys it contained previously.</li>\n</ul>\n<h2>Interactions between AOF and RDB persistence</h2>\n<p>Valkey makes sure to avoid triggering an AOF rewrite when an RDB<br>snapshotting operation is already in progress, or allowing a <code>BGSAVE</code> while the<br>AOF rewrite is in progress. This prevents two Valkey background processes<br>from doing heavy disk I/O at the same time.</p>\n<p>When snapshotting is in progress and the user explicitly requests a log<br>rewrite operation using <code>BGREWRITEAOF</code> the server will reply with an OK<br>status code telling the user the operation is scheduled, and the rewrite<br>will start once the snapshotting is completed.</p>\n<p>In the case both AOF and RDB persistence are enabled and Valkey restarts the<br>AOF file will be used to reconstruct the original dataset since it is<br>guaranteed to be the most complete.</p>\n<h2>Backing up Valkey data</h2>\n<p>Before starting this section, make sure to read the following sentence: <strong>Make Sure to Backup Your Database</strong>. Disks break, instances in the cloud disappear, and so forth: no backups means huge risk of data disappearing into /dev/null.</p>\n<p>Valkey is very data backup friendly since you can copy RDB files while the<br>database is running: the RDB is never modified once produced, and while it<br>gets produced it uses a temporary name and is renamed into its final destination<br>atomically using rename(2) only when the new snapshot is complete.</p>\n<p>This means that copying the RDB file is completely safe while the server is<br>running. This is what we suggest:</p>\n<ul>\n<li>Create a cron job in your server creating hourly snapshots of the RDB file in one directory, and daily snapshots in a different directory.</li>\n<li>Every time the cron script runs, make sure to call the <code>find</code> command to make sure too old snapshots are deleted: for instance you can take hourly snapshots for the latest 48 hours, and daily snapshots for one or two months. Make sure to name the snapshots with date and time information.</li>\n<li>At least one time every day make sure to transfer an RDB snapshot <em>outside your data center</em> or at least <em>outside the physical machine</em> running your Valkey instance.</li>\n</ul>\n<h3>Backing up AOF persistence</h3>\n<p>If you run a Valkey instance with only AOF persistence enabled, you can still perform backups.<br>AOF files are split into multiple files which reside in a single directory determined by the <code>appenddirname</code> configuration.<br>During normal operation all you need to do is copy/tar the files in this directory to achieve a backup. However, if this is done during a <a href=\"#log-rewriting\">rewrite</a>, you might end up with an invalid backup.<br>To work around this you must disable AOF rewrites during the backup:</p>\n<ol>\n<li>Turn off automatic rewrites with<br/><br><code>CONFIG SET</code> <code>auto-aof-rewrite-percentage 0</code><br/><br>Make sure you don&#39;t manually start a rewrite (using <code>BGREWRITEAOF</code>) during this time.</li>\n<li>Check there&#39;s no current rewrite in progress using<br/><br><code>INFO</code> <code>persistence</code><br/><br>and verifying <code>aof_rewrite_in_progress</code> is 0. If it&#39;s 1, then you&#39;ll need to wait for the rewrite to complete.</li>\n<li>Now you can safely copy the files in the <code>appenddirname</code> directory.</li>\n<li>Re-enable rewrites when done:<br/><br><code>CONFIG SET</code> <code>auto-aof-rewrite-percentage &lt;prev-value&gt;</code></li>\n</ol>\n<p><strong>Note:</strong> If you want to minimize the time AOF rewrites are disabled you may create hard links to the files in <code>appenddirname</code> (in step 3 above) and then re-enable rewrites (step 4) after the hard links are created.<br>Now you can copy/tar the hardlinks and delete them when done. This works because Valkey guarantees that it<br>only appends to files in this directory, or completely replaces them if necessary, so the content should be<br>consistent at any given point in time.</p>\n<p><strong>Note:</strong> If you want to handle the case of the server being restarted during the backup and make sure no rewrite will automatically start after the restart you can change step 1 above to also persist the updated configuration via <code>CONFIG REWRITE</code>.<br>Just make sure to re-enable automatic rewrites when done (step 4) and persist it with another <code>CONFIG REWRITE</code>.</p>\n<h2>Disaster recovery</h2>\n<p>Disaster recovery in the context of Valkey is basically the same story as<br>backups, plus the ability to transfer those backups in many different external<br>data centers. This way data is secured even in the case of some catastrophic<br>event affecting the main data center where Valkey is running and producing its<br>snapshots.</p>\n<p>We&#39;ll review the most interesting disaster recovery techniques<br>that don&#39;t have too high costs.</p>\n<ul>\n<li>Amazon S3 and other similar services are a good way for implementing your disaster recovery system. Simply transfer your daily or hourly RDB snapshot to S3 in an encrypted form. You can encrypt your data using <code>gpg -c</code> (in symmetric encryption mode). Make sure to store your password in many different safe places (for instance give a copy to the most important people of your organization). It is recommended to use multiple storage services for improved data safety.</li>\n<li>Transfer your snapshots using SCP (part of SSH) to far servers. This is a fairly simple and safe route: get a small VPS in a place that is very far from you, install ssh there, and generate a ssh client key without passphrase, then add it in the <code>authorized_keys</code> file of your small VPS. You are ready to transfer backups in an automated fashion. Get at least two VPS in two different providers<br>for best results.</li>\n</ul>\n<p>It is important to understand that this system can easily fail if not<br>implemented in the right way. At least, make absolutely sure that after the<br>transfer is completed you are able to verify the file size (that should match<br>the one of the file you copied) and possibly the SHA1 digest, if you are using<br>a VPS.</p>\n<p>You also need some kind of independent alert system if the transfer of fresh<br>backups is not working for some reason.</p>\n"
  },
  {
    "id": "signals",
    "topicName": "Signal handling",
    "description": "How Valkey handles common Unix signals",
    "htmlContent": "<p>This document provides information about how Valkey reacts to different POSIX signals such as <code>SIGTERM</code> and <code>SIGSEGV</code>.</p>\n<h2>SIGTERM and SIGINT</h2>\n<p>The <code>SIGTERM</code> and <code>SIGINT</code> signals tell Valkey to shut down gracefully. When the server receives this signal,<br>it does not immediately exit. Instead, it schedules<br>a shutdown similar to the one performed by the <code>SHUTDOWN</code> command. The scheduled shutdown starts as soon as possible, specifically as long as the<br>current command in execution terminates (if any), with a possible additional<br>delay of 0.1 seconds or less.</p>\n<p>If the server is blocked by a long-running Lua script,<br>kill the script with <code>SCRIPT KILL</code> if possible. The scheduled shutdown will<br>run just after the script is killed or terminates spontaneously.</p>\n<p>This shutdown process includes the following actions:</p>\n<ul>\n<li>If there are any replicas lagging behind in replication:<ul>\n<li>Pause clients attempting to write with <code>CLIENT PAUSE</code> and the <code>WRITE</code> option.</li>\n<li>Wait up to the configured <code>shutdown-timeout</code> (default 10 seconds) for replicas to catch up with the primary&#39;s replication offset.</li>\n</ul>\n</li>\n<li>If a background child is saving the RDB file or performing an AOF rewrite, the child process is killed.</li>\n<li>If the AOF is active, Valkey calls the <code>fsync</code> system call on the AOF file descriptor to flush the buffers on disk.</li>\n<li>If Valkey is configured to persist on disk using RDB files, a synchronous (blocking) save is performed. Since the save is synchronous, it doesn&#39;t use any additional memory.</li>\n<li>If the server is daemonized, the PID file is removed.</li>\n<li>If the Unix domain socket is enabled, it gets removed.</li>\n<li>The server exits with an exit code of zero.</li>\n</ul>\n<p>IF the RDB file can&#39;t be saved, the shutdown fails, and the server continues to run in order to ensure no data loss.<br>Likewise, if the user just turned on AOF, and the server triggered the first AOF rewrite in order to create the initial AOF file but this file can&#39;t be saved, the shutdown fails and the server continues to run.<br>No further attempt to shut down will be made unless a new <code>SIGTERM</code> is received or the <code>SHUTDOWN</code> command is issued.</p>\n<p>Since Redis OSS 7.0, the server waits for lagging replicas up to a configurable <code>shutdown-timeout</code>, 10 seconds by default, before shutting down.<br>This provides a best effort to minimize the risk of data loss in a situation where no save points are configured and AOF is deactivated.<br>Before version 7.0, shutting down a heavily loaded primary node in a diskless setup was more likely to result in data loss.<br>To minimize the risk of data loss in such setups, trigger a manual <code>FAILOVER</code> (or <code>CLUSTER FAILOVER</code>) to demote the primary to a replica and promote one of the replicas to a new primary before shutting down a primary node.</p>\n<h2>SIGSEGV, SIGBUS, SIGFPE and SIGILL</h2>\n<p>The following signals are handled as a Valkey crash:</p>\n<ul>\n<li>SIGSEGV</li>\n<li>SIGBUS</li>\n<li>SIGFPE</li>\n<li>SIGILL</li>\n</ul>\n<p>Once one of these signals is trapped, Valkey stops any current operation and performs the following actions:</p>\n<ul>\n<li>Adds a bug report to the log file. This includes a stack trace, dump of registers, and information about the state of clients.</li>\n<li>A fast memory test is performed as a first check of the reliability of the crashing system.</li>\n<li>If the server was daemonized, the PID file is removed.</li>\n<li>Finally the server unregisters its own signal handler for the received signal and resends the same signal to itself to make sure that the default action is performed, such as dumping the core on the file system.</li>\n</ul>\n<h2>What happens when a child process gets killed</h2>\n<p>When the child performing the Append Only File rewrite gets killed by a signal,<br>Valkey handles this as an error and discards the (probably partial or corrupted)<br>AOF file. It will attempt the rewrite again later.</p>\n<p>When the child performing an RDB save is killed, Valkey handles the<br>condition as a more severe error. While the failure of an<br>AOF file rewrite can cause AOF file enlargement, failed RDB file<br>creation reduces durability.</p>\n<p>As a result of the child producing the RDB file being killed by a signal,<br>or when the child exits with an error (non zero exit code), Valkey enters<br>a special error condition where no further write command is accepted.</p>\n<ul>\n<li>Valkey will continue to reply to read commands.</li>\n<li>Valkey will reply to all write commands with a <code>MISCONFIG</code> error.</li>\n</ul>\n<p>This error condition will persist until it becomes possible to create an RDB file successfully.</p>\n<h2>Kill the RDB file without errors</h2>\n<p>Sometimes the user may want to kill the RDB-saving child process without<br>generating an error. This can be done using the signal <code>SIGUSR1</code>. This signal is handled in a special way:<br>it kills the child process like any other signal, but the parent process will<br>not detect this as a critical error and will continue to serve write<br>requests.</p>\n"
  },
  {
    "id": "memory-optimization",
    "topicName": "Memory optimization",
    "description": "Strategies for optimizing memory usage in Valkey",
    "htmlContent": "<h2>Special encoding of small aggregate data types</h2>\n<p>Many data types are optimized to use less space up to a certain size.<br>Hashes, Lists, Sets composed of just integers, and Sorted Sets, when smaller than a given number of elements, and up to a maximum element size, are encoded in a very memory-efficient way that uses <em>up to 10 times less memory</em> (with 5 times less memory used being the average saving).</p>\n<p>This is completely transparent from the point of view of the user and API.<br>Since this is a CPU / memory tradeoff it is possible to tune the maximum<br>number of elements and maximum element size for special encoded types<br>using the following valkey.conf directives (defaults for Valkey 7.2 are shown):</p>\n<pre><code>hash-max-listpack-entries 512\nhash-max-listpack-value 64\nzset-max-listpack-entries 128\nzset-max-listpack-value 64\nset-max-intset-entries 512\nset-max-listpack-entries 128\nset-max-listpack-value 64\n</code></pre>\n<p>If a specially encoded value overflows the configured max size,<br>Valkey will automatically convert it into normal encoding.<br>This operation is very fast for small values,<br>but if you change the setting in order to use specially encoded values<br>for much larger aggregate types the suggestion is to run some<br>benchmarks and tests to check the conversion time.</p>\n<h2>Using 32-bit instances</h2>\n<p>When Valkey is compiled as a 32-bit target, it uses a lot less memory per key, since pointers are small,<br>but such an instance will be limited to 4 GB of maximum memory usage.<br>To compile Valkey as 32-bit binary use <em>make 32bit</em>.<br>RDB and AOF files are compatible between 32-bit and 64-bit instances<br>(and between little and big endian of course) so you can switch from 32 to 64-bit, or the contrary, without problems.</p>\n<h2>Bit and byte level operations</h2>\n<p>Valkey has bit and byte level operations: <code>GETRANGE</code>, <code>SETRANGE</code>, <code>GETBIT</code> and <code>SETBIT</code>.<br>Using these commands you can treat the String type as a random access array.<br>For instance, if you have an application where users are identified by a unique progressive integer number,<br>you can use a bitmap to save information about the subscription of users in a mailing list,<br>setting the bit for subscribed and clearing it for unsubscribed, or the other way around.<br>With 100 million users this data will take just 12 megabytes of RAM in a Valkey instance.<br>You can do the same using <code>GETRANGE</code> and <code>SETRANGE</code> to store one byte of information for each user.<br>This is just an example but it is possible to model several problems in very little space with these new primitives.</p>\n<h2>Use hashes when possible</h2>\n<p>Small hashes are encoded in a very small space, so you should try representing your data using hashes whenever possible.<br>For instance, if you have objects representing users in a web application,<br>instead of using different keys for name, surname, email, password, use a single hash with all the required fields.</p>\n<p>If you want to know more about this, read the next section.</p>\n<h2>Using hashes to abstract a very memory-efficient plain key-value store on top of Valkey</h2>\n<p>I understand the title of this section is a bit scary, but I&#39;m going to explain in detail what this is about.</p>\n<p>Basically it is possible to model a plain key-value store using Valkey<br>where values can just be just strings, which is not just more memory efficient<br>than Valkey plain keys but also much more memory efficient than memcached.</p>\n<p>Let&#39;s start with some facts: a few keys use a lot more memory than a single key<br>containing a hash with a few fields. How is this possible? We use a trick.<br>In theory to guarantee that we perform lookups in constant time<br>(also known as O(1) in big O notation) there is the need to use a data structure<br>with a constant time complexity in the average case, like a hash table.</p>\n<p>But many times hashes contain just a few fields. When hashes are small we can<br>instead just encode them in an O(N) data structure, like a linear<br>array with length-prefixed key-value pairs. Since we do this only when N<br>is small, the amortized time for <code>HGET</code> and <code>HSET</code> commands is still O(1): the<br>hash will be converted into a real hash table as soon as the number of elements<br>it contains grows too large (you can configure the limit in valkey.conf).</p>\n<p>This does not only work well from the point of view of time complexity, but<br>also from the point of view of constant times since a linear array of key-value pairs happens to play very well with the CPU cache (it has a better<br>cache locality than a hash table).</p>\n<p>However since hash fields and values are not (always) represented as full-featured Valkey objects, hash fields can&#39;t have an associated time to live<br>(expire) like a real key, and can only contain a string. But we are okay with<br>this, this was the intention anyway when the hash data type API was<br>designed (we trust simplicity more than features, so nested data structures<br>are not allowed, as expires of single fields are not allowed).</p>\n<p>So hashes are memory efficient. This is useful when using hashes<br>to represent objects or to model other problems when there are group of<br>related fields. But what about if we have a plain key value business?</p>\n<p>Imagine we want to use Valkey as a cache for many small objects, which can be JSON encoded objects, small HTML fragments, simple key -&gt; boolean values<br>and so forth. Basically, anything is a string -&gt; string map with small keys<br>and values.</p>\n<p>Now let&#39;s assume the objects we want to cache are numbered, like:</p>\n<ul>\n<li>object:102393</li>\n<li>object:1234</li>\n<li>object:5</li>\n</ul>\n<p>This is what we can do. Every time we perform a<br>SET operation to set a new value, we actually split the key into two parts,<br>one part used as a key, and the other part used as the field name for the hash. For instance, the<br>object named &quot;object:1234&quot; is actually split into:</p>\n<ul>\n<li>a Key named object:12</li>\n<li>a Field named 34</li>\n</ul>\n<p>So we use all the characters but the last two for the key, and the final<br>two characters for the hash field name. To set our key we use the following<br>command:</p>\n<pre><code>HSET object:12 34 somevalue\n</code></pre>\n<p>As you can see every hash will end up containing 100 fields, which is an optimal compromise between CPU and memory saved.</p>\n<p>There is another important thing to note, with this schema<br>every hash will have more or<br>less 100 fields regardless of the number of objects we cached. This is because our objects will always end with a number and not a random string. In some way, the final number can be considered as a form of implicit pre-sharding.</p>\n<p>What about small numbers? Like object:2? We handle this case using just<br>&quot;object:&quot; as a key name, and the whole number as the hash field name.<br>So object:2 and object:10 will both end inside the key &quot;object:&quot;, but one<br>as field name &quot;2&quot; and one as &quot;10&quot;.</p>\n<p>Every time a hash exceeds the number of elements or element size specified<br>it will be converted into a real hash table, and the memory saving will be lost.</p>\n<p>You may ask, why don&#39;t you do this implicitly in the normal key space so that<br>I don&#39;t have to care? There are two reasons: one is that we tend to make<br>tradeoffs explicit, and this is a clear tradeoff between many things: CPU,<br>memory, and max element size. The second is that the top-level key space must<br>support a lot of interesting things like expires, LRU data, and so<br>forth so it is not practical to do this in a general way.</p>\n<p>But the Valkey Way is that the user must understand how things work so that he can pick the best compromise and to understand how the system will<br>behave exactly.</p>\n<h2>Memory allocation</h2>\n<p>To store user keys, Valkey allocates at most as much memory as the <code>maxmemory</code><br>setting enables (however there are small extra allocations possible).</p>\n<p>The exact value can be set in the configuration file or set later via<br><code>CONFIG SET</code> (for more info, see <a href=\"lru-cache.md\">Using memory as an LRU cache</a>).<br>There are a few things that should be noted about how Valkey manages memory:</p>\n<ul>\n<li>Valkey will not always free up (return) memory to the OS when keys are removed.<br>This is not something special about Valkey, but it is how most malloc() implementations work.<br>For example, if you fill an instance with 5GB worth of data, and then<br>remove the equivalent of 2GB of data, the Resident Set Size (also known as<br>the RSS, which is the number of memory pages consumed by the process)<br>will probably still be around 5GB, even if Valkey will claim that the user<br>memory is around 3GB.  This happens because the underlying allocator can&#39;t easily release the memory.<br>For example, often most of the removed keys were allocated on the same pages as the other keys that still exist.</li>\n<li>The previous point means that you need to provision memory based on your<br><strong>peak memory usage</strong>. If your workload from time to time requires 10GB, even if<br>most of the time 5GB could do, you need to provision for 10GB.</li>\n<li>However allocators are smart and are able to reuse free chunks of memory,<br>so after you free 2GB of your 5GB data set, when you start adding more keys<br>again, you&#39;ll see the RSS (Resident Set Size) stay steady and not grow<br>more, as you add up to 2GB of additional keys. The allocator is basically<br>trying to reuse the 2GB of memory previously (logically) freed.</li>\n<li>Because of all this, the fragmentation ratio is not reliable when you<br>had a memory usage that at the peak is much larger than the currently used memory.<br>The fragmentation is calculated as the physical memory actually used (the RSS<br>value) divided by the amount of memory currently in use (as the sum of all<br>the allocations performed by Valkey). Because the RSS reflects the peak memory,<br>when the (virtually) used memory is low since a lot of keys/values were freed, but the RSS is high, the ratio <code>RSS / mem_used</code> will be very high.</li>\n</ul>\n<p>If <code>maxmemory</code> is not set Valkey will keep allocating memory as it sees<br>fit and thus it can (gradually) eat up all your free memory.<br>Therefore it is generally advisable to configure some limits. You may also<br>want to set <code>maxmemory-policy</code> to <code>noeviction</code> (which is <em>not</em> the default<br>value in some older versions of Valkey).</p>\n<p>It makes Valkey return an out-of-memory error for write commands if and when it reaches the<br>limit - which in turn may result in errors in the application but will not render the<br>whole machine dead because of memory starvation.</p>\n"
  },
  {
    "id": "pipelining",
    "topicName": "Pipelining",
    "description": "How to optimize round-trip times by batching Valkey commands",
    "htmlContent": "<p>Valkey pipelining is a technique for improving performance by issuing multiple commands at once without waiting for the response to each individual command. Pipelining is supported by most Valkey clients. This document describes the problem that pipelining is designed to solve and how pipelining works in Valkey.</p>\n<h2>Request/Response protocols and round-trip time (RTT)</h2>\n<p>Valkey is a TCP server using the client-server model and what is called a <em>Request/Response</em> protocol.</p>\n<p>This means that usually a request is accomplished with the following steps:</p>\n<ul>\n<li>The client sends a query to the server, and reads from the socket, usually in a blocking way, for the server response.</li>\n<li>The server processes the command and sends the response back to the client.</li>\n</ul>\n<p>So for instance a four commands sequence is something like this:</p>\n<ul>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 1</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 2</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 3</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 4</li>\n</ul>\n<p>Clients and Servers are connected via a network link.<br>Such a link can be very fast (a loopback interface) or very slow (a connection established over the Internet with many hops between the two hosts).<br>Whatever the network latency is, it takes time for the packets to travel from the client to the server, and back from the server to the client to carry the reply.</p>\n<p>This time is called RTT (Round Trip Time).<br>It&#39;s easy to see how this can affect performance when a client needs to perform many requests in a row (for instance adding many elements to the same list, or populating a database with many keys).<br>For instance if the RTT time is 250 milliseconds (in the case of a very slow link over the Internet), even if the server is able to process 100k requests per second, we&#39;ll be able to process at max four requests per second.</p>\n<p>If the interface used is a loopback interface, the RTT is much shorter, typically sub-millisecond, but even this will add up to a lot if you need to perform many writes in a row.</p>\n<p>Fortunately there is a way to improve this use case.</p>\n<h2>Valkey Pipelining</h2>\n<p>A Request/Response server can be implemented so that it is able to process new requests even if the client hasn&#39;t already read the old responses.<br>This way it is possible to send <em>multiple commands</em> to the server without waiting for the replies at all, and finally read the replies in a single step.</p>\n<p>This is called pipelining, and is a technique widely in use for many decades.<br>For instance many POP3 protocol implementations already support this feature, dramatically speeding up the process of downloading new emails from the server.</p>\n<p>Valkey has supported pipelining since its early days, so whatever version you are running, you can use pipelining with Valkey.<br>This is an example using the raw netcat utility:</p>\n<pre><code class=\"language-bash\">$ (printf &quot;PING\\r\\nPING\\r\\nPING\\r\\n&quot;; sleep 1) | nc localhost 6379\n+PONG\n+PONG\n+PONG\n</code></pre>\n<p>This time we don&#39;t pay the cost of RTT for every call, but just once for the three commands.</p>\n<p>To be explicit, with pipelining the order of operations of our very first example will be the following:</p>\n<ul>\n<li><em>Client:</em> INCR X</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 1</li>\n<li><em>Server:</em> 2</li>\n<li><em>Server:</em> 3</li>\n<li><em>Server:</em> 4</li>\n</ul>\n<blockquote>\n<p><strong>IMPORTANT NOTE</strong>: While the client sends commands using pipelining, the server will be forced to queue the replies, using memory. So if you need to send a lot of commands with pipelining, it is better to send them as batches each containing a reasonable number, for instance 10k commands, read the replies, and then send another 10k commands again, and so forth. The speed will be nearly the same, but the additional memory used will be at most the amount needed to queue the replies for these 10k commands.</p>\n</blockquote>\n<h2>It&#39;s not just a matter of RTT</h2>\n<p>Pipelining is not just a way to reduce the latency cost associated with the<br>round trip time, it actually greatly improves the number of operations<br>you can perform per second in a given Valkey server.<br>This is because without using pipelining, serving each command is very cheap from<br>the point of view of accessing the data structures and producing the reply,<br>but it is very costly from the point of view of doing the socket I/O. This<br>involves calling the <code>read()</code> and <code>write()</code> syscall, that means going from user<br>land to kernel land.<br>The context switch is a huge speed penalty.</p>\n<p>When pipelining is used, many commands are usually read with a single <code>read()</code><br>system call, and multiple replies are delivered with a single <code>write()</code> system<br>call. Consequently, the number of total queries performed per second<br>initially increases almost linearly with longer pipelines, and eventually<br>reaches 10 times the baseline obtained without pipelining, as shown in this figure.</p>\n<p><img src=\"pipeline_iops.png\" alt=\"Pipeline size and IOPs\"></p>\n<h2>A real world code example</h2>\n<p>In the following benchmark we&#39;ll use a Ruby client, supporting pipelining, to test the speed improvement due to pipelining:</p>\n<pre><code class=\"language-ruby\">require &#39;rubygems&#39;\nrequire &#39;redis&#39;\n\ndef bench(descr)\n  start = Time.now\n  yield\n  puts &quot;#{descr} #{Time.now - start} seconds&quot;\nend\n\ndef without_pipelining\n  r = Redis.new\n  10_000.times do\n    r.ping\n  end\nend\n\ndef with_pipelining\n  r = Redis.new\n  r.pipelined do\n    10_000.times do\n      r.ping\n    end\n  end\nend\n\nbench(&#39;without pipelining&#39;) do\n  without_pipelining\nend\nbench(&#39;with pipelining&#39;) do\n  with_pipelining\nend\n</code></pre>\n<p>Running the above simple script yields the following figures on my MacOS system, running over the loopback interface, where pipelining will provide the smallest improvement as the RTT is already pretty low:</p>\n<pre><code>without pipelining 1.185238 seconds\nwith pipelining 0.250783 seconds\n</code></pre>\n<p>As you can see, using pipelining, we improved the transfer by a factor of five.</p>\n<h2>Pipelining vs Scripting</h2>\n<p>Using <a href=\"../commands/eval.md\">Valkey scripting</a>, a number of use cases for pipelining can be addressed more efficiently using scripts that perform a lot of the work needed at the server side.<br>A big advantage of scripting is that it is able to both read and write data with minimal latency, making operations like <em>read, compute, write</em> very fast (pipelining can&#39;t help in this scenario since the client needs the reply of the read command before it can call the write command).</p>\n<p>Sometimes the application may also want to send <code>EVAL</code> or <code>EVALSHA</code> commands in a pipeline.<br>This is entirely possible and Valkey explicitly supports it with the <a href=\"../commands/script-load.md\">SCRIPT LOAD</a> command (it guarantees that <code>EVALSHA</code> can be called without the risk of failing).</p>\n<h2>Appendix: Why are busy loops slow even on the loopback interface?</h2>\n<p>Even with all the background covered in this page, you may still wonder why<br>a Valkey benchmark like the following (in pseudo code), is slow even when<br>executed in the loopback interface, when the server and the client are running<br>in the same physical machine:</p>\n<pre><code class=\"language-sh\">FOR-ONE-SECOND:\n    Valkey.SET(&quot;foo&quot;,&quot;bar&quot;)\nEND\n</code></pre>\n<p>After all, if both the Valkey process and the benchmark are running in the same<br>box, isn&#39;t it just copying messages in memory from one place to another without<br>any actual latency or networking involved?</p>\n<p>The reason is that processes in a system are not always running, actually it is<br>the kernel scheduler that lets the process run.<br>So, for instance, when the benchmark is allowed to run, it reads the reply from the Valkey server (related to the last command executed), and writes a new command.<br>The command is now in the loopback interface buffer, but in order to be read by the server, the kernel should schedule the server process (currently blocked in a system call)<br>to run, and so forth.<br>So in practical terms the loopback interface still involves network-like latency, because of how the kernel scheduler works.</p>\n<p>Basically a busy loop benchmark is the silliest thing that can be done when<br>metering performances on a networked server. The wise thing is just avoiding<br>benchmarking in this way.</p>\n"
  },
  {
    "id": "latency-monitor",
    "topicName": "Latency monitoring",
    "description": "Discovering slow server events in Valkey",
    "htmlContent": "<p>Valkey is often used for demanding use cases, where it<br>serves a large number of queries per second per instance, but also has strict latency requirements for the average response<br>time and the worst-case latency.</p>\n<p>While Valkey is an in-memory system, it deals with the operating system in<br>different ways, for example, in the context of persisting to disk.<br>Moreover Valkey implements a rich set of commands. Certain commands<br>are fast and run in constant or logarithmic time. Other commands are slower<br>O(N) commands that can cause latency spikes.</p>\n<p>Finally, Valkey is single threaded. This is usually an advantage<br>from the point of view of the amount of work it can perform per core, and in<br>the latency figures it is able to provide. However, it poses<br>a challenge for latency, since the single<br>thread must be able to perform certain tasks incrementally, for<br>example key expiration, in a way that does not impact the other clients<br>that are served.</p>\n<p>For all these reasons, there is a feature called<br><strong>Latency Monitoring</strong>, that helps the user to check and troubleshoot possible<br>latency problems. Latency monitoring is composed of the following conceptual<br>parts:</p>\n<ul>\n<li>Latency hooks that sample different latency-sensitive code paths.</li>\n<li>Time series recording of latency spikes, split by different events.</li>\n<li>Reporting engine to fetch raw data from the time series.</li>\n<li>Analysis engine to provide human-readable reports and hints according to the measurements.</li>\n</ul>\n<p>The rest of this document covers the latency monitoring subsystem<br>details. For more information about the general topic of Valkey<br>and latency, see <a href=\"latency.md\">Valkey latency problems troubleshooting</a>.</p>\n<h2>Events and time series</h2>\n<p>Different monitored code paths have different names and are called <em>events</em>.<br>For example, <code>command</code> is an event that measures latency spikes of possibly slow<br>command executions, while <code>fast-command</code> is the event name for the monitoring<br>of the O(1) and O(log N) commands. Other events are less generic and monitor<br>specific operations performed by Valkey. For example, the <code>fork</code> event<br>only monitors the time taken by Valkey to execute the <code>fork(2)</code> system call.</p>\n<p>A latency spike is an event that takes more time to run than the configured latency<br>threshold. There is a separate time series associated with every monitored<br>event. This is how the time series work:</p>\n<ul>\n<li>Every time a latency spike happens, it is logged in the appropriate time series.</li>\n<li>Every time series is composed of 160 elements.</li>\n<li>Each element is a pair made of a Unix timestamp of the time the latency spike was measured and the number of milliseconds the event took to execute.</li>\n<li>Latency spikes for the same event that occur in the same second are merged by taking the maximum latency. Even if continuous latency spikes are measured for a given event, which could happen with a low threshold, at least 160 seconds of history are available.</li>\n<li>Records the all-time maximum latency for every element.</li>\n</ul>\n<p>The framework monitors and logs latency spikes in the execution time of these events:</p>\n<ul>\n<li><code>command</code>: regular commands.</li>\n<li><code>fast-command</code>: O(1) and O(log N) commands.</li>\n<li><code>fork</code>: the <code>fork(2)</code> system call.</li>\n<li><code>rdb-unlink-temp-file</code>: the <code>unlink(2)</code> system call.</li>\n<li><code>aof-fsync-always</code>: the <code>fsync(2)</code> system call when invoked by the <code>appendfsync allways</code> policy.</li>\n<li><code>aof-write</code>: writing to the AOF - a catchall event for <code>write(2)</code> system calls.</li>\n<li><code>aof-write-pending-fsync</code>: the <code>write(2)</code> system call when there is a pending fsync.</li>\n<li><code>aof-write-active-child</code>: the <code>write(2)</code> system call when there are active child processes.</li>\n<li><code>aof-write-alone</code>: the <code>write(2)</code> system call when no pending fsync and no active child process.</li>\n<li><code>aof-fstat</code>: the <code>fstat(2)</code> system call.</li>\n<li><code>aof-rename</code>: the <code>rename(2)</code> system call for renaming the temporary file after completing <code>BGREWRITEAOF</code>.</li>\n<li><code>aof-rewrite-diff-write</code>: writing the differences accumulated while performing <code>BGREWRITEAOF</code>.</li>\n<li><code>active-defrag-cycle</code>: the active defragmentation cycle.</li>\n<li><code>expire-cycle</code>: the expiration cycle.</li>\n<li><code>eviction-cycle</code>: the eviction cycle.</li>\n<li><code>eviction-del</code>: deletes during the eviction cycle.</li>\n</ul>\n<h2>How to enable latency monitoring</h2>\n<p>What is high latency for one use case may not be considered high latency for another. Some applications may require that all queries be served in less than 1 millisecond. For other applications, it may be acceptable for a small amount of clients to experience a 2 second latency on occasion.</p>\n<p>The first step to enable the latency monitor is to set a <strong>latency threshold</strong> in milliseconds. Only events that take longer than the specified threshold will be logged as latency spikes. The user should set the threshold according to their needs. For example, if the application requires a maximum acceptable latency of 100 milliseconds, the threshold should be set to log all the events blocking the server for a time equal or greater to 100 milliseconds.</p>\n<p>Enable the latency monitor at runtime in a production server<br>with the following command:</p>\n<pre><code>CONFIG SET latency-monitor-threshold 100\n</code></pre>\n<p>Monitoring is turned off by default (threshold set to 0), even if the actual cost of latency monitoring is near zero. While the memory requirements of latency monitoring are very small, there is no good reason to raise the baseline memory usage of a Valkey instance that is working well.</p>\n<h2>Report information with the LATENCY command</h2>\n<p>The user interface to the latency monitoring subsystem is the <code>LATENCY</code> command.<br>Like many other Valkey commands, <code>LATENCY</code> accepts subcommands that modify its behavior. These subcommands are:</p>\n<ul>\n<li><code>LATENCY LATEST</code> - returns the latest latency samples for all events.</li>\n<li><code>LATENCY HISTORY</code> - returns latency time series for a given event.</li>\n<li><code>LATENCY RESET</code> - resets latency time series data for one or more events.</li>\n<li><code>LATENCY GRAPH</code> - renders an ASCII-art graph of an event&#39;s latency samples.</li>\n<li><code>LATENCY DOCTOR</code> - replies with a human-readable latency analysis report.</li>\n</ul>\n<p>Refer to each subcommand&#39;s documentation page for further information.</p>\n"
  },
  {
    "id": "performance-on-cpu",
    "topicName": "CPU profiling",
    "description": "Performance engineering guide for on-CPU profiling and tracing\n",
    "htmlContent": "<h2>Filling the performance checklist</h2>\n<p>Valkey is developed with a great emphasis on performance. We do our best with<br>every release to make sure you&#39;ll experience a very stable and fast product. </p>\n<p>Nevertheless, if you&#39;re finding room to improve the efficiency of Valkey or<br>are pursuing a performance regression investigation you will need a concise<br>methodical way of monitoring and analyzing Valkey performance. </p>\n<p>To do so you can rely on different methodologies (some more suited than other<br>depending on the class of issues/analysis we intend to make). A curated list<br>of methodologies and their steps are enumerated by Brendan Greg at the<br><a href=\"https://www.brendangregg.com/methodology.html\">following link</a>. </p>\n<p>We recommend the Utilization Saturation and Errors (USE) Method for answering<br>the question of what is your bottleneck. Check the following mapping between<br>system resource, metric, and tools for a practical deep dive:<br><a href=\"https://www.brendangregg.com/USEmethod/use-rosetta.html\">USE method</a>. </p>\n<h3>Ensuring the CPU is your bottleneck</h3>\n<p>This guide assumes you&#39;ve followed one of the above methodologies to perform a<br>complete check of system health, and identified the bottleneck being the CPU.<br><strong>If you have identified that most of the time is spent blocked on I/O, locks,<br>timers, paging/swapping, etc., this guide is not for you</strong>. </p>\n<h3>Build Prerequisites</h3>\n<p>For a proper On-CPU analysis, Valkey (and any dynamically loaded library like<br>Valkey Modules) requires stack traces to be available to tracers, which you may<br>need to fix first. </p>\n<p>By default, Valkey is compiled with the <code>-O3</code> optimization flag (which we intent to keep<br>during profiling). This means that compiler optimizations are enabled which significantly<br>enhance the performance. Valkey is also compiled with the <code>-fno-omit-frame-pointer</code> flag<br>by default, ensuring that the frame pointer is preserved across function calls.<br>This combination allows for precise stack walking and call stack tracing,<br>which is essential for accurate profiling and debugging. Keeping the frame pointer<br>intact helps profiling tools like <code>perf</code>, <code>gdb</code>, and others correctly attribute on-CPU<br>time to deeper call stack frames, leading to more reliable insights into performance bottlenecks<br>and hotspots. This setup strikes a balance between maintaining a highly optimized executable<br>and ensuring that profiling and tracing tools provide accurate and actionable data.</p>\n<p>It&#39;s important that you ensure that:</p>\n<ul>\n<li>we still run with optimizations to get an accurate representation of production run times, meaning we will keep: <code>-O3</code></li>\n</ul>\n<p>You can do it as follows within valkey main repo:</p>\n<pre><code>$ make SERVER_CFLAGS=&quot;-g&quot;\n</code></pre>\n<h2>A set of instruments to identify performance regressions and/or potential <strong>on-CPU performance</strong> improvements</h2>\n<p>This document focuses specifically on <strong>on-CPU</strong> resource bottlenecks analysis,<br>meaning we&#39;re interested in understanding where threads are spending CPU cycles<br>while running on-CPU and, as importantly, whether those cycles are effectively<br>being used for computation or stalled waiting (not blocked!) for memory I/O,<br>and cache misses, etc.</p>\n<p>For that we will rely on toolkits (perf, bcc tools), and hardware specific PMCs<br>(Performance Monitoring Counters), to proceed with:</p>\n<ul>\n<li><p>Hotspot analysis (perf or bcc tools): to profile code execution and determine which functions are consuming the most time and thus are targets for optimization. We&#39;ll present two options to collect, report, and visualize hotspots either with perf or bcc/BPF tracing tools.</p>\n</li>\n<li><p>Call counts analysis: to count events including function calls, enabling us to correlate several calls/components at once, relying on bcc/BPF tracing tools.</p>\n</li>\n<li><p>Hardware event sampling: crucial for understanding CPU behavior, including memory I/O, stall cycles, and cache misses.</p>\n</li>\n</ul>\n<h3>Tool prerequisites</h3>\n<p>The following steps rely on Linux perf_events (aka <a href=\"https://man7.org/linux/man-pages/man1/perf.1.html\">&quot;perf&quot;</a>), <a href=\"https://github.com/iovisor/bcc\">bcc/BPF tracing tools</a>, and Brendan Gregs <a href=\"https://github.com/brendangregg/FlameGraph\">FlameGraph repo</a>.</p>\n<p>We assume beforehand you have:</p>\n<ul>\n<li>Installed the perf tool on your system. Most Linux distributions will likely package this as a package related to the kernel. More information about the perf tool can be found at perf <a href=\"https://perf.wiki.kernel.org/\">wiki</a>.</li>\n<li>Followed the install <a href=\"https://github.com/iovisor/bcc/blob/master/INSTALL.md#installing-bcc\">bcc/BPF</a> instructions to install bcc toolkit on your machine.</li>\n<li>Cloned Brendan Gregs <a href=\"https://github.com/brendangregg/FlameGraph\">FlameGraph repo</a> and made accessible the <code>difffolded.pl</code> and <code>flamegraph.pl</code> files, to generated the collapsed stack traces and Flame Graphs.</li>\n</ul>\n<h2>Hotspot analysis with perf or eBPF (stack traces sampling)</h2>\n<p>Profiling CPU usage by sampling stack traces at a timed interval is a fast and<br>easy way to identify performance-critical code sections (hotspots).</p>\n<h3>Sampling stack traces using perf</h3>\n<p>To profile both user- and kernel-level stacks of valkey-server for a specific<br>length of time, for example 60 seconds, at a sampling frequency of 999 samples<br>per second:</p>\n<pre><code>$ perf record -g --pid $(pgrep valkey-server) -F 999 -- sleep 60\n</code></pre>\n<h4>Displaying the recorded profile information using perf report</h4>\n<p>By default perf record will generate a perf.data file in the current working<br>directory. </p>\n<p>You can then report with a call-graph output (call chain, stack backtrace),<br>with a minimum call graph inclusion threshold of 0.5%, with:</p>\n<pre><code>$ perf report -g &quot;graph,0.5,caller&quot;\n</code></pre>\n<p>See the <a href=\"https://man7.org/linux/man-pages/man1/perf-report.1.html\">perf report</a><br>documentation for advanced filtering, sorting and aggregation capabilities.</p>\n<h4>Visualizing the recorded profile information using Flame Graphs</h4>\n<p><a href=\"https://www.brendangregg.com/flamegraphs.html\">Flame graphs</a> allow for a quick<br>and accurate visualization of frequent code-paths. They can be generated using<br>Brendan Greg&#39;s open source programs on <a href=\"https://github.com/brendangregg/FlameGraph\">github</a>,<br>which create interactive SVGs from folded stack files.</p>\n<p>Specifically, for perf we need to convert the generated perf.data into the<br>captured stacks, and fold each of them into single lines. You can then render<br>the on-CPU flame graph with:</p>\n<pre><code>$ perf script &gt; valkey.perf.stacks\n$ stackcollapse-perf.pl valkey.perf.stacks &gt; valkey.folded.stacks\n$ flamegraph.pl valkey.folded.stacks &gt; valkey.svg\n</code></pre>\n<p>By default, perf script will generate a perf.data file in the current working<br>directory. See the <a href=\"https://linux.die.net/man/1/perf-script\">perf script</a><br>documentation for advanced usage.</p>\n<p>See <a href=\"https://github.com/brendangregg/FlameGraph#options\">FlameGraph usage options</a><br>for more advanced stack trace visualizations (like the differential one).</p>\n<h4>Archiving and sharing recorded profile information</h4>\n<p>So that analysis of the perf.data contents can be possible on a machine other<br>than the one on which collection happened, you need to export along with the<br>perf.data file all object files with build-ids found in the record data file.<br>This can be easily done with the help of<br><a href=\"https://github.com/torvalds/linux/blob/master/tools/perf/perf-archive.sh\">perf-archive.sh</a><br>script:</p>\n<pre><code>$ perf-archive.sh perf.data\n</code></pre>\n<p>Now please run:</p>\n<pre><code>$ tar xvf perf.data.tar.bz2 -C ~/.debug\n</code></pre>\n<p>on the machine where you need to run <code>perf report</code>.</p>\n<h3>Sampling stack traces using bcc/BPF&#39;s profile</h3>\n<p>Similarly to perf, as of Linux kernel 4.9, BPF-optimized profiling is now fully<br>available with the promise of lower overhead on CPU (as stack traces are<br>frequency counted in kernel context) and disk I/O resources during profiling. </p>\n<p>Apart from that, and relying solely on bcc/BPF&#39;s profile tool, we have also<br>removed the perf.data and intermediate steps if stack traces analysis is our<br>main goal. You can use bcc&#39;s profile tool to output folded format directly, for<br>flame graph generation:</p>\n<pre><code>$ /usr/share/bcc/tools/profile -F 999 -f --pid $(pgrep valkey-server) --duration 60 &gt; valkey.folded.stacks\n</code></pre>\n<p>In that manner, we&#39;ve remove any preprocessing and can render the on-CPU flame<br>graph with a single command:</p>\n<pre><code>$ flamegraph.pl valkey.folded.stacks &gt; valkey.svg\n</code></pre>\n<h3>Visualizing the recorded profile information using Flame Graphs</h3>\n<h2>Call counts analysis with bcc/BPF</h2>\n<p>A function may consume significant CPU cycles either because its code is slow<br>or because it&#39;s frequently called. To answer at what rate functions are being<br>called, you can rely upon call counts analysis using BCC&#39;s <code>funccount</code> tool:</p>\n<pre><code>$ /usr/share/bcc/tools/funccount &#39;valkey-server:(call*|*Read*|*Write*)&#39; --pid $(pgrep valkey-server) --duration 60\nTracing 64 functions for &quot;valkey-server:(call*|*Read*|*Write*)&quot;... Hit Ctrl-C to end.\n\nFUNC                                    COUNT\ncall                                      334\nhandleClientsWithPendingWrites            388\nclientInstallWriteHandler                 388\npostponeClientRead                        514\nhandleClientsWithPendingReadsUsingThreads      735\nhandleClientsWithPendingWritesUsingThreads      735\nprepareClientToWrite                     1442\nDetaching...\n</code></pre>\n<p>The above output shows that, while tracing, the Valkey&#39;s call() function was<br>called 334 times, handleClientsWithPendingWrites() 388 times, etc.</p>\n<h2>Hardware event counting with Performance Monitoring Counters (PMCs)</h2>\n<p>Many modern processors contain a performance monitoring unit (PMU) exposing<br>Performance Monitoring Counters (PMCs). PMCs are crucial for understanding CPU<br>behavior, including memory I/O, stall cycles, and cache misses, and provide<br>low-level CPU performance statistics that aren&#39;t available anywhere else.</p>\n<p>The design and functionality of a PMU is CPU-specific and you should assess<br>your CPU supported counters and features by using <code>perf list</code>. </p>\n<p>To calculate the number of instructions per cycle, the number of micro ops<br>executed, the number of cycles during which no micro ops were dispatched, the<br>number stalled cycles on memory, including a per memory type stalls, for the<br>duration of 60s, specifically for the valkey-server process: </p>\n<pre><code>$ perf stat -e &quot;cpu-clock,cpu-cycles,instructions,uops_executed.core,uops_executed.stall_cycles,cache-references,cache-misses,cycle_activity.stalls_total,cycle_activity.stalls_mem_any,cycle_activity.stalls_l3_miss,cycle_activity.stalls_l2_miss,cycle_activity.stalls_l1d_miss&quot; --pid $(pgrep valkey-server) -- sleep 60\n\nPerformance counter stats for process id &#39;3038&#39;:\n\n  60046.411437      cpu-clock (msec)          #    1.001 CPUs utilized          \n  168991975443      cpu-cycles                #    2.814 GHz                      (36.40%)\n  388248178431      instructions              #    2.30  insn per cycle           (45.50%)\n  443134227322      uops_executed.core        # 7379.862 M/sec                    (45.51%)\n   30317116399      uops_executed.stall_cycles #  504.895 M/sec                    (45.51%)\n     670821512      cache-references          #   11.172 M/sec                    (45.52%)\n      23727619      cache-misses              #    3.537 % of all cache refs      (45.43%)\n   30278479141      cycle_activity.stalls_total #  504.251 M/sec                    (36.33%)\n   19981138777      cycle_activity.stalls_mem_any #  332.762 M/sec                    (36.33%)\n     725708324      cycle_activity.stalls_l3_miss #   12.086 M/sec                    (36.33%)\n    8487905659      cycle_activity.stalls_l2_miss #  141.356 M/sec                    (36.32%)\n   10011909368      cycle_activity.stalls_l1d_miss #  166.736 M/sec                    (36.31%)\n\n  60.002765665 seconds time elapsed\n</code></pre>\n<p>It&#39;s important to know that there are two very different ways in which PMCs can<br>be used (counting and sampling), and we&#39;ve focused solely on PMCs counting for<br>the sake of this analysis. Brendan Greg clearly explains it on the following<br><a href=\"https://www.brendangregg.com/blog/2017-05-04/the-pmcs-of-ec2.html\">link</a>.</p>\n"
  },
  {
    "id": "benchmark",
    "topicName": "Benchmarking tool",
    "description": "Using the valkey-benchmark utility on a Valkey server\n",
    "htmlContent": "<h2>Usage</h2>\n<p><strong><code>valkey-benchmark</code></strong> [ <em>OPTIONS</em> ] [ <em>COMMAND</em> <em>ARGS</em>... ]</p>\n<h2>Description</h2>\n<p>Valkey includes the <code>valkey-benchmark</code> utility that simulates running commands done<br>by N clients while at the same time sending M total queries. The utility provides<br>a default set of tests, or you can supply a custom set of tests.</p>\n<h2>Options</h2>\n<p><strong><code>-h</code></strong> <em>hostname</em><br>: Server hostname (default 127.0.0.1)</p>\n<p><strong><code>-p</code></strong> <em>port</em><br>: Server port (default 6379)</p>\n<p><strong><code>-s</code></strong> <em>socket</em><br>: Server socket (overrides host and port)</p>\n<p><strong><code>-a</code></strong> <em>password</em><br>: Password for Valkey Auth</p>\n<p><strong><code>--user</code></strong> <em>username</em><br>: Used to send ACL style &#39;AUTH username pass&#39;. Needs -a.</p>\n<p><strong><code>-u</code></strong> <em>uri</em><br>: Server URI on format <code>valkey://user:password@host:port/dbnum</code>.<br>  User, password and dbnum are optional. For authentication<br>  without a username, use username &#39;default&#39;. For TLS, use<br>  the scheme &#39;valkeys&#39;.</p>\n<p><strong><code>-c</code></strong> <em>clients</em><br>: Number of parallel connections (default 50).<br>  Note: If <code>--cluster</code> is used then number of clients has to be<br>  the same or higher than the number of nodes.</p>\n<p><strong><code>-n</code></strong> <em>requests</em><br>: Total number of requests (default 100000)</p>\n<p><strong><code>-d</code></strong> <em>size</em><br>: Data size of SET/GET value in bytes (default 3)</p>\n<p><strong><code>--dbnum</code></strong> <em>db</em><br>: SELECT the specified db number (default 0)</p>\n<p><strong><code>-3</code></strong><br>: Start session in RESP3 protocol mode.</p>\n<p><strong><code>--threads</code></strong> <em>num</em><br>: Enable multi-thread mode.</p>\n<p><strong><code>--cluster</code></strong><br>: Enable cluster mode.<br>  If the command is supplied on the command line in cluster<br>  mode, the key must contain &quot;{tag}&quot;. Otherwise, the<br>  command will not be sent to the right cluster node.</p>\n<p><strong><code>--rfr</code></strong> <em>mode</em><br>: Enable read from replicas in cluster mode.<br>  This command must be used with the <code>--cluster</code> option.<br>  There are three modes for reading from replicas:</p>\n<p>  <strong>no</strong> - sends read requests to primaries only (default).</p>\n<p>  <strong>yes</strong> - sends read requests to replicas only.</p>\n<p>  <strong>all</strong> - sends read requests to all nodes.</p>\n<p>   Since write commands will be rejected by replicas,<br>   it is recommended to enable read from replicas only for read command tests.</p>\n<p><strong><code>--enable-tracking</code></strong><br>: Send CLIENT TRACKING ON before starting benchmark.</p>\n<p><strong><code>-k</code></strong> <em>boolean</em><br>: 1=keep alive 0=reconnect (default 1)</p>\n<p><strong><code>-r</code></strong> <em>keyspacelen</em><br>: Use random keys for SET/GET/INCR, random values for SADD,<br>  random members and scores for ZADD.<br>  Using this option the benchmark will expand the string<br>  <code>__rand_int__</code> inside an argument with a 12 digits number in<br>  the specified range from 0 to keyspacelen - 1. The<br>  substitution changes every time a command is executed.<br>  Default tests use this to hit random keys in the specified<br>  range.<br>  Note: If <code>-r</code> is omitted, all commands in a benchmark will<br>  use the same key.</p>\n<p><strong><code>-P</code></strong> <em>numreq</em><br>: Pipeline <em>numreq</em> requests. Default 1 (no pipeline).</p>\n<p><strong><code>-q</code></strong><br>: Quiet. Just show query/sec values</p>\n<p><strong><code>--precision</code></strong><br>: Number of decimal places to display in latency output (default 0)</p>\n<p><strong><code>--csv</code></strong><br>: Output in CSV format</p>\n<p><strong><code>-l</code></strong><br>: Loop. Run the tests forever</p>\n<p><strong><code>-t</code></strong> <em>tests</em><br>: Only run the comma separated list of tests. The test<br>  names are the same as the ones produced as output.<br>  The <code>-t</code> option is ignored if a specific command is supplied<br>  on the command line.</p>\n<p><strong><code>-I</code></strong><br>: Idle mode. Just open N idle connections and wait.</p>\n<p><strong><code>-x</code></strong><br>: Read last argument from STDIN.</p>\n<p><strong><code>--seed</code></strong> <em>num</em><br>: Set the seed for random number generator. Default seed is based on time.</p>\n<p><strong><code>--tls</code></strong><br>: Establish a secure TLS connection.</p>\n<p><strong><code>--sni</code></strong> <em>host</em><br>: Server name indication for TLS.</p>\n<p><strong><code>--cacert</code></strong> <em>file</em><br>: CA Certificate file to verify with.</p>\n<p><strong><code>--cacertdir</code></strong> <em>dir</em><br>: Directory where trusted CA certificates are stored.<br>  If neither cacert nor cacertdir are specified, the default<br>  system-wide trusted root certs configuration will apply.</p>\n<p><strong><code>--insecure</code></strong><br>: Allow insecure TLS connection by skipping cert validation.</p>\n<p><strong><code>--cert</code></strong> <em>file</em><br>: Client certificate to authenticate with.</p>\n<p><strong><code>--key</code></strong> <em>file</em><br>: Private key file to authenticate with.</p>\n<p><strong><code>--tls-ciphers</code></strong> <em>list</em><br>: Sets the list of preferred ciphers (TLSv1.2 and below)<br>  in order of preference from highest to lowest separated by colon (&quot;:&quot;).<br>  See the <strong>ciphers</strong>(1ssl) manpage for more information about the syntax of this string.</p>\n<p><strong><code>--tls-ciphersuites</code></strong> <em>list</em><br>: Sets the list of preferred ciphersuites (TLSv1.3)<br>  in order of preference from highest to lowest separated by colon (&quot;:&quot;).<br>  See the <strong>ciphers</strong>(1ssl) manpage for more information about the syntax of this string,<br>  and specifically for TLSv1.3 ciphersuites.</p>\n<p><strong><code>--help</code></strong><br>: Output help and exit.</p>\n<p><strong><code>--version</code></strong><br>: Output version and exit.</p>\n<h2>Examples</h2>\n<p>Run the benchmark with the default configuration against 127.0.0.1:6379. You<br>need to have a running Valkey instance before launching the benchmark:</p>\n<pre><code>$ valkey-benchmark\n</code></pre>\n<p>Run a benchmark with 20 parallel clients, pipelining 10 commands at a time,<br>using 2 threads and less verbose output:</p>\n<pre><code>$ valkey-benchmark -c 20 -P 10 --threads 2 -q\n</code></pre>\n<p>Use 20 parallel clients, for a total of 100k requests, against 192.168.1.1:</p>\n<pre><code>$ valkey-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20\n</code></pre>\n<p>Fill 127.0.0.1:6379 with about 1 million keys only using the SET test:</p>\n<pre><code>$ valkey-benchmark -t set -n 1000000 -r 100000000\n</code></pre>\n<p>Benchmark 127.0.0.1:6379 for a few commands producing CSV output:</p>\n<pre><code>$ valkey-benchmark -t ping,set,get -n 100000 --csv\n</code></pre>\n<p>Benchmark a specific command line:</p>\n<pre><code>$ valkey-benchmark -r 10000 -n 10000 eval &#39;return redis.call(&quot;ping&quot;)&#39; 0\n</code></pre>\n<p>Fill a list with 10000 random elements:</p>\n<pre><code>$ valkey-benchmark -r 10000 -n 10000 lpush mylist __rand_int__\n</code></pre>\n<p>On user specified command lines <code>__rand_int__</code> is replaced with a random integer<br>with a range of values selected by the <code>-r</code> option.</p>\n<h3>Running only a subset of the tests</h3>\n<p>You don&#39;t need to run all the default tests every time you execute <code>valkey-benchmark</code>.<br>For example, to select only a subset of tests, use the <code>-t</code> option<br>as in the following example:</p>\n<pre><code>$ valkey-benchmark -t set,lpush -n 100000 -q\nSET: 74239.05 requests per second\nLPUSH: 79239.30 requests per second\n</code></pre>\n<p>This example runs the tests for the <code>SET</code> and <code>LPUSH</code> commands and uses quiet mode (see the <code>-q</code> switch).</p>\n<p>You can even benchmark a specific command:</p>\n<pre><code>$ valkey-benchmark -n 100000 -q script load &quot;server.call(&#39;set&#39;,&#39;foo&#39;,&#39;bar&#39;)&quot;\nscript load server.call(&#39;set&#39;,&#39;foo&#39;,&#39;bar&#39;): 69881.20 requests per second\n</code></pre>\n<h3>Selecting the size of the key space</h3>\n<p>By default, the benchmark runs against a single key. In Valkey the difference<br>between such a synthetic benchmark and a real one is not huge since it is an<br>in-memory system, however it is possible to stress cache misses and in general<br>to simulate a more real-world work load by using a large key space.</p>\n<p>This is obtained by using the <code>-r</code> switch. For instance if I want to run<br>one million SET operations, using a random key for every operation out of<br>100k possible keys, I&#39;ll use the following command line:</p>\n<pre><code>$ valkey-cli flushall\nOK\n\n$ valkey-benchmark -t set -r 100000 -n 1000000\n====== SET ======\n  1000000 requests completed in 13.86 seconds\n  50 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n99.76% `&lt;=` 1 milliseconds\n99.98% `&lt;=` 2 milliseconds\n100.00% `&lt;=` 3 milliseconds\n100.00% `&lt;=` 3 milliseconds\n72144.87 requests per second\n\n$ valkey-cli dbsize\n(integer) 99993\n</code></pre>\n<h3>Using pipelining</h3>\n<p>By default every client (the benchmark simulates 50 clients if not otherwise<br>specified with <code>-c</code>) sends the next command only when the reply of the previous<br>command is received, this means that the server will likely need a read call<br>in order to read each command from every client. Also RTT is paid as well.</p>\n<p>Valkey supports <a href=\"pipelining.md\">pipelining</a>, so it is possible to send<br>multiple commands at once, a feature often exploited by real world applications.<br>Valkey pipelining is able to dramatically improve the number of operations per<br>second a server is able do deliver.</p>\n<p>Consider this example of running the benchmark using a<br>pipelining of 16 commands:</p>\n<pre><code>$ valkey-benchmark -n 1000000 -t set,get -P 16 -q\nSET: 403063.28 requests per second\nGET: 508388.41 requests per second\n</code></pre>\n<p>Using pipelining results in a significant increase in performance.</p>\n<h3>Pitfalls and misconceptions</h3>\n<p>The first point is obvious: the golden rule of a useful benchmark is to<br>only compare apples and apples. You can compare different versions of Valkey on the same workload or the same version of Valkey, but with<br>different options. If you plan to compare Valkey to something else, then it is<br>important to evaluate the functional and technical differences, and take them<br>in account.</p>\n<ul>\n<li>Valkey is a server: all commands involve network or IPC round trips. It is meaningless to compare it to embedded data stores, because the cost of most operations is primarily in network/protocol management.</li>\n<li>Valkey commands return an acknowledgment for all usual commands. Some other data stores do not. Comparing Valkey to stores involving one-way queries is only mildly useful.</li>\n<li>Naively iterating on synchronous Valkey commands does not benchmark Valkey itself, but rather measure your network (or IPC) latency and the client library intrinsic latency. To really test Valkey, you need multiple connections (like valkey-benchmark) and/or to use pipelining to aggregate several commands and/or multiple threads or processes.</li>\n<li>Valkey is an in-memory data store with some optional persistence options. If you plan to compare it to transactional servers (MySQL, PostgreSQL, etc ...), then you should consider activating AOF and decide on a suitable fsync policy.</li>\n<li>Valkey primarily operates as a single-threaded server from the POV of commands execution. While the server can employ threads for I/O operations and command parsing, the core command execution remains sequential. For CPU-intensive workloads requiring multiple cores, users should consider running multiple Valkey instances in parallel. It is not really fair to compare one single Valkey instance to a multi-threaded data store.</li>\n</ul>\n<p>The <code>valkey-benchmark</code> program is a quick and useful way to get some figures and<br>evaluate the performance of a Valkey instance on a given hardware. However,<br>by default, it does not represent the maximum throughput a Valkey instance can<br>sustain. Actually, by using pipelining and a fast client (hiredis), it is fairly<br>easy to write a program generating more throughput than valkey-benchmark. The<br>default behavior of valkey-benchmark is to achieve throughput by exploiting<br>concurrency only (i.e. it creates several connections to the server).<br>It does not use pipelining or any parallelism at all (one pending query per<br>connection at most, and no multi-threading), if not explicitly enabled via<br>the <code>-P</code> parameter. So in some way using <code>valkey-benchmark</code> and, triggering, for<br>example, a <code>BGSAVE</code> operation in the background at the same time, will provide<br>the user with numbers more near to the <em>worst case</em> than to the best case.</p>\n<p>To run a benchmark using pipelining mode (and achieve higher throughput),<br>you need to explicitly use the -P option. Please note that it is still a<br>realistic behavior since a lot of Valkey based applications actively use<br>pipelining to improve performance. However you should use a pipeline size that<br>is more or less the average pipeline length you&#39;ll be able to use in your<br>application in order to get realistic numbers.</p>\n<p>The benchmark should apply the same operations, and work in the same way<br>with the multiple data stores you want to compare. It is absolutely pointless to<br>compare the result of valkey-benchmark to the result of another benchmark<br>program and extrapolate.</p>\n<p>For instance, Valkey and memcached in single-threaded mode can be compared on<br>GET/SET operations. Both are in-memory data stores, working mostly in the same<br>way at the protocol level. Provided their respective benchmark application is<br>aggregating queries in the same way (pipelining) and use a similar number of<br>connections, the comparison is actually meaningful.</p>\n<p>When you&#39;re benchmarking a high-performance, in-memory database like Valkey,<br>it may be difficult to saturate<br>the server. Sometimes, the performance bottleneck is on the client side,<br>and not the server-side. In that case, the client (i.e., the benchmarking program itself)<br>must be fixed, or perhaps scaled out, to reach the maximum throughput.</p>\n<h3>Factors impacting Valkey performance</h3>\n<p>There are multiple factors having direct consequences on Valkey performance.<br>We mention them here, since they can alter the result of any benchmarks.<br>Please note however, that a typical Valkey instance running on a low end,<br>untuned box usually provides good enough performance for most applications.</p>\n<ul>\n<li><p>Network bandwidth and latency usually have a direct impact on the performance.<br>It is a good practice to use the ping program to quickly check the latency<br>between the client and server hosts is normal before launching the benchmark.<br>Regarding the bandwidth, it is generally useful to estimate<br>the throughput in Gbit/s and compare it to the theoretical bandwidth<br>of the network. For instance a benchmark setting 4 KB strings<br>in Valkey at 100000 q/s, would actually consume 3.2 Gbit/s of bandwidth<br>and probably fit within a 10 Gbit/s link, but not a 1 Gbit/s one. In many real<br>world scenarios, Valkey throughput is limited by the network well before being<br>limited by the CPU. To consolidate several high-throughput Valkey instances<br>on a single server, it worth considering putting a 10 Gbit/s NIC<br>or multiple 1 Gbit/s NICs with TCP/IP bonding.</p>\n</li>\n<li><p>CPU is another important factor.</p>\n</li>\n<li><p>Speed of RAM and memory bandwidth seem less critical for global performance<br>especially for small objects. For large objects (&gt;10 KB), it may become<br>noticeable though. Usually, it is not really cost-effective to buy expensive<br>fast memory modules to optimize Valkey.</p>\n</li>\n<li><p>Valkey runs slower on a VM compared to running without virtualization using<br>the same hardware. If you have the chance to run Valkey on a physical machine<br>this is preferred. However this does not mean that Valkey is slow in<br>virtualized environments, the delivered performances are still very good<br>and most of the serious performance issues you may incur in virtualized<br>environments are due to over-provisioning, non-local disks with high latency,<br>or old hypervisor software that have slow <code>fork</code> syscall implementation.</p>\n</li>\n<li><p>When the server and client benchmark programs run on the same box, both<br>the TCP/IP loopback and unix domain sockets can be used. Depending on the<br>platform, unix domain sockets can achieve around 50% more throughput than<br>the TCP/IP loopback (on Linux for instance). The default behavior of<br>valkey-benchmark is to use the TCP/IP loopback.</p>\n</li>\n<li><p>The performance benefit of unix domain sockets compared to TCP/IP loopback<br>tends to decrease when pipelining is heavily used (i.e. long pipelines).</p>\n</li>\n<li><p>When an ethernet network is used to access Valkey, aggregating commands using<br>pipelining is especially efficient when the size of the data is kept under<br>the ethernet packet size (about 1500 bytes). Actually, processing 10 bytes,<br>100 bytes, or 1000 bytes queries almost result in the same throughput.<br>See the graph below.</p>\n<p>  <img src=\"Data_size.png\" alt=\"Data size impact\"></p>\n</li>\n<li><p>On multi CPU sockets servers, Valkey performance becomes dependent on the<br>NUMA configuration and process location. The most visible effect is that<br>valkey-benchmark results seem non-deterministic because client and server<br>processes are distributed randomly on the cores. To get deterministic results,<br>it is required to use process placement tools (on Linux: taskset or numactl).<br>The most efficient combination is always to put the client and server on two<br>different cores of the same CPU to benefit from the L3 cache.<br>Here are some results of 4 KB SET benchmark for 3 server CPUs (AMD Istanbul,<br>Intel Nehalem EX, and Intel Westmere) with different relative placements.<br>Please note this benchmark is not meant to compare CPU models between themselves<br>(CPUs exact model and frequency are therefore not disclosed).</p>\n<p>  <img src=\"NUMA_chart.gif\" alt=\"NUMA chart\"></p>\n</li>\n<li><p>With high-end configurations, the number of client connections is also an<br>important factor. Being based on epoll/kqueue, the Valkey event loop is quite<br>scalable. Valkey has already been benchmarked at more than 60000 connections,<br>and was still able to sustain 50000 q/s in these conditions. As a rule of thumb,<br>an instance with 30000 connections can only process half the throughput<br>achievable with 100 connections. Here is an example showing the throughput of<br>a Valkey instance per number of connections:</p>\n<p>  <img src=\"Connections_chart.png\" alt=\"connections chart\"></p>\n</li>\n<li><p>With high-end configurations, it is possible to achieve higher throughput by<br>tuning the NIC(s) configuration and associated interruptions. Best throughput<br>is achieved by setting an affinity between Rx/Tx NIC queues and CPU cores,<br>and activating RPS (Receive Packet Steering) support. More information in this<br><a href=\"https://groups.google.com/forum/#!msg/redis-db/gUhc19gnYgc/BruTPCOroiMJ\">thread</a>.<br>Jumbo frames may also provide a performance boost when large objects are used.</p>\n</li>\n<li><p>Depending on the platform, Valkey can be compiled against different memory<br>allocators (libc malloc, jemalloc, tcmalloc), which may have different behaviors<br>in term of raw speed, internal and external fragmentation.<br>If you did not compile Valkey yourself, you can use the INFO command to check<br>the <code>mem_allocator</code> field. Please note most benchmarks do not run long enough to<br>generate significant external fragmentation (contrary to production Valkey<br>instances).</p>\n</li>\n</ul>\n<h3>Other things to consider</h3>\n<p>One important goal of any benchmark is to get reproducible results, so they<br>can be compared to the results of other tests.</p>\n<ul>\n<li>A good practice is to try to run tests on isolated hardware as much as possible.<br>If it is not possible, then the system must be monitored to check the benchmark<br>is not impacted by some external activity.</li>\n<li>Some configurations (desktops and laptops for sure, some servers as well)<br>have a variable CPU core frequency mechanism. The policy controlling this<br>mechanism can be set at the OS level. Some CPU models are more aggressive than<br>others at adapting the frequency of the CPU cores to the workload. To get<br>reproducible results, it is better to set the highest possible fixed frequency<br>for all the CPU cores involved in the benchmark.</li>\n<li>An important point is to size the system accordingly to the benchmark.<br>The system must have enough RAM and must not swap. On Linux, do not forget<br>to set the <code>overcommit_memory</code> parameter correctly. Please note 32 and 64 bit<br>Valkey instances do not have the same memory footprint.</li>\n<li>If you plan to use RDB or AOF for your benchmark, please check there is no other<br>I/O activity in the system. Avoid putting RDB or AOF files on NAS or NFS shares,<br>or on any other devices impacting your network bandwidth and/or latency<br>(for instance, EBS on Amazon EC2).</li>\n<li>Set Valkey logging level (loglevel parameter) to warning or notice. Avoid putting<br>the generated log file on a remote filesystem.</li>\n<li>Avoid using monitoring tools which can alter the result of the benchmark. For<br>instance using INFO at regular interval to gather statistics is probably fine,<br>but MONITOR will impact the measured performance significantly.</li>\n<li>When running <code>valkey-benchmark</code> on the same machine as the <code>valkey-server</code><br>being tested, you may need to run the benchmark with at least two threads<br>(<code>--threads 2</code>) to prevent the benchmarking tool itself from being the<br>bottleneck, i.e. prevent that <code>valkey-benchmark</code> is running on 100% CPU while<br><code>valkey-server</code> is using less than 100% CPU.</li>\n</ul>\n<h3>Other Valkey benchmarking tools</h3>\n<p>There are several third-party tools that can be used for benchmarking Valkey. Refer to each tool&#39;s<br>documentation for more information about its goals and capabilities.</p>\n<ul>\n<li><a href=\"https://github.com/redislabs/memtier_benchmark\">memtier_benchmark</a> from <a href=\"https://twitter.com/RedisInc\">Redis Ltd.</a> is a NoSQL Valkey, Redis and Memcache traffic generation and benchmarking tool.</li>\n<li><a href=\"https://github.com/twitter/rpc-perf\">rpc-perf</a> from <a href=\"https://twitter.com/twitter\">Twitter</a> is a tool for benchmarking RPC services that supports Valkey and Memcache.</li>\n<li><a href=\"https://github.com/brianfrankcooper/YCSB\">YCSB</a> from <a href=\"https://twitter.com/Yahoo\">Yahoo @Yahoo</a> is a benchmarking framework with clients to many databases, including Valkey.</li>\n</ul>\n<h2>See also</h2>\n<p><a href=\"cli.md\">valkey-cli</a>, <a href=\"server.md\">valkey-server</a></p>\n"
  },
  {
    "id": "problems",
    "topicName": "Troubleshooting Valkey",
    "description": "Problems with Valkey? Start here.",
    "htmlContent": "<p>This page tries to help you with what to do if you have issues with Valkey. Part of the Valkey project is helping people that are experiencing problems because we don&#39;t like to leave people alone with their issues.</p>\n<ul>\n<li>If you have <strong>latency problems</strong> with Valkey, that in some way appears to be idle for some time, read our <a href=\"latency.md\">Valkey latency troubleshooting guide</a>.</li>\n<li>Valkey stable releases are usually very reliable, however in the rare event you are <strong>experiencing crashes</strong> the developers can help a lot more if you provide debugging information. Please read our <a href=\"debugging.md\">Debugging Valkey guide</a>.</li>\n<li>We have a long history of users experiencing crashes with Valkey that actually turned out to be servers with <strong>broken RAM</strong>. Please test your RAM using <strong>valkey-server --test-memory</strong> in case Valkey is not stable in your system. Valkey built-in memory test is fast and reasonably reliable, but if you can you should reboot your server and use <a href=\"https://memtest86.com\">memtest86</a>.</li>\n</ul>\n"
  },
  {
    "id": "debugging",
    "topicName": "Debugging",
    "description": "A guide to debugging Valkey server processes\n",
    "htmlContent": "<p>Valkey is developed with an emphasis on stability. We do our best with<br>every release to make sure you&#39;ll experience a stable product with no<br>crashes. However, if you ever need to debug the Valkey process itself, read on.</p>\n<p>When Valkey crashes, it produces a detailed report of what happened. However,<br>sometimes looking at the crash report is not enough, nor is it possible for<br>the Valkey core team to reproduce the issue independently. In this scenario, we<br>need help from the user who can reproduce the issue.</p>\n<p>This guide shows how to use GDB to provide the information the<br>Valkey developers will need to track the bug more easily.</p>\n<h2>What is GDB?</h2>\n<p>GDB is the Gnu Debugger: a program that is able to inspect the internal state<br>of another program. Usually tracking and fixing a bug is an exercise in<br>gathering more information about the state of the program at the moment the<br>bug happens, so GDB is an extremely useful tool.</p>\n<p>GDB can be used in two ways:</p>\n<ul>\n<li>It can attach to a running program and inspect the state of it at runtime.</li>\n<li>It can inspect the state of a program that already terminated using what is called a <em>core file</em>, that is, the image of the memory at the time the program was running.</li>\n</ul>\n<p>From the point of view of investigating Valkey bugs we need to use both of these<br>GDB modes. The user able to reproduce the bug attaches GDB to their running Valkey<br>instance, and when the crash happens, they create the <code>core</code> file that in turn<br>the developer will use to inspect the Valkey internals at the time of the crash.</p>\n<p>This way the developer can perform all the inspections in his or her computer<br>without the help of the user, and the user is free to restart Valkey in their<br>production environment.</p>\n<h2>Compiling Valkey without optimizations</h2>\n<p>By default, Valkey is compiled with the <code>-O3</code> optimization flag, which enables<br>a high level of compiler optimizations that aim to maximize runtime performance.<br>Valkey is also compiled with the <code>-fno-omit-frame-pointer</code> flag by default, ensuring that<br>the frame pointer is preserved across function calls. This combination allows for<br>precise stack walking and call stack tracing, which is essential for debugging.</p>\n<p>It is better to attach GDB to Valkey compiled without optimizations using the<br><code>make noopt</code> command (instead of just using the plain <code>make</code> command). However,<br>if you have an already running Valkey in production there is no need to recompile<br>and restart it if this is going to create problems on your side. GDB still works<br>against executables compiled with optimizations.</p>\n<p>You should not be overly concerned at the loss of performance from compiling Valkey<br>without optimizations. It is unlikely that this will cause problems in your<br>environment as Valkey is not very CPU-bound.</p>\n<h2>Attaching GDB to a running process</h2>\n<p>If you have an already running Valkey server, you can attach GDB to it, so that<br>if Valkey crashes it will be possible to both inspect the internals and generate<br>a <code>core dump</code> file.</p>\n<p>After you attach GDB to the Valkey process it will continue running as usual without<br>any loss of performance, so this is not a dangerous procedure.</p>\n<p>In order to attach GDB the first thing you need is the <em>process ID</em> of the running<br>Valkey instance (the <em>pid</em> of the process). You can easily obtain it using<br><code>valkey-cli</code>:</p>\n<pre><code>$ valkey-cli info | grep process_id\nprocess_id:58414\n</code></pre>\n<p>In the above example the process ID is <strong>58414</strong>.</p>\n<p>Login into your Valkey server.</p>\n<p>(Optional but recommended) Start <strong>screen</strong> or <strong>tmux</strong> or any other program that will make sure that your GDB session will not be closed if your ssh connection times out. You can learn more about screen in <a href=\"https://www.linuxjournal.com/article/6340\">this article</a>.</p>\n<p>Attach GDB to the running Valkey server by typing:</p>\n<pre><code>$ gdb &lt;path-to-valkey-executable&gt; &lt;pid&gt;\n</code></pre>\n<p>For example:</p>\n<pre><code>$ gdb /usr/local/bin/valkey-server 58414\n</code></pre>\n<p>GDB will start and will attach to the running server printing something like the following:</p>\n<pre><code>Reading symbols for shared libraries + done\n0x00007fff8d4797e6 in epoll_wait ()\n(gdb)\n</code></pre>\n<p>At this point GDB is attached but <strong>your Valkey instance is blocked by GDB</strong>. In<br>order to let the Valkey instance continue the execution just type <strong>continue</strong> at<br>the GDB prompt, and press enter.</p>\n<pre><code>(gdb) continue\nContinuing.\n</code></pre>\n<p>Done! Now your Valkey instance has GDB attached. Now you can wait for the next crash. :)</p>\n<p>Now it&#39;s time to detach your screen/tmux session, if you are running GDB using it, by<br>pressing <strong>Ctrl-a a</strong> key combination.</p>\n<h2>After the crash</h2>\n<p>Valkey has a command to simulate a segmentation fault (in other words a bad crash) using<br>the <code>DEBUG SEGFAULT</code> command (don&#39;t use it against a real production instance of course!<br>So I&#39;ll use this command to crash my instance to show what happens in the GDB side:</p>\n<pre><code>(gdb) continue\nContinuing.\n\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0xffffffffffffffff\ndebugCommand (c=0x7ffc32005000) at debug.c:220\n220         *((char*)-1) = &#39;x&#39;;\n</code></pre>\n<p>As you can see GDB detected that Valkey crashed, and was even able to show me<br>the file name and line number causing the crash. This is already much better<br>than the Valkey crash report back trace (containing just function names and<br>binary offsets).</p>\n<h2>Obtaining the stack trace</h2>\n<p>The first thing to do is to obtain a full stack trace with GDB. This is as<br>simple as using the <strong>bt</strong> command:</p>\n<pre><code>(gdb) bt\n#0  debugCommand (c=0x7ffc32005000) at debug.c:220\n#1  0x000000010d246d63 in call (c=0x7ffc32005000) at valkey.c:1163\n#2  0x000000010d247290 in processCommand (c=0x7ffc32005000) at valkey.c:1305\n#3  0x000000010d251660 in processInputBuffer (c=0x7ffc32005000) at networking.c:959\n#4  0x000000010d251872 in readQueryFromClient (el=0x0, fd=5, privdata=0x7fff76f1c0b0, mask=220924512) at networking.c:1021\n#5  0x000000010d243523 in aeProcessEvents (eventLoop=0x7fff6ce408d0, flags=220829559) at ae.c:352\n#6  0x000000010d24373b in aeMain (eventLoop=0x10d429ef0) at ae.c:397\n#7  0x000000010d2494ff in main (argc=1, argv=0x10d2b2900) at valkey.c:2046\n</code></pre>\n<p>This shows the backtrace, but we also want to dump the processor registers using the <strong>info registers</strong> command:</p>\n<pre><code>(gdb) info registers\nrax            0x0  0\nrbx            0x7ffc32005000   140721147367424\nrcx            0x10d2b0a60  4515891808\nrdx            0x7fff76f1c0b0   140735188943024\nrsi            0x10d299777  4515796855\nrdi            0x0  0\nrbp            0x7fff6ce40730   0x7fff6ce40730\nrsp            0x7fff6ce40650   0x7fff6ce40650\nr8             0x4f26b3f7   1327936503\nr9             0x7fff6ce40718   140735020271384\nr10            0x81 129\nr11            0x10d430398  4517462936\nr12            0x4b7c04f8babc0  1327936503000000\nr13            0x10d3350a0  4516434080\nr14            0x10d42d9f0  4517452272\nr15            0x10d430398  4517462936\nrip            0x10d26cfd4  0x10d26cfd4 &lt;debugCommand+68&gt;\neflags         0x10246  66118\ncs             0x2b 43\nss             0x0  0\nds             0x0  0\nes             0x0  0\nfs             0x0  0\ngs             0x0  0\n</code></pre>\n<p>Please <strong>make sure to include</strong> both of these outputs in your bug report.</p>\n<h2>Obtaining the core file</h2>\n<p>The next step is to generate the core dump, that is the image of the memory of the running Valkey process. This is done using the <code>gcore</code> command:</p>\n<pre><code>(gdb) gcore\nSaved corefile core.58414\n</code></pre>\n<p>Now you have the core dump to send to the Valkey developer, but <strong>it is important<br>to understand</strong> that this happens to contain all the data that was inside the<br>Valkey instance at the time of the crash; Valkey developers will make sure not to<br>share the content with anyone else, and will delete the file as soon as it is no<br>longer used for debugging purposes, but you are warned that by sending the core<br>file you are sending your data.</p>\n<h2>What to send to developers</h2>\n<p>Finally you can send everything to the Valkey core team:</p>\n<ul>\n<li>The Valkey executable you are using.</li>\n<li>The stack trace produced by the <strong>bt</strong> command, and the registers dump.</li>\n<li>The core file you generated with gdb.</li>\n<li>Information about the operating system and GCC version, and Valkey version you are using.</li>\n</ul>\n<h2>Thank you</h2>\n<p>Your help is extremely important! Many issues can only be tracked this way. So<br>thanks!</p>\n"
  },
  {
    "id": "ldb",
    "topicName": "Debugging Lua scripts",
    "description": "How to use the built-in Lua debugger",
    "htmlContent": "<p>Valkey includes a complete Lua debugger, that can be<br>used to make the task of writing complex Lua scripts much simpler.</p>\n<p>The Valkey Lua debugger, codenamed LDB, has the following important features:</p>\n<ul>\n<li>It uses a server-client model, so it&#39;s a remote debugger.<br>The Valkey server acts as the debugging server, while the default client is <code>valkey-cli</code>.<br>However other clients can be developed by following the simple protocol implemented by the server.</li>\n<li>By default every new debugging session is a forked session.<br>It means that while the Valkey Lua script is being debugged, the server does not block and is usable for development or in order to execute multiple debugging sessions in parallel.<br>This also means that changes are <strong>rolled back</strong> after the script debugging session finished, so that&#39;s possible to restart a new debugging session again, using exactly the same Valkey data set as the previous debugging session.</li>\n<li>An alternative synchronous (non forked) debugging model is available on demand, so that changes to the dataset can be retained.<br>In this mode the server blocks for the time the debugging session is active.</li>\n<li>Support for step by step execution.</li>\n<li>Support for static and dynamic breakpoints.</li>\n<li>Support from logging the debugged script into the debugger console.</li>\n<li>Inspection of Lua variables.</li>\n<li>Tracing of Valkey commands executed by the script.</li>\n<li>Pretty printing of Valkey and Lua values.</li>\n<li>Infinite loops and long execution detection, which simulates a breakpoint.</li>\n</ul>\n<h2>Quick start</h2>\n<p>A simple way to get started with the Lua debugger is to watch this video<br>introduction:</p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/IMvRfStaoyM\" frameborder=\"0\" allowfullscreen></iframe>\n\n<blockquote>\n<p>Important Note:  please make sure to avoid debugging Lua scripts using your Valkey production server.<br>Use a development server instead.<br>Also note that using the synchronous debugging mode (which is NOT the default) results in the Valkey server blocking for all the time the debugging session lasts.</p>\n</blockquote>\n<p>To start a new debugging session using <code>valkey-cli</code> do the following:</p>\n<ol>\n<li><p>Create your script in some file with your preferred editor. Let&#39;s assume you are editing your Valkey Lua script located at <code>/tmp/script.lua</code>.</p>\n</li>\n<li><p>Start a debugging session with:</p>\n<p> ./valkey-cli --ldb --eval /tmp/script.lua</p>\n</li>\n</ol>\n<p>Note that with the <code>--eval</code> option of <code>valkey-cli</code> you can pass key names and arguments to the script, separated by a comma, like in the following example:</p>\n<pre><code>./valkey-cli --ldb --eval /tmp/script.lua mykey somekey , arg1 arg2\n</code></pre>\n<p>You&#39;ll enter a special mode where <code>valkey-cli</code> no longer accepts its normal<br>commands, but instead prints a help screen and passes the unmodified debugging<br>commands directly to Valkey.</p>\n<p>The only commands which are not passed to the Valkey debugger are:</p>\n<ul>\n<li><code>quit</code> -- this will terminate the debugging session.<br>It&#39;s like removing all the breakpoints and using the <code>continue</code> debugging command.<br>Moreover the command will exit from <code>valkey-cli</code>.</li>\n<li><code>restart</code> -- the debugging session will restart from scratch, <strong>reloading the new version of the script from the file</strong>.<br>So a normal debugging cycle involves modifying the script after some debugging, and calling <code>restart</code> in order to start debugging again with the new script changes.</li>\n<li><code>help</code> -- this command is passed to the Valkey Lua debugger, that will print a list of commands like the following:</li>\n</ul>\n<pre><code>lua debugger&gt; help\nValkey Lua debugger help:\n[h]elp               Show this help.\n[s]tep               Run current line and stop again.\n[n]ext               Alias for step.\n[c]ontinue           Run till next breakpoint.\n[l]ist               List source code around current line.\n[l]ist [line]        List source code around [line].\n                     line = 0 means: current position.\n[l]ist [line] [ctx]  In this form [ctx] specifies how many lines\n                     to show before/after [line].\n[w]hole              List all source code. Alias for &#39;list 1 1000000&#39;.\n[p]rint              Show all the local variables.\n[p]rint &lt;var&gt;        Show the value of the specified variable.\n                     Can also show global vars KEYS and ARGV.\n[b]reak              Show all breakpoints.\n[b]reak &lt;line&gt;       Add a breakpoint to the specified line.\n[b]reak -&lt;line&gt;      Remove breakpoint from the specified line.\n[b]reak 0            Remove all breakpoints.\n[t]race              Show a backtrace.\n[e]val &lt;code&gt;        Execute some Lua code (in a different callframe).\n[r]edis &lt;cmd&gt;        Execute a Valkey command.\n[m]axlen [len]       Trim logged Valkey replies and Lua var dumps to len.\n                     Specifying zero as &lt;len&gt; means unlimited.\n[a]bort              Stop the execution of the script. In sync\n                     mode dataset changes will be retained.\n\nDebugger functions you can call from Lua scripts:\nserver.debug()        Produce logs in the debugger console.\nserver.breakpoint()   Stop execution as if there was a breakpoint in the\n                     next line of code.\n</code></pre>\n<p>Note that when you start the debugger it will start in <strong>stepping mode</strong>.<br>It will stop at the first line of the script that actually does something before executing it.</p>\n<p>From this point you usually call <code>step</code> in order to execute the line and go to the next line.<br>While you step Valkey will show all the commands executed by the server like in the following example:</p>\n<pre><code>* Stopped at 1, stop reason = step over\n-&gt; 1   server.call(&#39;ping&#39;)\nlua debugger&gt; step\n&lt;redis&gt; ping\n&lt;reply&gt; &quot;+PONG&quot;\n* Stopped at 2, stop reason = step over\n</code></pre>\n<p>The <code>&lt;redis&gt;</code> and <code>&lt;reply&gt;</code> lines show the command executed by the line just<br>executed, and the reply from the server. Note that this happens only in stepping mode.<br>If you use <code>continue</code> in order to execute the script till the next breakpoint, commands will not be dumped on the screen to prevent too much output.</p>\n<h2>Termination of the debugging session</h2>\n<p>When the scripts terminates naturally, the debugging session ends and<br><code>valkey-cli</code> returns in its normal non-debugging mode. You can restart the<br>session using the <code>restart</code> command as usual.</p>\n<p>Another way to stop a debugging session is just interrupting <code>valkey-cli</code><br>manually by pressing <code>Ctrl+C</code>. Note that also any event breaking the<br>connection between <code>valkey-cli</code> and the <code>valkey-server</code> will interrupt the<br>debugging session.</p>\n<p>All the forked debugging sessions are terminated when the server is shut<br>down.</p>\n<h2>Abbreviating debugging commands</h2>\n<p>Debugging can be a very repetitive task. For this reason every Valkey<br>debugger command starts with a different character, and you can use the single<br>initial character in order to refer to the command.</p>\n<p>So for example instead of typing <code>step</code> you can just type <code>s</code>.</p>\n<h2>Breakpoints</h2>\n<p>Adding and removing breakpoints is trivial as described in the online help.<br>Just use <code>b 1 2 3 4</code> to add a breakpoint in line 1, 2, 3, 4.<br>The command <code>b 0</code> removes all the breakpoints. Selected breakpoints can be<br>removed using as argument the line where the breakpoint we want to remove is, but prefixed by a minus sign.<br>So for example <code>b -3</code> removes the breakpoint from line 3.</p>\n<p>Note that adding breakpoints to lines that Lua never executes, like declaration of local variables or comments, will not work.<br>The breakpoint will be added but since this part of the script will never be executed, the program will never stop.</p>\n<h2>Dynamic breakpoints</h2>\n<p>Using the <code>breakpoint</code> command it is possible to add breakpoints into specific<br>lines. However sometimes we want to stop the execution of the program only<br>when something special happens. In order to do so, you can use the<br><code>server.breakpoint()</code> function inside your Lua script. When called it simulates<br>a breakpoint in the next line that will be executed.</p>\n<pre><code>if counter &gt; 10 then server.breakpoint() end\n</code></pre>\n<p>This feature is extremely useful when debugging, so that we can avoid<br>continuing the script execution manually multiple times until a given condition<br>is encountered.</p>\n<h2>Synchronous mode</h2>\n<p>As explained previously, but default LDB uses forked sessions with rollback<br>of all the data changes operated by the script while it has being debugged.<br>Determinism is usually a good thing to have during debugging, so that successive<br>debugging sessions can be started without having to reset the database content<br>to its original state.</p>\n<p>However for tracking certain bugs, you may want to retain the changes performed<br>to the key space by each debugging session. When this is a good idea you<br>should start the debugger using a special option, <code>ldb-sync-mode</code>, in <code>valkey-cli</code>.</p>\n<pre><code>./valkey-cli --ldb-sync-mode --eval /tmp/script.lua\n</code></pre>\n<blockquote>\n<p>Note: Valkey server will be unreachable during the debugging session in this mode, so use with care.</p>\n</blockquote>\n<p>In this special mode, the <code>abort</code> command can stop the script half-way taking the changes operated to the dataset.<br>Note that this is different compared to ending the debugging session normally.<br>If you just interrupt <code>valkey-cli</code> the script will be fully executed and then the session terminated.<br>Instead with <code>abort</code> you can interrupt the script execution in the middle and start a new debugging session if needed.</p>\n<h2>Logging from scripts</h2>\n<p>The <code>server.debug()</code> command is a powerful debugging facility that can be<br>called inside the Valkey Lua script in order to log things into the debug<br>console:</p>\n<pre><code>lua debugger&gt; list\n-&gt; 1   local a = {1,2,3}\n   2   local b = false\n   3   server.debug(a,b)\nlua debugger&gt; continue\n&lt;debug&gt; line 3: {1; 2; 3}, false\n</code></pre>\n<p>If the script is executed outside of a debugging session, <code>server.debug()</code> has no effects at all.<br>Note that the function accepts multiple arguments, that are separated by a comma and a space in the output.</p>\n<p>Tables and nested tables are displayed correctly in order to make values simple to observe for the programmer debugging the script.</p>\n<h2>Inspecting the program state with <code>print</code> and <code>eval</code></h2>\n<p>While the <code>server.debug()</code> function can be used in order to print values<br>directly from within the Lua script, often it is useful to observe the local<br>variables of a program while stepping or when stopped into a breakpoint.</p>\n<p>The <code>print</code> command does just that, and performs lookup in the call frames<br>starting from the current one back to the previous ones, up to top-level.<br>This means that even if we are into a nested function inside a Lua script,<br>we can still use <code>print foo</code> to look at the value of <code>foo</code> in the context<br>of the calling function. When called without a variable name, <code>print</code> will<br>print all variables and their respective values.</p>\n<p>The <code>eval</code> command executes small pieces of Lua scripts <strong>outside the context of the current call frame</strong> (evaluating inside the context of the current call frame is not possible with the current Lua internals).<br>However you can use this command in order to test Lua functions.</p>\n<pre><code>lua debugger&gt; e server.sha1hex(&#39;foo&#39;)\n&lt;retval&gt; &quot;0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33&quot;\n</code></pre>\n<h2>Debugging clients</h2>\n<p>LDB uses the client-server model where the Valkey server acts as a debugging server that communicates using <a href=\"protocol.md\">RESP</a>. While <code>valkey-cli</code> is the default debug client, any <a href=\"../clients/\">client</a> can be used for debugging as long as it meets one of the following conditions:</p>\n<ol>\n<li>The client provides a native interface for setting the debug mode and controlling the debug session.</li>\n<li>The client provides an interface for sending arbitrary commands over RESP.</li>\n<li>The client allows sending raw messages to the Valkey server.</li>\n</ol>\n"
  }
];

export const categories: TopicCategory[] = [
  {
    "title": "CONFIGURATION",
    "items": [
      {
        "id": "acl",
        "topicName": "ACL",
        "description": "Valkey Access Control List",
        "htmlContent": "<p>The Valkey ACL, short for Access Control List, is a feature that allows certain connections to be limited in terms of the commands that can be executed and the keys that can be accessed.<br>The way it works is that, after connecting, a client is required to provide a username and a valid password to authenticate.<br>If authentication succeeded, the connection is associated with a given user and the limits the user has.<br>Valkey can be configured so that new connections are already authenticated with a &quot;default&quot; user (this is the default configuration).<br>Configuring the default user has, as a side effect, the ability to provide only a specific subset of functionalities to connections that are not explicitly authenticated.</p>\n<p>The standard way to authenticate is the two-argument form of the <code>AUTH</code> command:</p>\n<pre><code>AUTH &lt;username&gt; &lt;password&gt;\n</code></pre>\n<p>If the password is valid matches, the connection will be authenticated to the user with the name <code>&lt;username&gt;</code>.</p>\n<p>When the single argument form of the command is used, where only the password is specified, it is assumed that the implicit username is &quot;default&quot;.</p>\n<pre><code>AUTH &lt;password&gt;\n</code></pre>\n<p>This form authenticates against the &quot;default&quot; user&#39;s password, either set by ACLs or by setting <code>requirepass</code>.</p>\n<h2>When ACLs are useful</h2>\n<p>Before using ACLs, you may want to ask yourself what&#39;s the goal you want to<br>accomplish by implementing this layer of protection. Normally there are<br>two main goals that are well served by ACLs:</p>\n<ol>\n<li>You want to improve security by restricting the access to commands and keys, so that untrusted clients have no access and trusted clients have just the minimum access level to the database in order to perform the work needed. For instance, certain clients may just be able to execute read only commands.</li>\n<li>You want to improve operational safety, so that processes or humans accessing Valkey are not allowed to damage the data or the configuration due to software errors or manual mistakes. For instance, there is no reason for a worker that fetches delayed jobs from Valkey to be able to call the <code>FLUSHALL</code> command.</li>\n</ol>\n<p>Another typical usage of ACLs is related to managed Valkey instances. Valkey is<br>often provided as a managed service both by internal company teams that handle<br>the Valkey infrastructure for the other internal customers they have, or is<br>provided in a software-as-a-service setup by cloud providers. In both<br>setups, we want to be sure that configuration commands are excluded for the<br>customers.</p>\n<h2>Configure ACLs with the ACL command</h2>\n<p>ACLs are defined using a DSL (domain specific language) that describes what<br>a given user is allowed to do. Such rules are always implemented from the<br>first to the last, left-to-right, because sometimes the order of the rules is<br>important to understand what the user is really able to do.</p>\n<p>By default there is a single user defined, called <em>default</em>. We<br>can use the <code>ACL LIST</code> command in order to check the currently active ACLs<br>and verify what the configuration of a freshly started, defaults-configured<br>Valkey instance is:</p>\n<pre><code>&gt; ACL LIST\n1) &quot;user default on nopass ~* &amp;* +@all&quot;\n</code></pre>\n<p>The command above reports the list of users in the same format that is<br>used in the Valkey configuration files, by translating the current ACLs set<br>for the users back into their description.</p>\n<p>The first two words in each line are &quot;user&quot; followed by the username. The<br>next words are ACL rules that describe different things. We&#39;ll show how the rules work in detail, but for now it is enough to say that the default<br>user is configured to be active (on), to require no password (nopass), to<br>access every possible key (<code>~*</code>) and Pub/Sub channel (<code>&amp;*</code>), and be able to<br>call every possible command (<code>+@all</code>).</p>\n<p>Also, in the special case of the default user, having the <em>nopass</em> rule means<br>that new connections are automatically authenticated with the default user<br>without any explicit <code>AUTH</code> call needed.</p>\n<h2>ACL rules</h2>\n<p>The following is the list of valid ACL rules. Certain rules are just<br>single words that are used in order to activate or remove a flag, or to<br>perform a given change to the user ACL. Other rules are char prefixes that<br>are concatenated with command or category names, key patterns, and<br>so forth.</p>\n<p>Enable and disallow users:</p>\n<ul>\n<li><code>on</code>: Enable the user: it is possible to authenticate as this user.</li>\n<li><code>off</code>: Disallow the user: it&#39;s no longer possible to authenticate with this user; however, previously authenticated connections will still work. Note that if the default user is flagged as <em>off</em>, new connections will start as not authenticated and will require the user to send <code>AUTH</code> or <code>HELLO</code> with the AUTH option in order to authenticate in some way, regardless of the default user configuration.</li>\n</ul>\n<p>Allow and disallow commands:</p>\n<ul>\n<li><code>+&lt;command&gt;</code>: Add the command to the list of commands the user can call. Can be used with <code>|</code> for allowing subcommands (e.g &quot;+config|get&quot;).</li>\n<li><code>-&lt;command&gt;</code>: Remove the command to the list of commands the user can call. Starting Valkey 7.0, it can be used with <code>|</code> for blocking subcommands (e.g &quot;-config|set&quot;).</li>\n<li><code>+@&lt;category&gt;</code>: Add all the commands in such category to be called by the user, with valid categories being like @admin, @set, @sortedset, ... and so forth, see the full list by calling the <code>ACL CAT</code> command. The special category @all means all the commands, both the ones currently present in the server, and the ones that will be loaded in the future via modules.</li>\n<li><code>-@&lt;category&gt;</code>: Like <code>+@&lt;category&gt;</code> but removes the commands from the list of commands the client can call.</li>\n<li><code>+&lt;command&gt;|first-arg</code>: Allow a specific first argument of an otherwise disabled command. It is only supported on commands with no sub-commands, and is not allowed as negative form like -SELECT|1, only additive starting with &quot;+&quot;. This feature is deprecated and may be removed in the future.</li>\n<li><code>allcommands</code>: Alias for +@all. Note that it implies the ability to execute all the future commands loaded via the modules system.</li>\n<li><code>nocommands</code>: Alias for -@all.</li>\n</ul>\n<p>Allow and disallow certain keys and key permissions:</p>\n<ul>\n<li><code>~&lt;pattern&gt;</code>: Add a pattern of keys that can be mentioned as part of commands. For instance <code>~*</code> allows all the keys. The pattern is a glob-style pattern like the one of <code>KEYS</code>. It is possible to specify multiple patterns.</li>\n<li><code>%R~&lt;pattern&gt;</code>: Add the specified read key pattern. This behaves similar to the regular key pattern but only grants permission to read from keys that match the given pattern. See <a href=\"#key-permissions\">key permissions</a> for more information.</li>\n<li><code>%W~&lt;pattern&gt;</code>: Add the specified write key pattern. This behaves similar to the regular key pattern but only grants permission to write to keys that match the given pattern. See <a href=\"#key-permissions\">key permissions</a> for more information.</li>\n<li><code>%RW~&lt;pattern&gt;</code>: Alias for <code>~&lt;pattern&gt;</code>. </li>\n<li><code>allkeys</code>: Alias for <code>~*</code>.</li>\n<li><code>resetkeys</code>: Flush the list of allowed keys patterns. For instance the ACL <code>~foo:* ~bar:* resetkeys ~objects:*</code>, will only allow the client to access keys that match the pattern <code>objects:*</code>.</li>\n</ul>\n<p>Allow and disallow Pub/Sub channels:</p>\n<ul>\n<li><code>&amp;&lt;pattern&gt;</code>: Add a glob style pattern of Pub/Sub channels that can be accessed by the user. It is possible to specify multiple channel patterns. Note that pattern matching is done only for channels mentioned by <code>PUBLISH</code> and <code>SUBSCRIBE</code>, whereas <code>PSUBSCRIBE</code> requires a literal match between its channel patterns and those allowed for user.</li>\n<li><code>allchannels</code>: Alias for <code>&amp;*</code> that allows the user to access all Pub/Sub channels.</li>\n<li><code>resetchannels</code>: Flush the list of allowed channel patterns and disconnect the user&#39;s Pub/Sub clients if these are no longer able to access their respective channels and/or channel patterns.</li>\n</ul>\n<p>Configure valid passwords for the user:</p>\n<ul>\n<li><code>&gt;&lt;password&gt;</code>: Add this password to the list of valid passwords for the user. For example <code>&gt;mypass</code> will add &quot;mypass&quot; to the list of valid passwords.  This directive clears the <em>nopass</em> flag (see later). Every user can have any number of passwords.</li>\n<li><code>&lt;&lt;password&gt;</code>: Remove this password from the list of valid passwords. Emits an error in case the password you are trying to remove is actually not set.</li>\n<li><code>#&lt;hash&gt;</code>: Add this SHA-256 hash value to the list of valid passwords for the user. This hash value will be compared to the hash of a password entered for an ACL user. This allows users to store hashes in the <code>acl.conf</code> file rather than storing cleartext passwords. Only SHA-256 hash values are accepted as the password hash must be 64 characters and only contain lowercase hexadecimal characters.</li>\n<li><code>!&lt;hash&gt;</code>: Remove this hash value from the list of valid passwords. This is useful when you do not know the password specified by the hash value but would like to remove the password from the user.</li>\n<li><code>nopass</code>: All the set passwords of the user are removed, and the user is flagged as requiring no password: it means that every password will work against this user. If this directive is used for the default user, every new connection will be immediately authenticated with the default user without any explicit AUTH command required. Note that the <em>resetpass</em> directive will clear this condition.</li>\n<li><code>resetpass</code>: Flushes the list of allowed passwords and removes the <em>nopass</em> status. After <em>resetpass</em>, the user has no associated passwords and there is no way to authenticate without adding some password (or setting it as <em>nopass</em> later).</li>\n</ul>\n<p><em>Note: if a user is not flagged with nopass and has no list of valid passwords, that user is effectively impossible to use because there will be no way to log in as that user.</em></p>\n<p>Configure selectors for the user:</p>\n<ul>\n<li><code>(&lt;rule list&gt;)</code>: Create a new selector to match rules against. Selectors are evaluated after the user permissions, and are evaluated according to the order they are defined. If a command matches either the user permissions or any selector, it is allowed. See <a href=\"#selectors\">selectors</a> for more information.</li>\n<li><code>clearselectors</code>: Delete all of the selectors attached to the user.</li>\n</ul>\n<p>Reset the user:</p>\n<ul>\n<li><code>reset</code> Performs the following actions: resetpass, resetkeys, resetchannels, allchannels (if acl-pubsub-default is set), off, clearselectors, -@all. The user returns to the same state it had immediately after its creation.</li>\n</ul>\n<h2>Create and edit user ACLs with the ACL SETUSER command</h2>\n<p>Users can be created and modified in two main ways:</p>\n<ol>\n<li>Using the ACL command and its <code>ACL SETUSER</code> subcommand.</li>\n<li>Modifying the server configuration, where users can be defined, and restarting the server. With an <em>external ACL file</em>, just call <code>ACL LOAD</code>.</li>\n</ol>\n<p>In this section we&#39;ll learn how to define users using the <code>ACL</code> command.<br>With such knowledge, it will be trivial to do the same things via the<br>configuration files. Defining users in the configuration deserves its own<br>section and will be discussed later separately.</p>\n<p>To start, try the simplest <code>ACL SETUSER</code> command call:</p>\n<pre><code>&gt; ACL SETUSER alice\nOK\n</code></pre>\n<p>The <code>ACL SETUSER</code> command takes the username and a list of ACL rules to apply<br>to the user. However the above example did not specify any rule at all.<br>This will just create the user if it did not exist, using the defaults for new<br>users. If the user already exists, the command above will do nothing at all.</p>\n<p>Check the default user status:</p>\n<pre><code>&gt; ACL LIST\n1) &quot;user alice off resetchannels -@all&quot;\n2) &quot;user default on nopass ~* &amp;* +@all&quot;\n</code></pre>\n<p>The new user &quot;alice&quot; is:</p>\n<ul>\n<li>In the off status, so <code>AUTH</code> will not work for the user &quot;alice&quot;.</li>\n<li>The user also has no passwords set.</li>\n<li>Cannot access any command. Note that the user is created by default without the ability to access any command, so the <code>-@all</code> in the output above could be omitted; however, <code>ACL LIST</code> attempts to be explicit rather than implicit.</li>\n<li>There are no key patterns that the user can access.</li>\n<li>There are no Pub/Sub channels that the user can access.</li>\n</ul>\n<p>Such user is completely useless. Let&#39;s try to define the user so that<br>it is active, has a password, and can access with only the <code>GET</code> command<br>to key names starting with the string &quot;cached:&quot;.</p>\n<pre><code>&gt; ACL SETUSER alice on &gt;p1pp0 ~cached:* +get\nOK\n</code></pre>\n<p>Now the user can do something, but will refuse to do other things:</p>\n<pre><code>&gt; AUTH alice p1pp0\nOK\n&gt; GET foo\n(error) NOPERM this user has no permissions to access one of the keys used as arguments\n&gt; GET cached:1234\n(nil)\n&gt; SET cached:1234 zap\n(error) NOPERM this user has no permissions to run the &#39;set&#39; command\n</code></pre>\n<p>Things are working as expected. In order to inspect the configuration of the<br>user alice (remember that user names are case sensitive), it is possible to<br>use an alternative to <code>ACL LIST</code> which is designed to be more suitable for<br>computers to read, while <code>ACL GETUSER</code> is more human readable.</p>\n<pre><code>&gt; ACL GETUSER alice\n1) &quot;flags&quot;\n2) 1) &quot;on&quot;\n3) &quot;passwords&quot;\n4) 1) &quot;2d9c75...&quot;\n5) &quot;commands&quot;\n6) &quot;-@all +get&quot;\n7) &quot;keys&quot;\n8) &quot;~cached:*&quot;\n9) &quot;channels&quot;\n10) &quot;&quot;\n11) &quot;selectors&quot;\n12) (empty array)\n</code></pre>\n<p>The <code>ACL GETUSER</code> returns a field-value array that describes the user in more parsable terms. The output includes the set of flags, a list of key patterns, passwords, and so forth. The output is probably more readable if we use RESP3, so that it is returned as a map reply:</p>\n<pre><code>&gt; ACL GETUSER alice\n1# &quot;flags&quot; =&gt; 1~ &quot;on&quot;\n2# &quot;passwords&quot; =&gt; 1) &quot;2d9c75273d72b32df726fb545c8a4edc719f0a95a6fd993950b10c474ad9c927&quot;\n3# &quot;commands&quot; =&gt; &quot;-@all +get&quot;\n4# &quot;keys&quot; =&gt; &quot;~cached:*&quot;\n5# &quot;channels&quot; =&gt; &quot;&quot;\n6# &quot;selectors&quot; =&gt; (empty array)\n</code></pre>\n<p><em>Note: from now on, we&#39;ll continue using the Valkey default protocol, version 2</em></p>\n<p>Using another <code>ACL SETUSER</code> command (from a different user, because alice cannot run the <code>ACL</code> command), we can add multiple patterns to the user:</p>\n<pre><code>&gt; ACL SETUSER alice ~objects:* ~items:* ~public:*\nOK\n&gt; ACL LIST\n1) &quot;user alice on #2d9c75... ~cached:* ~objects:* ~items:* ~public:* resetchannels -@all +get&quot;\n2) &quot;user default on nopass ~* &amp;* +@all&quot;\n</code></pre>\n<p>The user representation in memory is now as we expect it to be.</p>\n<h2>Multiple calls to ACL SETUSER</h2>\n<p>It is very important to understand what happens when <code>ACL SETUSER</code> is called<br>multiple times. What is critical to know is that every <code>ACL SETUSER</code> call will<br>NOT reset the user, but will just apply the ACL rules to the existing user.<br>The user is reset only if it was not known before. In that case, a brand new<br>user is created with zeroed-ACLs. The user cannot do anything, is<br>disallowed, has no passwords, and so forth. This is the best default for safety.</p>\n<p>However later calls will just modify the user incrementally. For instance,<br>the following sequence:</p>\n<pre><code>&gt; ACL SETUSER myuser +set\nOK\n&gt; ACL SETUSER myuser +get\nOK\n</code></pre>\n<p>Will result in myuser being able to call both <code>GET</code> and <code>SET</code>:</p>\n<pre><code>&gt; ACL LIST\n1) &quot;user default on nopass ~* &amp;* +@all&quot;\n2) &quot;user myuser off resetchannels -@all +get +set&quot;\n</code></pre>\n<h2>Command categories</h2>\n<p>Setting user ACLs by specifying all the commands one after the other is<br>really annoying, so instead we do things like this:</p>\n<pre><code>&gt; ACL SETUSER antirez on +@all -@dangerous &gt;42a979... ~*\n</code></pre>\n<p>By saying +@all and -@dangerous, we included all the commands and later removed<br>all the commands that are tagged as dangerous inside the Valkey command table.<br>Note that command categories <strong>never include modules commands</strong> with<br>the exception of +@all. If you say +@all, all the commands can be executed by<br>the user, even future commands loaded via the modules system. However if you<br>use the ACL rule +@read or any other, the modules commands are always<br>excluded. This is very important because you should just trust the Valkey<br>internal command table. Modules may expose dangerous things and in<br>the case of an ACL that is just additive, that is, in the form of <code>+@all -...</code><br>You should be absolutely sure that you&#39;ll never include what you did not mean<br>to.</p>\n<p>The following is a list of command categories and their meanings:</p>\n<ul>\n<li><strong>admin</strong> - Administrative commands. Normal applications will never need to use<br>these. Includes <code>REPLICAOF</code>, <code>CONFIG</code>, <code>DEBUG</code>, <code>SAVE</code>, <code>MONITOR</code>, <code>ACL</code>, <code>SHUTDOWN</code>, etc.</li>\n<li><strong>bitmap</strong> - Data type: bitmaps related.</li>\n<li><strong>blocking</strong> - Potentially blocking the connection until released by another<br>command.</li>\n<li><strong>connection</strong> - Commands affecting the connection or other connections.<br>This includes <code>AUTH</code>, <code>SELECT</code>, <code>COMMAND</code>, <code>CLIENT</code>, <code>ECHO</code>, <code>PING</code>, etc.</li>\n<li><strong>dangerous</strong> - Potentially dangerous commands (each should be considered with care for<br>various reasons). This includes <code>FLUSHALL</code>, <code>MIGRATE</code>, <code>RESTORE</code>, <code>SORT</code>, <code>KEYS</code>,<br><code>CLIENT</code>, <code>DEBUG</code>, <code>INFO</code>, <code>CONFIG</code>, <code>SAVE</code>, <code>REPLICAOF</code>, etc.</li>\n<li><strong>geo</strong> - Data type: geospatial indexes related.</li>\n<li><strong>hash</strong> - Data type: hashes related.</li>\n<li><strong>hyperloglog</strong> - Data type: hyperloglog related.</li>\n<li><strong>fast</strong> - Fast O(1) commands. May loop on the number of arguments, but not the<br>number of elements in the key.</li>\n<li><strong>keyspace</strong> - Writing or reading from keys, databases, or their metadata<br>in a type agnostic way. Includes <code>DEL</code>, <code>RESTORE</code>, <code>DUMP</code>, <code>RENAME</code>, <code>EXISTS</code>, <code>DBSIZE</code>,<br><code>KEYS</code>, <code>EXPIRE</code>, <code>TTL</code>, <code>FLUSHALL</code>, etc. Commands that may modify the keyspace,<br>key, or metadata will also have the <code>write</code> category. Commands that only read<br>the keyspace, key, or metadata will have the <code>read</code> category.</li>\n<li><strong>list</strong> - Data type: lists related.</li>\n<li><strong>pubsub</strong> - PubSub-related commands.</li>\n<li><strong>read</strong> - Reading from keys (values or metadata). Note that commands that don&#39;t<br>interact with keys, will not have either <code>read</code> or <code>write</code>.</li>\n<li><strong>scripting</strong> - Scripting related.</li>\n<li><strong>set</strong> - Data type: sets related.</li>\n<li><strong>sortedset</strong> - Data type: sorted sets related.</li>\n<li><strong>slow</strong> - All commands that are not <code>fast</code>.</li>\n<li><strong>stream</strong> - Data type: streams related.</li>\n<li><strong>string</strong> - Data type: strings related.</li>\n<li><strong>transaction</strong> - <code>WATCH</code> / <code>MULTI</code> / <code>EXEC</code> related commands.</li>\n<li><strong>write</strong> - Writing to keys (values or metadata).</li>\n</ul>\n<p>Valkey can also show you a list of all categories and the exact commands each category includes using the Valkey <code>ACL CAT</code> command. It can be used in two forms:</p>\n<pre><code>ACL CAT -- Will just list all the categories available\nACL CAT &lt;category-name&gt; -- Will list all the commands inside the category\n</code></pre>\n<p>Examples:</p>\n<pre><code> &gt; ACL CAT\n 1) &quot;keyspace&quot;\n 2) &quot;read&quot;\n 3) &quot;write&quot;\n 4) &quot;set&quot;\n 5) &quot;sortedset&quot;\n 6) &quot;list&quot;\n 7) &quot;hash&quot;\n 8) &quot;string&quot;\n 9) &quot;bitmap&quot;\n10) &quot;hyperloglog&quot;\n11) &quot;geo&quot;\n12) &quot;stream&quot;\n13) &quot;pubsub&quot;\n14) &quot;admin&quot;\n15) &quot;fast&quot;\n16) &quot;slow&quot;\n17) &quot;blocking&quot;\n18) &quot;dangerous&quot;\n19) &quot;connection&quot;\n20) &quot;transaction&quot;\n21) &quot;scripting&quot;\n</code></pre>\n<p>As you can see, so far there are 21 distinct categories. Now let&#39;s check what<br>command is part of the <em>geo</em> category:</p>\n<pre><code> &gt; ACL CAT geo\n 1) &quot;geohash&quot;\n 2) &quot;georadius_ro&quot;\n 3) &quot;georadiusbymember&quot;\n 4) &quot;geopos&quot;\n 5) &quot;geoadd&quot;\n 6) &quot;georadiusbymember_ro&quot;\n 7) &quot;geodist&quot;\n 8) &quot;georadius&quot;\n 9) &quot;geosearch&quot;\n10) &quot;geosearchstore&quot;\n</code></pre>\n<p>Note that commands may be part of multiple categories. For example, an<br>ACL rule like <code>+@geo -@read</code> will result in certain geo commands to be<br>excluded because they are read-only commands.</p>\n<h2>Allow/block subcommands</h2>\n<p>Subcommands can be allowed/blocked just like other<br>commands (by using the separator <code>|</code> between the command and subcommand, for<br>example: <code>+config|get</code> or <code>-config|set</code>)</p>\n<p>That is true for all commands except DEBUG. In order to allow/block specific DEBUG subcommands, see the next section.</p>\n<h2>Allow the first-arg of a blocked command</h2>\n<p><strong>Note: This feature is deprecated and may be removed in the future.</strong></p>\n<p>Sometimes the ability to exclude or include a command or a subcommand as a whole is not enough.<br>Many deployments may not be happy providing the ability to execute a <code>SELECT</code> for any DB, but may<br>still want to be able to run <code>SELECT 0</code>.</p>\n<p>In such case we could alter the ACL of a user in the following way:</p>\n<pre><code>ACL SETUSER myuser -select +select|0\n</code></pre>\n<p>First, remove the <code>SELECT</code> command and then add the allowed<br>first-arg. Note that <strong>it is not possible to do the reverse</strong> since first-args<br>can be only added, not excluded. It is safer to specify all the first-args<br>that are valid for some user since it is possible that<br>new first-args may be added in the future.</p>\n<p>Another example:</p>\n<pre><code>ACL SETUSER myuser -debug +debug|digest\n</code></pre>\n<p>Note that first-arg matching may add some performance penalty; however, it is hard to measure even with synthetic benchmarks. The<br>additional CPU cost is only paid when such commands are called, and not when<br>other commands are called.</p>\n<p>It is possible to use this mechanism in order to allow subcommands in Valkey<br>versions prior to 7.0 (see above section).</p>\n<h2>+@all VS -@all</h2>\n<p>In the previous section, it was observed how it is possible to define command<br>ACLs based on adding/removing single commands.</p>\n<h2>Selectors</h2>\n<p>Valkey supports adding multiple sets of rules that are evaluated independently of each other.<br>These secondary sets of permissions are called selectors and added by wrapping a set of rules within parentheses.<br>In order to execute a command, either the root permissions (rules defined outside of parenthesis) or any of the selectors (rules defined inside parenthesis) must match the given command.<br>Internally, the root permissions are checked first followed by selectors in the order they were added.</p>\n<p>For example, consider a user with the ACL rules <code>+GET ~key1 (+SET ~key2)</code>.<br>This user is able to execute <code>GET key1</code> and <code>SET key2 hello</code>, but not <code>GET key2</code> or <code>SET key1 world</code>.</p>\n<p>Unlike the user&#39;s root permissions, selectors cannot be modified after they are added.<br>Instead, selectors can be removed with the <code>clearselectors</code> keyword, which removes all of the added selectors.<br>Note that <code>clearselectors</code> does not remove the root permissions.</p>\n<h2>Key permissions</h2>\n<p>key patterns can also be used to define how a command is able to touch a key.<br>This is achieved through rules that define key permissions.<br>The key permission rules take the form of <code>%(&lt;permission&gt;)~&lt;pattern&gt;</code>.<br>Permissions are defined as individual characters that map to the following key permissions:</p>\n<ul>\n<li>W (Write): The data stored within the key may be updated or deleted. </li>\n<li>R (Read): User supplied data from the key is processed, copied or returned. Note that this does not include metadata such as size information (example <code>STRLEN</code>), type information (example <code>TYPE</code>) or information about whether a value exists within a collection (example <code>SISMEMBER</code>).</li>\n</ul>\n<p>Permissions can be composed together by specifying multiple characters.<br>Specifying the permission as &#39;RW&#39; is considered full access and is analogous to just passing in <code>~&lt;pattern&gt;</code>.</p>\n<p>For a concrete example, consider a user with ACL rules <code>+@all ~app1:* (+@read ~app2:*)</code>.<br>This user has full access on <code>app1:*</code> and readonly access on <code>app2:*</code>.<br>However, some commands support reading data from one key, doing some transformation, and storing it into another key.<br>One such command is the <code>COPY</code> command, which copies the data from the source key into the destination key.<br>The example set of ACL rules is unable to handle a request copying data from <code>app2:user</code> into <code>app1:user</code>, since neither the root permission nor the selector fully matches the command.<br>However, using key selectors you can define a set of ACL rules that can handle this request <code>+@all ~app1:* %R~app2:*</code>.<br>The first pattern is able to match <code>app1:user</code> and the second pattern is able to match <code>app2:user</code>.</p>\n<p>Which type of permission is required for a command is documented through <a href=\"key-specs.md#logical-operation-flags\">key specifications</a>.<br>The type of permission is based off the keys logical operation flags.<br>The insert, update, and delete flags map to the write key permission.<br>The access flag maps to the read key permission.<br>If the key has no logical operation flags, such as <code>EXISTS</code>, the user still needs either key read or key write permissions to execute the command. </p>\n<p>Note: Side channels to accessing user data are ignored when it comes to evaluating whether read permissions are required to execute a command.<br>This means that some write commands that return metadata about the modified key only require write permission on the key to execute.<br>For example, consider the following two commands:</p>\n<ul>\n<li><code>LPUSH key1 data</code>: modifies &quot;key1&quot; but only returns metadata about it, the size of the list after the push, so the command only requires write permission on &quot;key1&quot; to execute.</li>\n<li><code>LPOP key2</code>: modifies &quot;key2&quot; but also returns data from it, the left most item in the list, so the command requires both read and write permission on &quot;key2&quot; to execute.</li>\n</ul>\n<p>If an application needs to make sure no data is accessed from a key, including side channels, it&#39;s recommended to not provide any access to the key.</p>\n<h2>How passwords are stored internally</h2>\n<p>Valkey internally stores passwords hashed with SHA256. If you set a password<br>and check the output of <code>ACL LIST</code> or <code>ACL GETUSER</code>, you&#39;ll see a long hex<br>string that looks pseudo random. Here is an example, because in the previous<br>examples, for the sake of brevity, the long hex string was trimmed:</p>\n<pre><code>&gt; ACL GETUSER default\n1) &quot;flags&quot;\n2) 1) &quot;on&quot;\n3) &quot;passwords&quot;\n4) 1) &quot;2d9c75273d72b32df726fb545c8a4edc719f0a95a6fd993950b10c474ad9c927&quot;\n5) &quot;commands&quot;\n6) &quot;+@all&quot;\n7) &quot;keys&quot;\n8) &quot;~*&quot;\n9) &quot;channels&quot;\n10) &quot;&amp;*&quot;\n11) &quot;selectors&quot;\n12) (empty array)\n</code></pre>\n<p>Using SHA256 provides the ability to avoid storing the password in clear text<br>while still allowing for a very fast <code>AUTH</code> command, which is a very important<br>feature of Valkey and is coherent with what clients expect from Valkey.</p>\n<p>However ACL <em>passwords</em> are not really passwords. They are shared secrets<br>between the server and the client, because the password is<br>not an authentication token used by a human being. For instance:</p>\n<ul>\n<li>There are no length limits, the password will just be memorized in some client software. There is no human that needs to recall a password in this context.</li>\n<li>The ACL password does not protect any other thing. For example, it will never be the password for some email account.</li>\n<li>Often when you are able to access the hashed password itself, by having full access to the Valkey commands of a given server, or corrupting the system itself, you already have access to what the password is protecting: the Valkey instance stability and the data it contains.</li>\n</ul>\n<p>For this reason, slowing down the password authentication, in order to use an<br>algorithm that uses time and space to make password cracking hard,<br>is a very poor choice. What we suggest instead is to generate strong<br>passwords, so that nobody will be able to crack it using a<br>dictionary or a brute force attack even if they have the hash. To do so, there is a special ACL<br>command <code>ACL GENPASS</code> that generates passwords using the system cryptographic pseudorandom<br>generator:</p>\n<pre><code>&gt; ACL GENPASS\n&quot;dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc&quot;\n</code></pre>\n<p>The command outputs a 32-byte (256-bit) pseudorandom string converted to a<br>64-byte alphanumerical string. This is long enough to avoid attacks and short<br>enough to be easy to manage, cut &amp; paste, store, and so forth. This is what<br>you should use in order to generate Valkey passwords.</p>\n<h2>Use an external ACL file</h2>\n<p>There are two ways to store users inside the Valkey configuration:</p>\n<ol>\n<li>Users can be specified directly inside the <code>valkey.conf</code> file.</li>\n<li>It is possible to specify an external ACL file.</li>\n</ol>\n<p>The two methods are <em>mutually incompatible</em>, so Valkey will ask you to use one<br>or the other. Specifying users inside <code>valkey.conf</code> is<br>good for simple use cases. When there are multiple users to define, in a<br>complex environment, we recommend you use the ACL file instead.</p>\n<p>The format used inside <code>valkey.conf</code> and in the external ACL file is exactly<br>the same, so it is trivial to switch from one to the other, and is<br>the following:</p>\n<pre><code>user &lt;username&gt; ... acl rules ...\n</code></pre>\n<p>For instance:</p>\n<pre><code>user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99\n</code></pre>\n<p>When you want to use an external ACL file, you are required to specify<br>the configuration directive called <code>aclfile</code>, like this:</p>\n<pre><code>aclfile /etc/valkey/users.acl\n</code></pre>\n<p>When you are just specifying a few users directly inside the <code>valkey.conf</code><br>file, you can use <code>CONFIG REWRITE</code> in order to store the new user configuration<br>inside the file by rewriting it.</p>\n<p>The external ACL file however is more powerful. You can do the following:</p>\n<ul>\n<li>Use <code>ACL LOAD</code> if you modified the ACL file manually and you want Valkey to reload the new configuration. Note that this command is able to load the file <em>only if all the users are correctly specified</em>. Otherwise, an error is reported to the user, and the old configuration will remain valid.</li>\n<li>Use <code>ACL SAVE</code> to save the current ACL configuration to the ACL file.</li>\n</ul>\n<p>Note that <code>CONFIG REWRITE</code> does not also trigger <code>ACL SAVE</code>. When you use<br>an ACL file, the configuration and the ACLs are handled separately.</p>\n<h2>ACL rules for Sentinel and Replicas</h2>\n<p>In case you don&#39;t want to provide Valkey replicas and Valkey Sentinel instances<br>full access to your Valkey instances, the following is the set of commands<br>that must be allowed in order for everything to work correctly.</p>\n<p>For Sentinel, allow the user to access the following commands both in the primary and replica instances:</p>\n<ul>\n<li>AUTH, CLIENT, SUBSCRIBE, SCRIPT, PUBLISH, PING, INFO, MULTI, SLAVEOF, CONFIG, CLIENT, EXEC.</li>\n</ul>\n<p>Sentinel does not need to access any key in the database but does use Pub/Sub, so the ACL rule would be the following (note: <code>AUTH</code> is not needed since it is always allowed):</p>\n<pre><code>ACL SETUSER sentinel-user on &gt;somepassword allchannels +multi +slaveof +ping +exec +subscribe +config|rewrite +role +publish +info +client|setname +client|kill +script|kill\n</code></pre>\n<p>Valkey replicas require the following commands to be allowed on the primary instance:</p>\n<ul>\n<li>PSYNC, REPLCONF, PING</li>\n</ul>\n<p>No keys need to be accessed, so this translates to the following rules:</p>\n<pre><code>ACL setuser replica-user on &gt;somepassword +psync +replconf +ping\n</code></pre>\n<p>Note that you don&#39;t need to configure the replicas to allow the primary to be able to execute any set of commands. The primary is always authenticated as the root user from the point of view of replicas.</p>\n"
      },
      {
        "id": "cli",
        "topicName": "CLI",
        "description": "Valkey command line interface\n",
        "htmlContent": "<h2>Usage</h2>\n<p><strong><code>valkey-cli</code></strong> [<em>OPTIONS</em>] [<em>cmd</em> [<em>arg</em>...]]</p>\n<h2>Description</h2>\n<p>The Valkey command line interface is used for administration, troubleshooting and experimenting with Valkey.</p>\n<p>In interactive mode, <code>valkey-cli</code> has basic line editing capabilities to provide a familiar typing experience.</p>\n<p>To launch the program in special modes, you can use several options, including:</p>\n<ul>\n<li>Simulate a replica and print the replication stream it receives from the primary.</li>\n<li>Check the latency of a Valkey server and display statistics. </li>\n<li>Request ASCII-art spectrogram of latency samples and frequencies.</li>\n</ul>\n<p>This topic covers the different aspects of <code>valkey-cli</code>, starting from the simplest and ending with the more advanced features.</p>\n<h2>Options</h2>\n<p><strong><code>-h</code></strong> <em>hostname</em><br>: Server hostname (default: 127.0.0.1).</p>\n<p><strong><code>-p</code></strong> <em>port</em><br>: Server port (default: 6379).</p>\n<p><strong><code>-t</code></strong> <em>timeout</em><br>: Server connection timeout in seconds (decimals allowed).<br>  Default timeout is 0, meaning no limit, depending on the OS.</p>\n<p><strong><code>-s</code></strong> <em>socket</em><br>: Server socket (overrides hostname and port).</p>\n<p><strong><code>-a</code></strong> <em>password</em><br>: Password to use when connecting to the server.<br>  You can also use the <code>REDISCLI_AUTH</code> environment<br>  variable to pass this password more safely.<br>  (If both are used, this argument takes precedence.)</p>\n<p><strong><code>--user</code></strong> <em>username</em><br>: Used to send ACL style &#39;AUTH username pass&#39;. Needs <code>-a</code>.</p>\n<p><strong><code>--pass</code></strong> <em>password</em><br>: Alias of -a for consistency with the new --user option.</p>\n<p><strong><code>--askpass</code></strong><br>: Force user to input password with mask from STDIN.<br>  If this argument is used, <code>-a</code> and the <code>REDISCLI_AUTH</code><br>  environment variable will be ignored.</p>\n<p><strong><code>-u</code></strong> <em>uri</em><br>: Server URI on format <code>valkey://user:password@host:port/dbnum</code>.<br>  User, password and dbnum are optional. For authentication<br>  without a username, use username &#39;default&#39;. For TLS, use<br>  the scheme &#39;valkeys&#39;.</p>\n<p><strong><code>-r</code></strong> <em>repeat</em><br>: Execute specified command N times.</p>\n<p><strong><code>-i</code></strong> <em>interval</em><br>: When <code>-r</code> is used, waits <em>interval</em> seconds per command.<br>  It is possible to specify sub-second times like <code>-i 0.1</code>.<br>  This interval is also used in <code>--scan</code> and <code>--stat</code> per cycle.<br>  and in <code>--bigkeys</code>, <code>--memkeys</code>, and <code>--hotkeys</code> per 100 cycles.</p>\n<p><strong><code>-n</code></strong> <em>db</em><br>: Database number.</p>\n<p><strong><code>-2</code></strong><br>: Start session in RESP2 protocol mode.</p>\n<p><strong><code>-3</code></strong><br>: Start session in RESP3 protocol mode.</p>\n<p><strong><code>-x</code></strong><br>: Read last argument from STDIN (see example below).</p>\n<p><strong><code>-X</code></strong><br>: Read <tag> argument from STDIN (see example below).</p>\n<p><strong><code>-d</code></strong> <em>delimiter</em><br>: Delimiter between response bulks for raw formatting (default: <code>\\n</code>).</p>\n<p><strong><code>-D</code></strong> <em>delimiter</em><br>: Delimiter between responses for raw formatting (default: <code>\\n</code>).</p>\n<p><strong><code>-c</code></strong><br>: Enable cluster mode (follow -ASK and -MOVED redirections).</p>\n<p><strong><code>-e</code></strong><br>: Return exit error code when command execution fails.</p>\n<p><strong><code>-4</code></strong><br>: Prefer IPv4 over IPv6 on DNS lookup.</p>\n<p><strong><code>-6</code></strong><br>: Prefer IPv6 over IPv4 on DNS lookup.&#39;</p>\n<p><strong><code>--tls</code></strong><br>: Establish a secure TLS connection.</p>\n<p><strong><code>--sni</code></strong> <em>host</em><br>: Server name indication for TLS.</p>\n<p><strong><code>--cacert</code></strong> <em>file</em><br>: CA Certificate file to verify with.</p>\n<p><strong><code>--cacertdir</code></strong> <em>dir</em><br>: Directory where trusted CA certificates are stored.<br>  If neither cacert nor cacertdir are specified, the default<br>  system-wide trusted root certs configuration will apply.</p>\n<p><strong><code>--insecure</code></strong><br>: Allow insecure TLS connection by skipping cert validation.</p>\n<p><strong><code>--cert</code></strong> <em>file</em><br>: Client certificate to authenticate with.</p>\n<p><strong><code>--key</code></strong> <em>file</em><br>: Private key file to authenticate with.</p>\n<p><strong><code>--tls-ciphers</code></strong> <em>list</em><br>: Sets the list of preferred ciphers (TLSv1.2 and below)<br>  in order of preference from highest to lowest separated by colon (&quot;:&quot;).<br>  See the <strong>ciphers</strong>(1ssl) manpage for more information about the syntax of this string.</p>\n<p><strong><code>--tls-ciphersuites</code></strong> <em>list</em><br>: Sets the list of preferred ciphersuites (TLSv1.3)<br>  in order of preference from highest to lowest separated by colon (&quot;:&quot;).<br>  See the <strong>ciphers</strong>(1ssl) manpage for more information about the syntax of this string,<br>  and specifically for TLSv1.3 ciphersuites.</p>\n<p><strong><code>--raw</code></strong><br>: Use raw formatting for replies (default when STDOUT is<br>  not a tty).</p>\n<p><strong><code>--no-raw</code></strong><br>: Force formatted output even when STDOUT is not a tty.</p>\n<p><strong><code>--quoted-input</code></strong><br>: Force input to be handled as quoted strings.</p>\n<p><strong><code>--csv</code></strong><br>: Output in CSV format.</p>\n<p><strong><code>--json</code></strong><br>: Output in JSON format (default RESP3, use -2 if you want to use with RESP2).</p>\n<p><strong><code>--quoted-json</code></strong><br>: Same as --json, but produce ASCII-safe quoted strings, not Unicode.</p>\n<p><strong><code>--show-pushes</code></strong> <strong><code>yes</code></strong>|<strong><code>no</code></strong><br>: Whether to print RESP3 PUSH messages.  Enabled by default when<br>  STDOUT is a tty but can be overridden with --show-pushes no.</p>\n<p><strong><code>--stat</code></strong><br>: Print rolling stats about server: mem, clients, ...</p>\n<p><strong><code>--latency</code></strong><br>: Enter a special mode continuously sampling latency.<br>  If you use this mode in an interactive session it runs<br>  forever displaying real-time stats. Otherwise if <code>--raw</code> or<br>  <code>--csv</code> is specified, or if you redirect the output to a non<br>  TTY, it samples the latency for 1 second (you can use<br>  <code>-i</code> to change the interval), then produces a single output<br>  and exits.</p>\n<p><strong><code>--latency-history</code></strong><br>: Like <code>--latency</code> but tracking latency changes over time.<br>  Default time interval is 15 sec. Change it using <code>-i</code>.</p>\n<p><strong><code>--latency-dist</code></strong><br>: Shows latency as a spectrum, requires xterm 256 colors.<br>  Default time interval is 1 sec. Change it using <code>-i</code>.</p>\n<p><strong><code>--lru-test</code></strong> <em>keys</em><br>: Simulate a cache workload with an 80-20 distribution.</p>\n<p><strong><code>--replica</code></strong><br>: Simulate a replica showing commands received from the primary.</p>\n<p><strong><code>--rdb</code></strong> <em>filename</em><br>: Transfer an RDB dump from remote server to local file.<br>  Use filename of &quot;-&quot; to write to stdout.</p>\n<p><strong><code>--functions-rdb</code></strong> <em>filename</em><br>: Like <code>--rdb</code> but only get the functions (not the keys)<br>  when getting the RDB dump file.</p>\n<p><strong><code>--pipe</code></strong><br>: Transfer raw RESP protocol from stdin to server.</p>\n<p><strong><code>--pipe-timeout</code></strong> <em>n</em><br>: In <code>--pipe</code> mode, abort with error if after sending all data.<br>  no reply is received within <em>n</em> seconds.<br>  Default timeout: 30. Use 0 to wait forever.</p>\n<p><strong><code>--bigkeys</code></strong><br>: Sample keys looking for keys with many elements (complexity).</p>\n<p><strong><code>--memkeys</code></strong><br>: Sample keys looking for keys consuming a lot of memory.</p>\n<p><strong><code>--memkeys-samples</code></strong> <em>n</em><br>: Sample keys looking for keys consuming a lot of memory.<br>  And define number of key elements to sample</p>\n<p><strong><code>--hotkeys</code></strong><br>: Sample keys looking for hot keys.<br>  only works when maxmemory-policy is <code>*lfu</code>.</p>\n<p><strong><code>--scan</code></strong><br>: List all keys using the SCAN command.</p>\n<p><strong><code>--pattern</code></strong> <em>pat</em><br>: Keys pattern when using the <code>--scan</code>, <code>--bigkeys</code> or <code>--hotkeys</code><br>  options (default: <code>*</code>).</p>\n<p><strong><code>--count</code></strong> <em>count</em><br>: Count option when using the <code>--scan</code>, <code>--bigkeys</code> or <code>--hotkeys</code> (default: 10).</p>\n<p><strong><code>--quoted-pattern</code></strong> <em>pat</em><br>: Same as <code>--pattern</code>, but the specified string can be<br>  quoted, in order to pass an otherwise non binary-safe string.</p>\n<p><strong><code>--intrinsic-latency</code></strong> <em>sec</em><br>: Run a test to measure intrinsic system latency.<br>  The test will run for the specified amount of seconds.</p>\n<p><strong><code>--eval</code></strong> <em>file</em><br>: Send an EVAL command using the Lua script at <em>file</em>.</p>\n<p><strong><code>--ldb</code></strong><br>: Used with <code>--eval</code> enable the Server Lua debugger.</p>\n<p><strong><code>--ldb-sync-mode</code></strong><br>: Like <code>--ldb</code> but uses the synchronous Lua debugger, in<br>  this mode the server is blocked and script changes are<br>  not rolled back from the server memory.</p>\n<p><strong><code>--cluster</code></strong> <em>command</em> [<em>args</em>...] [<em>opts</em>...]<br>: Cluster Manager command and arguments (see below).</p>\n<p><strong><code>--verbose</code></strong><br>: Verbose mode.</p>\n<p><strong><code>--no-auth-warning</code></strong><br>: Don&#39;t show warning message when using password on command<br>  line interface.</p>\n<p><strong><code>--help</code></strong><br>: Output help and exit.</p>\n<p><strong><code>--version</code></strong><br>: Output version and exit.</p>\n<h2>Cluster Manager commands</h2>\n<p>For management of <a href=\"cluster-tutorial.md\">Valkey Cluster</a>, the following syntax is used:</p>\n<p><strong><code>valkey-cli</code></strong> <strong><code>--cluster</code></strong> <em>command</em> [<em>args</em>...] [<em>opts</em>...]</p>\n<pre><code>  Command        Args\n  --------------------------------------------------------------------------------\n  create         host1:port1 ... hostN:portN\n                 --cluster-replicas &lt;arg&gt;\n  check          &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n                 --cluster-search-multiple-owners\n  info           &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n  fix            &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n                 --cluster-search-multiple-owners\n                 --cluster-fix-with-unreachable-masters\n  reshard        &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n                 --cluster-from &lt;arg&gt;\n                 --cluster-to &lt;arg&gt;\n                 --cluster-slots &lt;arg&gt;\n                 --cluster-yes\n                 --cluster-timeout &lt;arg&gt;\n                 --cluster-pipeline &lt;arg&gt;\n                 --cluster-replace\n  rebalance      &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space\n                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;\n                 --cluster-use-empty-masters\n                 --cluster-timeout &lt;arg&gt;\n                 --cluster-simulate\n                 --cluster-pipeline &lt;arg&gt;\n                 --cluster-threshold &lt;arg&gt;\n                 --cluster-replace\n  add-node       new_host:new_port existing_host:existing_port\n                 --cluster-replica\n                 --cluster-master-id &lt;arg&gt;\n  del-node       host:port node_id\n  call           host:port command arg arg .. arg\n                 --cluster-only-masters\n                 --cluster-only-replicas\n  set-timeout    host:port milliseconds\n  import         host:port\n                 --cluster-from &lt;arg&gt;\n                 --cluster-from-user &lt;arg&gt;\n                 --cluster-from-pass &lt;arg&gt;\n                 --cluster-from-askpass\n                 --cluster-copy\n                 --cluster-replace\n  backup         host:port backup_directory\n  help\n</code></pre>\n<h2>Command line usage</h2>\n<p>To run a Valkey command and return a standard output at the terminal, include the command to execute as separate arguments of <code>valkey-cli</code>:</p>\n<pre><code>$ valkey-cli INCR mycounter\n(integer) 7\n</code></pre>\n<p>The reply of the command is &quot;7&quot;. Since Valkey replies are typed (strings, arrays, integers, nil, errors, etc.), you see the type of the reply between parentheses. This additional information may not be ideal when the output of <code>valkey-cli</code> must be used as input of another command or redirected into a file.</p>\n<p><code>valkey-cli</code> only shows additional information for human readability when it detects the standard output is a tty, or terminal. For all other outputs it will auto-enable the <em>raw output mode</em>, as in the following example:</p>\n<pre><code>$ valkey-cli INCR mycounter &gt; /tmp/output.txt\n$ cat /tmp/output.txt\n8\n</code></pre>\n<p>Note that <code>(integer)</code> is omitted from the output because <code>valkey-cli</code> detects<br>the output is no longer written to the terminal. You can force raw output<br>even on the terminal with the <code>--raw</code> option:</p>\n<pre><code>$ valkey-cli --raw INCR mycounter\n9\n</code></pre>\n<p>You can force human readable output when writing to a file or in<br>pipe to other commands by using <code>--no-raw</code>.</p>\n<h2>String quoting and escaping</h2>\n<p>When <code>valkey-cli</code> parses a command, whitespace characters automatically delimit the arguments.<br>In interactive mode, a newline sends the command for parsing and execution.<br>To input string values that contain whitespaces or non-printable characters, you can use quoted and escaped strings.</p>\n<p>Quoted string values are enclosed in double (<code>&quot;</code>) or single (<code>&#39;</code>) quotation marks.<br>Escape sequences are used to put nonprintable characters in character and string literals.</p>\n<p>An escape sequence contains a backslash (<code>\\</code>) symbol followed by one of the escape sequence characters.</p>\n<p>Doubly-quoted strings support the following escape sequences:</p>\n<ul>\n<li><code>\\&quot;</code> - double-quote</li>\n<li><code>\\n</code> - newline</li>\n<li><code>\\r</code> - carriage return</li>\n<li><code>\\t</code> - horizontal tab</li>\n<li><code>\\b</code> - backspace</li>\n<li><code>\\a</code> - alert</li>\n<li><code>\\\\</code> - backslash</li>\n<li><code>\\xhh</code> - any ASCII character represented by a hexadecimal number (<em>hh</em>)</li>\n</ul>\n<p>Single quotes assume the string is literal, and allow only the following escape sequences:</p>\n<ul>\n<li><code>\\&#39;</code> - single quote</li>\n<li><code>\\\\</code> - backslash</li>\n</ul>\n<p>For example, to return <code>Hello World</code> on two lines:</p>\n<pre><code>127.0.0.1:6379&gt; SET mykey &quot;Hello\\nWorld&quot;\nOK\n127.0.0.1:6379&gt; GET mykey\nHello\nWorld\n</code></pre>\n<p>When you input strings that contain single or double quotes, as you might in passwords, for example, escape the string, like so: </p>\n<pre><code>127.0.0.1:6379&gt; AUTH some_admin_user &quot;&gt;^8T&gt;6Na{u|jp&gt;+v\\&quot;55\\@_;OU(OR]7mbAYGqsfyu48(j&#39;%hQH7;v*f1H${*gD(Se&#39;&quot;\n</code></pre>\n<h2>Host, port, password, and database</h2>\n<p>By default, <code>valkey-cli</code> connects to the server at the address 127.0.0.1 with port 6379.<br>You can change the port using several command line options. To specify a different host name or an IP address, use the <code>-h</code> option. In order to set a different port, use <code>-p</code>.</p>\n<pre><code>$ valkey-cli -h valkey15.example.com -p 6390 PING\nPONG\n</code></pre>\n<p>If your instance is password protected, the <code>-a &lt;password&gt;</code> option will<br>perform authentication saving the need of explicitly using the <code>AUTH</code> command:</p>\n<pre><code>$ valkey-cli -a myUnguessablePazzzzzword123 PING\nPONG\n</code></pre>\n<p><strong>NOTE:</strong> For security reasons, provide the password to <code>valkey-cli</code> automatically via the<br><code>REDISCLI_AUTH</code> environment variable.</p>\n<p>Finally, it&#39;s possible to send a command that operates on a database number<br>other than the default number zero by using the <code>-n &lt;dbnum&gt;</code> option:</p>\n<pre><code>$ valkey-cli FLUSHALL\nOK\n$ valkey-cli -n 1 INCR a\n(integer) 1\n$ valkey-cli -n 1 INCR a\n(integer) 2\n$ valkey-cli -n 2 INCR a\n(integer) 1\n</code></pre>\n<p>Some or all of this information can also be provided by using the <code>-u &lt;uri&gt;</code><br>option and the URI pattern <code>valkey://user:password@host:port/dbnum</code>:</p>\n<pre><code>$ valkey-cli -u valkey://LJenkins:p%40ssw0rd@valkey-16379.example.com:16379/0 PING\nPONG\n</code></pre>\n<p><strong>NOTE:</strong><br>User, password and dbnum are optional.<br>For authentication without a username, use username <code>default</code>.<br>For TLS, use the scheme <code>valkeys</code>.</p>\n<h2>SSL/TLS</h2>\n<p>By default, <code>valkey-cli</code> uses a plain TCP connection to connect to Valkey.<br>You may enable SSL/TLS using the <code>--tls</code> option, along with <code>--cacert</code> or<br><code>--cacertdir</code> to configure a trusted root certificate bundle or directory.</p>\n<p>If the target server requires authentication using a client side certificate,<br>you can specify a certificate and a corresponding private key using <code>--cert</code> and<br><code>--key</code>.</p>\n<h2>Getting input from other programs</h2>\n<p>There are two ways you can use <code>valkey-cli</code> in order to receive input from other<br>commands via the standard input. One is to use the target payload as the last argument<br>from <em>stdin</em>. For example, in order to set the Valkey key <code>net_services</code><br>to the content of the file <code>/etc/services</code> from a local file system, use the <code>-x</code><br>option:</p>\n<pre><code>$ valkey-cli -x SET net_services &lt; /etc/services\nOK\n$ valkey-cli GETRANGE net_services 0 50\n&quot;#\\n# Network services, Internet style\\n#\\n# Note that &quot;\n</code></pre>\n<p>In the first line of the above session, <code>valkey-cli</code> was executed with the <code>-x</code> option and a file was redirected to the CLI&#39;s<br>standard input as the value to satisfy the <code>SET net_services</code> command phrase. This is useful for scripting.</p>\n<p>A different approach is to feed <code>valkey-cli</code> a sequence of commands written in a<br>text file:</p>\n<pre><code>$ cat /tmp/commands.txt\nSET item:3374 100\nINCR item:3374\nAPPEND item:3374 xxx\nGET item:3374\n$ cat /tmp/commands.txt | valkey-cli\nOK\n(integer) 101\n(integer) 6\n&quot;101xxx&quot;\n</code></pre>\n<p>All the commands in <code>commands.txt</code> are executed consecutively by<br><code>valkey-cli</code> as if they were typed by the user in interactive mode. Strings can be<br>quoted inside the file if needed, so that it&#39;s possible to have single<br>arguments with spaces, newlines, or other special characters:</p>\n<pre><code>$ cat /tmp/commands.txt\nSET arg_example &quot;This is a single argument&quot;\nSTRLEN arg_example\n$ cat /tmp/commands.txt | valkey-cli\nOK\n(integer) 25\n</code></pre>\n<h2>Continuously run the same command</h2>\n<p>It is possible to execute a single command a specified number of times<br>with a user-selected pause between executions. This is useful in<br>different contexts - for example when we want to continuously monitor some<br>key content or <code>INFO</code> field output, or when we want to simulate some<br>recurring write event, such as pushing a new item into a list every 5 seconds.</p>\n<p>This feature is controlled by two options: <code>-r &lt;count&gt;</code> and <code>-i &lt;delay&gt;</code>.<br>The <code>-r</code> option states how many times to run a command and <code>-i</code> sets<br>the delay between the different command calls in seconds (with the ability<br>to specify values such as 0.1 to represent 100 milliseconds).</p>\n<p>By default the interval (or delay) is set to 0, so commands are just executed<br>ASAP:</p>\n<pre><code>$ valkey-cli -r 5 INCR counter_value\n(integer) 1\n(integer) 2\n(integer) 3\n(integer) 4\n(integer) 5\n</code></pre>\n<p>To run the same command indefinitely, use <code>-1</code> as the count value.<br>To monitor over time the RSS memory size it&#39;s possible to use the following command:</p>\n<pre><code>$ valkey-cli -r -1 -i 1 INFO | grep rss_human\nused_memory_rss_human:2.71M\nused_memory_rss_human:2.73M\nused_memory_rss_human:2.73M\nused_memory_rss_human:2.73M\n... a new line will be printed each second ...\n</code></pre>\n<h2>Mass insertion of data using <code>valkey-cli</code></h2>\n<p>Mass insertion using <code>valkey-cli</code> is covered in a separate page as it is a<br>worthwhile topic itself. Please refer to our <a href=\"mass-insertion.md\">mass insertion guide</a>.</p>\n<h2>CSV output</h2>\n<p>A CSV (Comma Separated Values) output feature exists within <code>valkey-cli</code> to export data from Valkey to an external program.  </p>\n<pre><code>$ valkey-cli LPUSH mylist a b c d\n(integer) 4\n$ valkey-cli --csv LRANGE mylist 0 -1\n&quot;d&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;\n</code></pre>\n<p>Note that the <code>--csv</code> flag will only work on a single command, not the entirety of a DB as an export.</p>\n<h2>Running Lua scripts</h2>\n<p>The <code>valkey-cli</code> has extensive support for using the debugging facility<br>of Lua scripting, available with Valkey 3.2 onwards. For this feature, refer to the <a href=\"ldb.md\">Valkey Lua debugger documentation</a>.</p>\n<p>Even without using the debugger, <code>valkey-cli</code> can be used to<br>run scripts from a file as an argument:</p>\n<pre><code>$ cat /tmp/script.lua\nreturn server.call(&#39;SET&#39;,KEYS[1],ARGV[1])\n$ valkey-cli --eval /tmp/script.lua location:hastings:temp , 23\nOK\n</code></pre>\n<p>The Valkey <code>EVAL</code> command takes the list of keys the script uses, and the<br>other non key arguments, as different arrays. When calling <code>EVAL</code> you<br>provide the number of keys as a number. </p>\n<p>When calling <code>valkey-cli</code> with the <code>--eval</code> option above, there is no need to specify the number of keys<br>explicitly. Instead it uses the convention of separating keys and arguments<br>with a comma. This is why in the above call you see <code>location:hastings:temp , 23</code> as arguments.</p>\n<p>So <code>location:hastings:temp</code> will populate the <code>KEYS</code> array, and <code>23</code> the <code>ARGV</code> array.</p>\n<p>The <code>--eval</code> option is useful when writing simple scripts. For more<br>complex work, the Lua debugger is recommended. It is possible to mix the two approaches, since the debugger can also execute scripts from an external file.</p>\n<h1>Interactive mode</h1>\n<p>We have explored how to use the Valkey CLI as a command line program.<br>This is useful for scripts and certain types of testing, however most<br>people will spend the majority of time in <code>valkey-cli</code> using its interactive<br>mode.</p>\n<p>In interactive mode the user types Valkey commands at the prompt. The command<br>is sent to the server, processed, and the reply is parsed back and rendered<br>into a simpler form to read.</p>\n<p>Nothing special is needed for running the <code>valkey-cli</code> in interactive mode -<br>just execute it without any arguments</p>\n<pre><code>$ valkey-cli\n127.0.0.1:6379&gt; PING\nPONG\n</code></pre>\n<p>The string <code>127.0.0.1:6379&gt;</code> is the prompt. It displays the connected Valkey server instance&#39;s hostname and port.</p>\n<p>The prompt updates as the connected server changes or when operating on a database different from the database number zero:</p>\n<pre><code>127.0.0.1:6379&gt; SELECT 2\nOK\n127.0.0.1:6379[2]&gt; DBSIZE\n(integer) 1\n127.0.0.1:6379[2]&gt; SELECT 0\nOK\n127.0.0.1:6379&gt; DBSIZE\n(integer) 503\n</code></pre>\n<h2>Handling connections and reconnections</h2>\n<p>Using the <code>CONNECT</code> command in interactive mode makes it possible to connect<br>to a different instance, by specifying the <em>hostname</em> and <em>port</em> we want<br>to connect to:</p>\n<pre><code>127.0.0.1:6379&gt; CONNECT metal 6379\nmetal:6379&gt; PING\nPONG\n</code></pre>\n<p>As you can see the prompt changes accordingly when connecting to a different server instance.<br>If a connection is attempted to an instance that is unreachable, the <code>valkey-cli</code> goes into disconnected<br>mode and attempts to reconnect with each new command:</p>\n<pre><code>127.0.0.1:6379&gt; CONNECT 127.0.0.1 9999\nCould not connect to Valkey at 127.0.0.1:9999: Connection refused\nnot connected&gt; PING\nCould not connect to Valkey at 127.0.0.1:9999: Connection refused\nnot connected&gt; PING\nCould not connect to Valkey at 127.0.0.1:9999: Connection refused\n</code></pre>\n<p>Generally after a disconnection is detected, <code>valkey-cli</code> always attempts to<br>reconnect transparently; if the attempt fails, it shows the error and<br>enters the disconnected state. The following is an example of disconnection<br>and reconnection:</p>\n<pre><code>127.0.0.1:6379&gt; INFO SERVER\nCould not connect to Valkey at 127.0.0.1:6379: Connection refused\nnot connected&gt; PING\nPONG\n127.0.0.1:6379&gt; \n(now we are connected again)\n</code></pre>\n<p>When a reconnection is performed, <code>valkey-cli</code> automatically re-selects the<br>last database number selected. However, all other states about the<br>connection is lost, such as within a MULTI/EXEC transaction:</p>\n<pre><code>$ valkey-cli\n127.0.0.1:6379&gt; MULTI\nOK\n127.0.0.1:6379&gt; PING\nQUEUED\n\n( here the server is manually restarted )\n\n127.0.0.1:6379&gt; EXEC\n(error) ERR EXEC without MULTI\n</code></pre>\n<p>This is usually not an issue when using the <code>valkey-cli</code> in interactive mode for<br>testing, but this limitation should be known.</p>\n<h2>Editing, history, completion and hints</h2>\n<p>Because <code>valkey-cli</code> uses the &quot;linenoise&quot; line editing library shipped with<br>Valkey, it has line editing capabilities without depending on <code>libreadline</code> or<br>other optional libraries.</p>\n<p>Command execution history can be accessed in order to avoid retyping commands by pressing the arrow keys (up and down).<br>The history is preserved between restarts of the CLI, in a file named<br><code>.valkeycli_history</code> inside the user home directory, as specified<br>by the <code>HOME</code> environment variable. It is possible to use a different<br>history filename by setting the <code>REDISCLI_HISTFILE</code> environment variable,<br>and disable it by setting it to <code>/dev/null</code>.</p>\n<p>The <code>valkey-cli</code> is also able to perform command-name completion by pressing the TAB<br>key, as in the following example:</p>\n<pre><code>127.0.0.1:6379&gt; Z&lt;TAB&gt;\n127.0.0.1:6379&gt; ZADD&lt;TAB&gt;\n127.0.0.1:6379&gt; ZCARD&lt;TAB&gt;\n</code></pre>\n<p>Once Valkey command name has been entered at the prompt, the <code>valkey-cli</code> will display<br>syntax hints. Like command history, this behavior can be turned on and off via the <code>valkey-cli</code> preferences.</p>\n<h2>Preferences</h2>\n<p>There are two ways to customize <code>valkey-cli</code> behavior. The file <code>.valkeyclirc</code><br>in the home directory is loaded by the CLI on startup. You can override the<br>file&#39;s default location by setting the <code>REDISCLI_RCFILE</code> environment variable to<br>an alternative path. Preferences can also be set during a CLI session, in which<br>case they will last only the duration of the session.</p>\n<p>To set preferences, use the special <code>:set</code> command. The following preferences<br>can be set, either by typing the command in the CLI or adding it to the<br><code>.valkeyclirc</code> file:</p>\n<ul>\n<li><code>:set hints</code> - enables syntax hints</li>\n<li><code>:set nohints</code> - disables syntax hints</li>\n</ul>\n<h2>Running the same command N times</h2>\n<p>It is possible to run the same command multiple times in interactive mode by prefixing the command<br>name by a number:</p>\n<pre><code>127.0.0.1:6379&gt; 5 INCR mycounter\n(integer) 1\n(integer) 2\n(integer) 3\n(integer) 4\n(integer) 5\n</code></pre>\n<h2>Showing help about Valkey commands</h2>\n<p><code>valkey-cli</code> provides online help for most Valkey <a href=\"../commands/\">commands</a>, using the <code>HELP</code> command. The command can be used<br>in two forms:</p>\n<ul>\n<li><code>HELP @&lt;category&gt;</code> shows all the commands about a given category. The<br>categories are: <ul>\n<li><code>@generic</code></li>\n<li><code>@string</code></li>\n<li><code>@list</code></li>\n<li><code>@set</code></li>\n<li><code>@sorted_set</code></li>\n<li><code>@hash</code></li>\n<li><code>@pubsub</code></li>\n<li><code>@transactions</code></li>\n<li><code>@connection</code></li>\n<li><code>@server</code></li>\n<li><code>@scripting</code></li>\n<li><code>@hyperloglog</code></li>\n<li><code>@cluster</code></li>\n<li><code>@geo</code></li>\n<li><code>@stream</code></li>\n</ul>\n</li>\n<li><code>HELP &lt;commandname&gt;</code> shows specific help for the command given as argument.</li>\n</ul>\n<p>For example in order to show help for the <code>PFADD</code> command, use:</p>\n<pre><code>127.0.0.1:6379&gt; HELP PFADD\n\nPFADD key element [element ...]\nsummary: Adds the specified elements to the specified HyperLogLog.\nsince: 2.8.9\n</code></pre>\n<p>Note that <code>HELP</code> supports TAB completion as well.</p>\n<h2>Clearing the terminal screen</h2>\n<p>Using the <code>CLEAR</code> command in interactive mode clears the terminal&#39;s screen.</p>\n<h1>Special modes of operation</h1>\n<p>So far we saw two main modes of <code>valkey-cli</code>.</p>\n<ul>\n<li>Command line execution of Valkey commands.</li>\n<li>Interactive &quot;REPL&quot; usage.</li>\n</ul>\n<p>The CLI performs other auxiliary tasks related to Valkey that<br>are explained in the next sections:</p>\n<ul>\n<li>Monitoring tool to show continuous stats about a Valkey server.</li>\n<li>Scanning a Valkey database for very large keys.</li>\n<li>Key space scanner with pattern matching.</li>\n<li>Acting as a <a href=\"pubsub.md\">Pub/Sub</a> client to subscribe to channels.</li>\n<li>Monitoring the commands executed into a Valkey instance.</li>\n<li>Checking the <a href=\"latency.md\">latency</a> of a Valkey server in different ways.</li>\n<li>Checking the scheduler latency of the local computer.</li>\n<li>Transferring RDB backups from a remote Valkey server locally.</li>\n<li>Acting as a Valkey replica for showing what a replica receives.</li>\n<li>Simulating <a href=\"lru-cache.md\">LRU</a> workloads for showing stats about keys hits.</li>\n<li>A client for the Lua debugger.</li>\n</ul>\n<h2>Continuous stats mode</h2>\n<p>Continuous stats mode is probably one of the lesser known yet very useful features of <code>valkey-cli</code> to monitor Valkey instances in real time. To enable this mode, the <code>--stat</code> option is used.<br>The output is very clear about the behavior of the CLI in this mode:</p>\n<pre><code>$ valkey-cli --stat\n------- data ------ --------------------- load -------------------- - child -\nkeys       mem      clients blocked requests            connections\n506        1015.00K 1       0       24 (+0)             7\n506        1015.00K 1       0       25 (+1)             7\n506        3.40M    51      0       60461 (+60436)      57\n506        3.40M    51      0       146425 (+85964)     107\n507        3.40M    51      0       233844 (+87419)     157\n507        3.40M    51      0       321715 (+87871)     207\n508        3.40M    51      0       408642 (+86927)     257\n508        3.40M    51      0       497038 (+88396)     257\n</code></pre>\n<p>In this mode a new line is printed every second with useful information and differences of request values between old data points. Memory usage, client connection counts, and various other statistics about the connected Valkey database can be easily understood with this auxiliary <code>valkey-cli</code> tool.</p>\n<p>The <code>-i &lt;interval&gt;</code> option in this case works as a modifier in order to<br>change the frequency at which new lines are emitted. The default is one<br>second.</p>\n<h2>Scanning for big keys</h2>\n<p>In this special mode, <code>valkey-cli</code> works as a key space analyzer. It scans the<br>dataset for big keys, but also provides information about the data types<br>that the data set consists of. This mode is enabled with the <code>--bigkeys</code> option,<br>and produces verbose output:</p>\n<pre><code>$ valkey-cli --bigkeys\n\n# Scanning the entire keyspace to find biggest keys as well as\n# average sizes per key type.  You can use -i 0.01 to sleep 0.01 sec\n# per SCAN command (not usually needed).\n\n[00.00%] Biggest string found so far &#39;key-419&#39; with 3 bytes\n[05.14%] Biggest list   found so far &#39;mylist&#39; with 100004 items\n[35.77%] Biggest string found so far &#39;counter:__rand_int__&#39; with 6 bytes\n[73.91%] Biggest hash   found so far &#39;myobject&#39; with 3 fields\n\n-------- summary -------\n\nSampled 506 keys in the keyspace!\nTotal key length in bytes is 3452 (avg len 6.82)\n\nBiggest string found &#39;counter:__rand_int__&#39; has 6 bytes\nBiggest   list found &#39;mylist&#39; has 100004 items\nBiggest   hash found &#39;myobject&#39; has 3 fields\n\n504 strings with 1403 bytes (99.60% of keys, avg size 2.78)\n1 lists with 100004 items (00.20% of keys, avg size 100004.00)\n0 sets with 0 members (00.00% of keys, avg size 0.00)\n1 hashs with 3 fields (00.20% of keys, avg size 3.00)\n0 zsets with 0 members (00.00% of keys, avg size 0.00)\n</code></pre>\n<p>In the first part of the output, each new key larger than the previous larger<br>key (of the same type) encountered is reported. The summary section<br>provides general stats about the data inside the Valkey instance.</p>\n<p>The program uses the <code>SCAN</code> command, so it can be executed against a busy<br>server without impacting the operations, however the <code>-i</code> option can be<br>used in order to throttle the scanning process of the specified fraction<br>of second for each <code>SCAN</code> command. </p>\n<p>For example, <code>-i 0.01</code> will slow down the program execution considerably, but will also reduce the load on the server<br>to a negligible amount.</p>\n<p>Note that the summary also reports in a cleaner form the biggest keys found<br>for each time. The initial output is just to provide some interesting info<br>ASAP if running against a very large data set.</p>\n<h2>Getting a list of keys</h2>\n<p>It is also possible to scan the key space, again in a way that does not<br>block the Valkey server (which does happen when you use a command<br>like <code>KEYS *</code>), and print all the key names, or filter them for specific<br>patterns. This mode, like the <code>--bigkeys</code> option, uses the <code>SCAN</code> command,<br>so keys may be reported multiple times if the dataset is changing, but no<br>key would ever be missing, if that key was present since the start of the<br>iteration. Because of the command that it uses this option is called <code>--scan</code>.</p>\n<pre><code>$ valkey-cli --scan | head -10\nkey-419\nkey-71\nkey-236\nkey-50\nkey-38\nkey-458\nkey-453\nkey-499\nkey-446\nkey-371\n</code></pre>\n<p>Note that <code>head -10</code> is used in order to print only the first ten lines of the<br>output.</p>\n<p>Scanning is able to use the underlying pattern matching capability of<br>the <code>SCAN</code> command with the <code>--pattern</code> option.</p>\n<pre><code>$ valkey-cli --scan --pattern &#39;*-11*&#39;\nkey-114\nkey-117\nkey-118\nkey-113\nkey-115\nkey-112\nkey-119\nkey-11\nkey-111\nkey-110\nkey-116\n</code></pre>\n<p>Piping the output through the <code>wc</code> command can be used to count specific<br>kind of objects, by key name:</p>\n<pre><code>$ valkey-cli --scan --pattern &#39;user:*&#39; | wc -l\n3829433\n</code></pre>\n<p>You can use <code>-i 0.01</code> to add a delay between calls to the <code>SCAN</code> command.<br>This will make the command slower but will significantly reduce load on the server.</p>\n<h2>Pub/sub mode</h2>\n<p>The CLI is able to publish messages in Valkey Pub/Sub channels using<br>the <code>PUBLISH</code> command. Subscribing to channels in order to receive<br>messages is different - the terminal is blocked and waits for<br>messages, so this is implemented as a special mode in <code>valkey-cli</code>. Unlike<br>other special modes this mode is not enabled by using a special option,<br>but simply by using the <code>SUBSCRIBE</code> or <code>PSUBSCRIBE</code> command, which are available in<br>interactive or command mode:</p>\n<pre><code>$ valkey-cli PSUBSCRIBE &#39;*&#39;\nReading messages... (press Ctrl-C to quit)\n1) &quot;PSUBSCRIBE&quot;\n2) &quot;*&quot;\n3) (integer) 1\n</code></pre>\n<p>The <em>reading messages</em> message shows that we entered Pub/Sub mode.<br>When another client publishes some message in some channel, such as with the command <code>valkey-cli PUBLISH mychannel mymessage</code>, the CLI in Pub/Sub mode will show something such as:</p>\n<pre><code>1) &quot;pmessage&quot;\n2) &quot;*&quot;\n3) &quot;mychannel&quot;\n4) &quot;mymessage&quot;\n</code></pre>\n<p>This is very useful for debugging Pub/Sub issues.<br>To exit the Pub/Sub mode just process <code>CTRL-C</code>.</p>\n<h2>Monitoring commands executed in Valkey</h2>\n<p>Similarly to the Pub/Sub mode, the monitoring mode is entered automatically<br>once you use the <code>MONITOR</code> command. All commands received by the active Valkey instance will be printed to the standard output:</p>\n<pre><code>$ valkey-cli MONITOR\nOK\n1460100081.165665 [0 127.0.0.1:51706] &quot;set&quot; &quot;shipment:8000736522714:status&quot; &quot;sorting&quot;\n1460100083.053365 [0 127.0.0.1:51707] &quot;get&quot; &quot;shipment:8000736522714:status&quot;\n</code></pre>\n<p>Note that it is possible to pipe the output, so you can monitor<br>for specific patterns using tools such as <code>grep</code>.</p>\n<h2>Monitoring the latency of Valkey instances</h2>\n<p>Valkey is often used in contexts where latency is very critical. Latency<br>involves multiple moving parts within the application, from the client library<br>to the network stack, to the Valkey instance itself.</p>\n<p>The <code>valkey-cli</code> has multiple facilities for studying the latency of a Valkey<br>instance and understanding the latency&#39;s maximum, average and distribution.</p>\n<p>The basic latency-checking tool is the <code>--latency</code> option. Using this<br>option the CLI runs a loop where the <code>PING</code> command is sent to the Valkey<br>instance and the time to receive a reply is measured. This happens 100<br>times per second, and stats are updated in a real time in the console:</p>\n<pre><code>$ valkey-cli --latency\nmin: 0, max: 1, avg: 0.19 (427 samples)\n</code></pre>\n<p>The stats are provided in milliseconds. Usually, the average latency of<br>a very fast instance tends to be overestimated a bit because of the<br>latency due to the kernel scheduler of the system running <code>valkey-cli</code><br>itself, so the average latency of 0.19 above may easily be 0.01 or less.<br>However this is usually not a big problem, since most developers are interested in<br>events of a few milliseconds or more.</p>\n<p>Sometimes it is useful to study how the maximum and average latencies<br>evolve during time. The <code>--latency-history</code> option is used for that<br>purpose: it works exactly like <code>--latency</code>, but every 15 seconds (by<br>default) a new sampling session is started from scratch:</p>\n<pre><code>$ valkey-cli --latency-history\nmin: 0, max: 1, avg: 0.14 (1314 samples) -- 15.01 seconds range\nmin: 0, max: 1, avg: 0.18 (1299 samples) -- 15.00 seconds range\nmin: 0, max: 1, avg: 0.20 (113 samples)^C\n</code></pre>\n<p>Sampling sessions&#39; length can be changed with the <code>-i &lt;interval&gt;</code> option.</p>\n<p>The most advanced latency study tool, but also the most complex to<br>interpret for non-experienced users, is the ability to use color terminals<br>to show a spectrum of latencies. You&#39;ll see a colored output that indicates the<br>different percentages of samples, and different ASCII characters that indicate<br>different latency figures. This mode is enabled using the <code>--latency-dist</code><br>option:</p>\n<pre><code>$ valkey-cli --latency-dist\n(output not displayed, requires a color terminal, try it!)\n</code></pre>\n<p>There is another pretty unusual latency tool implemented inside <code>valkey-cli</code>.<br>It does not check the latency of a Valkey instance, but the latency of the<br>computer running <code>valkey-cli</code>. This latency is intrinsic to the kernel scheduler,<br>the hypervisor in case of virtualized instances, and so forth.</p>\n<p>Valkey calls it <em>intrinsic latency</em> because it&#39;s mostly opaque to the programmer.<br>If the Valkey instance has high latency regardless of all the obvious things<br>that may be the source cause, it&#39;s worth to check what&#39;s the best your system<br>can do by running <code>valkey-cli</code> in this special mode directly in the system you<br>are running Valkey servers on.</p>\n<p>By measuring the intrinsic latency, you know that this is the baseline,<br>and Valkey cannot outdo your system. In order to run the CLI<br>in this mode, use the <code>--intrinsic-latency &lt;test-time&gt;</code>. Note that the test time is in seconds and dictates how long the test should run.</p>\n<pre><code>$ ./valkey-cli --intrinsic-latency 5\nMax latency so far: 1 microseconds.\nMax latency so far: 7 microseconds.\nMax latency so far: 9 microseconds.\nMax latency so far: 11 microseconds.\nMax latency so far: 13 microseconds.\nMax latency so far: 15 microseconds.\nMax latency so far: 34 microseconds.\nMax latency so far: 82 microseconds.\nMax latency so far: 586 microseconds.\nMax latency so far: 739 microseconds.\n\n65433042 total runs (avg latency: 0.0764 microseconds / 764.14 nanoseconds per run).\nWorst run took 9671x longer than the average latency.\n</code></pre>\n<p>IMPORTANT: this command must be executed on the computer that runs the Valkey server instance, not on a different host. It does not connect to a Valkey instance and performs the test locally.</p>\n<p>In the above case, the system cannot do better than 739 microseconds of worst<br>case latency, so one can expect certain queries to occasionally run less than 1 millisecond.</p>\n<h2>Remote backups of RDB files</h2>\n<p>During a Valkey replication&#39;s first synchronization, the primary and the replica<br>exchange the whole data set in the form of an RDB file. This feature is exploited<br>by <code>valkey-cli</code> in order to provide a remote backup facility that allows a<br>transfer of an RDB file from any Valkey instance to the local computer running<br><code>valkey-cli</code>. To use this mode, call the CLI with the <code>--rdb &lt;dest-filename&gt;</code><br>option:</p>\n<pre><code>$ valkey-cli --rdb /tmp/dump.rdb\nSYNC sent to master, writing 13256 bytes to &#39;/tmp/dump.rdb&#39;\nTransfer finished with success.\n</code></pre>\n<p>This is a simple but effective way to ensure disaster recovery<br>RDB backups exist of your Valkey instance. When using this options in<br>scripts or <code>cron</code> jobs, make sure to check the return value of the command.<br>If it is non zero, an error occurred as in the following example:</p>\n<pre><code>$ valkey-cli --rdb /tmp/dump.rdb\nSYNC with master failed: -ERR Can&#39;t SYNC while not connected with my master\n$ echo $?\n1\n</code></pre>\n<h2>Replica mode</h2>\n<p>The replica mode of the CLI is an advanced feature useful for<br>Valkey developers and for debugging operations.<br>It allows for the inspection of the content a primary sends to its replicas in the replication<br>stream in order to propagate the writes to its replicas. The option<br>name is simply <code>--replica</code>. The following is a working example:</p>\n<pre><code>$ valkey-cli --replica\nSYNC with master, discarding 13256 bytes of bulk transfer...\nSYNC done. Logging commands from master.\n&quot;PING&quot;\n&quot;SELECT&quot;,&quot;0&quot;\n&quot;SET&quot;,&quot;last_name&quot;,&quot;Enigk&quot;\n&quot;PING&quot;\n&quot;INCR&quot;,&quot;mycounter&quot;\n</code></pre>\n<p>The command begins by discarding the RDB file of the first synchronization<br>and then logs each command received in CSV format.</p>\n<p>If you think some of the commands are not replicated correctly in your replicas<br>this is a good way to check what&#39;s happening, and also useful information<br>in order to improve the bug report.</p>\n<h2>Performing an LRU simulation</h2>\n<p>Valkey is often used as a cache with <a href=\"lru-cache.md\">LRU eviction</a>.<br>Depending on the number of keys and the amount of memory allocated for the<br>cache (specified via the <code>maxmemory</code> directive), the amount of cache hits<br>and misses will change. Sometimes, simulating the rate of hits is very<br>useful to correctly provision your cache.</p>\n<p>The <code>valkey-cli</code> has a special mode where it performs a simulation of GET and SET<br>operations, using an 80-20% power law distribution in the requests pattern.<br>This means that 20% of keys will be requested 80% of times, which is a<br>common distribution in caching scenarios.</p>\n<p>Theoretically, given the distribution of the requests and the Valkey memory<br>overhead, it should be possible to compute the hit rate analytically<br>with a mathematical formula. However, Valkey can be configured with<br>different LRU settings (number of samples) and LRU&#39;s implementation, which<br>is approximated in Valkey, changes a lot between different versions. Similarly<br>the amount of memory per key may change between versions. That is why this<br>tool was built: its main motivation was for testing the quality of Valkey&#39; LRU<br>implementation, but now is also useful for testing how a given version<br>behaves with the settings originally intended for deployment.</p>\n<p>To use this mode, specify the amount of keys in the test and configure a sensible <code>maxmemory</code> setting as a first attempt.</p>\n<p>IMPORTANT NOTE: Configuring the <code>maxmemory</code> setting in the Valkey configuration<br>is crucial: if there is no cap to the maximum memory usage, the hit will<br>eventually be 100% since all the keys can be stored in memory. If too many keys are specified with maximum memory, eventually all of the computer RAM will be used. It is also needed to configure an appropriate<br><em>maxmemory policy</em>; most of the time <code>allkeys-lru</code> is selected.</p>\n<p>In the following example there is a configured a memory limit of 100MB and an LRU<br>simulation using 10 million keys.</p>\n<p>WARNING: the test uses pipelining and will stress the server, don&#39;t use it<br>with production instances.</p>\n<pre><code>$ ./valkey-cli --lru-test 10000000\n156000 Gets/sec | Hits: 4552 (2.92%) | Misses: 151448 (97.08%)\n153750 Gets/sec | Hits: 12906 (8.39%) | Misses: 140844 (91.61%)\n159250 Gets/sec | Hits: 21811 (13.70%) | Misses: 137439 (86.30%)\n151000 Gets/sec | Hits: 27615 (18.29%) | Misses: 123385 (81.71%)\n145000 Gets/sec | Hits: 32791 (22.61%) | Misses: 112209 (77.39%)\n157750 Gets/sec | Hits: 42178 (26.74%) | Misses: 115572 (73.26%)\n154500 Gets/sec | Hits: 47418 (30.69%) | Misses: 107082 (69.31%)\n151250 Gets/sec | Hits: 51636 (34.14%) | Misses: 99614 (65.86%)\n</code></pre>\n<p>The program shows stats every second. In the first seconds the cache starts to be populated. The misses rate later stabilizes into the actual figure that can be expected:</p>\n<pre><code>120750 Gets/sec | Hits: 48774 (40.39%) | Misses: 71976 (59.61%)\n122500 Gets/sec | Hits: 49052 (40.04%) | Misses: 73448 (59.96%)\n127000 Gets/sec | Hits: 50870 (40.06%) | Misses: 76130 (59.94%)\n124250 Gets/sec | Hits: 50147 (40.36%) | Misses: 74103 (59.64%)\n</code></pre>\n<p>A miss rate of 59% may not be acceptable for certain use cases therefor<br>100MB of memory is not enough. Observe an example using a half gigabyte of memory. After several<br>minutes the output stabilizes to the following figures:</p>\n<pre><code>140000 Gets/sec | Hits: 135376 (96.70%) | Misses: 4624 (3.30%)\n141250 Gets/sec | Hits: 136523 (96.65%) | Misses: 4727 (3.35%)\n140250 Gets/sec | Hits: 135457 (96.58%) | Misses: 4793 (3.42%)\n140500 Gets/sec | Hits: 135947 (96.76%) | Misses: 4553 (3.24%)\n</code></pre>\n<p>With 500MB there is sufficient space for the key quantity (10 million) and distribution (80-20 style).</p>\n"
      },
      {
        "id": "valkey.conf",
        "topicName": "Configuration",
        "description": "Overview of valkey.conf, the Valkey configuration file\n",
        "htmlContent": "<p>Valkey is able to start without a configuration file using a built-in default<br>configuration, however this setup is only recommended for testing and<br>development purposes.</p>\n<p>The proper way to configure Valkey is by providing a Valkey configuration file,<br>usually called <code>valkey.conf</code>.</p>\n<p>The <code>valkey.conf</code> file contains a number of directives that have a very simple<br>format:</p>\n<pre><code>keyword argument1 argument2 ... argumentN\n</code></pre>\n<p>This is an example of a configuration directive:</p>\n<pre><code>replicaof 127.0.0.1 6380\n</code></pre>\n<p>It is possible to provide strings containing spaces as arguments using<br>(double or single) quotes, as in the following example:</p>\n<pre><code>requirepass &quot;hello world&quot;\n</code></pre>\n<p>Single-quoted string can contain characters escaped by backslashes, and<br>double-quoted strings can additionally include any ASCII symbols encoded using<br>backslashed hexadecimal notation &quot;\\xff&quot;.</p>\n<p>The list of configuration directives, and their meaning and intended usage<br>is available in the self documented example valkey.conf shipped into the<br>Valkey distribution.</p>\n<ul>\n<li>The self documented <a href=\"https://raw.githubusercontent.com/valkey-io/valkey/7.2/valkey.conf\">valkey.conf for Valkey OSS 7.2</a>.</li>\n<li>The self documented <a href=\"https://raw.githubusercontent.com/redis/redis/7.2/redis.conf\">redis.conf for Redis OSS 7.2</a>.</li>\n<li>The self documented <a href=\"https://raw.githubusercontent.com/redis/redis/7.0/redis.conf\">redis.conf for Redis OSS 7.0</a>.</li>\n<li>The self documented <a href=\"https://raw.githubusercontent.com/redis/redis/6.2/redis.conf\">redis.conf for Redis OSS 6.2</a>.</li>\n</ul>\n<h2>Passing arguments via the command line</h2>\n<p>You can also pass Valkey configuration parameters<br>using the command line directly. This is very useful for testing purposes.<br>The following is an example that starts a new Valkey instance using port 6380<br>as a replica of the instance running at 127.0.0.1 port 6379.</p>\n<pre><code>./valkey-server --port 6380 --replicaof 127.0.0.1 6379\n</code></pre>\n<p>The format of the arguments passed via the command line is exactly the same<br>as the one used in the valkey.conf file, with the exception that the keyword<br>is prefixed with <code>--</code>.</p>\n<p>Note that internally this generates an in-memory temporary config file<br>(possibly concatenating the config file passed by the user, if any) where<br>arguments are translated into the format of valkey.conf.</p>\n<h2>Changing Valkey configuration while the server is running</h2>\n<p>It is possible to reconfigure Valkey on the fly without stopping and restarting<br>the service, or querying the current configuration programmatically using the<br>special commands <code>CONFIG SET</code> and <code>CONFIG GET</code>.</p>\n<p>Not all of the configuration directives are supported in this way, but most<br>are supported as expected.<br>Please refer to the <code>CONFIG SET</code> and <code>CONFIG GET</code> pages for more information.</p>\n<p>Note that modifying the configuration on the fly <strong>has no effects on the<br>valkey.conf file</strong> so at the next restart of Valkey the old configuration will<br>be used instead.</p>\n<p>Make sure to also modify the <code>valkey.conf</code> file accordingly to the configuration<br>you set using <code>CONFIG SET</code>.<br>You can do it manually, or you can use <code>CONFIG REWRITE</code>, which will automatically scan your <code>valkey.conf</code> file and update the fields which don&#39;t match the current configuration value.<br>Fields non existing but set to the default value are not added.<br>Comments inside your configuration file are retained.</p>\n<h2>Configuring Valkey as a cache</h2>\n<p>If you plan to use Valkey as a cache where every key will have an<br>expire set, you may consider using the following configuration instead<br>(assuming a max memory limit of 2 megabytes as an example):</p>\n<pre><code>maxmemory 2mb\nmaxmemory-policy allkeys-lru\n</code></pre>\n<p>In this configuration there is no need for the application to set a<br>time to live for keys using the <code>EXPIRE</code> command (or equivalent) since<br>all the keys will be evicted using an approximated LRU algorithm as long<br>as we hit the 2 megabyte memory limit.</p>\n<p>Basically, in this configuration Valkey acts in a similar way to memcached.<br>We have more extensive documentation about using Valkey as an LRU cache <a href=\"lru-cache.md\">here</a>.</p>\n"
      },
      {
        "id": "server",
        "topicName": "The Valkey server",
        "description": "Manual for valkey-server, the Valkey server program\n",
        "htmlContent": "<h2>Usage</h2>\n<p><strong><code>valkey-server</code></strong> [ <em>/path/to/valkey.conf</em> ] [ <em>OPTIONS</em> ] [<strong><code>-</code></strong>]<br><strong><code>valkey-server</code></strong> <strong><code>-v</code></strong> | <strong><code>--version</code></strong><br><strong><code>valkey-server</code></strong> <strong><code>-h</code></strong> | <strong><code>--help</code></strong><br><strong><code>valkey-server</code></strong> <strong><code>--test-memory</code></strong> <em>megabytes</em><br><strong><code>valkey-server</code></strong> <strong><code>--check-system</code></strong></p>\n<h2>Description</h2>\n<p><code>valkey-server</code> is the Valkey database program.</p>\n<p>What is Valkey? See <a href=\"introduction.md\">Introduction</a>.</p>\n<h2>Options</h2>\n<p>The configuration file and the configuration directives are documented in<br><a href=\"valkey.conf.md\">Configuration</a>. Use <code>-</code> to read configuration from stdin.</p>\n<p>Each of the configuration directives can be provided on the command line<br>with its name prefixed by two dashes. For example, <code>--port 6380</code> on the command<br>line is equivalent to <code>port 6380</code> in the config file.</p>\n<p>Additional options:</p>\n<p><strong><code>-v</code></strong>, <strong><code>--version</code></strong><br>: Output version and exit.</p>\n<p><strong><code>-h</code></strong>, <strong><code>--help</code></strong><br>: Output help and exit.</p>\n<p><strong><code>--test-memory</code></strong> <em>megabytes</em><br>: Run a memory test and exit.</p>\n<p><strong><code>--check-sytem</code></strong><br>: Output some operating system properties relevant for running Valkey and exit.</p>\n<p><strong><code>--sentinel</code></strong><br>: Start in <a href=\"sentinel.md\">sentinel</a> mode</p>\n<h2>Examples</h2>\n<p>Run the server with default config:</p>\n<pre><code>valkey-server\n</code></pre>\n<p>Read configuration from stdin:</p>\n<pre><code>echo &#39;maxmemory 128mb&#39; | valkey-server -\n</code></pre>\n<p>Start with a configuration file:</p>\n<pre><code>valkey-server /etc/valkey/6379.conf\n</code></pre>\n<p>Start with configuration as command line options:</p>\n<pre><code>valkey-server --port 7777\n</code></pre>\n<p>Start as a replica of another Valkey server that can accessed at 127.0.0.1:8888:</p>\n<pre><code>valkey-server --port 7777 --replicaof 127.0.0.1 8888\n</code></pre>\n<p>Start with a config file, then some additional options overriding the ones in<br>the config file, and finally some more options from stdin:</p>\n<pre><code>valkey-server /etc/myvalkey.conf --loglevel verbose -\n</code></pre>\n<p>Start with a config file and some additional options overriding the ones in<br>the config file:</p>\n<pre><code>valkey-server /etc/myvalkey.conf --loglevel verbose\n</code></pre>\n<h2>See also</h2>\n<p><a href=\"./\">Valkey documentation</a>, <a href=\"introduction.md\">Introduction</a>, <a href=\"valkey.conf.md\">Configuration</a>, <a href=\"installation.md\">Installation</a>, <a href=\"cli.md\">valkey-cli</a></p>\n"
      }
    ]
  },
  {
    "title": "CLIENT HANDLING",
    "items": [
      {
        "id": "clients",
        "topicName": "Client handling",
        "description": "How the Valkey server manages client connections\n",
        "htmlContent": "<p>This document provides information about how Valkey handles clients at the network layer level: connections, timeouts, buffers, and other similar topics are covered here.</p>\n<h2>Accepting Client Connections</h2>\n<p>Valkey accepts clients connections on the configured TCP port and on the Unix socket if enabled. When a new client connection is accepted the following operations are performed:</p>\n<ul>\n<li>The client socket is put in the non-blocking state since Valkey uses multiplexing and non-blocking I/O.</li>\n<li>The <code>TCP_NODELAY</code> option is set in order to ensure that there are no delays to the connection.</li>\n<li>A <em>readable</em> file event is created so that Valkey is able to collect the client queries as soon as new data is available to read on the socket.</li>\n</ul>\n<p>After the client is initialized, Valkey checks if it is already at the limit<br>configured for the number of simultaneous clients (configured using the <code>maxclients</code> configuration directive, see the next section of this document for further information).</p>\n<p>When Valkey can&#39;t accept a new client connection because the maximum number of clients<br>has been reached, it tries to send an error to the client in order to<br>make it aware of this condition, closing the connection immediately.<br>The error message will reach the client even if the connection is<br>closed immediately by Valkey because the new socket output buffer is usually<br>big enough to contain the error, so the kernel will handle transmission<br>of the error.</p>\n<h2>What Order are Client Requests Served In?</h2>\n<p>The order is determined by a combination of the client socket file descriptor<br>number and order in which the kernel reports events, so the order should be<br>considered as unspecified.</p>\n<p>However, Valkey does the following two things when serving clients:</p>\n<ul>\n<li>It only performs a single <code>read()</code> system call every time there is something new to read from the client socket. This ensures that if we have multiple clients connected, and a few send queries at a high rate, other clients are not penalized and will not experience latency issues.</li>\n<li>However once new data is read from a client, all the queries contained in the current buffers are processed sequentially. This improves locality and does not need iterating a second time to see if there are clients that need some processing time.</li>\n</ul>\n<h2>Maximum Concurrent Connected Clients</h2>\n<p>The limit for the maximum number of clients that can be handled simultaneously<br>is configurable using the <code>maxclients</code> directive in <code>valkey.conf</code>. The default<br>is 10,000 clients.</p>\n<p>However, Valkey checks with the kernel what the maximum number of file<br>descriptors that we are able to open is (the <em>soft limit</em> is checked). If the<br>limit is less than the maximum number of clients we want to handle, plus<br>32 (that is the number of file descriptors Valkey reserves for internal uses),<br>then the maximum number of clients is updated to match the number<br>of clients it is <em>really able to handle</em> under the current operating system<br>limit.</p>\n<p>When <code>maxclients</code> is set to a number greater than Valkey can support, a message is logged at startup:</p>\n<pre><code>$ ./valkey-server --maxclients 100000\n[41422] 23 Jan 11:28:33.179 # Unable to set the max number of files limit to 100032 (Invalid argument), setting the max clients configuration to 10112.\n</code></pre>\n<p>When Valkey is configured in order to handle a specific number of clients it<br>is a good idea to make sure that the operating system limit for the maximum<br>number of file descriptors per process is also set accordingly.</p>\n<p>Under Linux these limits can be set both in the current session and as a<br>system-wide setting with the following commands:</p>\n<ul>\n<li><code>ulimit -Sn 100000 # This will only work if hard limit is big enough.</code></li>\n<li><code>sysctl -w fs.file-max=100000</code></li>\n</ul>\n<h2>Output Buffer Limits</h2>\n<p>Valkey needs to handle a variable-length output buffer for every client, since<br>a command can produce a large amount of data that needs to be transferred to the<br>client.</p>\n<p>However it is possible that a client sends more commands producing more output<br>to serve at a faster rate than that which Valkey can send the existing output to the<br>client. This is especially true with Pub/Sub clients in case a client is not<br>able to process new messages fast enough.</p>\n<p>Both conditions will cause the client output buffer to grow and consume<br>more and more memory. For this reason by default Sets limits to the<br>output buffer size for different kind of clients. When the limit is reached<br>the client connection is closed and the event logged in the Valkey log file.</p>\n<p>There are two kind of limits Valkey uses:</p>\n<ul>\n<li>The <strong>hard limit</strong> is a fixed limit that when reached will make Valkey close the client connection as soon as possible.</li>\n<li>The <strong>soft limit</strong> instead is a limit that depends on the time, for instance a soft limit of 32 megabytes per 10 seconds means that if the client has an output buffer bigger than 32 megabytes for, continuously, 10 seconds, the connection gets closed.</li>\n</ul>\n<p>Different kind of clients have different default limits:</p>\n<ul>\n<li><strong>Normal clients</strong> have a default limit of 0, that means, no limit at all, because most normal clients use blocking implementations sending a single command and waiting for the reply to be completely read before sending the next command, so it is always not desirable to close the connection in case of a normal client.</li>\n<li><strong>Pub/Sub clients</strong> have a default hard limit of 32 megabytes and a soft limit of 8 megabytes per 60 seconds.</li>\n<li><strong>Replicas</strong> have a default hard limit of 256 megabytes and a soft limit of 64 megabyte per 60 seconds.</li>\n</ul>\n<p>It is possible to change the limit at runtime using the <code>CONFIG SET</code> command or in a permanent way using the Valkey configuration file <code>valkey.conf</code>. See the example <code>valkey.conf</code> in the Valkey distribution for more information about how to set the limit.</p>\n<h2>Query Buffer Hard Limit</h2>\n<p>Every client is also subject to a query buffer limit. This is a non-configurable hard limit that will close the connection when the client query buffer (that is the buffer we use to accumulate commands from the client) reaches 1 GB, and is actually only an extreme limit to avoid a server crash in case of client or server software bugs.</p>\n<h2>Client Eviction</h2>\n<p>Valkey is built to handle a very large number of client connections.<br>Client connections tend to consume memory, and when there are many of them, the aggregate memory consumption can be extremely high, leading to data eviction or out-of-memory errors.<br>These cases can be mitigated to an extent using <a href=\"#output-buffer-limits\">output buffer limits</a>, but Valkey allows us a more robust configuration to limit the aggregate memory used by all clients&#39; connections.</p>\n<p>This mechanism is called <strong>client eviction</strong>, and it&#39;s essentially a safety mechanism that will disconnect clients once the aggregate memory usage of all clients is above a threshold.<br>The mechanism first attempts to disconnect clients that use the most memory.<br>It disconnects the minimal number of clients needed to return below the <code>maxmemory-clients</code> threshold.</p>\n<p><code>maxmemory-clients</code> defines the maximum aggregate memory usage of all clients connected to Valkey.<br>The aggregation takes into account all the memory used by the client connections: the <a href=\"#query-buffer-hard-limit\">query buffer</a>, the output buffer, and other intermediate buffers.</p>\n<p>Note that replica and primary connections aren&#39;t affected by the client eviction mechanism. Therefore, such connections are never evicted.</p>\n<p><code>maxmemory-clients</code> can be set permanently in the configuration file (<code>valkey.conf</code>) or via the <code>CONFIG SET</code> command.<br>This setting can either be 0 (meaning no limit), a size in bytes (possibly with <code>mb</code>/<code>gb</code> suffix),<br>or a percentage of <code>maxmemory</code> by using the <code>%</code> suffix (e.g. setting it to <code>10%</code> would mean 10% of the <code>maxmemory</code> configuration).</p>\n<p>The default setting is 0, meaning client eviction is turned off by default.<br>However, for any large production deployment, it is highly recommended to configure some non-zero <code>maxmemory-clients</code> value.<br>A value <code>5%</code>, for example, can be a good place to start.</p>\n<p>It is possible to flag a specific client connection to be excluded from the client eviction mechanism.<br>This is useful for control path connections.<br>If, for example, you have an application that monitors the server via the <code>INFO</code> command and alerts you in case of a problem, you might want to make sure this connection isn&#39;t evicted.<br>You can do so using the following command (from the relevant client&#39;s connection):</p>\n<p><code>CLIENT NO-EVICT</code> <code>on</code></p>\n<p>And you can revert that with:</p>\n<p><code>CLIENT NO-EVICT</code> <code>off</code></p>\n<p>For more information and an example refer to the <code>maxmemory-clients</code> section in the default <code>valkey.conf</code> file.</p>\n<p>Client eviction is available from Redis OSS 7.0.</p>\n<h2>Client Timeouts</h2>\n<p>By default recent versions of Valkey don&#39;t close the connection with the client<br>if the client is idle for many seconds: the connection will remain open forever.</p>\n<p>However if you don&#39;t like this behavior, you can configure a timeout, so that<br>if the client is idle for more than the specified number of seconds, the client connection will be closed.</p>\n<p>You can configure this limit via <code>valkey.conf</code> or simply using <code>CONFIG SET timeout &lt;value&gt;</code>.</p>\n<p>Note that the timeout only applies to normal clients and it <strong>does not apply to Pub/Sub clients</strong>, since a Pub/Sub connection is a <em>push style</em> connection so a client that is idle is the norm.</p>\n<p>Even if by default connections are not subject to timeout, there are two conditions when it makes sense to set a timeout:</p>\n<ul>\n<li>Mission critical applications where a bug in the client software may saturate the Valkey server with idle connections, causing service disruption.</li>\n<li>As a debugging mechanism in order to be able to connect with the server if a bug in the client software saturates the server with idle connections, making it impossible to interact with the server.</li>\n</ul>\n<p>Timeouts are not to be considered very precise: Valkey avoids setting timer events or running O(N) algorithms in order to check idle clients, so the check is performed incrementally from time to time. This means that it is possible that while the timeout is set to 10 seconds, the client connection will be closed, for instance, after 12 seconds if many clients are connected at the same time.</p>\n<h2>The CLIENT Command</h2>\n<p>The Valkey <code>CLIENT</code> command allows you to inspect the state of every connected client, to kill a specific client, and to name connections. It is a very powerful debugging tool if you use Valkey at scale.</p>\n<p><code>CLIENT LIST</code> is used in order to obtain a list of connected clients and their state:</p>\n<pre><code>127.0.0.1:6379&gt; client list\naddr=127.0.0.1:52555 fd=5 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client\naddr=127.0.0.1:52787 fd=6 name= age=6 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping\n</code></pre>\n<p>In the above example two clients are connected to the Valkey server. Let&#39;s look at what some of the data returned represents:</p>\n<ul>\n<li><strong>addr</strong>: The client address, that is, the client IP and the remote port number it used to connect with the Valkey server.</li>\n<li><strong>fd</strong>: The client socket file descriptor number.</li>\n<li><strong>name</strong>: The client name as set by <code>CLIENT SETNAME</code>.</li>\n<li><strong>age</strong>: The number of seconds the connection existed for.</li>\n<li><strong>idle</strong>: The number of seconds the connection is idle.</li>\n<li><strong>flags</strong>: The kind of client (N means normal client, check the <a href=\"../commands/client-list.md\">full list of flags</a>).</li>\n<li><strong>omem</strong>: The amount of memory used by the client for the output buffer.</li>\n<li><strong>cmd</strong>: The last executed command.</li>\n</ul>\n<p>See the <a href=\"../commands/client-list.md\"><code>CLIENT LIST</code></a> documentation for the full listing of fields and their purpose.</p>\n<p>Once you have the list of clients, you can close a client&#39;s connection using the <code>CLIENT KILL</code> command, specifying the client address as its argument.</p>\n<p>The commands <code>CLIENT SETNAME</code> and <code>CLIENT GETNAME</code> can be used to set and get the connection name. Starting with Redis OSS 4.0, the client name is shown in the<br><code>SLOWLOG</code> output, to help identify clients that create latency issues.</p>\n<h2>TCP keepalive</h2>\n<p>Valkey has TCP keepalive (<code>SO_KEEPALIVE</code> socket option) enabled by default and set to about 300 seconds. This option is useful in order to detect dead peers (clients that cannot be reached even if they look connected). Moreover, if there is network equipment between clients and servers that need to see some traffic in order to take the connection open, the option will prevent unexpected connection closed events.</p>\n"
      },
      {
        "id": "client-side-caching",
        "topicName": "Client-side caching",
        "description": "Server-assisted, client-side caching in Valkey\n",
        "htmlContent": "<p>Client-side caching is a technique used to create high performance services.<br>It exploits the memory available on application servers, servers that are<br>usually distinct computers compared to the Valkey nodes, to store some subset<br>of the Valkey information directly in the application side.</p>\n<p>Normally when data is required, the application servers ask the Valkey about<br>such information, like in the following diagram:</p>\n<pre><code>+-------------+                                +----------+\n|             | ------- GET user:1234 -------&gt; |          |\n| Application |                                |  Valkey  |\n|             | &lt;---- username = Alice ------- |          |\n+-------------+                                +----------+\n</code></pre>\n<p>When client-side caching is used, the application will store the reply of<br>popular queries directly inside the application memory, so that it can<br>reuse such replies later, without contacting the Valkey again:</p>\n<pre><code>+-------------+                                +----------+\n|             |                                |          |\n| Application |       ( No chat needed )       |  Valkey  |\n|             |                                |          |\n+-------------+                                +----------+\n| Local cache |\n|             |\n| user:1234 = |\n| username    |\n| Alice       |\n+-------------+\n</code></pre>\n<p>While the application memory used for the local cache may not be very big,<br>the time needed in order to access the local computer memory is orders of<br>magnitude smaller compared to accessing a networked service like a Valkey.<br>Since often the same small percentage of data are accessed frequently,<br>this pattern can greatly reduce the latency for the application to get data<br>and, at the same time, the load in the Valkey side.</p>\n<p>Moreover there are many datasets where items change very infrequently.<br>For instance, most user posts in a social network are either immutable or<br>rarely edited by the user. Adding to this the fact that usually a small<br>percentage of the posts are very popular, either because a small set of users<br>have a lot of followers and/or because recent posts have a lot more<br>visibility, it is clear why such a pattern can be very useful.</p>\n<p>Usually the two key advantages of client-side caching are:</p>\n<ol>\n<li>Data is available with a very small latency.</li>\n<li>The Valkey system receives less queries, allowing it to serve the same dataset with a smaller number of nodes.</li>\n</ol>\n<h2>There are two hard problems in computer science...</h2>\n<p>A problem with the above pattern is how to invalidate the information that<br>the application is holding, in order to avoid presenting stale data to the<br>user. For example after the application above locally cached the information<br>for user:1234, Alice may update her username to Flora. Yet the application<br>may continue to serve the old username for user:1234.</p>\n<p>Sometimes, depending on the exact application we are modeling, this isn&#39;t a<br>big deal, so the client will just use a fixed maximum &quot;time to live&quot; for the<br>cached information. Once a given amount of time has elapsed, the information<br>will no longer be considered valid. More complex patterns, when using Valkey,<br>leverage the Pub/Sub system in order to send invalidation messages to<br>listening clients. This can be made to work but is tricky and costly from<br>the point of view of the bandwidth used, because often such patterns involve<br>sending the invalidation messages to every client in the application, even<br>if certain clients may not have any copy of the invalidated data. Moreover<br>every application query altering the data requires to use the <code>PUBLISH</code><br>command, costing the Valkey more CPU time to process this command.</p>\n<p>Regardless of what schema is used, there is a simple fact: many very large<br>applications implement some form of client-side caching, because it is the<br>next logical step to having a fast store or a fast cache server. For this<br>reason Valkey implements direct support for client-side caching, in order<br>to make this pattern much simpler to implement, more accessible, reliable,<br>and efficient.</p>\n<h2>The Valkey implementation of client-side caching</h2>\n<p>The Valkey client-side caching support is called <em>Tracking</em>, and has two modes:</p>\n<ul>\n<li>In the default mode, the server remembers what keys a given client accessed, and sends invalidation messages when the same keys are modified. This costs memory in the server side, but sends invalidation messages only for the set of keys that the client might have in memory.</li>\n<li>In the <em>broadcasting</em> mode, the server does not attempt to remember what keys a given client accessed, so this mode costs no memory at all in the server side. Instead clients subscribe to key prefixes such as <code>object:</code> or <code>user:</code>, and receive a notification message every time a key matching a subscribed prefix is touched.</li>\n</ul>\n<p>To recap, for now let&#39;s forget for a moment about the broadcasting mode, to<br>focus on the first mode. We&#39;ll describe broadcasting in more detail later.</p>\n<ol>\n<li>Clients can enable tracking if they want. Connections start without tracking enabled.</li>\n<li>When tracking is enabled, the server remembers what keys each client requested during the connection lifetime (by sending read commands about such keys).</li>\n<li>When a key is modified by some client, or is evicted because it has an associated expire time, or evicted because of a <em>maxmemory</em> policy, all the clients with tracking enabled that may have the key cached, are notified with an <em>invalidation message</em>.</li>\n<li>When clients receive invalidation messages, they are required to remove the corresponding keys, in order to avoid serving stale data.</li>\n</ol>\n<p>This is an example of the protocol:</p>\n<ul>\n<li>Client 1 <code>-&gt;</code> Server: CLIENT TRACKING ON</li>\n<li>Client 1 <code>-&gt;</code> Server: GET foo</li>\n<li>(The server remembers that Client 1 may have the key &quot;foo&quot; cached)</li>\n<li>(Client 1 may remember the value of &quot;foo&quot; inside its local memory)</li>\n<li>Client 2 <code>-&gt;</code> Server: SET foo SomeOtherValue</li>\n<li>Server <code>-&gt;</code> Client 1: INVALIDATE &quot;foo&quot;</li>\n</ul>\n<p>This looks great superficially, but if you imagine 10k connected clients all<br>asking for millions of keys over long living connection, the server ends up<br>storing too much information. For this reason Valkey uses two key ideas in<br>order to limit the amount of memory used server-side and the CPU cost of<br>handling the data structures implementing the feature:</p>\n<ul>\n<li>The server remembers the list of clients that may have cached a given key in a single global table. This table is called the <strong>Invalidation Table</strong>. The invalidation table can contain a maximum number of entries. If a new key is inserted, the server may evict an older entry by pretending that such key was modified (even if it was not), and sending an invalidation message to the clients. Doing so, it can reclaim the memory used for this key, even if this will force the clients having a local copy of the key to evict it.</li>\n<li>Inside the invalidation table we don&#39;t really need to store pointers to clients&#39; structures, that would force a garbage collection procedure when the client disconnects: instead what we do is just store client IDs (each Valkey client has a unique numerical ID). If a client disconnects, the information will be incrementally garbage collected as caching slots are invalidated.</li>\n<li>There is a single keys namespace, not divided by Valkey numbers. So if a client is caching the key <code>foo</code> in Valkey 2, and some other client changes the value of the key <code>foo</code> in Valkey 3, an invalidation message will still be sent. This way we can ignore Valkey numbers reducing both the memory usage and the implementation complexity.</li>\n</ul>\n<h2>Two connections mode</h2>\n<p>Using the new version of the Valkey protocol, RESP3, it is possible to run the data queries and receive the invalidation messages in the same connection. However many client implementations may prefer to implement client-side caching using two separated connections: one for data, and one for invalidation messages. For this reason when a client enables tracking, it can specify to redirect the invalidation messages to another connection by specifying the &quot;client ID&quot; of a different connection. Many data connections can redirect invalidation messages to the same connection, this is useful for clients implementing connection pooling. The two connections model is the only one that is also supported for RESP2 (which lacks the ability to multiplex different kind of information in the same connection).</p>\n<p>Here&#39;s an example of a complete session using the Valkey protocol in the old RESP2 mode involving the following steps: enabling tracking redirecting to another connection, asking for a key, and getting an invalidation message once the key gets modified.</p>\n<p>To start, the client opens a first connection that will be used for invalidations, requests the connection ID, and subscribes via Pub/Sub to the special channel that is used to get invalidation messages when in RESP2 modes (remember that RESP2 is the usual Valkey protocol, and not the more advanced protocol that you can use, optionally, using the <code>HELLO</code> command):</p>\n<pre><code>(Connection 1 -- used for invalidations)\nCLIENT ID\n:4\nSUBSCRIBE __redis__:invalidate\n*3\n$9\nsubscribe\n$20\n__redis__:invalidate\n:1\n</code></pre>\n<p>Now we can enable tracking from the data connection:</p>\n<pre><code>(Connection 2 -- data connection)\nCLIENT TRACKING on REDIRECT 4\n+OK\n\nGET foo\n$3\nbar\n</code></pre>\n<p>The client may decide to cache <code>&quot;foo&quot; =&gt; &quot;bar&quot;</code> in the local memory.</p>\n<p>A different client will now modify the value of the &quot;foo&quot; key:</p>\n<pre><code>(Some other unrelated connection)\nSET foo bar\n+OK\n</code></pre>\n<p>As a result, the invalidations connection will receive a message that invalidates the specified key.</p>\n<pre><code>(Connection 1 -- used for invalidations)\n*3\n$7\nmessage\n$20\n__redis__:invalidate\n*1\n$3\nfoo\n</code></pre>\n<p>The client will check if there are cached keys in this caching slot, and will evict the information that is no longer valid.</p>\n<p>Note that the third element of the Pub/Sub message is not a single key but<br>is a Valkey array with just a single element. Since we send an array, if there<br>are groups of keys to invalidate, we can do that in a single message.<br>In case of a flush (<code>FLUSHALL</code> or <code>FLUSHDB</code>), a <code>null</code> message will be sent.</p>\n<p>A very important thing to understand about client-side caching used with<br>RESP2 and a Pub/Sub connection in order to read the invalidation messages,<br>is that using Pub/Sub is entirely a trick <strong>in order to reuse old client<br>implementations</strong>, but actually the message is not really sent to a channel<br>and received by all the clients subscribed to it. Only the connection we<br>specified in the <code>REDIRECT</code> argument of the <code>CLIENT</code> command will actually<br>receive the Pub/Sub message, making the feature a lot more scalable.</p>\n<p>When RESP3 is used instead, invalidation messages are sent (either in the<br>same connection, or in the secondary connection when redirection is used)<br>as <code>push</code> messages (read the RESP3 specification for more information).</p>\n<h2>What tracking tracks</h2>\n<p>As you can see clients do not need, by default, to tell the server what keys<br>they are caching. Every key that is mentioned in the context of a read-only<br>command is tracked by the server, because it <em>could be cached</em>.</p>\n<p>This has the obvious advantage of not requiring the client to tell the server<br>what it is caching. Moreover in many clients implementations, this is what<br>you want, because a good solution could be to just cache everything that is not<br>already cached, using a first-in first-out approach: we may want to cache a<br>fixed number of objects, every new data we retrieve, we could cache it,<br>discarding the oldest cached object. More advanced implementations may instead<br>drop the least used object or alike.</p>\n<p>Note that anyway if there is write traffic on the server, caching slots<br>will get invalidated during the course of the time. In general when the<br>server assumes that what we get we also cache, we are making a tradeoff:</p>\n<ol>\n<li>It is more efficient when the client tends to cache many things with a policy that welcomes new objects.</li>\n<li>The server will be forced to retain more data about the client keys.</li>\n<li>The client will receive useless invalidation messages about objects it did not cache.</li>\n</ol>\n<p>So there is an alternative described in the next section.</p>\n<h2>Opt-in caching</h2>\n<p>Clients implementations may want to cache only selected keys, and communicate<br>explicitly to the server what they&#39;ll cache and what they will not. This will<br>require more bandwidth when caching new objects, but at the same time reduces<br>the amount of data that the server has to remember and the amount of<br>invalidation messages received by the client.</p>\n<p>In order to do this, tracking must be enabled using the OPTIN option:</p>\n<pre><code>CLIENT TRACKING on REDIRECT 1234 OPTIN\n</code></pre>\n<p>In this mode, by default, keys mentioned in read queries <em>are not supposed to be cached</em>, instead when a client wants to cache something, it must send a special command immediately before the actual command to retrieve the data:</p>\n<pre><code>CLIENT CACHING YES\n+OK\nGET foo\n&quot;bar&quot;\n</code></pre>\n<p>The <code>CACHING</code> command affects the command executed immediately after it,<br>however in case the next command is <code>MULTI</code>, all the commands in the<br>transaction will be tracked. Similarly in case of Lua scripts, all the<br>commands executed by the script will be tracked.</p>\n<h2>Broadcasting mode</h2>\n<p>So far we described the first client-side caching model that Valkey implements.<br>There is another one, called broadcasting, that sees the problem from the<br>point of view of a different tradeoff, does not consume any memory on the<br>server side, but instead sends more invalidation messages to clients.<br>In this mode we have the following main behaviors:</p>\n<ul>\n<li>Clients enable client-side caching using the <code>BCAST</code> option, specifying one or more prefixes using the <code>PREFIX</code> option. For instance: <code>CLIENT TRACKING on REDIRECT 10 BCAST PREFIX object: PREFIX user:</code>. If no prefix is specified at all, the prefix is assumed to be the empty string, so the client will receive invalidation messages for every key that gets modified. Instead if one or more prefixes are used, only keys matching one of the specified prefixes will be sent in the invalidation messages.</li>\n<li>The server does not store anything in the invalidation table. Instead it uses a different <strong>Prefixes Table</strong>, where each prefix is associated to a list of clients.</li>\n<li>No two prefixes can track overlapping parts of the keyspace. For instance, having the prefix &quot;foo&quot; and &quot;foob&quot; would not be allowed, since they would both trigger an invalidation for the key &quot;foobar&quot;. However, just using the prefix &quot;foo&quot; is sufficient.</li>\n<li>Every time a key matching any of the prefixes is modified, all the clients subscribed to that prefix, will receive the invalidation message.</li>\n<li>The server will consume CPU proportional to the number of registered prefixes. If you have just a few, it is hard to see any difference. With a big number of prefixes the CPU cost can become quite large.</li>\n<li>In this mode the server can perform the optimization of creating a single reply for all the clients subscribed to a given prefix, and send the same reply to all. This helps to lower the CPU usage.</li>\n</ul>\n<h2>The NOLOOP option</h2>\n<p>By default client-side tracking will send invalidation messages to the<br>client that modified the key. Sometimes clients want this, since they<br>implement very basic logic that does not involve automatically caching<br>writes locally. However, more advanced clients may want to cache even the<br>writes they are doing in the local in-memory table. In such case receiving<br>an invalidation message immediately after the write is a problem, since it<br>will force the client to evict the value it just cached.</p>\n<p>In this case it is possible to use the <code>NOLOOP</code> option: it works both<br>in normal and broadcasting mode. Using this option, clients are able to<br>tell the server they don&#39;t want to receive invalidation messages for keys<br>that they modified.</p>\n<h2>Avoiding race conditions</h2>\n<p>When implementing client-side caching redirecting the invalidation messages<br>to a different connection, you should be aware that there is a possible<br>race condition. See the following example interaction, where we&#39;ll call<br>the data connection &quot;D&quot; and the invalidation connection &quot;I&quot;:</p>\n<pre><code>[D] client -&gt; server: GET foo\n[I] server -&gt; client: Invalidate foo (somebody else touched it)\n[D] server -&gt; client: &quot;bar&quot; (the reply of &quot;GET foo&quot;)\n</code></pre>\n<p>As you can see, because the reply to the GET was slower to reach the<br>client, we received the invalidation message before the actual data that<br>is already no longer valid. So we&#39;ll keep serving a stale version of the<br>foo key. To avoid this problem, it is a good idea to populate the cache<br>when we send the command with a placeholder:</p>\n<pre><code>Client cache: set the local copy of &quot;foo&quot; to &quot;caching-in-progress&quot;\n[D] client-&gt; server: GET foo.\n[I] server -&gt; client: Invalidate foo (somebody else touched it)\nClient cache: delete &quot;foo&quot; from the local cache.\n[D] server -&gt; client: &quot;bar&quot; (the reply of &quot;GET foo&quot;)\nClient cache: don&#39;t set &quot;bar&quot; since the entry for &quot;foo&quot; is missing.\n</code></pre>\n<p>Such a race condition is not possible when using a single connection for both<br>data and invalidation messages, since the order of the messages is always known<br>in that case.</p>\n<h2>What to do when losing connection with the server</h2>\n<p>Similarly, if we lost the connection with the socket we use in order to<br>get the invalidation messages, we may end with stale data. In order to avoid<br>this problem, we need to do the following things:</p>\n<ol>\n<li>Make sure that if the connection is lost, the local cache is flushed.</li>\n<li>Both when using RESP2 with Pub/Sub, or RESP3, ping the invalidation channel periodically (you can send PING commands even when the connection is in Pub/Sub mode!). If the connection looks broken and we are not able to receive ping backs, after a maximum amount of time, close the connection and flush the cache.</li>\n</ol>\n<h2>What to cache</h2>\n<p>Clients may want to run internal statistics about the number of times<br>a given cached key was actually served in a request, to understand in the<br>future what is good to cache. In general:</p>\n<ul>\n<li>We don&#39;t want to cache many keys that change continuously.</li>\n<li>We don&#39;t want to cache many keys that are requested very rarely.</li>\n<li>We want to cache keys that are requested often and change at a reasonable rate. For an example of key not changing at a reasonable rate, think of a global counter that is continuously <code>INCR</code>emented.</li>\n</ul>\n<p>However simpler clients may just evict data using some random sampling just<br>remembering the last time a given cached value was served, trying to evict<br>keys that were not served recently.</p>\n<h2>Other hints for implementing client libraries</h2>\n<ul>\n<li>Handling TTLs: make sure you also request the key TTL and set the TTL in the local cache if you want to support caching keys with a TTL.</li>\n<li>Putting a max TTL on every key is a good idea, even if it has no TTL. This protects against bugs or connection issues that would make the client have old data in the local copy.</li>\n<li>Limiting the amount of memory used by clients is absolutely needed. There must be a way to evict old keys when new ones are added.</li>\n</ul>\n<h2>Limiting the amount of memory used by Valkey</h2>\n<p>Be sure to configure a suitable value for the maximum number of keys remembered by Valkey or alternatively use the BCAST mode that consumes no memory at all on the Valkey side. Note that the memory consumed by Valkey when BCAST is not used, is proportional both to the number of keys tracked and the number of clients requesting such keys.</p>\n"
      },
      {
        "id": "protocol",
        "topicName": "Serialization protocol specification",
        "description": "Valkey's serialization protocol (RESP) is the wire protocol that clients implement",
        "htmlContent": "<p>To communicate with the Valkey server, Valkey clients use a protocol called REdis Serialization Protocol (RESP).<br>While the protocol was designed for Redis, it&#39;s used by many other client-server software projects.</p>\n<p>RESP is a compromise among the following considerations:</p>\n<ul>\n<li>Simple to implement.</li>\n<li>Fast to parse.</li>\n<li>Human readable.</li>\n</ul>\n<p>RESP can serialize different data types including integers, strings, and arrays.<br>It also features an error-specific type.<br>A client sends a request to the Valkey server as an array of strings.<br>The array&#39;s contents are the command and its arguments that the server should execute.<br>The server&#39;s reply type is command-specific.</p>\n<p>RESP is binary-safe and uses prefixed length to transfer bulk data so it does not require processing bulk data transferred from one process to another.</p>\n<p>RESP is the protocol you should implement in your Valkey client.</p>\n<p><strong>Note:</strong><br>The protocol outlined here is used only for client-server communication.<br><a href=\"cluster-spec.md\">Valkey Cluster</a> uses a different binary protocol for exchanging messages between nodes.</p>\n<h2>RESP versions</h2>\n<p>The first version of the RESP protocol was experimental and was never widely used.</p>\n<p>The next version, RESP2, early became the standard communication method for clients with Redis OSS.</p>\n<p><a href=\"https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md\">RESP3</a> is a superset of RESP2 that mainly aims to make a client author&#39;s life a little bit easier.<br>Redis OSS 6.0 introduced experimental opt-in support of RESP3&#39;s features (excluding streaming strings and streaming aggregates).<br>In addition, the introduction of the <code>HELLO</code> command allows clients to handshake and upgrade the connection&#39;s protocol version (see <a href=\"#client-handshake\">Client handshake</a>).</p>\n<p>Up to and including Redis OSS 7, both RESP2 and RESP3 clients can invoke all core commands.<br>However, commands may return differently typed replies for different protocol versions.</p>\n<p>Future versions of Valkey may change the default protocol version, but it is unlikely that RESP2 will become entirely deprecated.<br>It is possible, however, that new features in upcoming versions will require the use of RESP3.</p>\n<h2>Network layer</h2>\n<p>A client connects to a Valkey server by creating a TCP connection to its port (the default is 6379).</p>\n<p>While RESP is technically non-TCP specific, the protocol is used exclusively with TCP connections (or equivalent stream-oriented connections like Unix sockets) in the context of Valkey.</p>\n<h2>Request-Response model</h2>\n<p>The Valkey server accepts commands composed of different arguments.<br>Then, the server processes the command and sends the reply back to the client.</p>\n<p>This is the simplest model possible; however, there are some exceptions:</p>\n<ul>\n<li>Valkey requests can be <a href=\"#multiple-commands-and-pipelining\">pipelined</a>.<br>Pipelining enables clients to send multiple commands at once and wait for replies later.</li>\n<li>When a RESP2 connection subscribes to a <a href=\"pubsub.md\">Pub/Sub</a> channel, the protocol changes semantics and becomes a <em>push</em> protocol.<br>The client no longer requires sending commands because the server will automatically send new messages to the client (for the channels the client is subscribed to) as soon as they are received.</li>\n<li>The <code>MONITOR</code> command.<br>Invoking the <code>MONITOR</code> command switches the connection to an ad-hoc push mode.<br>The protocol of this mode is not specified but is obvious to parse.</li>\n<li><a href=\"security.md#protected-mode\">Protected mode</a>.<br>Connections opened from a non-loopback address to a Valkey while in protected mode are denied and terminated by the server.<br>Before terminating the connection, Valkey unconditionally sends a <code>-DENIED</code> reply, regardless of whether the client writes to the socket.</li>\n<li>The <a href=\"#pushes\">RESP3 Push type</a>.<br>As the name suggests, a push type allows the server to send out-of-band data to the connection.<br>The server may push data at any time, and the data isn&#39;t necessarily related to specific commands executed by the client.</li>\n<li>When RESP3 is used, the commands <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code> and their pattern and sharded variants,<br>return either an error reply <em>or one or more Push replies, without any regular in-band reply</em>.<br>This is considered a design mistake of these commands but the behaviour is kept for backward compatibility.<br>Clients need to compensate for this behaviour.</li>\n</ul>\n<p>Excluding these exceptions, the Valkey protocol is a simple request-response protocol.</p>\n<h2>RESP protocol description</h2>\n<p>RESP is essentially a serialization protocol that supports several data types.<br>In RESP, the first byte of data determines its type.</p>\n<p>Valkey generally uses RESP as a <a href=\"#request-response-model\">request-response</a> protocol in the following way:</p>\n<ul>\n<li>Clients send commands to a Valkey server as an <a href=\"#arrays\">array</a> of <a href=\"#bulk-strings\">bulk strings</a>.<br>The first (and sometimes also the second) bulk string in the array is the command&#39;s name.<br>Subsequent elements of the array are the arguments for the command.</li>\n<li>The server replies with a RESP type.<br>The reply&#39;s type is determined by the command&#39;s implementation and possibly by the client&#39;s protocol version.</li>\n</ul>\n<p>RESP is a binary protocol that uses control sequences encoded in standard ASCII.<br>The <code>A</code> character, for example, is encoded with the binary byte of value 65.<br>Similarly, the characters CR (<code>\\r</code>), LF (<code>\\n</code>) and SP (<code> </code>) have binary byte values of 13, 10 and 32, respectively.</p>\n<p>The <code>\\r\\n</code> (CRLF) is the protocol&#39;s <em>terminator</em>, which <strong>always</strong> separates its parts.</p>\n<p>The first byte in an RESP-serialized payload always identifies its type.<br>Subsequent bytes constitute the type&#39;s contents.</p>\n<p>We categorize every RESP data type as either <em>simple</em>, <em>bulk</em> or <em>aggregate</em>.</p>\n<p>Simple types are similar to scalars in programming languages that represent plain literal values. Booleans and Integers are such examples.</p>\n<p>RESP strings are either <em>simple</em> or <em>bulk</em>.<br>Simple strings never contain carriage return (<code>\\r</code>) or line feed (<code>\\n</code>) characters.<br>Bulk strings can contain any binary data and may also be referred to as <em>binary</em> or <em>blob</em>.<br>Note that bulk strings may be further encoded and decoded, e.g. with a wide multi-byte encoding, by the client.</p>\n<p>Aggregates, such as Arrays and Maps, can have varying numbers of sub-elements and nesting levels.</p>\n<p>The following table summarizes the RESP data types that Valkey supports:</p>\n<table>\n<thead>\n<tr>\n<th>RESP data type</th>\n<th>Minimal protocol version</th>\n<th>Category</th>\n<th>First byte</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"#simple-strings\">Simple strings</a></td>\n<td>RESP2</td>\n<td>Simple</td>\n<td><code>+</code></td>\n</tr>\n<tr>\n<td><a href=\"#simple-errors\">Simple Errors</a></td>\n<td>RESP2</td>\n<td>Simple</td>\n<td><code>-</code></td>\n</tr>\n<tr>\n<td><a href=\"#integers\">Integers</a></td>\n<td>RESP2</td>\n<td>Simple</td>\n<td><code>:</code></td>\n</tr>\n<tr>\n<td><a href=\"#bulk-strings\">Bulk strings</a></td>\n<td>RESP2</td>\n<td>Aggregate</td>\n<td><code>$</code></td>\n</tr>\n<tr>\n<td><a href=\"#arrays\">Arrays</a></td>\n<td>RESP2</td>\n<td>Aggregate</td>\n<td><code>*</code></td>\n</tr>\n<tr>\n<td><a href=\"#nulls\">Nulls</a></td>\n<td>RESP3</td>\n<td>Simple</td>\n<td><code>_</code></td>\n</tr>\n<tr>\n<td><a href=\"#booleans\">Booleans</a></td>\n<td>RESP3</td>\n<td>Simple</td>\n<td><code>#</code></td>\n</tr>\n<tr>\n<td><a href=\"#doubles\">Doubles</a></td>\n<td>RESP3</td>\n<td>Simple</td>\n<td><code>,</code></td>\n</tr>\n<tr>\n<td><a href=\"#big-numbers\">Big numbers</a></td>\n<td>RESP3</td>\n<td>Simple</td>\n<td><code>(</code></td>\n</tr>\n<tr>\n<td><a href=\"#bulk-errors\">Bulk errors</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>!</code></td>\n</tr>\n<tr>\n<td><a href=\"#verbatim-strings\">Verbatim strings</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>=</code></td>\n</tr>\n<tr>\n<td><a href=\"#maps\">Maps</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>%</code></td>\n</tr>\n<tr>\n<td><a href=\"#sets\">Sets</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>~</code></td>\n</tr>\n<tr>\n<td><a href=\"#pushes\">Pushes</a></td>\n<td>RESP3</td>\n<td>Aggregate</td>\n<td><code>&gt;</code></td>\n</tr>\n</tbody></table>\n<h3>Simple strings</h3>\n<p>Simple strings are encoded as a plus (<code>+</code>) character, followed by a string.<br>The string mustn&#39;t contain a CR (<code>\\r</code>) or LF (<code>\\n</code>) character and is terminated by CRLF (i.e., <code>\\r\\n</code>).</p>\n<p>Simple strings transmit short, non-binary strings with minimal overhead.<br>For example, many Valkey commands reply with just &quot;OK&quot; on success.<br>The encoding of this Simple String is the following 5 bytes:</p>\n<pre><code>+OK\\r\\n\n</code></pre>\n<p>When Valkey replies with a simple string, a client library should return to the caller a string value composed of the first character after the <code>+</code> up to the end of the string, excluding the final CRLF bytes.</p>\n<p>To send binary strings, use <a href=\"#bulk-strings\">bulk strings</a> instead.</p>\n<h3>Simple errors</h3>\n<p>RESP has specific data types for errors.<br>Simple errors, or simply just errors, are similar to <a href=\"#simple-strings\">simple strings</a>, but their first character is the minus (<code>-</code>) character.<br>The difference between simple strings and errors in RESP is that clients should treat errors as exceptions, whereas the string encoded in the error type is the error message itself.</p>\n<p>The basic format is:</p>\n<pre><code>-Error message\\r\\n\n</code></pre>\n<p>Valkey replies with an error only when something goes wrong, for example, when you try to operate against the wrong data type, or when the command does not exist.<br>The client should raise an exception when it receives an Error reply.</p>\n<p>The following are examples of error replies:</p>\n<pre><code>-ERR unknown command &#39;asdf&#39;\n-WRONGTYPE Operation against a key holding the wrong kind of value\n</code></pre>\n<p>The first upper-case word after the <code>-</code>, up to the first space or newline, represents the kind of error returned.<br>This word is called an <em>error prefix</em>.<br>Note that the error prefix is a convention used by Valkey rather than part of the RESP error type.</p>\n<p>For example, in Valkey, <code>ERR</code> is a generic error, whereas <code>WRONGTYPE</code> is a more specific error that implies that the client attempted an operation against the wrong data type.<br>The error prefix allows the client to understand the type of error returned by the server without checking the exact error message.</p>\n<p>A client implementation can return different types of exceptions for various errors, or provide a generic way for trapping errors by directly providing the error name to the caller as a string.</p>\n<p>However, such a feature should not be considered vital as it is rarely useful.<br>Also, simpler client implementations can return a generic error value, such as <code>false</code>.</p>\n<h3>Integers</h3>\n<p>This type is a CRLF-terminated string that represents a signed, base-10, 64-bit integer.</p>\n<p>RESP encodes integers in the following way:</p>\n<pre><code>:[&lt;+|-&gt;]&lt;value&gt;\\r\\n\n</code></pre>\n<ul>\n<li>The colon (<code>:</code>) as the first byte.</li>\n<li>An optional plus (<code>+</code>) or minus (<code>-</code>) as the sign.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the integer&#39;s unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n</ul>\n<p>For example, <code>:0\\r\\n</code> and <code>:1000\\r\\n</code> are integer replies (of zero and one thousand, respectively).</p>\n<p>Many Valkey commands return RESP integers, including <code>INCR</code>, <code>LLEN</code>, and <code>LASTSAVE</code>.<br>An integer, by itself, has no special meaning other than in the context of the command that returned it.<br>For example, it is an incremental number for <code>INCR</code>, a UNIX timestamp for <code>LASTSAVE</code>, and so forth.<br>However, the returned integer is guaranteed to be in the range of a signed 64-bit integer.</p>\n<p>In some cases, integers can represent true and false Boolean values.<br>For instance, <code>SISMEMBER</code> returns 1 for true and 0 for false.</p>\n<p>Other commands, including <code>SADD</code>, <code>SREM</code>, and <code>SETNX</code>, return 1 when the data changes and 0 otherwise.</p>\n<h3>Bulk strings</h3>\n<p>A bulk string represents a single binary string.<br>The string can be of any size, but by default, Valkey limits it to 512 MB (see the <code>proto-max-bulk-len</code> configuration directive).</p>\n<p>RESP encodes bulk strings in the following way:</p>\n<pre><code>$&lt;length&gt;\\r\\n&lt;data&gt;\\r\\n\n</code></pre>\n<ul>\n<li>The dollar sign (<code>$</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the string&#39;s length, in bytes, as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>The data.</li>\n<li>A final CRLF.</li>\n</ul>\n<p>So the string &quot;hello&quot; is encoded as follows:</p>\n<pre><code>$5\\r\\nhello\\r\\n\n</code></pre>\n<p>The empty string&#39;s encoding is:</p>\n<pre><code>$0\\r\\n\\r\\n\n</code></pre>\n<p><a name=\"nil-reply\"></a></p>\n<h3>Arrays</h3>\n<p>Clients send commands to the Valkey server as RESP arrays.<br>Similarly, some Valkey commands that return collections of elements use arrays as their replies.<br>An example is the <code>LRANGE</code> command that returns elements of a list.</p>\n<p>RESP Arrays&#39; encoding uses the following format:</p>\n<pre><code>*&lt;number-of-elements&gt;\\r\\n&lt;element-1&gt;...&lt;element-n&gt;\n</code></pre>\n<ul>\n<li>An asterisk (<code>*</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of elements in the array as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>An additional RESP type for every element of the array.</li>\n</ul>\n<p>So an empty Array is just the following:</p>\n<pre><code>*0\\r\\n\n</code></pre>\n<p>Whereas the encoding of an array consisting of the two bulk strings &quot;hello&quot; and &quot;world&quot; is:</p>\n<pre><code>*2\\r\\n$5\\r\\nhello\\r\\n$5\\r\\nworld\\r\\n\n</code></pre>\n<p>As you can see, after the <code>*&lt;count&gt;CRLF</code> part prefixing the array, the other data types that compose the array are concatenated one after the other.<br>For example, an Array of three integers is encoded as follows:</p>\n<pre><code>*3\\r\\n:1\\r\\n:2\\r\\n:3\\r\\n\n</code></pre>\n<p>Arrays can contain mixed data types.<br>For instance, the following encoding is of a list of four integers and a bulk string:</p>\n<pre><code>*5\\r\\n\n:1\\r\\n\n:2\\r\\n\n:3\\r\\n\n:4\\r\\n\n$5\\r\\n\nhello\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<p>The first line the server sent is <code>*5\\r\\n</code>.<br>This numeric value tells the client that five reply types are about to follow it.<br>Then, every successive reply constitutes an element in the array.</p>\n<p>All of the aggregate RESP types support nesting.<br>For example, a nested array of two arrays is encoded as follows:</p>\n<pre><code>*2\\r\\n\n*3\\r\\n\n:1\\r\\n\n:2\\r\\n\n:3\\r\\n\n*2\\r\\n\n+Hello\\r\\n\n-World\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<p>The above encodes a two-element array.<br>The first element is an array that, in turn, contains three integers (1, 2, 3).<br>The second element is another array containing a simple string and an error.</p>\n<p><strong>Note:</strong><br>In some places, the RESP Array type may be referred to as <em>multi bulk</em>.<br>The two are the same.</p>\n<h3>Nulls</h3>\n<p>The null data type represents non-existent values.</p>\n<p>In RESP3, null is encoded using the underscore (<code>_</code>) character, followed by the CRLF terminator (<code>\\r\\n</code>).<br>Here&#39;s null&#39;s raw RESP encoding:</p>\n<pre><code>_\\r\\n\n</code></pre>\n<p>RESP2 features two specially crafted values for representing null values,<br>known as &quot;null bulk strings&quot; and &quot;null arrays&quot;.<br>This duality has always been a redundancy that added zero semantical value to the protocol itself.<br>The null type, introduced in RESP3, aims to fix this wrong.<br>Clients should handle all these representations of null in the same way.<br>For example, a Ruby library should return <code>nil</code> while a C library should return <code>NULL</code> (or set a special flag in the reply object).</p>\n<h4>Null bulk strings</h4>\n<p>Whereas RESP3 has a dedicated data type for <a href=\"#nulls\">null values</a>, RESP2 has no such type.<br>Instead, due to historical reasons, the representation of null values in RESP2 is via predetermined forms of the <a href=\"#bulk-strings\">bulk strings</a> and <a href=\"#arrays\">arrays</a> types.</p>\n<p>The null bulk string represents a non-existing value.<br>The <code>GET</code> command returns the Null Bulk String when the target key doesn&#39;t exist.</p>\n<p>It is encoded as a bulk string with the length of negative one (-1), like so:</p>\n<pre><code>$-1\\r\\n\n</code></pre>\n<p>A Valkey client should return a nil object when the server replies with a null bulk string rather than the empty string.</p>\n<h4>Null arrays</h4>\n<p>Whereas RESP3 has a dedicated data type for <a href=\"#nulls\">null values</a>, RESP2 has no such type. Instead, due to historical reasons, the representation of null values in RESP2 is via predetermined forms of the <a href=\"#bulk-strings\">Bulk Strings</a> and <a href=\"#arrays\">arrays</a> types.</p>\n<p>Null arrays exist as an alternative way of representing a null value.<br>For instance, when the <code>BLPOP</code> command times out, it returns a null array.</p>\n<p>The encoding of a null array is that of an array with the length of -1, i.e.</p>\n<pre><code>*-1\\r\\n\n</code></pre>\n<p>When Valkey replies with a null array, the client should return a null object rather than an empty array.</p>\n<h4>Null elements in arrays</h4>\n<p>Single elements of an array may be <a href=\"#nulls\">null</a>.<br>This is used in Valkey replies to signal that these elements are missing and not empty strings. This can happen, for example, with the <code>SORT</code> command when used with the <code>GET pattern</code> option<br>if the specified key is missing.</p>\n<p>Here&#39;s an example of an array reply containing a null element, represented as a RESP2 null bulk string:</p>\n<pre><code>*3\\r\\n\n$5\\r\\n\nhello\\r\\n\n$-1\\r\\n\n$5\\r\\n\nworld\\r\\n\n</code></pre>\n<p>Above, the second element is null.<br>The client library should return to its caller something like this:</p>\n<pre><code>[&quot;hello&quot;,nil,&quot;world&quot;]\n</code></pre>\n<h3>Booleans</h3>\n<p>RESP booleans are encoded as follows:</p>\n<pre><code>#&lt;t|f&gt;\\r\\n\n</code></pre>\n<ul>\n<li>The octothorpe character (<code>#</code>) as the first byte.</li>\n<li>A <code>t</code> character for true values, or an <code>f</code> character for false ones.</li>\n<li>The CRLF terminator.</li>\n</ul>\n<h3>Doubles</h3>\n<p>The Double RESP type encodes a double-precision floating point value.<br>Doubles are encoded as follows:</p>\n<pre><code>,[&lt;+|-&gt;]&lt;integral&gt;[.&lt;fractional&gt;][&lt;E|e&gt;[sign]&lt;exponent&gt;]\\r\\n\n</code></pre>\n<ul>\n<li>The comma character (<code>,</code>) as the first byte.</li>\n<li>An optional plus (<code>+</code>) or minus (<code>-</code>) as the sign.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 integral value.</li>\n<li>An optional dot (<code>.</code>), followed by one or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 fractional value.</li>\n<li>An optional capital or lowercase letter E (<code>E</code> or <code>e</code>), followed by an optional plus (<code>+</code>) or minus (<code>-</code>) as the exponent&#39;s sign, ending with one or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 exponent value.</li>\n<li>The CRLF terminator.</li>\n</ul>\n<p>Here&#39;s the encoding of the number 1.23:</p>\n<pre><code>,1.23\\r\\n\n</code></pre>\n<p>Because the fractional part is optional, the integer value of ten (10) can, therefore, be RESP-encoded both as an integer as well as a double:</p>\n<pre><code>:10\\r\\n\n,10\\r\\n\n</code></pre>\n<p>In such cases, the Valkey client should return native integer and double values, respectively, providing that these types are supported by the language of its implementation.</p>\n<p>The positive infinity, negative infinity and NaN values are encoded as follows:</p>\n<pre><code>,inf\\r\\n\n,-inf\\r\\n\n,nan\\r\\n\n</code></pre>\n<p><a name=\"big-number-reply\"></a></p>\n<h3>Big numbers</h3>\n<p>This type can encode integer values outside the range of signed 64-bit integers.</p>\n<p>Big numbers use the following encoding:</p>\n<pre><code>([+|-]&lt;number&gt;\\r\\n\n</code></pre>\n<ul>\n<li>The left parenthesis character (<code>(</code>) as the first byte.</li>\n<li>An optional plus (<code>+</code>) or minus (<code>-</code>) as the sign.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n</ul>\n<p>Example:</p>\n<pre><code>(3492890328409238509324850943850943825024385\\r\\n\n</code></pre>\n<p>Big numbers can be positive or negative but can&#39;t include fractionals.<br>Client libraries written in languages with a big number type should return a big number.<br>When big numbers aren&#39;t supported, the client should return a string and, when possible, signal to the caller that the reply is a big integer (depending on the API used by the client library).</p>\n<h3>Bulk errors</h3>\n<p>This type combines the purpose of <a href=\"#simple-errors\">simple errors</a> with the expressive power of <a href=\"#bulk-strings\">bulk strings</a>.</p>\n<p>It is encoded as:</p>\n<pre><code>!&lt;length&gt;\\r\\n&lt;error&gt;\\r\\n\n</code></pre>\n<ul>\n<li>An exclamation mark (<code>!</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the error&#39;s length, in bytes, as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>The error itself.</li>\n<li>A final CRLF.</li>\n</ul>\n<p>As a convention, the error begins with an uppercase (space-delimited) word that conveys the error message.</p>\n<p>For instance, the error &quot;SYNTAX invalid syntax&quot; is represented by the following protocol encoding:</p>\n<pre><code>!21\\r\\n\nSYNTAX invalid syntax\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<h3>Verbatim strings</h3>\n<p>This type is similar to the <a href=\"#bulk-strings\">bulk string</a>, with the addition of providing a hint about the data&#39;s encoding.</p>\n<p>A verbatim string&#39;s RESP encoding is as follows:</p>\n<pre><code>=&lt;length&gt;\\r\\n&lt;encoding&gt;:&lt;data&gt;\\r\\n\n</code></pre>\n<ul>\n<li>An equal sign (<code>=</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the string&#39;s total length, in bytes, as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>Exactly three (3) bytes represent the data&#39;s encoding.</li>\n<li>The colon (<code>:</code>) character separates the encoding and data.</li>\n<li>The data.</li>\n<li>A final CRLF.</li>\n</ul>\n<p>Example:</p>\n<pre><code>=15\\r\\n\ntxt:Some string\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<p>Some client libraries may ignore the difference between this type and the string type and return a native string in both cases.<br>However, interactive clients, such as command line interfaces (e.g., <a href=\"cli.md\"><code>valkey-cli</code></a>), can use this type and know that their output should be presented to the human user as is and without quoting the string.</p>\n<p>For example, the Valkey command <code>INFO</code> outputs a report that includes newlines.<br>When using RESP3, <code>valkey-cli</code> displays it correctly because it is sent as a Verbatim String reply (with its three bytes being &quot;txt&quot;).<br>When using RESP2, however, the <code>valkey-cli</code> is hard-coded to look for the <code>INFO</code> command to ensure its correct display to the user.</p>\n<h3>Maps</h3>\n<p>The RESP map encodes a collection of key-value tuples, i.e., a dictionary or a hash.</p>\n<p>It is encoded as follows:</p>\n<pre><code>%&lt;number-of-entries&gt;\\r\\n&lt;key-1&gt;&lt;value-1&gt;...&lt;key-n&gt;&lt;value-n&gt;\n</code></pre>\n<ul>\n<li>A percent character (<code>%</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of entries, or key-value tuples, in the map as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>Two additional RESP types for every key and value in the map.</li>\n</ul>\n<p>For example, the following JSON object:</p>\n<pre><code>{\n    &quot;first&quot;: 1,\n    &quot;second&quot;: 2\n}\n</code></pre>\n<p>Can be encoded in RESP like so:</p>\n<pre><code>%2\\r\\n\n+first\\r\\n\n:1\\r\\n\n+second\\r\\n\n:2\\r\\n\n</code></pre>\n<p>(The raw RESP encoding is split into multiple lines for readability).</p>\n<p>Both map keys and values can be any of RESP&#39;s types.</p>\n<p>Valkey clients should return the idiomatic dictionary type that their language provides.<br>However, low-level programming languages (such as C, for example) will likely return an array along with type information that indicates to the caller that it is a dictionary.</p>\n<p><strong>Note:</strong><br>RESP2 doesn&#39;t have a map type.<br>A map in RESP2 is represented by a flat array containing the keys and the values.<br>The first element is a key, followed by the corresponding value, then the next key and so on, like this:<br><code>key1, value1, key2, value2, ...</code>.</p>\n<h3>Sets</h3>\n<p>Sets are somewhat like <a href=\"#arrays\">Arrays</a> but are unordered and should only contain unique elements.</p>\n<p>RESP set&#39;s encoding is:</p>\n<pre><code>~&lt;number-of-elements&gt;\\r\\n&lt;element-1&gt;...&lt;element-n&gt;\n</code></pre>\n<ul>\n<li>A tilde (<code>~</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of elements in the set as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>An additional RESP type for every element of the Set.</li>\n</ul>\n<p>Clients should return the native set type if it is available in their programming language.<br>Alternatively, in the absence of a native set type, an array coupled with type information can be used (in C, for example).</p>\n<p><a name=\"push-event\"></a></p>\n<h3>Pushes</h3>\n<p>RESP&#39;s pushes contain out-of-band data.<br>They are an exception to the protocol&#39;s request-response model and provide a generic <em>push mode</em> for connections.</p>\n<p>Push events are encoded similarly to <a href=\"#arrays\">arrays</a>, differing only in their first byte:</p>\n<pre><code>&gt;&lt;number-of-elements&gt;\\r\\n&lt;element-1&gt;...&lt;element-n&gt;\n</code></pre>\n<ul>\n<li>A greater-than sign (<code>&gt;</code>) as the first byte.</li>\n<li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of elements in the message as an unsigned, base-10 value.</li>\n<li>The CRLF terminator.</li>\n<li>An additional RESP type for every element of the push event.</li>\n</ul>\n<p>Pushed data may precede or follow any of RESP&#39;s data types but never inside them.<br>That means a client won&#39;t find push data in the middle of a map reply, for example.<br>It also means that pushed data may appear before or after a command&#39;s reply, as well as by itself (without calling any command).</p>\n<p>Clients should react to pushes by invoking a callback that implements their handling of the pushed data.</p>\n<h2>Client handshake</h2>\n<p>New RESP connections should begin the session by calling the <code>HELLO</code> command.<br>This practice accomplishes two things:</p>\n<ol>\n<li>It allows servers to be backward compatible with RESP2 versions.<br>  This is needed in Valkey to make the transition to version 3 of the protocol gentler.</li>\n<li>The <code>HELLO</code> command returns information about the server and the protocol that the client can use for different goals.</li>\n</ol>\n<p>The <code>HELLO</code> command has the following high-level syntax:</p>\n<pre><code>HELLO &lt;protocol-version&gt; [optional-arguments]\n</code></pre>\n<p>The first argument of the command is the protocol version we want the connection to be set.<br>By default, the connection starts in RESP2 mode.<br>If we specify a connection version that is too big and unsupported by the server, it should reply with a <code>-NOPROTO</code> error. Example:</p>\n<pre><code>Client: HELLO 4\nServer: -NOPROTO sorry, this protocol version is not supported.\n</code></pre>\n<p>At that point, the client may retry with a lower protocol version.</p>\n<p>Similarly, the client can easily detect a server that is only able to speak RESP2:</p>\n<pre><code>Client: HELLO 3\nServer: -ERR unknown command &#39;HELLO&#39;\n</code></pre>\n<p>The client can then proceed and use RESP2 to communicate with the server.</p>\n<p>Note that even if the protocol&#39;s version is supported, the <code>HELLO</code> command may return an error, perform no action and remain in RESP2 mode.<br>For example, when used with invalid authentication credentials in the command&#39;s optional <code>!AUTH</code> clause:</p>\n<pre><code>Client: HELLO 3 AUTH default mypassword\nServer: -ERR invalid password\n(the connection remains in RESP2 mode)\n</code></pre>\n<p>A successful reply to the <code>HELLO</code> command is a map reply.<br>The information in the reply is partly server-dependent, but certain fields are mandatory for all the RESP3 implementations:</p>\n<ul>\n<li><strong>server</strong>: &quot;redis&quot; (or other software name).</li>\n<li><strong>version</strong>: the server&#39;s version.</li>\n<li><strong>proto</strong>: the highest supported version of the RESP protocol.</li>\n</ul>\n<p>In Valkey&#39; RESP3 implementation, the following fields are also emitted:</p>\n<ul>\n<li><strong>id</strong>: the connection&#39;s identifier (ID).</li>\n<li><strong>mode</strong>: &quot;standalone&quot;, &quot;sentinel&quot; or &quot;cluster&quot;.</li>\n<li><strong>role</strong>: &quot;primary&quot; or &quot;replica&quot;.</li>\n<li><strong>modules</strong>: list of loaded modules as an Array of Bulk Strings.</li>\n</ul>\n<h2>Sending commands to a Valkey server</h2>\n<p>Now that you are familiar with the RESP serialization format, you can use it to help write a Valkey client library.<br>We can further specify how the interaction between the client and the server works:</p>\n<ul>\n<li>A client sends the Valkey server an <a href=\"#arrays\">array</a> consisting of only bulk strings.</li>\n<li>A Valkey server replies to clients, sending any valid RESP data type as a reply.</li>\n</ul>\n<p>So, for example, a typical interaction could be the following.</p>\n<p>The client sends the command <code>LLEN mylist</code> to get the length of the list stored at the key <em>mylist</em>.<br>Then the server replies with an <a href=\"#integers\">integer</a> reply as in the following example (<code>C:</code> is the client, <code>S:</code> the server).</p>\n<pre><code>C: *2\\r\\n\nC: $4\\r\\n\nC: LLEN\\r\\n\nC: $6\\r\\n\nC: mylist\\r\\n\n\nS: :48293\\r\\n\n</code></pre>\n<p>As usual, we separate different parts of the protocol with newlines for simplicity, but the actual interaction is the client sending <code>*2\\r\\n$4\\r\\nLLEN\\r\\n$6\\r\\nmylist\\r\\n</code> as a whole.</p>\n<h2>Multiple commands and pipelining</h2>\n<p>A client can use the same connection to issue multiple commands.<br>Pipelining is supported, so multiple commands can be sent with a single write operation by the client.<br>The client can skip reading replies and continue to send the commands one after the other.<br>All the replies can be read at the end.</p>\n<p>For more information, see <a href=\"pipelining.md\">Pipelining</a>.</p>\n<h2>Inline commands</h2>\n<p>Sometimes you may need to send a command to the Valkey server but only have <code>telnet</code> available.<br>While the Valkey protocol is simple to implement, it is not ideal for interactive sessions, and <code>valkey-cli</code> may not always be available.<br>For this reason, Valkey also accepts commands in the <em>inline command</em> format.</p>\n<p>The following example demonstrates a server/client exchange using an inline command (the server chat starts with <code>S:</code>, the client chat with <code>C:</code>):</p>\n<pre><code>C: PING\nS: +PONG\n</code></pre>\n<p>Here&#39;s another example of an inline command where the server returns an integer:</p>\n<pre><code>C: EXISTS somekey\nS: :0\n</code></pre>\n<p>Basically, to issue an inline command, you write space-separated arguments in a telnet session.<br>Since no command starts with <code>*</code> (the identifying byte of RESP Arrays), Valkey detects this condition and parses your command inline.</p>\n<h2>High-performance parser for the Valkey protocol</h2>\n<p>While the Valkey protocol is human-readable and easy to implement, its implementation can exhibit performance similar to that of a binary protocol.</p>\n<p>RESP uses prefixed lengths to transfer bulk data.<br>That makes scanning the payload for special characters unnecessary (unlike parsing JSON, for example).<br>For the same reason, quoting and escaping the payload isn&#39;t needed.</p>\n<p>Reading the length of aggregate types (for example, bulk strings or arrays) can be processed with code that performs a single operation per character while at the same time scanning for the CR character.</p>\n<p>Example (in C):</p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint main(void) {\n    unsigned char *p = &quot;$123\\r\\n&quot;;\n    int len = 0;\n\n    p++;\n    while(*p != &#39;\\r&#39;) {\n        len = (len*10)+(*p - &#39;0&#39;);\n        p++;\n    }\n\n    /* Now p points at &#39;\\r&#39;, and the len is in bulk_len. */\n    printf(&quot;%d\\n&quot;, len);\n    return 0;\n}\n</code></pre>\n<p>After the first CR is identified, it can be skipped along with the following LF without further processing.<br>Then, the bulk data can be read with a single read operation that doesn&#39;t inspect the payload in any way.<br>Finally, the remaining CR and LF characters are discarded without additional processing.</p>\n<p>While comparable in performance to a binary protocol, the Valkey protocol is significantly more straightforward to implement in most high-level languages, reducing the number of bugs in client software.</p>\n<h2>Tips for Valkey client authors</h2>\n<ul>\n<li>For testing purposes, use <a href=\"lua-api.md#lua-to-resp3-type-conversion\">Lua&#39;s type conversions</a> to have Valkey reply with any RESP2/RESP3 needed.<br>As an example, a RESP3 double can be generated like so:<pre><code>EVAL &quot;return { double = tonumber(ARGV[1]) }&quot; 0 1e0\n</code></pre>\n</li>\n</ul>\n"
      }
    ]
  },
  {
    "title": "DATA TYPES",
    "items": [
      {
        "id": "strings",
        "topicName": "Strings",
        "description": "Introduction to Strings\n",
        "htmlContent": "<p>Strings store sequences of bytes, including text, serialized objects, and binary arrays.<br>As such, strings are the simplest type of value you can associate with<br>a Valkey key.<br>They&#39;re often used for caching, but they support additional functionality that lets you implement counters and perform bitwise operations, too.</p>\n<p>Since Valkey keys are strings, when we use the string type as a value too,<br>we are mapping a string to another string. The string data type is useful<br>for a number of use cases, like caching HTML fragments or pages.</p>\n<pre><code>127.0.0.1:6379&gt; SET bike:1 Deimos\nOK\n127.0.0.1:6379&gt; GET bike:1\n&quot;Deimos&quot;\n</code></pre>\n<p>As you can see using the <code>SET</code> and the <code>GET</code> commands are the way we set<br>and retrieve a string value. Note that <code>SET</code> will replace any existing value<br>already stored into the key, in the case that the key already exists, even if<br>the key is associated with a non-string value. So <code>SET</code> performs an assignment.</p>\n<p>Values can be strings (including binary data) of every kind, for instance you<br>can store a jpeg image inside a value. A value can&#39;t be bigger than 512 MB.</p>\n<p>The <code>SET</code> command has interesting options, that are provided as additional<br>arguments. For example, I may ask <code>SET</code> to fail if the key already exists,<br>or the opposite, that it only succeed if the key already exists:</p>\n<pre><code>127.0.0.1:6379&gt; set bike:1 bike nx\n(nil)\n127.0.0.1:6379&gt; set bike:1 bike xx\nOK\n</code></pre>\n<p>There are a number of other commands for operating on strings. For example<br>the <code>GETSET</code> command sets a key to a new value, returning the old value as the<br>result. You can use this command, for example, if you have a<br>system that increments a Valkey key using <code>INCR</code><br>every time your web site receives a new visitor. You may want to collect this<br>information once every hour, without losing a single increment.<br>You can <code>GETSET</code> the key, assigning it the new value of &quot;0&quot; and reading the<br>old value back.</p>\n<p>The ability to set or retrieve the value of multiple keys in a single<br>command is also useful for reduced latency. For this reason there are<br>the <code>MSET</code> and <code>MGET</code> commands:</p>\n<pre><code>127.0.0.1:6379&gt; mset bike:1 &quot;Deimos&quot; bike:2 &quot;Ares&quot; bike:3 &quot;Vanth&quot;\nOK\n127.0.0.1:6379&gt; mget bike:1 bike:2 bike:3\n1) &quot;Deimos&quot;\n2) &quot;Ares&quot;\n3) &quot;Vanth&quot;\n</code></pre>\n<p>When <code>MGET</code> is used, Valkey returns an array of values.</p>\n<h3>Strings as counters</h3>\n<p>Even if strings are the basic values of Valkey, there are interesting operations<br>you can perform with them. For instance, one is atomic increment:</p>\n<pre><code>127.0.0.1:6379&gt; set total_crashes 0\nOK\n127.0.0.1:6379&gt; incr total_crashes\n(integer) 1\n127.0.0.1:6379&gt; incrby total_crashes 10\n(integer) 11\n</code></pre>\n<p>The <code>INCR</code> command parses the string value as an integer,<br>increments it by one, and finally sets the obtained value as the new value.<br>There are other similar commands like <code>INCRBY</code>,<br><code>DECR</code> and <code>DECRBY</code>. Internally it&#39;s<br>always the same command, acting in a slightly different way.</p>\n<p>What does it mean that INCR is atomic?<br>That even multiple clients issuing INCR against<br>the same key will never enter into a race condition. For instance, it will never<br>happen that client 1 reads &quot;10&quot;, client 2 reads &quot;10&quot; at the same time, both<br>increment to 11, and set the new value to 11. The final value will always be<br>12 and the read-increment-set operation is performed while all the other<br>clients are not executing a command at the same time.</p>\n<h2>Limits</h2>\n<p>By default, a single String can be a maximum of 512 MB.</p>\n<h2>Basic commands</h2>\n<h3>Getting and setting Strings</h3>\n<ul>\n<li><code>SET</code> stores a string value.</li>\n<li><code>SETNX</code> stores a string value only if the key doesn&#39;t already exist. Useful for implementing locks.</li>\n<li><code>GET</code> retrieves a string value.</li>\n<li><code>MGET</code> retrieves multiple string values in a single operation.</li>\n</ul>\n<h3>Managing counters</h3>\n<ul>\n<li><code>INCRBY</code> atomically increments (and decrements when passing a negative number) counters stored at a given key.</li>\n<li>Another command exists for floating point counters: <code>INCRBYFLOAT</code>.</li>\n</ul>\n<h3>Bitwise operations</h3>\n<p>To perform bitwise operations on a string, see the <a href=\"bitmaps.md\">bitmaps data type</a> docs.</p>\n<p>See the <a href=\"../commands/#string\">complete list of string commands</a>.</p>\n<h2>Performance</h2>\n<p>Most string operations are O(1), which means they&#39;re highly efficient.<br>However, be careful with the <code>SUBSTR</code>, <code>GETRANGE</code>, and <code>SETRANGE</code> commands, which can be O(n).<br>These random-access string commands may cause performance issues when dealing with large strings.</p>\n<h2>Alternatives</h2>\n<p>If you&#39;re storing structured data as a serialized string, you may also want to consider Valkey <a href=\"hashes.md\">hashes</a>.</p>\n"
      },
      {
        "id": "lists",
        "topicName": "Lists",
        "description": "Introduction to Lists\n",
        "htmlContent": "<p>Lists are linked lists of string values.<br>Lists are frequently used to:</p>\n<ul>\n<li>Implement stacks and queues.</li>\n<li>Build queue management for background worker systems.</li>\n</ul>\n<h2>Basic commands</h2>\n<ul>\n<li><code>LPUSH</code> adds a new element to the head of a list; <code>RPUSH</code> adds to the tail.</li>\n<li><code>LPOP</code> removes and returns an element from the head of a list; <code>RPOP</code> does the same but from the tails of a list. </li>\n<li><code>LLEN</code> returns the length of a list.</li>\n<li><code>LMOVE</code> atomically moves elements from one list to another.</li>\n<li><code>LTRIM</code> reduces a list to the specified range of elements.</li>\n</ul>\n<h3>Blocking commands</h3>\n<p>Lists support several blocking commands.<br>For example:</p>\n<ul>\n<li><code>BLPOP</code> removes and returns an element from the head of a list.<br>If the list is empty, the command blocks until an element becomes available or until the specified timeout is reached.</li>\n<li><code>BLMOVE</code> atomically moves elements from a source list to a target list.<br>If the source list is empty, the command will block until a new element becomes available.</li>\n</ul>\n<p>See the <a href=\"../commands/#list\">complete series of list commands</a>.</p>\n<h2>Examples</h2>\n<ul>\n<li>Treat a list like a queue (first in, first out):</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; LPUSH bikes:repairs bike:1\n(integer) 1\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:2\n(integer) 2\n127.0.0.1:6379&gt; RPOP bikes:repairs\n&quot;bike:1&quot;\n127.0.0.1:6379&gt; RPOP bikes:repairs\n&quot;bike:2&quot;\n</code></pre>\n<ul>\n<li>Treat a list like a stack (first in, last out):</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; LPUSH bikes:repairs bike:1\n(integer) 1\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:2\n(integer) 2\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:2&quot;\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:1&quot;\n</code></pre>\n<ul>\n<li>Check the length of a list:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; LLEN bikes:repairs\n(integer) 0\n</code></pre>\n<ul>\n<li>Atomically pop an element from one list and push to another:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; LPUSH bikes:repairs bike:1\n(integer) 1\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:2\n(integer) 2\n127.0.0.1:6379&gt; LMOVE bikes:repairs bikes:finished LEFT LEFT\n&quot;bike:2&quot;\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:1&quot;\n127.0.0.1:6379&gt; LRANGE bikes:finished 0 -1\n1) &quot;bike:2&quot;\n</code></pre>\n<ul>\n<li>To limit the length of a list you can call <code>LTRIM</code>:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3 bike:4 bike:5\n(integer) 5\n127.0.0.1:6379&gt; LTRIM bikes:repairs 0 2\nOK\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:1&quot;\n2) &quot;bike:2&quot;\n3) &quot;bike:3&quot;\n</code></pre>\n<h3>What are Lists?</h3>\n<p>To explain the List data type it&#39;s better to start with a little bit of theory,<br>as the term <em>List</em> is often used in an improper way by information technology<br>folks. For instance &quot;Python Lists&quot; are not what the name may suggest (Linked<br>Lists), but rather Arrays (the same data type is called Array in<br>Ruby actually).</p>\n<p>From a very general point of view a List is just a sequence of ordered<br>elements: 10,20,1,2,3 is a list. But the properties of a List implemented using<br>an Array are very different from the properties of a List implemented using a<br><em>Linked List</em>.</p>\n<p>Lists are implemented via Linked Lists. This means that even if you have<br>millions of elements inside a list, the operation of adding a new element in<br>the head or in the tail of the list is performed <em>in constant time</em>. The speed of adding a<br>new element with the <code>LPUSH</code> command to the head of a list with ten<br>elements is the same as adding an element to the head of list with 10<br>million elements.</p>\n<p>What&#39;s the downside? Accessing an element <em>by index</em> is very fast in lists<br>implemented with an Array (constant time indexed access) and not so fast in<br>lists implemented by linked lists (where the operation requires an amount of<br>work proportional to the index of the accessed element).</p>\n<p>Lists are implemented with linked lists because for a database system it<br>is crucial to be able to add elements to a very long list in a very fast way.<br>Another strong advantage, as you&#39;ll see in a moment, is that Lists can be<br>taken at constant length in constant time.</p>\n<p>When fast access to the middle of a large collection of elements is important,<br>there is a different data structure that can be used, called sorted sets.<br>Sorted sets are covered in the <a href=\"sorted-sets.md\">Sorted sets</a> tutorial page.</p>\n<h3>First steps with Lists</h3>\n<p>The <code>LPUSH</code> command adds a new element into a list, on the<br>left (at the head), while the <code>RPUSH</code> command adds a new<br>element into a list, on the right (at the tail). Finally the<br><code>LRANGE</code> command extracts ranges of elements from lists:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1\n(integer) 1\n127.0.0.1:6379&gt; RPUSH bikes:repairs bike:2\n(integer) 2\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:important_bike\n(integer) 3\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:important_bike&quot;\n2) &quot;bike:1&quot;\n3) &quot;bike:2&quot;\n</code></pre>\n<p>Note that <code>LRANGE</code> takes two indexes, the first and the last<br>element of the range to return. Both the indexes can be negative, telling Valkey<br>to start counting from the end: so -1 is the last element, -2 is the<br>penultimate element of the list, and so forth.</p>\n<p>As you can see <code>RPUSH</code> appended the elements on the right of the list, while<br>the final <code>LPUSH</code> appended the element on the left.</p>\n<p>Both commands are <em>variadic commands</em>, meaning that you are free to push<br>multiple elements into a list in a single call:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; LPUSH bikes:repairs bike:important_bike bike:very_important_bike\n127.0.0.1:6379&gt; LRANGE mylist 0 -1\n1) &quot;bike:very_important_bike&quot;\n2) &quot;bike:important_bike&quot;\n3) &quot;bike:1&quot;\n4) &quot;bike:2&quot;\n5) &quot;bike:3&quot;\n</code></pre>\n<p>An important operation defined on Lists is the ability to <em>pop elements</em>.<br>Popping elements is the operation of both retrieving the element from the list,<br>and eliminating it from the list, at the same time. You can pop elements<br>from left and right, similarly to how you can push elements in both sides<br>of the list. We&#39;ll add three elements and pop three elements, so at the end of this<br>sequence of commands the list is empty and there are no more elements to<br>pop:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; RPOP bikes:repairs\n&quot;bike:3&quot;\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:1&quot;\n127.0.0.1:6379&gt; RPOP bikes:repairs\n&quot;bike:2&quot;\n127.0.0.1:6379&gt; RPOP bikes:repairs\n(nil)\n</code></pre>\n<p>Valkey returned a NULL value to signal that there are no elements in the<br>list.</p>\n<h3>Common use cases for lists</h3>\n<p>Lists are useful for a number of tasks, two very representative use cases<br>are the following:</p>\n<ul>\n<li>Remember the latest updates posted by users into a social network.</li>\n<li>Communication between processes, using a consumer-producer pattern where the producer pushes items into a list, and a consumer (usually a <em>worker</em>) consumes those items and executes actions. Valkey has special list commands to make this use case both more reliable and efficient.</li>\n</ul>\n<p>For example both the popular Ruby libraries <a href=\"https://github.com/resque/resque\">resque</a> and<br><a href=\"https://github.com/mperham/sidekiq\">sidekiq</a> use Lists under the hood in order to<br>implement background jobs.</p>\n<p>The popular Twitter social network <a href=\"https://www.infoq.com/presentations/Real-Time-Delivery-Twitter\">takes the latest tweets</a><br>posted by users into Lists.</p>\n<p>To describe a common use case step by step, imagine your home page shows the latest<br>photos published in a photo sharing social network and you want to speedup access.</p>\n<ul>\n<li>Every time a user posts a new photo, we add its ID into a list with <code>LPUSH</code>.</li>\n<li>When users visit the home page, we use <code>LRANGE 0 9</code> in order to get the latest 10 posted items.</li>\n</ul>\n<h3>Capped lists</h3>\n<p>In many use cases we just want to use lists to store the <em>latest items</em>,<br>whatever they are: social network updates, logs, or anything else.</p>\n<p>Valkey allows us to use lists as a capped collection, only remembering the latest<br>N items and discarding all the oldest items using the <code>LTRIM</code> command.</p>\n<p>The <code>LTRIM</code> command is similar to <code>LRANGE</code>, but <strong>instead of displaying the<br>specified range of elements</strong> it sets this range as the new list value. All<br>the elements outside the given range are removed.</p>\n<p>For example, if you&#39;re adding bikes on the end of a list of repairs, but only<br>want to worry about the 3 that have been on the list the longest:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3 bike:4 bike:5\n(integer) 5\n127.0.0.1:6379&gt; LTRIM bikes:repairs 0 2\nOK\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:1&quot;\n2) &quot;bike:2&quot;\n3) &quot;bike:3&quot;\n</code></pre>\n<p>The above <code>LTRIM</code> command tells Valkey to keep just list elements from index<br>0 to 2, everything else will be discarded. This allows for a very simple but<br>useful pattern: doing a List push operation + a List trim operation together<br>to add a new element and discard elements exceeding a limit. Using<br><code>LTRIM</code> with negative indexes can then be used to keep only the 3 most recently added:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3 bike:4 bike:5\n(integer) 5\n127.0.0.1:6379&gt; LTRIM bikes:repairs -3 -1\nOK\n127.0.0.1:6379&gt; LRANGE bikes:repairs 0 -1\n1) &quot;bike:3&quot;\n2) &quot;bike:4&quot;\n3) &quot;bike:5&quot;\n</code></pre>\n<p>The above combination adds new elements and keeps only the 3<br>newest elements into the list. With <code>LRANGE</code> you can access the top items<br>without any need to remember very old data.</p>\n<p>Note: while <code>LRANGE</code> is technically an O(N) command, accessing small ranges<br>towards the head or the tail of the list is a constant time operation.</p>\n<h2>Blocking operations on lists</h2>\n<p>Lists have a special feature that make them suitable to implement queues,<br>and in general as a building block for inter process communication systems:<br>blocking operations.</p>\n<p>Imagine you want to push items into a list with one process, and use<br>a different process in order to actually do some kind of work with those<br>items. This is the usual producer / consumer setup, and can be implemented<br>in the following simple way:</p>\n<ul>\n<li>To push items into the list, producers call <code>LPUSH</code>.</li>\n<li>To extract / process items from the list, consumers call <code>RPOP</code>.</li>\n</ul>\n<p>However it is possible that sometimes the list is empty and there is nothing<br>to process, so <code>RPOP</code> just returns NULL. In this case a consumer is forced to wait<br>some time and retry again with <code>RPOP</code>. This is called <em>polling</em>, and is not<br>a good idea in this context because it has several drawbacks:</p>\n<ol>\n<li>Forces Valkey and clients to process useless commands (all the requests when the list is empty will get no actual work done, they&#39;ll just return NULL).</li>\n<li>Adds a delay to the processing of items, since after a worker receives a NULL, it waits some time. To make the delay smaller, we could wait less between calls to <code>RPOP</code>, with the effect of amplifying problem number 1, i.e. more useless calls to Valkey.</li>\n</ol>\n<p>So Valkey implements commands called <code>BRPOP</code> and <code>BLPOP</code> which are versions<br>of <code>RPOP</code> and <code>LPOP</code> able to block if the list is empty: they&#39;ll return to<br>the caller only when a new element is added to the list, or when a user-specified<br>timeout is reached.</p>\n<p>This is an example of a <code>BRPOP</code> call we could use in the worker:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2\n(integer) 2\n127.0.0.1:6379&gt; BRPOP bikes:repairs 1\n1) &quot;bikes:repairs&quot;\n2) &quot;bike:2&quot;\n127.0.0.1:6379&gt; BRPOP bikes:repairs 1\n1) &quot;bikes:repairs&quot;\n2) &quot;bike:1&quot;\n127.0.0.1:6379&gt; BRPOP bikes:repairs 1\n(nil)\n(2.01s)\n</code></pre>\n<p>It means: &quot;wait for elements in the list <code>bikes:repairs</code>, but return if after 1 second<br>no element is available&quot;.</p>\n<p>Note that you can use 0 as timeout to wait for elements forever, and you can<br>also specify multiple lists and not just one, in order to wait on multiple<br>lists at the same time, and get notified when the first list receives an<br>element.</p>\n<p>A few things to note about <code>BRPOP</code>:</p>\n<ol>\n<li>Clients are served in an ordered way: the first client that blocked waiting for a list, is served first when an element is pushed by some other client, and so forth.</li>\n<li>The return value is different compared to <code>RPOP</code>: it is a two-element array since it also includes the name of the key, because <code>BRPOP</code> and <code>BLPOP</code> are able to block waiting for elements from multiple lists.</li>\n<li>If the timeout is reached, NULL is returned.</li>\n</ol>\n<p>There are more things you should know about lists and blocking ops. We<br>suggest that you read more on the following:</p>\n<ul>\n<li>It is possible to build safer queues or rotating queues using <code>LMOVE</code>.</li>\n<li>There is also a blocking variant of the command, called <code>BLMOVE</code>.</li>\n</ul>\n<h2>Automatic creation and removal of keys</h2>\n<p>So far in our examples we never had to create empty lists before pushing<br>elements, or removing empty lists when they no longer have elements inside.<br>It is Valkey&#39; responsibility to delete keys when lists are left empty, or to create<br>an empty list if the key does not exist and we are trying to add elements<br>to it, for example, with <code>LPUSH</code>.</p>\n<p>This is not specific to lists, it applies to all the Valkey data types<br>composed of multiple elements -- Streams, Sets, Sorted Sets and Hashes.</p>\n<p>Basically we can summarize the behavior with three rules:</p>\n<ol>\n<li>When we add an element to an aggregate data type, if the target key does not exist, an empty aggregate data type is created before adding the element.</li>\n<li>When we remove elements from an aggregate data type, if the value remains empty, the key is automatically destroyed. The Stream data type is the only exception to this rule.</li>\n<li>Calling a read-only command such as <code>LLEN</code> (which returns the length of the list), or a write command removing elements, with an empty key, always produces the same result as if the key is holding an empty aggregate type of the type the command expects to find.</li>\n</ol>\n<p>Examples of rule 1:</p>\n<pre><code>127.0.0.1:6379&gt; DEL new_bikes\n(integer) 0\n127.0.0.1:6379&gt; LPUSH new_bikes bike:1 bike:2 bike:3\n(integer) 3\n</code></pre>\n<p>However we can&#39;t perform operations against the wrong type if the key exists:</p>\n<pre><code>127.0.0.1:6379&gt; SET new_bikes bike:1\nOK\n127.0.0.1:6379&gt; TYPE new_bikes\nstring\n127.0.0.1:6379&gt; LPUSH new_bikes bike:2 bike:3\n(error) WRONGTYPE Operation against a key holding the wrong kind of value\n</code></pre>\n<p>Example of rule 2:</p>\n<pre><code>127.0.0.1:6379&gt; RPUSH bikes:repairs bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; EXISTS bikes:repairs\n(integer) 1\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:3&quot;\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:2&quot;\n127.0.0.1:6379&gt; LPOP bikes:repairs\n&quot;bike:1&quot;\n127.0.0.1:6379&gt; EXISTS bikes:repairs\n(integer) 0\n</code></pre>\n<p>The key no longer exists after all the elements are popped.</p>\n<p>Example of rule 3:</p>\n<pre><code>127.0.0.1:6379&gt; DEL bikes:repairs\n(integer) 0\n127.0.0.1:6379&gt; LLEN bikes:repairs\n(integer) 0\n127.0.0.1:6379&gt; LPOP bikes:repairs\n(nil)\n</code></pre>\n<h2>Limits</h2>\n<p>The max length of a List is 2^32 - 1 (4,294,967,295) elements.</p>\n<h2>Performance</h2>\n<p>List operations that access its head or tail are O(1), which means they&#39;re highly efficient.<br>However, commands that manipulate elements within a list are usually O(n).<br>Examples of these include <code>LINDEX</code>, <code>LINSERT</code>, and <code>LSET</code>.<br>Exercise caution when running these commands, mainly when operating on large lists.</p>\n<h2>Alternatives</h2>\n<p>Consider <a href=\"streams-intro.md\">Streams</a> as an alternative to lists when you need to store and process an indeterminate series of events.</p>\n"
      },
      {
        "id": "sets",
        "topicName": "Sets",
        "description": "Introduction to Sets\n",
        "htmlContent": "<p>A Set is an unordered collection of unique strings (members).<br>You can use Sets to efficiently:</p>\n<ul>\n<li>Track unique items (e.g., track all unique IP addresses accessing a given blog post).</li>\n<li>Represent relations (e.g., the set of all users with a given role).</li>\n<li>Perform common set operations such as intersection, unions, and differences.</li>\n</ul>\n<h2>Basic commands</h2>\n<ul>\n<li><code>SADD</code> adds a new member to a set.</li>\n<li><code>SREM</code> removes the specified member from the set.</li>\n<li><code>SISMEMBER</code> tests a string for set membership.</li>\n<li><code>SINTER</code> returns the set of members that two or more sets have in common (i.e., the intersection).</li>\n<li><code>SCARD</code> returns the size (a.k.a. cardinality) of a set.</li>\n</ul>\n<p>See the <a href=\"../commands/#set\">complete list of set commands</a>.</p>\n<h2>Examples</h2>\n<ul>\n<li>Store the sets of bikes racing in France and the USA. Note that<br>if you add a member that already exists, it will be ignored.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:france bike:1\n(integer) 1\n127.0.0.1:6379&gt; SADD bikes:racing:france bike:1\n(integer) 0\n127.0.0.1:6379&gt; SADD bikes:racing:france bike:2 bike:3\n(integer) 2\n127.0.0.1:6379&gt; SADD bikes:racing:usa bike:1 bike:4\n(integer) 2\n</code></pre>\n<ul>\n<li>Check whether bike:1 or bike:2 are racing in the US.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SISMEMBER bikes:racing:usa bike:1\n(integer) 1\n127.0.0.1:6379&gt; SISMEMBER bikes:racing:usa bike:2\n(integer) 0\n</code></pre>\n<ul>\n<li>Which bikes are competing in both races?</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SINTER bikes:racing:france bikes:racing:usa\n1) &quot;bike:1&quot;\n</code></pre>\n<ul>\n<li>How many bikes are racing in France?</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SCARD bikes:racing:france\n(integer) 3\n</code></pre>\n<h2>Tutorial</h2>\n<p>The <code>SADD</code> command adds new elements to a set. It&#39;s also possible<br>to do a number of other operations against sets like testing if a given element<br>already exists, performing the intersection, union or difference between<br>multiple sets, and so forth.</p>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:france bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; SMEMBERS bikes:racing:france\n1) bike:3\n2) bike:1\n3) bike:2\n</code></pre>\n<p>Here I&#39;ve added three elements to my set and told Valkey to return all the<br>elements. There is no order guarantee with a set. Valkey is free to return the<br>elements in any order at every call.</p>\n<p>Valkey has commands to test for set membership. These commands can be used on single as well as multiple items:</p>\n<pre><code>127.0.0.1:6379&gt; SISMEMBER bikes:racing:france bike:1\n(integer) 1\n127.0.0.1:6379&gt; SMISMEMBER bikes:racing:france bike:2 bike:3 bike:4\n1) (integer) 1\n2) (integer) 1\n3) (integer) 0\n</code></pre>\n<p>We can also find the difference between two sets. For instance, we may want<br>to know which bikes are racing in France but not in the USA:</p>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:usa bike:1 bike:4\n(integer) 2\n127.0.0.1:6379&gt; SDIFF bikes:racing:france bikes:racing:usa\n1) &quot;bike:3&quot;\n2) &quot;bike:2&quot;\n</code></pre>\n<p>There are other non trivial operations that are still easy to implement<br>using the right Valkey commands. For instance we may want a list of all the<br>bikes racing in France, the USA, and some other races. We can do this using<br>the <code>SINTER</code> command, which performs the intersection between different<br>sets. In addition to intersection you can also perform<br>unions, difference, and more. For example<br>if we add a third race we can see some of these commands in action:</p>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:france bike:1 bike:2 bike:3\n(integer) 3\n127.0.0.1:6379&gt; SADD bikes:racing:usa bike:1 bike:4\n(integer) 2\n127.0.0.1:6379&gt; SADD bikes:racing:italy bike:1 bike:2 bike:3 bike:4\n(integer) 4\n127.0.0.1:6379&gt; SINTER bikes:racing:france bikes:racing:usa bikes:racing:italy\n1) &quot;bike:1&quot;\n127.0.0.1:6379&gt; SUNION bikes:racing:france bikes:racing:usa bikes:racing:italy\n1) &quot;bike:2&quot;\n2) &quot;bike:1&quot;\n3) &quot;bike:4&quot;\n4) &quot;bike:3&quot;\n127.0.0.1:6379&gt; SDIFF bikes:racing:france bikes:racing:usa bikes:racing:italy\n(empty array)\n127.0.0.1:6379&gt; SDIFF bikes:racing:france bikes:racing:usa\n1) &quot;bike:3&quot;\n2) &quot;bike:2&quot;\n127.0.0.1:6379&gt; SDIFF bikes:racing:usa bikes:racing:france\n1) &quot;bike:4&quot;\n</code></pre>\n<p>You&#39;ll note that the <code>SDIFF</code> command returns an empty array when the<br>difference between all sets is empty. You&#39;ll also note that the order of sets<br>passed to <code>SDIFF</code> matters, since the difference is not commutative.</p>\n<p>When you want to remove items from a set, you can use the <code>SREM</code> command to<br>remove one or more items from a set, or you can use the <code>SPOP</code> command to<br>remove a random item from a set. You can also <em>return</em> a random item from a<br>set without removing it using the <code>SRANDMEMBER</code> command:</p>\n<pre><code>127.0.0.1:6379&gt; SADD bikes:racing:france bike:1 bike:2 bike:3 bike:4 bike:5\n(integer) 5\n127.0.0.1:6379&gt; SREM bikes:racing:france bike:1\n(integer) 1\n127.0.0.1:6379&gt; SPOP bikes:racing:france\n&quot;bike:3&quot;\n127.0.0.1:6379&gt; SMEMBERS bikes:racing:france\n1) &quot;bike:2&quot;\n2) &quot;bike:4&quot;\n3) &quot;bike:5&quot;\n127.0.0.1:6379&gt; SRANDMEMBER bikes:racing:france\n&quot;bike:2&quot;\n</code></pre>\n<h2>Limits</h2>\n<p>The max size of a Set is 2^32 - 1 (4,294,967,295) members.</p>\n<h2>Performance</h2>\n<p>Most set operations, including adding, removing, and checking whether an item is a set member, are O(1).<br>This means that they&#39;re highly efficient.<br>However, for large sets with hundreds of thousands of members or more, you should exercise caution when running the <code>SMEMBERS</code> command.<br>This command is O(n) and returns the entire set in a single response.<br>As an alternative, consider the <code>SSCAN</code>, which lets you retrieve all members of a set iteratively.</p>\n"
      },
      {
        "id": "sorted-sets",
        "topicName": "Sorted Sets",
        "description": "Introduction to Sorted Sets\n",
        "htmlContent": "<p>A Sorted Set is a collection of unique strings (members) ordered by an associated score.<br>When more than one string has the same score, the strings are ordered lexicographically.<br>Some use cases for sorted sets include:</p>\n<ul>\n<li>Leaderboards. For example, you can use sorted sets to easily maintain  ordered lists of the highest scores in a massive online game.</li>\n<li>Rate limiters. In particular, you can use a sorted set to build a sliding-window rate limiter to prevent excessive API requests.</li>\n</ul>\n<p>You can think of sorted sets as a mix between a Set and<br>a Hash. Like sets, sorted sets are composed of unique, non-repeating<br>string elements, so in some sense a sorted set is a set as well.</p>\n<p>However while elements inside sets are not ordered, every element in<br>a sorted set is associated with a floating point value, called <em>the score</em><br>(this is why the type is also similar to a hash, since every element<br>is mapped to a value).</p>\n<p>Moreover, elements in a sorted set are <em>taken in order</em> (so they are not<br>ordered on request, order is a peculiarity of the data structure used to<br>represent sorted sets). They are ordered according to the following rule:</p>\n<ul>\n<li>If B and A are two elements with a different score, then A &gt; B if A.score is &gt; B.score.</li>\n<li>If B and A have exactly the same score, then A &gt; B if the A string is lexicographically greater than the B string. B and A strings can&#39;t be equal since sorted sets only have unique elements.</li>\n</ul>\n<p>Let&#39;s start with a simple example, we&#39;ll add all our racers and the score they got in the first race:</p>\n<pre><code>127.0.0.1:6379&gt; ZADD racer_scores 10 &quot;Norem&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZADD racer_scores 12 &quot;Castilla&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZADD racer_scores 8 &quot;Sam-Bodden&quot; 10 &quot;Royce&quot; 6 &quot;Ford&quot; 14 &quot;Prickett&quot;\n(integer) 4\n</code></pre>\n<p>As you can see <code>ZADD</code> is similar to <code>SADD</code>, but takes one additional argument<br>(placed before the element to be added) which is the score.<br><code>ZADD</code> is also variadic, so you are free to specify multiple score-value<br>pairs, even if this is not used in the example above.</p>\n<p>With sorted sets it is trivial to return a list of hackers sorted by their<br>birth year because actually <em>they are already sorted</em>.</p>\n<p>Implementation note: Sorted sets are implemented via a<br>dual-ported data structure containing both a skip list and a hash table, so<br>every time we add an element Valkey performs an O(log(N)) operation. That&#39;s<br>good, but when we ask for sorted elements Valkey does not have to do any work at<br>all, it&#39;s already sorted. Note that the <code>ZRANGE</code> order is low to high, while the <code>ZREVRANGE</code> order is high to low:</p>\n<pre><code>127.0.0.1:6379&gt; ZRANGE racer_scores 0 -1\n1) &quot;Ford&quot;\n2) &quot;Sam-Bodden&quot;\n3) &quot;Norem&quot;\n4) &quot;Royce&quot;\n5) &quot;Castilla&quot;\n6) &quot;Prickett&quot;\n127.0.0.1:6379&gt; ZREVRANGE racer_scores 0 -1\n1) &quot;Prickett&quot;\n2) &quot;Castilla&quot;\n3) &quot;Royce&quot;\n4) &quot;Norem&quot;\n5) &quot;Sam-Bodden&quot;\n6) &quot;Ford&quot;\n</code></pre>\n<p>Note: 0 and -1 means from element index 0 to the last element (-1 works<br>here just as it does in the case of the <code>LRANGE</code> command).</p>\n<p>It is possible to return scores as well, using the <code>WITHSCORES</code> argument:</p>\n<pre><code>127.0.0.1:6379&gt; ZRANGE racer_scores 0 -1 withscores\n 1) &quot;Ford&quot;\n 2) &quot;6&quot;\n 3) &quot;Sam-Bodden&quot;\n 4) &quot;8&quot;\n 5) &quot;Norem&quot;\n 6) &quot;10&quot;\n 7) &quot;Royce&quot;\n 8) &quot;10&quot;\n 9) &quot;Castilla&quot;\n10) &quot;12&quot;\n11) &quot;Prickett&quot;\n12) &quot;14&quot;\n</code></pre>\n<h3>Operating on ranges</h3>\n<p>Sorted sets are more powerful than this. They can operate on ranges.<br>Let&#39;s get all the racers with 10 or fewer points. We<br>use the <code>ZRANGEBYSCORE</code> command to do it:</p>\n<pre><code>127.0.0.1:6379&gt; ZRANGEBYSCORE racer_scores -inf 10\n1) &quot;Ford&quot;\n2) &quot;Sam-Bodden&quot;\n3) &quot;Norem&quot;\n4) &quot;Royce&quot;\n</code></pre>\n<p>We asked Valkey to return all the elements with a score between negative<br>infinity and 10 (both extremes are included).</p>\n<p>To remove an element we&#39;d simply call <code>ZREM</code> with the racer&#39;s name.<br>It&#39;s also possible to remove ranges of elements. Let&#39;s remove racer Castilla along with all<br>the racers with strictly fewer than 10 points:</p>\n<pre><code>127.0.0.1:6379&gt; ZREM racer_scores &quot;Castilla&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZREMRANGEBYSCORE racer_scores -inf 9\n(integer) 2\n127.0.0.1:6379&gt; ZRANGE racer_scores 0 -1\n1) &quot;Norem&quot;\n2) &quot;Royce&quot;\n3) &quot;Prickett&quot;\n</code></pre>\n<p><code>ZREMRANGEBYSCORE</code> is perhaps not the best command name,<br>but it can be very useful, and returns the number of removed elements.</p>\n<p>Another extremely useful operation defined for sorted set elements<br>is the get-rank operation. It is possible to ask what is the<br>position of an element in the set of ordered elements.<br>The <code>ZREVRANK</code> command is also available in order to get the rank, considering<br>the elements sorted in a descending way.</p>\n<pre><code>127.0.0.1:6379&gt; ZRANK racer_scores &quot;Norem&quot;\n(integer) 0\n127.0.0.1:6379&gt; ZREVRANK racer_scores &quot;Norem&quot;\n(integer) 3\n</code></pre>\n<h3>Lexicographical scores</h3>\n<p>A family of commands allow<br>getting ranges lexicographically, assuming elements in a sorted set are all<br>inserted with the same identical score. Elements are compared with the C<br><code>memcmp</code> function, so it is guaranteed that there is no collation, and every<br>Valkey instance will reply with the same output.</p>\n<p>The main commands to operate with lexicographical ranges are <code>ZRANGEBYLEX</code>,<br><code>ZREVRANGEBYLEX</code>, <code>ZREMRANGEBYLEX</code> and <code>ZLEXCOUNT</code>.</p>\n<p>For example, let&#39;s add again our list of famous hackers, but this time<br>using a score of zero for all the elements. We&#39;ll see that because of the sorted sets ordering rules, they are already sorted lexicographically. Using <code>ZRANGEBYLEX</code> we can ask for lexicographical ranges:</p>\n<pre><code>127.0.0.1:6379&gt; ZADD racer_scores 0 &quot;Norem&quot; 0 &quot;Sam-Bodden&quot; 0 &quot;Royce&quot; 0 &quot;Castilla&quot; 0 &quot;Prickett&quot; 0 &quot;Ford&quot;\n(integer) 3\n127.0.0.1:6379&gt; ZRANGE racer_scores 0 -1\n1) &quot;Castilla&quot;\n2) &quot;Ford&quot;\n3) &quot;Norem&quot;\n4) &quot;Prickett&quot;\n5) &quot;Royce&quot;\n6) &quot;Sam-Bodden&quot;\n127.0.0.1:6379&gt; ZRANGEBYLEX racer_scores [A [L\n1) &quot;Castilla&quot;\n2) &quot;Ford&quot;\n</code></pre>\n<p>Ranges can be inclusive or exclusive (depending on the first character),<br>also string infinite and minus infinite are specified respectively with<br>the <code>+</code> and <code>-</code> strings. See the documentation for more information.</p>\n<p>This feature is important because it allows us to use sorted sets as a generic<br>index. For example, if you want to index elements by a 128-bit unsigned<br>integer argument, all you need to do is to add elements into a sorted<br>set with the same score (for example 0) but with a 16 byte prefix<br>consisting of <strong>the 128 bit number in big endian</strong>. Since numbers in big<br>endian, when ordered lexicographically (in raw bytes order) are actually<br>ordered numerically as well, you can ask for ranges in the 128 bit space,<br>and get the element&#39;s value discarding the prefix.</p>\n<h2>Updating the score: leaderboards</h2>\n<p>Just a final note about sorted sets before switching to the next topic.<br>Sorted sets&#39; scores can be updated at any time. Just calling <code>ZADD</code> against<br>an element already included in the sorted set will update its score<br>(and position) with O(log(N)) time complexity.  As such, sorted sets are suitable<br>when there are tons of updates.</p>\n<p>Because of this characteristic a common use case is leaderboards.<br>The typical application is a Facebook game where you combine the ability to<br>take users sorted by their high score, plus the get-rank operation, in order<br>to show the top-N users, and the user rank in the leader board (e.g., &quot;you are<br>the #4932 best score here&quot;).</p>\n<h2>Examples</h2>\n<ul>\n<li>There are two ways we can use a sorted set to represent a leaderboard. If we know a racer&#39;s new score, we can update it directly via the <code>ZADD</code> command. However, if we want to add points to an existing score, we can use the <code>ZINCRBY</code> command.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; ZADD racer_scores 100 &quot;Wood&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZADD racer_scores 100 &quot;Henshaw&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZADD racer_scores 150 &quot;Henshaw&quot;\n(integer) 0\n127.0.0.1:6379&gt; ZINCRBY racer_scores 50 &quot;Wood&quot;\n&quot;150&quot;\n127.0.0.1:6379&gt; ZINCRBY racer_scores 50 &quot;Henshaw&quot;\n&quot;200&quot;\n</code></pre>\n<p>You&#39;ll see that <code>ZADD</code> returns 0 when the member already exists (the score is updated), while <code>ZINCRBY</code> returns the new score. The score for racer Henshaw went from 100, was changed to 150 with no regard for what score was there before, and then was incremented by 50 to 200.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>ZADD</code> adds a new member and associated score to a sorted set. If the member already exists, the score is updated.</li>\n<li><code>ZRANGE</code> returns members of a sorted set, sorted within a given range.</li>\n<li><code>ZRANK</code> returns the rank of the provided member, assuming the sorted is in ascending order.</li>\n<li><code>ZREVRANK</code> returns the rank of the provided member, assuming the sorted set is in descending order.</li>\n</ul>\n<p>See the <a href=\"../commands/#sorted-set\">complete list of sorted set commands</a>.</p>\n<h2>Performance</h2>\n<p>Most sorted set operations are O(log(n)), where <em>n</em> is the number of members.</p>\n<p>Exercise some caution when running the <code>ZRANGE</code> command with large returns values (e.g., in the tens of thousands or more).<br>This command&#39;s time complexity is O(log(n) + m), where <em>m</em> is the number of results returned. </p>\n"
      },
      {
        "id": "hashes",
        "topicName": "Hashes",
        "description": "Introduction to Hashes\n",
        "htmlContent": "<p>Hashes are record types structured as collections of field-value pairs.<br>You can use hashes to represent basic objects and to store groupings of counters, among other things.</p>\n<pre><code>127.0.0.1:6379&gt; HSET bike:1 model Deimos brand Ergonom type &#39;Enduro bikes&#39; price 4972\n(integer) 4\n127.0.0.1:6379&gt; HGET bike:1 model\n&quot;Deimos&quot;\n127.0.0.1:6379&gt; HGET bike:1 price\n&quot;4972&quot;\n127.0.0.1:6379&gt; HGETALL bike:1\n1) &quot;model&quot;\n2) &quot;Deimos&quot;\n3) &quot;brand&quot;\n4) &quot;Ergonom&quot;\n5) &quot;type&quot;\n6) &quot;Enduro bikes&quot;\n7) &quot;price&quot;\n8) &quot;4972&quot;\n</code></pre>\n<p>While hashes are handy to represent <em>objects</em>, actually the number of fields you can<br>put inside a hash has no practical limits (other than available memory), so you can use<br>hashes in many different ways inside your application.</p>\n<p>The command <code>HSET</code> sets multiple fields of the hash, while <code>HGET</code> retrieves<br>a single field. <code>HMGET</code> is similar to <code>HGET</code> but returns an array of values:</p>\n<pre><code>127.0.0.1:6379&gt; HMGET bike:1 model price no-such-field\n1) &quot;Deimos&quot;\n2) &quot;4972&quot;\n3) (nil)\n</code></pre>\n<p>There are commands that are able to perform operations on individual fields<br>as well, like <code>HINCRBY</code>:</p>\n<pre><code>127.0.0.1:6379&gt; HINCRBY bike:1 price 100\n(integer) 5072\n127.0.0.1:6379&gt; HINCRBY bike:1 price -100\n(integer) 4972\n</code></pre>\n<p>It is worth noting that small hashes (i.e., a few elements with small values) are<br>encoded in special way in memory that make them very memory efficient.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>HSET</code> sets the value of one or more fields on a hash.</li>\n<li><code>HGET</code> returns the value at a given field.</li>\n<li><code>HMGET</code> returns the values at one or more given fields.</li>\n<li><code>HINCRBY</code> increments the value at a given field by the integer provided.</li>\n</ul>\n<p>See the <a href=\"../commands/#hash\">complete list of hash commands</a>.</p>\n<h2>Examples</h2>\n<ul>\n<li>Store counters for the number of times bike:1 has been ridden, has crashed, or has changed owners:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; HINCRBY bike:1:stats rides 1\n(integer) 1\n127.0.0.1:6379&gt; HINCRBY bike:1:stats rides 1\n(integer) 2\n127.0.0.1:6379&gt; HINCRBY bike:1:stats rides 1\n(integer) 3\n127.0.0.1:6379&gt; HINCRBY bike:1:stats crashes 1\n(integer) 1\n127.0.0.1:6379&gt; HINCRBY bike:1:stats owners 1\n(integer) 1\n127.0.0.1:6379&gt; HGET bike:1:stats rides\n&quot;3&quot;\n127.0.0.1:6379&gt; HMGET bike:1:stats owners crashes\n1) &quot;1&quot;\n2) &quot;1&quot;\n</code></pre>\n<h2>Performance</h2>\n<p>Most Hash commands are O(1).</p>\n<p>A few commands - such as <code>HKEYS</code>, <code>HVALS</code>, and <code>HGETALL</code> - are O(n), where <em>n</em> is the number of field-value pairs.</p>\n<h2>Limits</h2>\n<p>Every hash can store up to 4,294,967,295 (2^32 - 1) field-value pairs.<br>In practice, your hashes are limited only by the overall memory on the VMs hosting your Valkey deployment.</p>\n"
      },
      {
        "id": "streams-intro",
        "topicName": "Streams",
        "description": "Introduction to Streams\n",
        "htmlContent": "<p>A Stream is a data structure that acts like an append-only log but also implements several operations to overcome some of the limits of a typical append-only log. These include random access in O(1) time and complex consumption strategies, such as consumer groups.<br>You can use streams to record and simultaneously syndicate events in real time.<br>Examples of Stream use cases include:</p>\n<ul>\n<li>Event sourcing (e.g., tracking user actions, clicks, etc.)</li>\n<li>Sensor monitoring (e.g., readings from devices in the field) </li>\n<li>Notifications (e.g., storing a record of each user&#39;s notifications in a separate stream)</li>\n</ul>\n<p>Valkey generates a unique ID for each stream entry.<br>You can use these IDs to retrieve their associated entries later or to read and process all subsequent entries in the stream. Note that because these IDs are related to time, the ones shown here may vary and will be different from the IDs you see in your own Valkey instance.</p>\n<p>Streams support several trimming strategies (to prevent streams from growing unbounded) and more than one consumption strategy (see <code>XREAD</code>, <code>XREADGROUP</code>, and <code>XRANGE</code>).</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>XADD</code> adds a new entry to a stream.</li>\n<li><code>XREAD</code> reads one or more entries, starting at a given position and moving forward in time.</li>\n<li><code>XRANGE</code> returns a range of entries between two supplied entry IDs.</li>\n<li><code>XLEN</code> returns the length of a stream.</li>\n</ul>\n<p>See the <a href=\"../commands/#stream\">complete list of stream commands</a>.</p>\n<h2>Examples</h2>\n<ul>\n<li>When our racers pass a checkpoint, we add a stream entry for each racer that includes the racer&#39;s name, speed, position, and location ID:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; XADD race:france * rider Castilla speed 30.2 position 1 location_id 1\n&quot;1692632086370-0&quot;\n127.0.0.1:6379&gt; XADD race:france * rider Norem speed 28.8 position 3 location_id 1\n&quot;1692632094485-0&quot;\n127.0.0.1:6379&gt; XADD race:france * rider Prickett speed 29.7 position 2 location_id 1\n&quot;1692632102976-0&quot;\n</code></pre>\n<ul>\n<li>Read two stream entries starting at ID <code>1692632086370-0</code>:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france 1692632086370-0 + COUNT 2\n1) 1) &quot;1692632086370-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;30.2&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n2) 1) &quot;1692632094485-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Norem&quot;\n      3) &quot;speed&quot;\n      4) &quot;28.8&quot;\n      5) &quot;position&quot;\n      6) &quot;3&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n</code></pre>\n<ul>\n<li>Read up to 100 new stream entries, starting at the end of the stream, and block for up to 300 ms if no entries are being written:</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; XREAD COUNT 100 BLOCK 300 STREAMS race:france $\n(nil)\n</code></pre>\n<h2>Performance</h2>\n<p>Adding an entry to a stream is O(1).<br>Accessing any single entry is O(n), where <em>n</em> is the length of the ID.<br>Since stream IDs are typically short and of a fixed length, this effectively reduces to a constant time lookup.<br>For details on why, note that streams are implemented as <a href=\"https://en.wikipedia.org/wiki/Radix_tree\">radix trees</a>.</p>\n<p>Simply put, Streams provide highly efficient inserts and reads.<br>See each command&#39;s time complexity for the details.</p>\n<h2>Streams basics</h2>\n<p>Streams are an append-only data structure. The fundamental write command, called <code>XADD</code>, appends a new entry to the specified stream.</p>\n<p>Each stream entry consists of one or more field-value pairs, somewhat like a dictionary or a Hash:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:france * rider Castilla speed 29.9 position 1 location_id 2\n&quot;1692632147973-0&quot;\n</code></pre>\n<p>The above call to the <code>XADD</code> command adds an entry <code>rider: Castilla, speed: 29.9, position: 1, location_id: 2</code> to the stream at key <code>race:france</code>, using an auto-generated entry ID, which is the one returned by the command, specifically <code>1692632147973-0</code>. It gets as its first argument the key name <code>race:france</code>, the second argument is the entry ID that identifies every entry inside a stream. However, in this case, we passed <code>*</code> because we want the server to generate a new ID for us. Every new ID will be monotonically increasing, so in more simple terms, every new entry added will have a higher ID compared to all the past entries. Auto-generation of IDs by the server is almost always what you want, and the reasons for specifying an ID explicitly are very rare. We&#39;ll talk more about this later. The fact that each Stream entry has an ID is another similarity with log files, where line numbers, or the byte offset inside the file, can be used in order to identify a given entry. Returning back at our <code>XADD</code> example, after the key name and ID, the next arguments are the field-value pairs composing our stream entry.</p>\n<p>It is possible to get the number of items inside a Stream just using the <code>XLEN</code> command:</p>\n<pre><code>127.0.0.1:6379&gt; XLEN race:france\n(integer) 4\n</code></pre>\n<h3>Entry IDs</h3>\n<p>The entry ID returned by the <code>XADD</code> command, and identifying univocally each entry inside a given stream, is composed of two parts:</p>\n<pre><code>&lt;millisecondsTime&gt;-&lt;sequenceNumber&gt;\n</code></pre>\n<p>The milliseconds time part is actually the local time in the local Valkey node generating the stream ID, however if the current milliseconds time happens to be smaller than the previous entry time, then the previous entry time is used instead, so if a clock jumps backward the monotonically incrementing ID property still holds. The sequence number is used for entries created in the same millisecond. Since the sequence number is 64 bit wide, in practical terms there is no limit to the number of entries that can be generated within the same millisecond.</p>\n<p>The format of such IDs may look strange at first, and the gentle reader may wonder why the time is part of the ID. The reason is that Streams support range queries by ID. Because the ID is related to the time the entry is generated, this gives the ability to query for time ranges basically for free. We will see this soon while covering the <code>XRANGE</code> command.</p>\n<p>If for some reason the user needs incremental IDs that are not related to time but are actually associated to another external system ID, as previously mentioned, the <code>XADD</code> command can take an explicit ID instead of the <code>*</code> wildcard ID that triggers auto-generation, like in the following examples:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:usa 0-1 racer Castilla\n0-1\n127.0.0.1:6379&gt; XADD race:usa 0-2 racer Norem\n0-2\n</code></pre>\n<p>Note that in this case, the minimum ID is 0-1 and that the command will not accept an ID equal or smaller than a previous one:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:usa 0-1 racer Prickett\n(error) ERR The ID specified in XADD is equal or smaller than the target stream top item\n</code></pre>\n<p>If you&#39;re running Redis OSS 7 or later, you can also provide an explicit ID consisting of the milliseconds part only. In this case, the sequence portion of the ID will be automatically generated. To do this, use the syntax below:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:usa 0-* racer Prickett\n0-3\n</code></pre>\n<h2>Getting data from Streams</h2>\n<p>Now we are finally able to append entries in our stream via <code>XADD</code>. However, while appending data to a stream is quite obvious, the way streams can be queried in order to extract data is not so obvious. If we continue with the analogy of the log file, one obvious way is to mimic what we normally do with the Unix command <code>tail -f</code>, that is, we may start to listen in order to get the new messages that are appended to the stream. Note that unlike the blocking list operations of Valkey, where a given element will reach a single client which is blocking in a <em>pop style</em> operation like <code>BLPOP</code>, with streams we want multiple consumers to see the new messages appended to the stream (the same way many <code>tail -f</code> processes can see what is added to a log). Using the traditional terminology we want the streams to be able to <em>fan out</em> messages to multiple clients.</p>\n<p>However, this is just one potential access mode. We could also see a stream in quite a different way: not as a messaging system, but as a <em>time series store</em>. In this case, maybe it&#39;s also useful to get the new messages appended, but another natural query mode is to get messages by ranges of time, or alternatively to iterate the messages using a cursor to incrementally check all the history. This is definitely another useful access mode.</p>\n<p>Finally, if we see a stream from the point of view of consumers, we may want to access the stream in yet another way, that is, as a stream of messages that can be partitioned to multiple consumers that are processing such messages, so that groups of consumers can only see a subset of the messages arriving in a single stream. In this way, it is possible to scale the message processing across different consumers, without single consumers having to process all the messages: each consumer will just get different messages to process. This is basically what Kafka (TM) does with consumer groups. Reading messages via consumer groups is yet another interesting mode of reading from a Stream.</p>\n<p>Streams support all three of the query modes described above via different commands. The next sections will show them all, starting from the simplest and most direct to use: range queries.</p>\n<h3>Querying by range: XRANGE and XREVRANGE</h3>\n<p>To query the stream by range we are only required to specify two IDs, <em>start</em> and <em>end</em>. The range returned will include the elements having start or end as ID, so the range is inclusive. The two special IDs <code>-</code> and <code>+</code> respectively mean the smallest and the greatest ID possible.</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france - +\n1) 1) &quot;1692632086370-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;30.2&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n2) 1) &quot;1692632094485-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Norem&quot;\n      3) &quot;speed&quot;\n      4) &quot;28.8&quot;\n      5) &quot;position&quot;\n      6) &quot;3&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n3) 1) &quot;1692632102976-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Prickett&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.7&quot;\n      5) &quot;position&quot;\n      6) &quot;2&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n4) 1) &quot;1692632147973-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.9&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;2&quot;\n</code></pre>\n<p>Each entry returned is an array of two items: the ID and the list of field-value pairs. We already said that the entry IDs have a relation with the time, because the part at the left of the <code>-</code> character is the Unix time in milliseconds of the local node that created the stream entry, at the moment the entry was created (however note that streams are replicated with fully specified <code>XADD</code> commands, so the replicas will have identical IDs to the primary). This means that I could query a range of time using <code>XRANGE</code>. In order to do so, however, I may want to omit the sequence part of the ID: if omitted, in the start of the range it will be assumed to be 0, while in the end part it will be assumed to be the maximum sequence number available. This way, querying using just two milliseconds Unix times, we get all the entries that were generated in that range of time, in an inclusive way. For instance, if I want to query a two milliseconds period I could use:</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france 1692632086369 1692632086371\n1) 1) &quot;1692632086370-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;30.2&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n</code></pre>\n<p>I have only a single entry in this range. However in real data sets, I could query for ranges of hours, or there could be many items in just two milliseconds, and the result returned could be huge. For this reason, <code>XRANGE</code> supports an optional <strong>COUNT</strong> option at the end. By specifying a count, I can just get the first <em>N</em> items. If I want more, I can get the last ID returned, increment the sequence part by one, and query again. Let&#39;s see this in the following example. Let&#39;s assume that the stream <code>race:france</code> was populated with 4 items. To start my iteration, getting 2 items per command, I start with the full range, but with a count of 2.</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france - + COUNT 2\n1) 1) &quot;1692632086370-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;30.2&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n2) 1) &quot;1692632094485-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Norem&quot;\n      3) &quot;speed&quot;\n      4) &quot;28.8&quot;\n      5) &quot;position&quot;\n      6) &quot;3&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n</code></pre>\n<p>To continue the iteration with the next two items, I have to pick the last ID returned, that is <code>1692632094485-0</code>, and add the prefix <code>(</code> to it. The resulting exclusive range interval, that is <code>(1692632094485-0</code> in this case, can now be used as the new <em>start</em> argument for the next <code>XRANGE</code> call:</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france (1692632094485-0 + COUNT 2\n1) 1) &quot;1692632102976-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Prickett&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.7&quot;\n      5) &quot;position&quot;\n      6) &quot;2&quot;\n      7) &quot;location_id&quot;\n      8) &quot;1&quot;\n2) 1) &quot;1692632147973-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.9&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;2&quot;\n</code></pre>\n<p>Now that we&#39;ve retrieved 4 items out of a stream that only had 4 entries in it, if we try to retrieve more items, we&#39;ll get an empty array:</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:france (1692632147973-0 + COUNT 2\n(empty array)\n</code></pre>\n<p>Since <code>XRANGE</code> complexity is <em>O(log(N))</em> to seek, and then <em>O(M)</em> to return M elements, with a small count the command has a logarithmic time complexity, which means that each step of the iteration is fast. So <code>XRANGE</code> is also the de facto <em>streams iterator</em> and does not require an <strong>XSCAN</strong> command.</p>\n<p>The command <code>XREVRANGE</code> is the equivalent of <code>XRANGE</code> but returning the elements in inverted order, so a practical use for <code>XREVRANGE</code> is to check what is the last item in a Stream:</p>\n<pre><code>127.0.0.1:6379&gt; XREVRANGE race:france + - COUNT 1\n1) 1) &quot;1692632147973-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Castilla&quot;\n      3) &quot;speed&quot;\n      4) &quot;29.9&quot;\n      5) &quot;position&quot;\n      6) &quot;1&quot;\n      7) &quot;location_id&quot;\n      8) &quot;2&quot;\n</code></pre>\n<p>Note that the <code>XREVRANGE</code> command takes the <em>start</em> and <em>stop</em> arguments in reverse order.</p>\n<h2>Listening for new items with XREAD</h2>\n<p>When we do not want to access items by a range in a stream, usually what we want instead is to <em>subscribe</em> to new items arriving to the stream. This concept may appear related to Valkey Pub/Sub, where you subscribe to a channel, or to Valkey blocking lists, where you wait for a key to get new elements to fetch, but there are fundamental differences in the way you consume a stream:</p>\n<ol>\n<li>A stream can have multiple clients (consumers) waiting for data. Every new item, by default, will be delivered to <em>every consumer</em> that is waiting for data in a given stream. This behavior is different than blocking lists, where each consumer will get a different element. However, the ability to <em>fan out</em> to multiple consumers is similar to Pub/Sub.</li>\n<li>While in Pub/Sub messages are <em>fire and forget</em> and are never stored anyway, and while when using blocking lists, when a message is received by the client it is <em>popped</em> (effectively removed) from the list, streams work in a fundamentally different way. All the messages are appended in the stream indefinitely (unless the user explicitly asks to delete entries): different consumers will know what is a new message from its point of view by remembering the ID of the last message received.</li>\n<li>Streams Consumer Groups provide a level of control that Pub/Sub or blocking lists cannot achieve, with different groups for the same stream, explicit acknowledgment of processed items, ability to inspect the pending items, claiming of unprocessed messages, and coherent history visibility for each single client, that is only able to see its private past history of messages.</li>\n</ol>\n<p>The command that provides the ability to listen for new messages arriving into a stream is called <code>XREAD</code>. It&#39;s a bit more complex than <code>XRANGE</code>, so we&#39;ll start showing simple forms, and later the whole command layout will be provided.</p>\n<pre><code>127.0.0.1:6379&gt; XREAD COUNT 2 STREAMS race:france 0\n1) 1) &quot;race:france&quot;\n   2) 1) 1) &quot;1692632086370-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Castilla&quot;\n            3) &quot;speed&quot;\n            4) &quot;30.2&quot;\n            5) &quot;position&quot;\n            6) &quot;1&quot;\n            7) &quot;location_id&quot;\n            8) &quot;1&quot;\n      2) 1) &quot;1692632094485-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Norem&quot;\n            3) &quot;speed&quot;\n            4) &quot;28.8&quot;\n            5) &quot;position&quot;\n            6) &quot;3&quot;\n            7) &quot;location_id&quot;\n            8) &quot;1&quot;\n</code></pre>\n<p>The above is the non-blocking form of <code>XREAD</code>. Note that the <strong>COUNT</strong> option is not mandatory, in fact the only mandatory option of the command is the <strong>STREAMS</strong> option, that specifies a list of keys together with the corresponding maximum ID already seen for each stream by the calling consumer, so that the command will provide the client only with messages with an ID greater than the one we specified.</p>\n<p>In the above command we wrote <code>STREAMS race:france 0</code> so we want all the messages in the Stream <code>race:france</code> having an ID greater than <code>0-0</code>. As you can see in the example above, the command returns the key name, because actually it is possible to call this command with more than one key to read from different streams at the same time. I could write, for instance: <code>STREAMS race:france race:italy 0 0</code>. Note how after the <strong>STREAMS</strong> option we need to provide the key names, and later the IDs. For this reason, the <strong>STREAMS</strong> option must always be the last option.<br>Any other options must come before the <strong>STREAMS</strong> option.</p>\n<p>Apart from the fact that <code>XREAD</code> can access multiple streams at once, and that we are able to specify the last ID we own to just get newer messages, in this simple form the command is not doing something so different compared to <code>XRANGE</code>. However, the interesting part is that we can turn <code>XREAD</code> into a <em>blocking command</em> easily, by specifying the <strong>BLOCK</strong> argument:</p>\n<pre><code>&gt; XREAD BLOCK 0 STREAMS race:france $\n</code></pre>\n<p>Note that in the example above, other than removing <strong>COUNT</strong>, I specified the new <strong>BLOCK</strong> option with a timeout of 0 milliseconds (that means to never timeout). Moreover, instead of passing a normal ID for the stream <code>race:france</code> I passed the special ID <code>$</code>. This special ID means that <code>XREAD</code> should use as last ID the maximum ID already stored in the stream <code>race:france</code>, so that we will receive only <em>new</em> messages, starting from the time we started listening. This is similar to the <code>tail -f</code> Unix command in some way.</p>\n<p>Note that when the <strong>BLOCK</strong> option is used, we do not have to use the special ID <code>$</code>. We can use any valid ID. If the command is able to serve our request immediately without blocking, it will do so, otherwise it will block. Normally if we want to consume the stream starting from new entries, we start with the ID <code>$</code>, and after that we continue using the ID of the last message received to make the next call, and so forth.</p>\n<p>The blocking form of <code>XREAD</code> is also able to listen to multiple Streams, just by specifying multiple key names. If the request can be served synchronously because there is at least one stream with elements greater than the corresponding ID we specified, it returns with the results. Otherwise, the command will block and will return the items of the first stream which gets new data (according to the specified ID).</p>\n<p>Similarly to blocking list operations, blocking stream reads are <em>fair</em> from the point of view of clients waiting for data, since the semantics is FIFO style. The first client that blocked for a given stream will be the first to be unblocked when new items are available.</p>\n<p><code>XREAD</code> has no other options than <strong>COUNT</strong> and <strong>BLOCK</strong>, so it&#39;s a pretty basic command with a specific purpose to attach consumers to one or multiple streams. More powerful features to consume streams are available using the consumer groups API, however reading via consumer groups is implemented by a different command called <code>XREADGROUP</code>, covered in the next section of this guide.</p>\n<h2>Consumer groups</h2>\n<p>When the task at hand is to consume the same stream from different clients, then <code>XREAD</code> already offers a way to <em>fan-out</em> to N clients, potentially also using replicas in order to provide more read scalability. However in certain problems what we want to do is not to provide the same stream of messages to many clients, but to provide a <em>different subset</em> of messages from the same stream to many clients. An obvious case where this is useful is that of messages which are slow to process: the ability to have N different workers that will receive different parts of the stream allows us to scale message processing, by routing different messages to different workers that are ready to do more work.</p>\n<p>In practical terms, if we imagine having three consumers C1, C2, C3, and a stream that contains the messages 1, 2, 3, 4, 5, 6, 7 then what we want is to serve the messages according to the following diagram:</p>\n<pre><code>1 -&gt; C1\n2 -&gt; C2\n3 -&gt; C3\n4 -&gt; C1\n5 -&gt; C2\n6 -&gt; C3\n7 -&gt; C1\n</code></pre>\n<p>In order to achieve this, Valkey uses a concept called <em>consumer groups</em>. It is very important to understand that Valkey consumer groups have nothing to do, from an implementation standpoint, with Kafka (TM) consumer groups. Yet they are similar in functionality, so I decided to keep Kafka&#39;s (TM) terminology, as it originally popularized this idea.</p>\n<p>A consumer group is like a <em>pseudo consumer</em> that gets data from a stream, and actually serves multiple consumers, providing certain guarantees:</p>\n<ol>\n<li>Each message is served to a different consumer so that it is not possible that the same message will be delivered to multiple consumers.</li>\n<li>Consumers are identified, within a consumer group, by a name, which is a case-sensitive string that the clients implementing consumers must choose. This means that even after a disconnect, the stream consumer group retains all the state, since the client will claim again to be the same consumer. However, this also means that it is up to the client to provide a unique identifier.</li>\n<li>Each consumer group has the concept of the <em>first ID never consumed</em> so that, when a consumer asks for new messages, it can provide just messages that were not previously delivered.</li>\n<li>Consuming a message, however, requires an explicit acknowledgment using a specific command. Valkey interprets the acknowledgment as: this message was correctly processed so it can be evicted from the consumer group.</li>\n<li>A consumer group tracks all the messages that are currently pending, that is, messages that were delivered to some consumer of the consumer group, but are yet to be acknowledged as processed. Thanks to this feature, when accessing the message history of a stream, each consumer <em>will only see messages that were delivered to it</em>.</li>\n</ol>\n<p>In a way, a consumer group can be imagined as some <em>amount of state</em> about a stream:</p>\n<pre><code>+----------------------------------------+\n| consumer_group_name: mygroup           |\n| consumer_group_stream: somekey         |\n| last_delivered_id: 1292309234234-92    |\n|                                        |\n| consumers:                             |\n|    &quot;consumer-1&quot; with pending messages  |\n|       1292309234234-4                  |\n|       1292309234232-8                  |\n|    &quot;consumer-42&quot; with pending messages |\n|       ... (and so forth)               |\n+----------------------------------------+\n</code></pre>\n<p>If you see this from this point of view, it is very simple to understand what a consumer group can do, how it is able to just provide consumers with their history of pending messages, and how consumers asking for new messages will just be served with message IDs greater than <code>last_delivered_id</code>. At the same time, if you look at the consumer group as an auxiliary data structure for Streams, it is obvious that a single stream can have multiple consumer groups, that have a different set of consumers. Actually, it is even possible for the same stream to have clients reading without consumer groups via <code>XREAD</code>, and clients reading via <code>XREADGROUP</code> in different consumer groups.</p>\n<p>Now it&#39;s time to zoom in to see the fundamental consumer group commands. They are the following:</p>\n<ul>\n<li><code>XGROUP</code> is used in order to create, destroy and manage consumer groups.</li>\n<li><code>XREADGROUP</code> is used to read from a stream via a consumer group.</li>\n<li><code>XACK</code> is the command that allows a consumer to mark a pending message as correctly processed.</li>\n</ul>\n<h2>Creating a consumer group</h2>\n<p>Assuming I have a key <code>race:france</code> of type stream already existing, in order to create a consumer group I just need to do the following:</p>\n<pre><code>127.0.0.1:6379&gt; XGROUP CREATE race:france france_riders $\nOK\n</code></pre>\n<p>As you can see in the command above when creating the consumer group we have to specify an ID, which in the example is just <code>$</code>. This is needed because the consumer group, among the other states, must have an idea about what message to serve next at the first consumer connecting, that is, what was the <em>last message ID</em> when the group was just created. If we provide <code>$</code> as we did, then only new messages arriving in the stream from now on will be provided to the consumers in the group. If we specify <code>0</code> instead the consumer group will consume <em>all</em> the messages in the stream history to start with. Of course, you can specify any other valid ID. What you know is that the consumer group will start delivering messages that are greater than the ID you specify. Because <code>$</code> means the current greatest ID in the stream, specifying <code>$</code> will have the effect of consuming only new messages.</p>\n<p><code>XGROUP CREATE</code> also supports creating the stream automatically, if it doesn&#39;t exist, using the optional <code>MKSTREAM</code> subcommand as the last argument:</p>\n<pre><code>127.0.0.1:6379&gt; XGROUP CREATE race:italy italy_riders $ MKSTREAM\nOK\n</code></pre>\n<p>Now that the consumer group is created we can immediately try to read messages via the consumer group using the <code>XREADGROUP</code> command. We&#39;ll read from consumers, that we will call Alice and Bob, to see how the system will return different messages to Alice or Bob.</p>\n<p><code>XREADGROUP</code> is very similar to <code>XREAD</code> and provides the same <strong>BLOCK</strong> option, otherwise it is a synchronous command. However there is a <em>mandatory</em> option that must be always specified, which is <strong>GROUP</strong> and has two arguments: the name of the consumer group, and the name of the consumer that is attempting to read. The option <strong>COUNT</strong> is also supported and is identical to the one in <code>XREAD</code>.</p>\n<p>We&#39;ll add riders to the race:italy stream and try reading something using the consumer group:<br>Note: <em>here rider is the field name, and the name is the associated value. Remember that stream items are small dictionaries.</em></p>\n<pre><code>127.0.0.1:6379&gt; XADD race:italy * rider Castilla\n&quot;1692632639151-0&quot;\n127.0.0.1:6379&gt; XADD race:italy * rider Royce\n&quot;1692632647899-0&quot;\n127.0.0.1:6379&gt; XADD race:italy * rider Sam-Bodden\n&quot;1692632662819-0&quot;\n127.0.0.1:6379&gt; XADD race:italy * rider Prickett\n&quot;1692632670501-0&quot;\n127.0.0.1:6379&gt; XADD race:italy * rider Norem\n&quot;1692632678249-0&quot;\n127.0.0.1:6379&gt; XREADGROUP GROUP italy_riders Alice COUNT 1 STREAMS race:italy &gt;\n1) 1) &quot;race:italy&quot;\n   2) 1) 1) &quot;1692632639151-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Castilla&quot;\n</code></pre>\n<p><code>XREADGROUP</code> replies are just like <code>XREAD</code> replies. Note however the <code>GROUP &lt;group-name&gt; &lt;consumer-name&gt;</code> provided above. It states that I want to read from the stream using the consumer group <code>mygroup</code> and I&#39;m the consumer <code>Alice</code>. Every time a consumer performs an operation with a consumer group, it must specify its name, uniquely identifying this consumer inside the group.</p>\n<p>There is another very important detail in the command line above, after the mandatory <strong>STREAMS</strong> option the ID requested for the key <code>race:italy</code> is the special ID <code>&gt;</code>. This special ID is only valid in the context of consumer groups, and it means: <strong>messages never delivered to other consumers so far</strong>.</p>\n<p>This is almost always what you want, however it is also possible to specify a real ID, such as <code>0</code> or any other valid ID, in this case, however, what happens is that we request from <code>XREADGROUP</code> to just provide us with the <strong>history of pending messages</strong>, and in such case, will never see new messages in the group. So basically <code>XREADGROUP</code> has the following behavior based on the ID we specify:</p>\n<ul>\n<li>If the ID is the special ID <code>&gt;</code> then the command will return only new messages never delivered to other consumers so far, and as a side effect, will update the consumer group&#39;s <em>last ID</em>.</li>\n<li>If the ID is any other valid numerical ID, then the command will let us access our <em>history of pending messages</em>. That is, the set of messages that were delivered to this specified consumer (identified by the provided name), and never acknowledged so far with <code>XACK</code>.</li>\n</ul>\n<p>We can test this behavior immediately specifying an ID of 0, without any <strong>COUNT</strong> option: we&#39;ll just see the only pending message, that is, the one about Castilla:</p>\n<pre><code>127.0.0.1:6379&gt; XREADGROUP GROUP italy_riders Alice STREAMS race:italy 0\n1) 1) &quot;race:italy&quot;\n   2) 1) 1) &quot;1692632639151-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Castilla&quot;\n</code></pre>\n<p>However, if we acknowledge the message as processed, it will no longer be part of the pending messages history, so the system will no longer report anything:</p>\n<pre><code>127.0.0.1:6379&gt; XACK race:italy italy_riders 1692632639151-0\n(integer) 1\n127.0.0.1:6379&gt; XREADGROUP GROUP italy_riders Alice STREAMS race:italy 0\n1) 1) &quot;race:italy&quot;\n   2) (empty array)\n</code></pre>\n<p>Don&#39;t worry if you yet don&#39;t know how <code>XACK</code> works, the idea is just that processed messages are no longer part of the history that we can access.</p>\n<p>Now it&#39;s Bob&#39;s turn to read something:</p>\n<pre><code>127.0.0.1:6379&gt; XREADGROUP GROUP italy_riders Bob COUNT 2 STREAMS race:italy &gt;\n1) 1) &quot;race:italy&quot;\n   2) 1) 1) &quot;1692632647899-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Royce&quot;\n      2) 1) &quot;1692632662819-0&quot;\n         2) 1) &quot;rider&quot;\n            2) &quot;Sam-Bodden&quot;\n</code></pre>\n<p>Bob asked for a maximum of two messages and is reading via the same group <code>mygroup</code>. So what happens is that Valkey reports just <em>new</em> messages. As you can see the &quot;Castilla&quot; message is not delivered, since it was already delivered to Alice, so Bob gets Royce and Sam-Bodden and so forth.</p>\n<p>This way Alice, Bob, and any other consumer in the group, are able to read different messages from the same stream, to read their history of yet to process messages, or to mark messages as processed. This allows creating different topologies and semantics for consuming messages from a stream.</p>\n<p>There are a few things to keep in mind:</p>\n<ul>\n<li>Consumers are auto-created the first time they are mentioned, no need for explicit creation.</li>\n<li>Even with <code>XREADGROUP</code> you can read from multiple keys at the same time, however for this to work, you need to create a consumer group with the same name in every stream. This is not a common need, but it is worth mentioning that the feature is technically available.</li>\n<li><code>XREADGROUP</code> is a <em>write command</em> because even if it reads from the stream, the consumer group is modified as a side effect of reading, so it can only be called on primary instances.</li>\n</ul>\n<p>An example of a consumer implementation, using consumer groups, written in the Ruby language could be the following. The Ruby code is aimed to be readable by virtually any experienced programmer, even if they do not know Ruby:</p>\n<pre><code class=\"language-ruby\">require &#39;redis&#39;\n\nif ARGV.length == 0\n    puts &quot;Please specify a consumer name&quot;\n    exit 1\nend\n\nConsumerName = ARGV[0]\nGroupName = &quot;mygroup&quot;\nr = Redis.new\n\ndef process_message(id,msg)\n    puts &quot;[#{ConsumerName}] #{id} = #{msg.inspect}&quot;\nend\n\n$lastid = &#39;0-0&#39;\n\nputs &quot;Consumer #{ConsumerName} starting...&quot;\ncheck_backlog = true\nwhile true\n    # Pick the ID based on the iteration: the first time we want to\n    # read our pending messages, in case we crashed and are recovering.\n    # Once we consumed our history, we can start getting new messages.\n    if check_backlog\n        myid = $lastid\n    else\n        myid = &#39;&gt;&#39;\n    end\n\n    items = r.xreadgroup(&#39;GROUP&#39;,GroupName,ConsumerName,&#39;BLOCK&#39;,&#39;2000&#39;,&#39;COUNT&#39;,&#39;10&#39;,&#39;STREAMS&#39;,:my_stream_key,myid)\n\n    if items == nil\n        puts &quot;Timeout!&quot;\n        next\n    end\n\n    # If we receive an empty reply, it means we were consuming our history\n    # and that the history is now empty. Let&#39;s start to consume new messages.\n    check_backlog = false if items[0][1].length == 0\n\n    items[0][1].each{|i|\n        id,fields = i\n\n        # Process the message\n        process_message(id,fields)\n\n        # Acknowledge the message as processed\n        r.xack(:my_stream_key,GroupName,id)\n\n        $lastid = id\n    }\nend\n</code></pre>\n<p>As you can see the idea here is to start by consuming the history, that is, our list of pending messages. This is useful because the consumer may have crashed before, so in the event of a restart we want to re-read messages that were delivered to us without getting acknowledged. Note that we might process a message multiple times or one time (at least in the case of consumer failures, but there are also the limits of Valkey persistence and replication involved, see the specific section about this topic).</p>\n<p>Once the history was consumed, and we get an empty list of messages, we can switch to using the <code>&gt;</code> special ID in order to consume new messages.</p>\n<h2>Recovering from permanent failures</h2>\n<p>The example above allows us to write consumers that participate in the same consumer group, each taking a subset of messages to process, and when recovering from failures re-reading the pending messages that were delivered just to them. However in the real world consumers may permanently fail and never recover. What happens to the pending messages of the consumer that never recovers after stopping for any reason?</p>\n<p>Valkey consumer groups offer a feature that is used in these situations in order to <em>claim</em> the pending messages of a given consumer so that such messages will change ownership and will be re-assigned to a different consumer. The feature is very explicit. A consumer has to inspect the list of pending messages, and will have to claim specific messages using a special command, otherwise the server will leave the messages pending forever and assigned to the old consumer. In this way different applications can choose if to use such a feature or not, and exactly how to use it.</p>\n<p>The first step of this process is just a command that provides observability of pending entries in the consumer group and is called <code>XPENDING</code>.<br>This is a read-only command which is always safe to call and will not change ownership of any message.<br>In its simplest form, the command is called with two arguments, which are the name of the stream and the name of the consumer group.</p>\n<pre><code>127.0.0.1:6379&gt; XPENDING race:italy italy_riders\n1) (integer) 2\n2) &quot;1692632647899-0&quot;\n3) &quot;1692632662819-0&quot;\n4) 1) 1) &quot;Bob&quot;\n      2) &quot;2&quot;\n</code></pre>\n<p>When called in this way, the command outputs the total number of pending messages in the consumer group (two in this case), the lower and higher message ID among the pending messages, and finally a list of consumers and the number of pending messages they have.<br>We have only Bob with two pending messages because the single message that Alice requested was acknowledged using <code>XACK</code>.</p>\n<p>We can ask for more information by giving more arguments to <code>XPENDING</code>, because the full command signature is the following:</p>\n<pre><code>XPENDING &lt;key&gt; &lt;groupname&gt; [[IDLE &lt;min-idle-time&gt;] &lt;start-id&gt; &lt;end-id&gt; &lt;count&gt; [&lt;consumer-name&gt;]]\n</code></pre>\n<p>By providing a start and end ID (that can be just <code>-</code> and <code>+</code> as in <code>XRANGE</code>) and a count to control the amount of information returned by the command, we are able to know more about the pending messages. The optional final argument, the consumer name, is used if we want to limit the output to just messages pending for a given consumer, but won&#39;t use this feature in the following example.</p>\n<pre><code>127.0.0.1:6379&gt; XPENDING race:italy italy_riders - + 10\n1) 1) &quot;1692632647899-0&quot;\n   2) &quot;Bob&quot;\n   3) (integer) 74642\n   4) (integer) 1\n2) 1) &quot;1692632662819-0&quot;\n   2) &quot;Bob&quot;\n   3) (integer) 74642\n   4) (integer) 1\n</code></pre>\n<p>Now we have the details for each message: the ID, the consumer name, the <em>idle time</em> in milliseconds, which is how many milliseconds have passed since the last time the message was delivered to some consumer, and finally the number of times that a given message was delivered.<br>We have two messages from Bob, and they are idle for 60000+ milliseconds, about a minute.</p>\n<p>Note that nobody prevents us from checking what the first message content was by just using <code>XRANGE</code>.</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:italy 1692632647899-0 1692632647899-0\n1) 1) &quot;1692632647899-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Royce&quot;\n</code></pre>\n<p>We have just to repeat the same ID twice in the arguments. Now that we have some ideas, Alice may decide that after 1 minute of not processing messages, Bob will probably not recover quickly, and it&#39;s time to <em>claim</em> such messages and resume the processing in place of Bob. To do so, we use the <code>XCLAIM</code> command.</p>\n<p>This command is very complex and full of options in its full form, since it is used for replication of consumer groups changes, but we&#39;ll use just the arguments that we need normally. In this case it is as simple as:</p>\n<pre><code>XCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; &lt;min-idle-time&gt; &lt;ID-1&gt; &lt;ID-2&gt; ... &lt;ID-N&gt;\n</code></pre>\n<p>Basically we say, for this specific key and group, I want that the message IDs specified will change ownership, and will be assigned to the specified consumer name <code>&lt;consumer&gt;</code>. However, we also provide a minimum idle time, so that the operation will only work if the idle time of the mentioned messages is greater than the specified idle time. This is useful because maybe two clients are retrying to claim a message at the same time:</p>\n<pre><code>Client 1: XCLAIM race:italy italy_riders Alice 60000 1692632647899-0\nClient 2: XCLAIM race:italy italy_riders Lora 60000 1692632647899-0\n</code></pre>\n<p>However, as a side effect, claiming a message will reset its idle time and will increment its number of deliveries counter, so the second client will fail claiming it. In this way we avoid trivial re-processing of messages (even if in the general case you cannot obtain exactly once processing).</p>\n<p>This is the result of the command execution:</p>\n<pre><code>127.0.0.1:6379&gt; XCLAIM race:italy italy_riders Alice 60000 1692632647899-0\n1) 1) &quot;1692632647899-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Royce&quot;\n</code></pre>\n<p>The message was successfully claimed by Alice, who can now process the message and acknowledge it, and move things forward even if the original consumer is not recovering.</p>\n<p>It is clear from the example above that as a side effect of successfully claiming a given message, the <code>XCLAIM</code> command also returns it. However this is not mandatory. The <strong>JUSTID</strong> option can be used in order to return just the IDs of the message successfully claimed. This is useful if you want to reduce the bandwidth used between the client and the server (and also the performance of the command) and you are not interested in the message because your consumer is implemented in a way that it will rescan the history of pending messages from time to time.</p>\n<p>Claiming may also be implemented by a separate process: one that just checks the list of pending messages, and assigns idle messages to consumers that appear to be active. Active consumers can be obtained using one of the observability features of Streams. This is the topic of the next section.</p>\n<h2>Automatic claiming</h2>\n<p>The <code>XAUTOCLAIM</code> command, added in Redis OSS 6.2, implements the claiming process that we&#39;ve described above.<br><code>XPENDING</code> and <code>XCLAIM</code> provide the basic building blocks for different types of recovery mechanisms.<br>This command optimizes the generic process by having Valkey manage it and offers a simple solution for most recovery needs.</p>\n<p><code>XAUTOCLAIM</code> identifies idle pending messages and transfers ownership of them to a consumer.<br>The command&#39;s signature looks like this:</p>\n<pre><code>XAUTOCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; &lt;min-idle-time&gt; &lt;start&gt; [COUNT count] [JUSTID]\n</code></pre>\n<p>So, in the example above, I could have used automatic claiming to claim a single message like this:</p>\n<pre><code>127.0.0.1:6379&gt; XAUTOCLAIM race:italy italy_riders Alice 60000 0-0 COUNT 1\n1) &quot;0-0&quot;\n2) 1) 1) &quot;1692632662819-0&quot;\n      2) 1) &quot;rider&quot;\n         2) &quot;Sam-Bodden&quot;\n</code></pre>\n<p>Like <code>XCLAIM</code>, the command replies with an array of the claimed messages, but it also returns a stream ID that allows iterating the pending entries.<br>The stream ID is a cursor, and I can use it in my next call to continue in claiming idle pending messages:</p>\n<pre><code>127.0.0.1:6379&gt; XAUTOCLAIM race:italy italy_riders Lora 60000 (1692632662819-0 COUNT 1\n1) &quot;1692632662819-0&quot;\n2) 1) 1) &quot;1692632647899-0&quot;\n      2) 1) &quot;rider&quot;\n         2) &quot;Royce&quot;\n</code></pre>\n<p>When <code>XAUTOCLAIM</code> returns the &quot;0-0&quot; stream ID as a cursor, that means that it reached the end of the consumer group pending entries list.<br>That doesn&#39;t mean that there are no new idle pending messages, so the process continues by calling <code>XAUTOCLAIM</code> from the beginning of the stream.</p>\n<h2>Claiming and the delivery counter</h2>\n<p>The counter that you observe in the <code>XPENDING</code> output is the number of deliveries of each message. The counter is incremented in two ways: when a message is successfully claimed via <code>XCLAIM</code> or when an <code>XREADGROUP</code> call is used in order to access the history of pending messages.</p>\n<p>When there are failures, it is normal that messages will be delivered multiple times, but eventually they usually get processed and acknowledged. However there might be a problem processing some specific message, because it is corrupted or crafted in a way that triggers a bug in the processing code. In such a case what happens is that consumers will continuously fail to process this particular message. Because we have the counter of the delivery attempts, we can use that counter to detect messages that for some reason are not processable. So once the deliveries counter reaches a given large number that you chose, it is probably wiser to put such messages in another stream and send a notification to the system administrator. This is basically the way that Streams implements the <em>dead letter</em> concept.</p>\n<h2>Streams observability</h2>\n<p>Messaging systems that lack observability are very hard to work with. Not knowing who is consuming messages, what messages are pending, the set of consumer groups active in a given stream, makes everything opaque. For this reason, Streams and consumer groups have different ways to observe what is happening. We already covered <code>XPENDING</code>, which allows us to inspect the list of messages that are under processing at a given moment, together with their idle time and number of deliveries.</p>\n<p>However we may want to do more than that, and the <code>XINFO</code> command is an observability interface that can be used with sub-commands in order to get information about streams or consumer groups.</p>\n<p>This command uses subcommands in order to show different information about the status of the stream and its consumer groups. For instance <strong>XINFO STREAM <key></strong> reports information about the stream itself.</p>\n<pre><code>127.0.0.1:6379&gt; XINFO STREAM race:italy\n 1) &quot;length&quot;\n 2) (integer) 5\n 3) &quot;radix-tree-keys&quot;\n 4) (integer) 1\n 5) &quot;radix-tree-nodes&quot;\n 6) (integer) 2\n 7) &quot;last-generated-id&quot;\n 8) &quot;1692632678249-0&quot;\n 9) &quot;groups&quot;\n10) (integer) 1\n11) &quot;first-entry&quot;\n12) 1) &quot;1692632639151-0&quot;\n    2) 1) &quot;rider&quot;\n       2) &quot;Castilla&quot;\n13) &quot;last-entry&quot;\n14) 1) &quot;1692632678249-0&quot;\n    2) 1) &quot;rider&quot;\n       2) &quot;Norem&quot;\n</code></pre>\n<p>The output shows information about how the stream is encoded internally, and also shows the first and last message in the stream. Another piece of information available is the number of consumer groups associated with this stream. We can dig further asking for more information about the consumer groups.</p>\n<pre><code>127.0.0.1:6379&gt; XINFO GROUPS race:italy\n1) 1) &quot;name&quot;\n   2) &quot;italy_riders&quot;\n   3) &quot;consumers&quot;\n   4) (integer) 3\n   5) &quot;pending&quot;\n   6) (integer) 2\n   7) &quot;last-delivered-id&quot;\n   8) &quot;1692632662819-0&quot;\n</code></pre>\n<p>As you can see in this and in the previous output, the <code>XINFO</code> command outputs a sequence of field-value items. Because it is an observability command this allows the human user to immediately understand what information is reported, and allows the command to report more information in the future by adding more fields without breaking compatibility with older clients. Other commands that must be more bandwidth efficient, like <code>XPENDING</code>, just report the information without the field names.</p>\n<p>The output of the example above, where the <strong>GROUPS</strong> subcommand is used, should be clear observing the field names. We can check in more detail the state of a specific consumer group by checking the consumers that are registered in the group.</p>\n<pre><code>127.0.0.1:6379&gt; XINFO CONSUMERS race:italy italy_riders\n1) 1) &quot;name&quot;\n   2) &quot;Alice&quot;\n   3) &quot;pending&quot;\n   4) (integer) 1\n   5) &quot;idle&quot;\n   6) (integer) 177546\n2) 1) &quot;name&quot;\n   2) &quot;Bob&quot;\n   3) &quot;pending&quot;\n   4) (integer) 0\n   5) &quot;idle&quot;\n   6) (integer) 424686\n3) 1) &quot;name&quot;\n   2) &quot;Lora&quot;\n   3) &quot;pending&quot;\n   4) (integer) 1\n   5) &quot;idle&quot;\n   6) (integer) 72241\n</code></pre>\n<p>In case you do not remember the syntax of the command, just ask the command itself for help:</p>\n<pre><code>&gt; XINFO HELP\n1) XINFO &lt;subcommand&gt; [&lt;arg&gt; [value] [opt] ...]. Subcommands are:\n2) CONSUMERS &lt;key&gt; &lt;groupname&gt;\n3)     Show consumers of &lt;groupname&gt;.\n4) GROUPS &lt;key&gt;\n5)     Show the stream consumer groups.\n6) STREAM &lt;key&gt; [FULL [COUNT &lt;count&gt;]\n7)     Show information about the stream.\n8) HELP\n9)     Prints this help.\n</code></pre>\n<h2>Differences with Kafka (TM) partitions</h2>\n<p>Consumer groups in Streams may resemble in some way Kafka (TM) partitioning-based consumer groups, however note that Streams are, in practical terms, very different. The partitions are only <em>logical</em> and the messages are just put into a single Valkey key, so the way the different clients are served is based on who is ready to process new messages, and not from which partition clients are reading. For instance, if the consumer C3 at some point fails permanently, Valkey will continue to serve C1 and C2 all the new messages arriving, as if now there are only two <em>logical</em> partitions.</p>\n<p>Similarly, if a given consumer is much faster at processing messages than the other consumers, this consumer will receive proportionally more messages in the same unit of time. This is possible since Valkey tracks all the unacknowledged messages explicitly, and remembers who received which message and the ID of the first message never delivered to any consumer.</p>\n<p>However, this also means that in Valkey if you really want to partition messages in the same stream into multiple Valkey instances, you have to use multiple keys and some sharding system such as Valkey Cluster or some other application-specific sharding system. A single Stream is not automatically partitioned to multiple instances.</p>\n<p>We could say that schematically the following is true:</p>\n<ul>\n<li>If you use 1 stream -&gt; 1 consumer, you are processing messages in order.</li>\n<li>If you use N streams with N consumers, so that only a given consumer hits a subset of the N streams, you can scale the above model of 1 stream -&gt; 1 consumer.</li>\n<li>If you use 1 stream -&gt; N consumers, you are load balancing to N consumers, however in that case, messages about the same logical item may be consumed out of order, because a given consumer may process message 3 faster than another consumer is processing message 4.</li>\n</ul>\n<p>So basically Kafka partitions are more similar to using N different Valkey keys, while Valkey consumer groups are a server-side load balancing system of messages from a given stream to N different consumers.</p>\n<h2>Capped Streams</h2>\n<p>Many applications do not want to collect data into a stream forever. Sometimes it is useful to have at maximum a given number of items inside a stream, other times once a given size is reached, it is useful to move data from Valkey to a storage which is not in memory and not as fast but suited to store the history for, potentially, decades to come. Streams have some support for this. One is the <strong>MAXLEN</strong> option of the <code>XADD</code> command. This option is very simple to use:</p>\n<pre><code>127.0.0.1:6379&gt; XADD race:italy MAXLEN 2 * rider Jones\n&quot;1692633189161-0&quot;\n127.0.0.1:6379&gt; XADD race:italy MAXLEN 2 * rider Wood\n&quot;1692633198206-0&quot;\n127.0.0.1:6379&gt; XADD race:italy MAXLEN 2 * rider Henshaw\n&quot;1692633208557-0&quot;\n127.0.0.1:6379&gt; XLEN race:italy\n(integer) 2\n127.0.0.1:6379&gt; XRANGE race:italy - +\n1) 1) &quot;1692633198206-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Wood&quot;\n2) 1) &quot;1692633208557-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Henshaw&quot;\n</code></pre>\n<p>Using <strong>MAXLEN</strong> the old entries are automatically evicted when the specified length is reached, so that the stream is left at a constant size. There is currently no option to tell the stream to just retain items that are not older than a given period, because such command, in order to run consistently, would potentially block for a long time in order to evict items. Imagine for example what happens if there is an insertion spike, then a long pause, and another insertion, all with the same maximum time. The stream would block to evict the data that became too old during the pause. So it is up to the user to do some planning and understand what is the maximum stream length desired. Moreover, while the length of the stream is proportional to the memory used, trimming by time is less simple to control and anticipate: it depends on the insertion rate which often changes over time (and when it does not change, then to just trim by size is trivial).</p>\n<p>However trimming with <strong>MAXLEN</strong> can be expensive: streams are represented by macro nodes into a radix tree, in order to be very memory efficient. Altering the single macro node, consisting of a few tens of elements, is not optimal. So it&#39;s possible to use the command in the following special form:</p>\n<pre><code>XADD race:italy MAXLEN ~ 1000 * ... entry fields here ...\n</code></pre>\n<p>The <code>~</code> argument between the <strong>MAXLEN</strong> option and the actual count means, I don&#39;t really need this to be exactly 1000 items. It can be 1000 or 1010 or 1030, just make sure to save at least 1000 items. With this argument, the trimming is performed only when we can remove a whole node. This makes it much more efficient, and it is usually what you want. You&#39;ll note here that the client libraries have various implementations of this. For example, the Python client defaults to approximate and has to be explicitly set to a true length.</p>\n<p>There is also the <code>XTRIM</code> command, which performs something very similar to what the <strong>MAXLEN</strong> option does above, except that it can be run by itself:</p>\n<pre><code>127.0.0.1:6379&gt; XTRIM race:italy MAXLEN 10\n(integer) 0\n</code></pre>\n<p>Or, as for the <code>XADD</code> option:</p>\n<pre><code>127.0.0.1:6379&gt; XTRIM race:italy MAXLEN ~ 10\n(integer) 0\n</code></pre>\n<p>However, <code>XTRIM</code> is designed to accept different trimming strategies. Another trimming strategy is <strong>MINID</strong>, that evicts entries with IDs lower than the one specified.</p>\n<p>As <code>XTRIM</code> is an explicit command, the user is expected to know about the possible shortcomings of different trimming strategies.</p>\n<p>Another useful eviction strategy that may be added to <code>XTRIM</code> in the future, is to remove by a range of IDs to ease use of <code>XRANGE</code> and <code>XTRIM</code> to move data from Valkey to other storage systems if needed.</p>\n<h2>Special IDs in the streams API</h2>\n<p>You may have noticed that there are several special IDs that can be used in the Valkey API. Here is a short recap, so that they can make more sense in the future.</p>\n<p>The first two special IDs are <code>-</code> and <code>+</code>, and are used in range queries with the <code>XRANGE</code> command. Those two IDs respectively mean the smallest ID possible (that is basically <code>0-1</code>) and the greatest ID possible (that is <code>18446744073709551615-18446744073709551615</code>). As you can see it is a lot cleaner to write <code>-</code> and <code>+</code> instead of those numbers.</p>\n<p>Then there are APIs where we want to say, the ID of the item with the greatest ID inside the stream. This is what <code>$</code> means. So for instance if I want only new entries with <code>XREADGROUP</code> I use this ID to signify I already have all the existing entries, but not the new ones that will be inserted in the future. Similarly when I create or set the ID of a consumer group, I can set the last delivered item to <code>$</code> in order to just deliver new entries to the consumers in the group.</p>\n<p>As you can see <code>$</code> does not mean <code>+</code>, they are two different things, as <code>+</code> is the greatest ID possible in every possible stream, while <code>$</code> is the greatest ID in a given stream containing given entries. Moreover APIs will usually only understand <code>+</code> or <code>$</code>, yet it was useful to avoid loading a given symbol with multiple meanings.</p>\n<p>Another special ID is <code>&gt;</code>, that is a special meaning only related to consumer groups and only when the <code>XREADGROUP</code> command is used. This special ID means that we want only entries that were never delivered to other consumers so far. So basically the <code>&gt;</code> ID is the <em>last delivered ID</em> of a consumer group.</p>\n<p>Finally the special ID <code>*</code>, that can be used only with the <code>XADD</code> command, means to auto select an ID for us for the new entry.</p>\n<p>So we have <code>-</code>, <code>+</code>, <code>$</code>, <code>&gt;</code> and <code>*</code>, and all have a different meaning, and most of the time, can be used in different contexts.</p>\n<h2>Persistence, replication and message safety</h2>\n<p>A Stream, like any other Valkey data structure, is asynchronously replicated to replicas and persisted into AOF and RDB files. However what may not be so obvious is that also the consumer groups full state is propagated to AOF, RDB and replicas, so if a message is pending in the primary, also the replica will have the same information. Similarly, after a restart, the AOF will restore the consumer groups&#39; state.</p>\n<p>However note that Streams and consumer groups are persisted and replicated using the Valkey default replication, so:</p>\n<ul>\n<li>AOF must be used with a strong fsync policy if persistence of messages is important in your application.</li>\n<li>By default the asynchronous replication will not guarantee that <code>XADD</code> commands or consumer groups state changes are replicated: after a failover something can be missing depending on the ability of replicas to receive the data from the primary.</li>\n<li>The <code>WAIT</code> command may be used in order to force the propagation of the changes to a set of replicas. However note that while this makes it very unlikely that data is lost, the Valkey failover process as operated by Sentinel or Valkey Cluster performs only a <em>best effort</em> check to failover to the replica which is the most updated, and under certain specific failure conditions may promote a replica that lacks some data.</li>\n</ul>\n<p>So when designing an application using Streams and consumer groups, make sure to understand the semantical properties your application should have during failures, and configure things accordingly, evaluating whether it is safe enough for your use case.</p>\n<h2>Removing single items from a stream</h2>\n<p>Streams also have a special command for removing items from the middle of a stream, just by ID. Normally for an append only data structure this may look like an odd feature, but it is actually useful for applications involving, for instance, privacy regulations. The command is called <code>XDEL</code> and receives the name of the stream followed by the IDs to delete:</p>\n<pre><code>127.0.0.1:6379&gt; XRANGE race:italy - + COUNT 2\n1) 1) &quot;1692633198206-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Wood&quot;\n2) 1) &quot;1692633208557-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Henshaw&quot;\n127.0.0.1:6379&gt; XDEL race:italy 1692633208557-0\n(integer) 1\n127.0.0.1:6379&gt; XRANGE race:italy - + COUNT 2\n1) 1) &quot;1692633198206-0&quot;\n   2) 1) &quot;rider&quot;\n      2) &quot;Wood&quot;\n</code></pre>\n<p>However in the current implementation, memory is not really reclaimed until a macro node is completely empty, so you should not abuse this feature.</p>\n<h2>Zero length streams</h2>\n<p>A difference between streams and other Valkey data structures is that when the other data structures no longer have any elements, as a side effect of calling commands that remove elements, the key itself will be removed. So for instance, a sorted set will be completely removed when a call to <code>ZREM</code> will remove the last element in the sorted set. Streams, on the other hand, are allowed to stay at zero elements, both as a result of using a <strong>MAXLEN</strong> option with a count of zero (<code>XADD</code> and <code>XTRIM</code> commands), or because <code>XDEL</code> was called.</p>\n<p>The reason why such an asymmetry exists is because Streams may have associated consumer groups, and we do not want to lose the state that the consumer groups defined just because there are no longer any items in the stream. Currently the stream is not deleted even when it has no associated consumer groups.</p>\n<h2>Total latency of consuming a message</h2>\n<p>Non blocking stream commands like <code>XRANGE</code> and <code>XREAD</code> or <code>XREADGROUP</code> without the BLOCK option are served synchronously like any other Valkey command, so to discuss latency of such commands is meaningless: it is more interesting to check the time complexity of the commands in the Valkey documentation. It should be enough to say that stream commands are at least as fast as sorted set commands when extracting ranges, and that <code>XADD</code> is very fast and can easily insert from half a million to one million items per second in an average machine if pipelining is used.</p>\n<p>However latency becomes an interesting parameter if we want to understand the delay of processing a message, in the context of blocking consumers in a consumer group, from the moment the message is produced via <code>XADD</code>, to the moment the message is obtained by the consumer because <code>XREADGROUP</code> returned with the message.</p>\n<h2>How serving blocked consumers works</h2>\n<p>Before providing the results of performed tests, it is interesting to understand what model Valkey uses in order to route stream messages (and in general actually how any blocking operation waiting for data is managed).</p>\n<ul>\n<li>The blocked client is referenced in a hash table that maps keys for which there is at least one blocking consumer, to a list of consumers that are waiting for such key. This way, given a key that received data, we can resolve all the clients that are waiting for such data.</li>\n<li>When a write happens, in this case when the <code>XADD</code> command is called, it calls the <code>signalKeyAsReady()</code> function. This function will put the key into a list of keys that need to be processed, because such keys may have new data for blocked consumers. Note that such <em>ready keys</em> will be processed later, so in the course of the same event loop cycle, it is possible that the key will receive other writes.</li>\n<li>Finally, before returning into the event loop, the <em>ready keys</em> are finally processed. For each key the list of clients waiting for data is scanned, and if applicable, such clients will receive the new data that arrived. In the case of streams the data is the messages in the applicable range requested by the consumer.</li>\n</ul>\n<p>As you can see, basically, before returning to the event loop both the client calling <code>XADD</code> and the clients blocked to consume messages, will have their reply in the output buffers, so the caller of <code>XADD</code> should receive the reply from Valkey at about the same time the consumers will receive the new messages.</p>\n<p>This model is <em>push-based</em>, since adding data to the consumers buffers will be performed directly by the action of calling <code>XADD</code>, so the latency tends to be quite predictable.</p>\n<h2>Latency tests results</h2>\n<p>In order to check these latency characteristics a test was performed using multiple instances of Ruby programs pushing messages having as an additional field the computer millisecond time, and Ruby programs reading the messages from the consumer group and processing them. The message processing step consisted of comparing the current computer time with the message timestamp, in order to understand the total latency.</p>\n<p>Results obtained:</p>\n<pre><code>Processed between 0 and 1 ms -&gt; 74.11%\nProcessed between 1 and 2 ms -&gt; 25.80%\nProcessed between 2 and 3 ms -&gt; 0.06%\nProcessed between 3 and 4 ms -&gt; 0.01%\nProcessed between 4 and 5 ms -&gt; 0.02%\n</code></pre>\n<p>So 99.9% of requests have a latency &lt;= 2 milliseconds, with the outliers that remain still very close to the average.</p>\n<p>Adding a few million unacknowledged messages to the stream does not change the gist of the benchmark, with most queries still processed with very short latency.</p>\n<p>A few remarks:</p>\n<ul>\n<li>Here we processed up to 10k messages per iteration, this means that the <code>COUNT</code> parameter of <code>XREADGROUP</code> was set to 10000. This adds a lot of latency but is needed in order to allow the slow consumers to be able to keep with the message flow. So you can expect a real world latency that is a lot smaller.</li>\n<li>The system used for this benchmark is very slow compared to today&#39;s standards.</li>\n</ul>\n"
      },
      {
        "id": "geospatial",
        "topicName": "Geospatial",
        "description": "Introduction to the Valkey Geospatial data type\n",
        "htmlContent": "<p>Geospatial indexes let you store coordinates and search for them.<br>This data structure is useful for finding nearby points within a given radius or bounding box.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>GEOADD</code> adds a location to a given geospatial index (note that longitude comes before latitude with this command).</li>\n<li><code>GEOSEARCH</code> returns locations with a given radius or a bounding box.</li>\n</ul>\n<p>See the <a href=\"../commands/#geo\">complete list of geospatial index commands</a>.</p>\n<h2>Examples</h2>\n<p>Suppose you&#39;re building a mobile app that lets you find all of the bike rental stations closest to your current location.</p>\n<p>Add several locations to a geospatial index:</p>\n<pre><code>127.0.0.1:6379&gt; GEOADD bikes:rentable -122.27652 37.805186 station:1\n(integer) 1\n127.0.0.1:6379&gt; GEOADD bikes:rentable -122.2674626 37.8062344 station:2\n(integer) 1\n127.0.0.1:6379&gt; GEOADD bikes:rentable -122.2469854 37.8104049 station:3\n(integer) 1\n</code></pre>\n<p>Find all locations within a 5 kilometer radius of a given location, and return the distance to each location:</p>\n<pre><code>127.0.0.1:6379&gt; GEOSEARCH bikes:rentable FROMLONLAT -122.2612767 37.7936847 BYRADIUS 5 km WITHDIST\n1) 1) &quot;station:1&quot;\n   2) &quot;1.8523&quot;\n2) 1) &quot;station:2&quot;\n   2) &quot;1.4979&quot;\n3) 1) &quot;station:3&quot;\n   2) &quot;2.2441&quot;\n</code></pre>\n"
      },
      {
        "id": "hyperloglogs",
        "topicName": "HyperLogLog",
        "description": "HyperLogLog is a probabilistic data structure that estimates the cardinality of a set.\n",
        "htmlContent": "<p>HyperLogLog is a probabilistic data structure that estimates the cardinality of a set. As a probabilistic data structure, HyperLogLog trades perfect accuracy for efficient space utilization.</p>\n<p>The HyperLogLog implementation uses up to 12 KB and provides a standard error of 0.81%.</p>\n<p>Counting unique items usually requires an amount of memory<br>proportional to the number of items you want to count, because you need<br>to remember the elements you have already seen in the past in order to avoid<br>counting them multiple times. However, a set of algorithms exist that trade<br>memory for precision: they return an estimated measure with a standard error,<br>which, in the case of the Valkey implementation for HyperLogLog, is less than 1%.<br>The magic of this algorithm is that you no longer need to use an amount of memory<br>proportional to the number of items counted, and instead can use a<br>constant amount of memory; 12k bytes in the worst case, or a lot less if your<br>HyperLogLog (We&#39;ll just call them HLL from now) has seen very few elements.</p>\n<p>HLLs in Valkey, while technically a different data structure, are encoded<br>as a String, so you can call <code>GET</code> to serialize a HLL, and <code>SET</code><br>to deserialize it back to the server.</p>\n<p>Conceptually the HLL API is like using Sets to do the same task. You would<br><code>SADD</code> every observed element into a set, and would use <code>SCARD</code> to check the<br>number of elements inside the set, which are unique since <code>SADD</code> will not<br>re-add an existing element.</p>\n<p>While you don&#39;t really <em>add items</em> into an HLL, because the data structure<br>only contains a state that does not include actual elements, the API is the<br>same:</p>\n<ul>\n<li>Every time you see a new element, you add it to the count with <code>PFADD</code>.</li>\n<li>When you want to retrieve the current approximation of unique elements added using the <code>PFADD</code> command, you can use the <code>PFCOUNT</code> command. If you need to merge two different HLLs, the <code>PFMERGE</code> command is available. Since HLLs provide approximate counts of unique elements, the result of the merge will give you an approximation of the number of unique elements across both source HLLs.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; PFADD bikes Hyperion Deimos Phoebe Quaoar\n(integer) 1\n127.0.0.1:6379&gt; PFCOUNT bikes\n(integer) 4\n127.0.0.1:6379&gt; PFADD commuter_bikes Salacia Mimas Quaoar\n(integer) 1\n127.0.0.1:6379&gt; PFMERGE all_bikes bikes commuter_bikes\nOK\n127.0.0.1:6379&gt; PFCOUNT all_bikes\n(integer) 6\n</code></pre>\n<p>Some examples of use cases for this data structure is counting unique queries<br>performed by users in a search form every day, number of unique visitors to a web page and other similar cases.</p>\n<p>Valkey is also able to perform the union of HLLs, please check the<br><a href=\"../commands/#hyperloglog\">full documentation</a> for more information.</p>\n<h2>Use cases</h2>\n<p><strong>Anonymous unique visits of a web page (SaaS, analytics tools)</strong> </p>\n<p>This application answers these questions: </p>\n<ul>\n<li>How many unique visits has this page had on this day? </li>\n<li>How many unique users have played this song? </li>\n<li>How many unique users have viewed this video?</li>\n</ul>\n<p><strong>Note:</strong><br>Storing the IP address or any other kind of personal identifier is against the law in some countries, which makes it impossible to get unique visitor statistics on your website.</p>\n<p>One HyperLogLog is created per page (video/song) per period, and every IP/identifier is added to it on every visit.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>PFADD</code> adds an item to a HyperLogLog.</li>\n<li><code>PFCOUNT</code> returns an estimate of the number of items in the set.</li>\n<li><code>PFMERGE</code> combines two or more HyperLogLogs into one.</li>\n</ul>\n<p>See the <a href=\"../commands/#hyperloglog\">complete list of HyperLogLog commands</a>.</p>\n<h2>Performance</h2>\n<p>Writing (<code>PFADD</code>) to and reading from (<code>PFCOUNT</code>) the HyperLogLog is done in constant time and space.<br>Merging HLLs is O(n), where <em>n</em> is the number of sketches.</p>\n<h2>Limits</h2>\n<p>The HyperLogLog can estimate the cardinality of sets with up to 18,446,744,073,709,551,616 (2^64) members.</p>\n<h2>Learn more</h2>\n<ul>\n<li>This blog post on <a href=\"https://web.archive.org/web/20241019222035/http://antirez.com/news/75\">the HyperLogLog data structure</a> has a lot of details about the data structure and its implementation in Valkey.</li>\n</ul>\n"
      },
      {
        "id": "bitmaps",
        "topicName": "Bitmaps",
        "description": "Introduction to Bitmaps\n",
        "htmlContent": "<p>Bitmaps are not an actual data type, but a set of bit-oriented operations<br>defined on the String type which is treated like a bit vector.<br>Since strings are binary safe blobs and their maximum length is 512 MB,<br>they are suitable to set up to 2^32 different bits.</p>\n<p>You can perform bitwise operations on one or more strings.<br>Some examples of bitmap use cases include:</p>\n<ul>\n<li>Efficient set representations for cases where the members of a set correspond to the integers 0-N.</li>\n<li>Object permissions, where each bit represents a particular permission, similar to the way that file systems store permissions.</li>\n</ul>\n<h2>Basic commands</h2>\n<ul>\n<li><code>SETBIT</code> sets a bit at the provided offset to 0 or 1.</li>\n<li><code>GETBIT</code> returns the value of a bit at a given offset.</li>\n</ul>\n<p>See the <a href=\"../commands/#bitmap\">complete list of bitmap commands</a>.</p>\n<h2>Example</h2>\n<p>Suppose you have 1000 cyclists racing through the country-side, with sensors on their bikes labeled 0-999.<br>You want to quickly determine whether a given sensor has pinged a tracking server within the hour to check in on a rider. </p>\n<p>You can represent this scenario using a bitmap whose key references the current hour.</p>\n<ul>\n<li>Rider 123 pings the server on January 1, 2024 within the 00:00 hour. You can then confirm that rider 123 pinged the server. You can also check to see if rider 456 has pinged the server for that same hour.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; SETBIT pings:2024-01-01-00:00 123 1\n(integer) 0\n127.0.0.1:6379&gt; GETBIT pings:2024-01-01-00:00 123\n(integer) 1\n127.0.0.1:6379&gt; GETBIT pings:2024-01-01-00:00 456\n(integer) 0\n</code></pre>\n<h2>Bit Operations</h2>\n<p>Bit operations are divided into two groups: constant-time single bit<br>operations, like setting a bit to 1 or 0, or getting its value, and<br>operations on groups of bits, for example counting the number of set<br>bits in a given range of bits (e.g., population counting).</p>\n<p>One of the biggest advantages of bitmaps is that they often provide<br>extreme space savings when storing information. For example in a system<br>where different users are represented by incremental user IDs, it is possible<br>to remember a single bit information (for example, knowing whether<br>a user wants to receive a newsletter) of 4 billion users using just 512 MB of memory.</p>\n<p>The <code>SETBIT</code> command takes as its first argument the bit number, and as its second<br>argument the value to set the bit to, which is 1 or 0. The command<br>automatically enlarges the string if the addressed bit is outside the<br>current string length.</p>\n<p><code>GETBIT</code> just returns the value of the bit at the specified index.<br>Out of range bits (addressing a bit that is outside the length of the string<br>stored into the target key) are always considered to be zero.</p>\n<p>There are three commands operating on group of bits:</p>\n<ol>\n<li><code>BITOP</code> performs bit-wise operations between different strings. The provided operations are AND, OR, XOR and NOT.</li>\n<li><code>BITCOUNT</code> performs population counting, reporting the number of bits set to 1.</li>\n<li><code>BITPOS</code> finds the first bit having the specified value of 0 or 1.</li>\n</ol>\n<p>Both <code>BITPOS</code> and <code>BITCOUNT</code> are able to operate with byte ranges of the<br>string, instead of running for the whole length of the string. We can trivially see the number of bits that have been set in a bitmap.</p>\n<pre><code>127.0.0.1:6379&gt; BITCOUNT pings:2024-01-01-00:00\n(integer) 1\n</code></pre>\n<p>For example imagine you want to know the longest streak of daily visits of<br>your web site users. You start counting days starting from zero, that is the<br>day you made your web site public, and set a bit with <code>SETBIT</code> every time<br>the user visits the web site. As a bit index you simply take the current unix<br>time, subtract the initial offset, and divide by the number of seconds in a day<br>(normally, 3600*24).</p>\n<p>This way for each user you have a small string containing the visit<br>information for each day. With <code>BITCOUNT</code> it is possible to easily get<br>the number of days a given user visited the web site, while with<br>a few <code>BITPOS</code> calls, or simply fetching and analyzing the bitmap client-side,<br>it is possible to easily compute the longest streak.</p>\n<p>Bitmaps are trivial to split into multiple keys, for example for<br>the sake of sharding the data set and because in general it is better to<br>avoid working with huge keys. To split a bitmap across different keys<br>instead of setting all the bits into a key, a trivial strategy is just<br>to store M bits per key and obtain the key name with <code>bit-number/M</code> and<br>the Nth bit to address inside the key with <code>bit-number MOD M</code>.</p>\n<h2>Performance</h2>\n<p><code>SETBIT</code> and <code>GETBIT</code> are O(1).<br><code>BITOP</code> is O(n), where <em>n</em> is the length of the longest string in the comparison.</p>\n"
      },
      {
        "id": "bitfields",
        "topicName": "Bitfields",
        "description": "Introduction to Bitfields\n",
        "htmlContent": "<p>Bitfields let you set, increment, and get integer values of arbitrary bit length.<br>For example, you can operate on anything from unsigned 1-bit integers to signed 63-bit integers.</p>\n<p>These values are stored using binary-encoded Strings.<br>Bitfields support atomic read, write and increment operations, making them a good choice for managing counters and similar numerical values.</p>\n<h2>Basic commands</h2>\n<ul>\n<li><code>BITFIELD</code> atomically sets, increments and reads one or more values.</li>\n<li><code>BITFIELD_RO</code> is a read-only variant of <code>BITFIELD</code>.</li>\n</ul>\n<h2>Example</h2>\n<p>Suppose you want to maintain two metrics for various bicycles: the current price and the number of owners over time. You can represent these counters with a 32-bit wide bitfield per for each bike.</p>\n<ul>\n<li>Bike 1 initially costs 1,000 (counter in offset 0) and has never had an owner. After being sold, it&#39;s now considered used and the price instantly drops to reflect its new condition, and it now has an owner (offset 1). After quite some time, the bike becomes a classic. The original owner sells it for a profit, so the price goes up and the number of owners does as well.Finally, you can look at the bike&#39;s current price and number of owners.</li>\n</ul>\n<pre><code>127.0.0.1:6379&gt; BITFIELD bike:1:stats SET u32 #0 1000\n1) (integer) 0\n127.0.0.1:6379&gt; BITFIELD bike:1:stats INCRBY u32 #0 -50 INCRBY u32 #1 1\n1) (integer) 950\n2) (integer) 1\n127.0.0.1:6379&gt; BITFIELD bike:1:stats INCRBY u32 #0 500 INCRBY u32 #1 1\n1) (integer) 1450\n2) (integer) 2\n127.0.0.1:6379&gt; BITFIELD bike:1:stats GET u32 #0 GET u32 #1\n1) (integer) 1450\n2) (integer) 2\n</code></pre>\n<h2>Performance</h2>\n<p><code>BITFIELD</code> is O(n), where <em>n</em> is the number of counters accessed.</p>\n"
      }
    ]
  },
  {
    "title": "SCRIPTING",
    "items": [
      {
        "id": "eval-intro",
        "topicName": "Scripting with Lua",
        "description": "Executing Lua in Valkey\n",
        "htmlContent": "<p>Valkey lets users upload and execute Lua scripts on the server.<br>Scripts can employ programmatic control structures and use most of the <a href=\"../commands/\">commands</a> while executing to access the database.<br>Because scripts execute in the server, reading and writing data from scripts is very efficient.</p>\n<p>Valkey guarantees the script&#39;s atomic execution.<br>While executing the script, all server activities are blocked during its entire runtime.<br>These semantics mean that all of the script&#39;s effects either have yet to happen or had already happened.</p>\n<p>Scripting offers several properties that can be valuable in many cases.<br>These include:</p>\n<ul>\n<li>Providing locality by executing logic where data lives. Data locality reduces overall latency and saves networking resources.</li>\n<li>Blocking semantics that ensure the script&#39;s atomic execution.</li>\n<li>Enabling the composition of simple capabilities that are either missing from Valkey or are too niche to be a part of it.</li>\n</ul>\n<p>Lua lets you run part of your application logic inside Valkey.<br>Such scripts can perform conditional updates across multiple keys, possibly combining several different data types atomically.</p>\n<p>Scripts are executed in Valkey by an embedded execution engine.<br>Presently, Valkey supports a single scripting engine, the <a href=\"https://www.lua.org/\">Lua 5.1</a> interpreter.<br>Please refer to the <a href=\"lua-api.md\">Valkey Lua API Reference</a> page for complete documentation.</p>\n<p>Although the server executes them, Eval scripts are regarded as a part of the client-side application, which is why they&#39;re not named, versioned, or persisted.<br>So all scripts may need to be reloaded by the application at any time if missing (after a server restart, fail-over to a replica, etc.).<br>As of version 7.0, <a href=\"functions-intro.md\">Valkey Functions</a> offer an alternative approach to programmability which allow the server itself to be extended with additional programmed logic.</p>\n<h2>Getting started</h2>\n<p>We&#39;ll start scripting with Valkey by using the <code>EVAL</code> command.</p>\n<p>Here&#39;s our first example:</p>\n<pre><code>&gt; EVAL &quot;return &#39;Hello, scripting!&#39;&quot; 0\n&quot;Hello, scripting!&quot;\n</code></pre>\n<p>In this example, <code>EVAL</code> takes two arguments.<br>The first argument is a string that consists of the script&#39;s Lua source code.<br>The script doesn&#39;t need to include any definitions of Lua function.<br>It is just a Lua program that will run in the Valkey engine&#39;s context.</p>\n<p>The second argument is the number of arguments that follow the script&#39;s body, starting from the third argument, representing Valkey key names.<br>In this example, we used the value <em>0</em> because we didn&#39;t provide the script with any arguments, whether the names of keys or not.</p>\n<h2>Script parameterization</h2>\n<p>It is possible, although highly ill-advised, to have the application dynamically generate script source code per its needs.<br>For example, the application could send these two entirely different, but at the same time perfectly identical scripts:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return &#39;Hello&#39;&quot; 0\n&quot;Hello&quot;\n127.0.0.1:6379&gt; EVAL &quot;return &#39;Scripting!&#39;&quot; 0\n&quot;Scripting!&quot;\n</code></pre>\n<p>Although this mode of operation isn&#39;t blocked by Valkey, it is an anti-pattern due to script cache considerations (more on the topic below).<br>Instead of having your application generate subtle variations of the same scripts, you can parametrize them and pass any arguments needed for to execute them.</p>\n<p>The following example demonstrates how to achieve the same effects as above, but via parameterization:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return ARGV[1]&quot; 0 Hello\n&quot;Hello&quot;\n127.0.0.1:6379&gt; EVAL &quot;return ARGV[1]&quot; 0 Parameterization!\n&quot;Parameterization!&quot;\n</code></pre>\n<p>At this point, it is essential to understand the distinction Valkey makes between input arguments that are names of keys and those that aren&#39;t.</p>\n<p>While key names in Valkey are just strings, unlike any other string values, these represent keys in the database.<br>The name of a key is a fundamental concept in Valkey and is the basis for operating the Valkey Cluster.</p>\n<p><strong>Important:</strong><br>to ensure the correct execution of scripts, both in standalone and clustered deployments, all names of keys that a script accesses must be explicitly provided as input key arguments.<br>The script <strong>should only</strong> access keys whose names are given as input arguments.<br>Scripts <strong>should never</strong> access keys with programmatically-generated names or based on the contents of data structures stored in the database.</p>\n<p>Any input to the function that isn&#39;t the name of a key is a regular input argument.</p>\n<p>In the example above, both <em>Hello</em> and <em>Parameterization!</em> regular input arguments for the script.<br>Because the script doesn&#39;t touch any keys, we use the numerical argument <em>0</em> to specify there are no key name arguments.<br>The execution context makes arguments available to the script through <a href=\"lua-api.md#the-keys-global-variable\"><em>KEYS</em></a> and <a href=\"lua-api.md#the-argv-global-variable\"><em>ARGV</em></a> global runtime variables.<br>The <em>KEYS</em> table is pre-populated with all key name arguments provided to the script before its execution, whereas the <em>ARGV</em> table serves a similar purpose but for regular arguments.</p>\n<p>The following attempts to demonstrate the distribution of input arguments between the scripts <em>KEYS</em> and <em>ARGV</em> runtime global variables:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3] }&quot; 2 key1 key2 arg1 arg2 arg3\n1) &quot;key1&quot;\n2) &quot;key2&quot;\n3) &quot;arg1&quot;\n4) &quot;arg2&quot;\n5) &quot;arg3&quot;\n</code></pre>\n<p><strong>Note:</strong><br>as can been seen above, Lua&#39;s table arrays are returned as <a href=\"protocol.md#arrays\">RESP2 array replies</a>, so it is likely that your client&#39;s library will convert it to the native array data type in your programming language.<br>Please refer to the rules that govern <a href=\"lua-api.md#data-type-conversion\">data type conversion</a> for more pertinent information.</p>\n<h2>Interacting with Valkey from a script</h2>\n<p>It is possible to call Valkey commands from a Lua script either via <a href=\"lua-api.md#server.call\"><code>server.call()</code></a> or <a href=\"lua-api.md#server.pcall\"><code>server.pcall()</code></a>.</p>\n<p>The two are nearly identical.<br>Both execute a Valkey command along with its provided arguments, if these represent a well-formed command.<br>However, the difference between the two functions lies in the manner in which runtime errors (such as syntax errors, for example) are handled.<br>Errors raised from calling <code>server.call()</code> function are returned directly to the client that had executed it.<br>Conversely, errors encountered when calling the <code>server.pcall()</code> function are returned to the script&#39;s execution context instead for possible handling.</p>\n<p>For example, consider the following:</p>\n<pre><code>&gt; EVAL &quot;return server.call(&#39;SET&#39;, KEYS[1], ARGV[1])&quot; 1 foo bar\nOK\n</code></pre>\n<p>The above script accepts one key name and one value as its input arguments.<br>When executed, the script calls the <code>SET</code> command to set the input key, <em>foo</em>, with the string value &quot;bar&quot;.</p>\n<h2>Script cache</h2>\n<p>Until this point, we&#39;ve used the <code>EVAL</code> command to run our script.</p>\n<p>Whenever we call <code>EVAL</code>, we also include the script&#39;s source code with the request.<br>Repeatedly calling <code>EVAL</code> to execute the same set of parameterized scripts, wastes both network bandwidth and also has some overheads in Valkey.<br>Naturally, saving on network and compute resources is key, so, instead, Valkey provides a caching mechanism for scripts.</p>\n<p>Every script you execute with <code>EVAL</code> is stored in a dedicated cache that the server keeps.<br>The cache&#39;s contents are organized by the scripts&#39; SHA1 digest sums, so the SHA1 digest sum of a script uniquely identifies it in the cache.<br>You can verify this behavior by running <code>EVAL</code> and calling <code>INFO</code> afterward.<br>You&#39;ll notice that the <em>used_memory_scripts_eval</em> and <em>number_of_cached_scripts</em> metrics grow with every new script that&#39;s executed.</p>\n<p>As mentioned above, dynamically-generated scripts are an anti-pattern.<br>Generating scripts during the application&#39;s runtime may, and probably will, exhaust the host&#39;s memory resources for caching them.<br>Instead, scripts should be as generic as possible and provide customized execution via their arguments.</p>\n<p>A script is loaded to the server&#39;s cache by calling the <code>SCRIPT LOAD</code> command and providing its source code.<br>The server doesn&#39;t execute the script, but instead just compiles and loads it to the server&#39;s cache.<br>Once loaded, you can execute the cached script with the SHA1 digest returned from the server.</p>\n<p>Here&#39;s an example of loading and then executing a cached script:</p>\n<pre><code>127.0.0.1:6379&gt; SCRIPT LOAD &quot;return &#39;Immabe a cached script&#39;&quot;\n&quot;c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f&quot;\n127.0.0.1:6379&gt; EVALSHA c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f 0\n&quot;Immabe a cached script&quot;\n</code></pre>\n<h3>Cache volatility</h3>\n<p>The Valkey script cache is <strong>always volatile</strong>.<br>It isn&#39;t considered as a part of the database and is <strong>not persisted</strong>.<br>The cache may be cleared when the server restarts, during fail-over when a replica assumes the primary role, or explicitly by <code>SCRIPT FLUSH</code>.<br>That means that cached scripts are ephemeral, and the cache&#39;s contents can be lost at any time.</p>\n<p>Applications that use scripts should always call <code>EVALSHA</code> to execute them.<br>The server returns an error if the script&#39;s SHA1 digest is not in the cache.<br>For example:</p>\n<pre><code>127.0.0.1:6379&gt; EVALSHA ffffffffffffffffffffffffffffffffffffffff 0\n(error) NOSCRIPT No matching script\n</code></pre>\n<p>In this case, the application should first load it with <code>SCRIPT LOAD</code> and then call <code>EVALSHA</code> once more to run the cached script by its SHA1 sum.<br>Most of <a href=\"../clients/\">Valkey&#39; clients</a> already provide utility APIs for doing that automatically.<br>Please consult your client&#39;s documentation regarding the specific details.</p>\n<h3><code>EVALSHA</code> in the context of pipelining</h3>\n<p>Special care should be given executing <code>EVALSHA</code> in the context of a <a href=\"pipelining.md\">pipelined request</a>.<br>The commands in a pipelined request run in the order they are sent, but other clients&#39; commands may be interleaved for execution between these.<br>Because of that, the <code>NOSCRIPT</code> error can return from a pipelined request but can&#39;t be handled.</p>\n<p>Therefore, a client library&#39;s implementation should revert to using plain <code>EVAL</code> of parameterized in the context of a pipeline.</p>\n<h3>Script cache semantics</h3>\n<p>During normal operation, an application&#39;s scripts are meant to stay indefinitely in the cache (that is, until the server is restarted or the cache being flushed).<br>The underlying reasoning is that the script cache contents of a well-written application are unlikely to grow continuously.<br>Even large applications that use hundreds of cached scripts shouldn&#39;t be an issue in terms of cache memory usage.</p>\n<p>The only way to flush the script cache is by explicitly calling the <code>SCRIPT FLUSH</code> command.<br>Running the command will <em>completely flush</em> the scripts cache, removing all the scripts executed so far.<br>Typically, this is only needed when the instance is going to be instantiated for another customer or application in a cloud environment.</p>\n<p>Also, as already mentioned, restarting a Valkey instance flushes the non-persistent script cache.<br>However, from the point of view of the Valkey client, there are only two ways to make sure that a Valkey instance was not restarted between two different commands:</p>\n<ul>\n<li>The connection we have with the server is persistent and was never closed so far.</li>\n<li>The client explicitly checks the <code>run_id</code> field in the <code>INFO</code> command to ensure the server was not restarted and is still the same process.</li>\n</ul>\n<p>Practically speaking, it is much simpler for the client to assume that in the context of a given connection, cached scripts are guaranteed to be there unless the administrator explicitly invoked the <code>SCRIPT FLUSH</code> command.<br>The fact that the user can count on Valkey to retain cached scripts is semantically helpful in the context of pipelining.</p>\n<h2>The <code>SCRIPT</code> command</h2>\n<p>The Valkey <code>SCRIPT</code> provides several ways for controlling the scripting subsystem.<br>These are:</p>\n<ul>\n<li><p><code>SCRIPT FLUSH</code>: this command is the only way to force Valkey to flush the scripts cache.<br>It is most useful in environments where the same Valkey instance is reassigned to different uses.<br>It is also helpful for testing client libraries&#39; implementations of the scripting feature.</p>\n</li>\n<li><p><code>SCRIPT EXISTS</code>: given one or more SHA1 digests as arguments, this command returns an array of <em>1</em>&#39;s and <em>0</em>&#39;s.<br><em>1</em> means the specific SHA1 is recognized as a script already present in the scripting cache. <em>0</em>&#39;s meaning is that a script with this SHA1 wasn&#39;t loaded before (or at least never since the latest call to <code>SCRIPT FLUSH</code>).</p>\n</li>\n<li><p><code>SCRIPT LOAD script</code>: this command registers the specified script in the Valkey script cache.<br>It is a useful command in all the contexts where we want to ensure that <code>EVALSHA</code> doesn&#39;t not fail (for instance, in a pipeline or when called from a <a href=\"transactions.md\"><code>MULTI</code>/<code>EXEC</code> transaction</a>), without the need to execute the script.</p>\n</li>\n<li><p><code>SCRIPT SHOW</code>: this command shows the original source code for a script that is stored in the script cache.<br>It is useful to help users easily obtain scripts using signature.</p>\n</li>\n<li><p><code>SCRIPT KILL</code>: this command is the only way to interrupt a long-running script (a.k.a slow script), short of shutting down the server.<br>A script is deemed as slow once its execution&#39;s duration exceeds the configured <a href=\"programmability.md#maximum-execution-time\">maximum execution time</a> threshold.<br>The <code>SCRIPT KILL</code> command can be used only with scripts that did not modify the dataset during their execution (since stopping a read-only script does not violate the scripting engine&#39;s guaranteed atomicity).</p>\n</li>\n<li><p><code>SCRIPT DEBUG</code>: controls use of the built-in <a href=\"ldb.md\">Valkey Lua scripts debugger</a>.</p>\n</li>\n</ul>\n<h2>Script replication</h2>\n<p>In a primary-replica setup (see <a href=\"replication.md\">replication</a>), write commands performed by a script on the primary are also sent to replicas to maintain consistency.<br>When the script execution finishes, the sequence of commands that the script generated are wrapped into a <a href=\"transactions.md\"><code>MULTI</code>/<code>EXEC</code> transaction</a> and are sent to the replicas and written to the AOF file, if an AOF file is used. (See <a href=\"persistence.md\">Persistence</a>.)<br>This is called <em>effects replication</em>.</p>\n<p>In the past, it was also possible to use <em>verbatim replication</em> which means that a script was replicated as a whole, but this was removed in 7.0.</p>\n<p>The <a href=\"lua-api.md#server.replicate_commands\"><code>server.replicate_commands()</code></a> function is deprecated and has no effect, but it exists to avoid breaking existing scripts.</p>\n<h2>Debugging Eval scripts</h2>\n<p>Valkey has a built-in Lua debugger.<br>The Valkey Lua debugger is a remote debugger consisting of a server, which is Valkey itself, and a client, which is by default <a href=\"cli.md\"><code>valkey-cli</code></a>.</p>\n<p>The Lua debugger is described in the <a href=\"ldb.md\">Lua scripts debugging</a> section of the Valkey documentation.</p>\n<h2>Execution under low memory conditions</h2>\n<p>When memory usage in Valkey exceeds the <code>maxmemory</code> limit, the first write command encountered in the script that uses additional memory will cause the script to abort (unless <a href=\"lua-api.md#server.pcall\"><code>server.pcall</code></a> was used).</p>\n<p>However, an exception to the above is when the script&#39;s first write command does not use additional memory, as is the case with  (for example, <code>DEL</code> and <code>LREM</code>).<br>In this case, Valkey will allow all commands in the script to run to ensure atomicity.<br>If subsequent writes in the script consume additional memory, Valkey&#39; memory usage can exceed the threshold set by the <code>maxmemory</code> configuration directive.</p>\n<p>Another scenario in which a script can cause memory usage to cross the <code>maxmemory</code> threshold is when the execution begins when Valkey is slightly below <code>maxmemory</code>, so the script&#39;s first write command is allowed.<br>As the script executes, subsequent write commands consume more memory leading to the server using more RAM than the configured <code>maxmemory</code> directive.</p>\n<p>In those scenarios, you should consider setting the <code>maxmemory-policy</code> configuration directive to any values other than <code>noeviction</code>.<br>In addition, Lua scripts should be as fast as possible so that eviction can kick in between executions.</p>\n<p>Note that you can change this behaviour by using <a href=\"#eval-flags\">flags</a></p>\n<h2>Eval flags</h2>\n<p>Normally, when you run an Eval script, the server does not know how it accesses the database.<br>By default, Valkey assumes that all scripts read and write data.<br>However, starting with Redis OSS 7.0, there&#39;s a way to declare flags when creating a script in order to tell Valkey how it should behave.</p>\n<p>The way to do that is by using a Shebang statement on the first line of the script like so:</p>\n<pre><code>#!lua flags=no-writes,allow-stale\nlocal x = server.call(&#39;get&#39;,&#39;x&#39;)\nreturn x\n</code></pre>\n<p>Note that as soon as Valkey sees the <code>#!</code> comment, it&#39;ll treat the script as if it declares flags, even if no flags are defined,<br>it still has a different set of defaults compared to a script without a <code>#!</code> line.</p>\n<p>Another difference is that scripts without <code>#!</code> can run commands that access keys belonging to different cluster hash slots, but ones with <code>#!</code> inherit the default flags, so they cannot.</p>\n<p>Please refer to <a href=\"lua-api.md#script_flags\">Script flags</a> to learn about the various scripts and the defaults.</p>\n"
      },
      {
        "id": "lua-api",
        "topicName": "Lua API reference",
        "description": "Executing Lua in Valkey\n",
        "htmlContent": "<p>Valkey includes an embedded <a href=\"https://www.lua.org/\">Lua 5.1</a> interpreter.<br>The interpreter runs user-defined <a href=\"eval-intro.md\">ephemeral scripts</a> and <a href=\"functions-intro.md\">functions</a>. Scripts run in a sandboxed context and can only access specific Lua packages. This page describes the packages and APIs available inside the execution&#39;s context.</p>\n<h2>Sandbox context</h2>\n<p>The sandboxed Lua context attempts to prevent accidental misuse and reduce potential threats from the server&#39;s environment.</p>\n<p>Scripts should never try to access the Valkey server&#39;s underlying host systems.<br>That includes the file system, network, and any other attempt to perform a system call other than those supported by the API.</p>\n<p>Scripts should operate solely on data stored in Valkey and data provided as arguments to their execution.</p>\n<h3>Global variables and functions</h3>\n<p>The sandboxed Lua execution context blocks the declaration of global variables and functions.<br>The blocking of global variables is in place to ensure that scripts and functions don&#39;t attempt to maintain any runtime context other than the data stored in Valkey.<br>In the (somewhat uncommon) use case that a context needs to be maintain between executions,<br>you should store the context in Valkey&#39; keyspace.</p>\n<p>Valkey will return an error when trying to execute the following snippet:</p>\n<pre><code class=\"language-lua\">my_global_variable = &#39;some value&#39;\n</code></pre>\n<p>And similarly for the following global function declaration:</p>\n<pre><code class=\"language-lua\">function my_global_function()\n  -- Do something amazing\nend\n</code></pre>\n<p>You&#39;ll also get a similar error when your script attempts to access any global variables that are undefined in the runtime&#39;s context:</p>\n<pre><code class=\"language-lua\">-- The following will surely raise an error\nreturn an_undefined_global_variable\n</code></pre>\n<p>Instead, all variable and function definitions are required to be declared as local.<br>To do so, you&#39;ll need to prepend the <a href=\"https://www.lua.org/manual/5.1/manual.html#2.4.7\"><code>local</code></a> keyword to your declarations.<br>For example, the following snippet will be considered perfectly valid by Valkey:</p>\n<pre><code class=\"language-lua\">local my_local_variable = &#39;some value&#39;\n\nlocal function my_local_function()\n  -- Do something else, but equally amazing\nend\n</code></pre>\n<p><strong>Note:</strong><br>the sandbox attempts to prevent the use of globals.<br>Using Lua&#39;s debugging functionality or other approaches such as altering the meta table used for implementing the globals&#39; protection to circumvent the sandbox isn&#39;t hard.<br>However, it is difficult to circumvent the protection by accident.<br>If the user messes with the Lua global state, the consistency of AOF and replication can&#39;t be guaranteed.<br>In other words, just don&#39;t do it.</p>\n<h3>Imported Lua modules</h3>\n<p>Using imported Lua modules is not supported inside the sandboxed execution context.<br>The sandboxed execution context prevents the loading modules by disabling Lua&#39;s <a href=\"https://www.lua.org/pil/8.1.html\"><code>require</code> function</a>.</p>\n<p>The only libraries that Valkey ships with and that you can use in scripts are listed under the <a href=\"#runtime-libraries\">Runtime libraries</a> section.</p>\n<h2>Runtime globals</h2>\n<p>While the sandbox prevents users from declaring globals, the execution context is pre-populated with several of these.</p>\n<p>For some of them, a &quot;since version&quot; is specified.<br>The ones without &quot;since version&quot; specified are available in all maintained versions.</p>\n<h3><a name=\"the-keys-global-variable\"></a>The <code>KEYS</code> global variable</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p><strong>Important:</strong><br>to ensure the correct execution of scripts, both in standalone and clustered deployments, all names of keys that a function accesses must be explicitly provided as input key arguments.<br>The script <strong>should only</strong> access keys whose names are given as input arguments.<br>Scripts <strong>should never</strong> access keys with programmatically-generated names or based on the contents of data structures stored in the database.</p>\n<p>The <code>KEYS</code> global variable is available only for <a href=\"eval-intro.md\">ephemeral scripts</a>.<br>It is pre-populated with all key name input arguments.</p>\n<h3><a name=\"the-argv-global-variable\"></a>The <code>ARGV</code> global variable</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p>The <code>ARGV</code> global variable is available only in <a href=\"eval-intro.md\">ephemeral scripts</a>.<br>It is pre-populated with all regular input arguments.</p>\n<h3>The <code>server</code> singleton</h3>\n<ul>\n<li>Since version: 7.2.5</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <code>server</code> singleton is an object instance that&#39;s accessible from all scripts.<br>It provides the API to interact with Valkey from scripts.<br>Following is the API provided by the <code>server</code> object instance.</p>\n<p><strong>Note:</strong><br>For compatibility with Redis, Valkey also exposes a <code>redis</code> top-level object, that exposes the exact same set of APIs as the <code>server</code> object.<br>Valkey does not intend to drop compatibility for this <code>redis</code> API, but it is recommended to use the <code>server</code> object for newly developed scripts.</p>\n<h2><a name=\"server_object\"></a> <code>server</code> object fields (functions and variables)</h2>\n<h3><a name=\"server.call\"></a> <code>server.call(command [,arg...])</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <code>server.call()</code> function calls a given Valkey command and returns its reply.<br>Its inputs are the command and arguments, and once called, it executes the command in Valkey and returns the reply.</p>\n<p>For example, we can call the <code>ECHO</code> command from a script and return its reply like so:</p>\n<pre><code class=\"language-lua\">return server.call(&#39;ECHO&#39;, &#39;Echo, echo... eco... o...&#39;)\n</code></pre>\n<p>If and when <code>server.call()</code> triggers a runtime exception, the raw exception is raised back to the user as an error, automatically.<br>Therefore, attempting to execute the following ephemeral script will fail and generate a runtime exception because <code>ECHO</code> accepts exactly one argument:</p>\n<pre><code class=\"language-lua\">127.0.0.1:6379&gt; EVAL &quot;return server.call(&#39;ECHO&#39;, &#39;Echo,&#39;, &#39;echo... &#39;, &#39;eco... &#39;, &#39;o...&#39;)&quot; 0\n(error) ERR Wrong number of args calling Valkey command from script script: b0345693f4b77517a711221050e76d24ae60b7f7, on @user_script:1.\n</code></pre>\n<p>Note that the call can fail due to various reasons, see <a href=\"eval-intro.md#execution-under-low-memory-conditions\">Execution under low memory conditions</a> and <a href=\"#script_flags\">Script flags</a></p>\n<p>To handle Valkey runtime errors use <code>server.pcall()</code> instead.</p>\n<h3><a name=\"server.pcall\"></a> <code>server.pcall(command [,arg...])</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function enables handling runtime errors raised by the Valkey server.<br>The <code>server.pcall()</code> function  behaves exactly like <a href=\"#server.call\"><code>server.call()</code></a>, except that it:</p>\n<ul>\n<li>Always returns a reply.</li>\n<li>Never throws a runtime exception, and returns in its stead a <a href=\"#server.error_reply\"><code>server.error_reply</code></a> in case that a runtime exception is thrown by the server.</li>\n</ul>\n<p>The following demonstrates how to use <code>server.pcall()</code> to intercept and handle runtime exceptions from within the context of an ephemeral script.</p>\n<pre><code class=\"language-lua\">local reply = server.pcall(&#39;ECHO&#39;, unpack(ARGV))\nif reply[&#39;err&#39;] ~= nil then\n  -- Handle the error sometime, but for now just log it\n  server.log(server.LOG_WARNING, reply[&#39;err&#39;])\n  reply[&#39;err&#39;] = &#39;ERR Something is wrong, but no worries, everything is under control&#39;\nend\nreturn reply\n</code></pre>\n<p>Evaluating this script with more than one argument will return:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;...&quot; 0 hello world\n(error) ERR Something is wrong, but no worries, everything is under control\n</code></pre>\n<h3><a name=\"server.error_reply\"></a> <code>server.error_reply(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This is a helper function that returns an <a href=\"protocol.md#simply-errors\">error reply</a>.<br>The helper accepts a single string argument and returns a Lua table with the <code>err</code> field set to that string.</p>\n<p>The outcome of the following code is that <code>error1</code> and <code>error2</code> are identical for all intents and purposes:</p>\n<pre><code class=\"language-lua\">local text = &#39;ERR My very special error&#39;\nlocal reply1 = { err = text }\nlocal reply2 = server.error_reply(text)\n</code></pre>\n<p>Therefore, both forms are valid as means for returning an error reply from scripts:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { err = &#39;ERR My very special table error&#39; }&quot; 0\n(error) ERR My very special table error\n127.0.0.1:6379&gt; EVAL &quot;return server.error_reply(&#39;ERR My very special reply error&#39;)&quot; 0\n(error) ERR My very special reply error\n</code></pre>\n<p>For returning Valkey status replies refer to <a href=\"#server.status_reply\"><code>server.status_reply()</code></a>.<br>Refer to the <a href=\"#data-type-conversion\">Data type conversion</a> for returning other response types.</p>\n<p><strong>Note:</strong><br>By convention, Valkey uses the first word of an error string as a unique error code for specific errors or <code>ERR</code> for general-purpose errors.<br>Scripts are advised to follow this convention, as shown in the example above, but this is not mandatory.</p>\n<h3><a name=\"server.status_reply\"></a> <code>server.status_reply(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This is a helper function that returns a <a href=\"protocol.md#simple-strings\">simple string reply</a>.<br>&quot;OK&quot; is an example of a standard Valkey status reply.<br>The Lua API represents status replies as tables with a single field, <code>ok</code>, set with a simple status string.</p>\n<p>The outcome of the following code is that <code>status1</code> and <code>status2</code> are identical for all intents and purposes:</p>\n<pre><code class=\"language-lua\">local text = &#39;Frosty&#39;\nlocal status1 = { ok = text }\nlocal status2 = server.status_reply(text)\n</code></pre>\n<p>Therefore, both forms are valid as means for returning status replies from scripts:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { ok = &#39;TICK&#39; }&quot; 0\nTICK\n127.0.0.1:6379&gt; EVAL &quot;return server.status_reply(&#39;TOCK&#39;)&quot; 0\nTOCK\n</code></pre>\n<p>For returning Valkey error replies refer to <a href=\"#server.error_reply\"><code>server.error_reply()</code></a>.<br>Refer to the <a href=\"#data-type-conversion\">Data type conversion</a> for returning other response types.</p>\n<h3><a name=\"server.sha1hex\"></a> <code>server.sha1hex(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function returns the SHA1 hexadecimal digest of its single string argument.</p>\n<p>You can, for example, obtain the empty string&#39;s SHA1 digest:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return server.sha1hex(&#39;&#39;)&quot; 0\n&quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;\n</code></pre>\n<h3><a name=\"server.log\"></a> <code>server.log(level, message)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function writes to the Valkey server log.</p>\n<p>It expects two input arguments: the log level and a message.<br>The message is a string to write to the log file.<br>Log level can be on of these:</p>\n<ul>\n<li><code>server.LOG_DEBUG</code></li>\n<li><code>server.LOG_VERBOSE</code></li>\n<li><code>server.LOG_NOTICE</code></li>\n<li><code>server.LOG_WARNING</code></li>\n</ul>\n<p>These levels map to the server&#39;s log levels.<br>The log only records messages equal or greater in level than the server&#39;s <code>loglevel</code> configuration directive.</p>\n<p>The following snippet:</p>\n<pre><code class=\"language-lua\">server.log(server.LOG_WARNING, &#39;Something is terribly wrong&#39;)\n</code></pre>\n<p>will produce a line similar to the following in your server&#39;s log:</p>\n<pre><code>[32343] 22 Mar 15:21:39 # Something is terribly wrong\n</code></pre>\n<h3><a name=\"server.setresp\"></a> <code>server.setresp(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function allows the executing script to switch between <a href=\"protocol.md\">RESP</a> protocol versions for the replies returned by <a href=\"#server.call\"><code>server.call()</code></a> and <a href=\"#server.pcall\"><code>server.pcall()</code></a>.<br>It expects a single numerical argument as the protocol&#39;s version.<br>The default protocol version is <em>2</em>, but it can be switched to version <em>3</em>.</p>\n<p>Here&#39;s an example of switching to RESP3 replies:</p>\n<pre><code class=\"language-lua\">server.setresp(3)\n</code></pre>\n<p>Please refer to the <a href=\"#data-type-conversion\">Data type conversion</a> for more information about type conversions.</p>\n<h3><a name=\"server.set_repl\"></a> <code>server.set_repl(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p><strong>Note:</strong><br>Prior to Redis OSS 7.0, scripts were replicated verbatim by default.<br>Since Redis OSS 7.0 (and Valkey), script effects replication is the only replication mode available.</p>\n<p>The <code>server.set_repl()</code> function instructs the server how to treat subsequent write commands in terms of replication.<br>It accepts a single input argument that only be one of the following:</p>\n<ul>\n<li><code>server.REPL_ALL</code>: replicates the effects to the AOF and replicas.</li>\n<li><code>server.REPL_AOF</code>: replicates the effects to the AOF alone.</li>\n<li><code>server.REPL_REPLICA</code>: replicates the effects to the replicas alone.</li>\n<li><code>server.REPL_SLAVE</code>: same as <code>REPL_REPLICA</code>, maintained for backward compatibility.</li>\n<li><code>server.REPL_NONE</code>: disables effect replication entirely.</li>\n</ul>\n<p>By default, the scripting engine is initialized to the <code>server.REPL_ALL</code> setting when a script begins its execution.<br>You can call the <code>server.set_repl()</code> function at any time during the script&#39;s execution to switch between the different replication modes.</p>\n<p>A simple example follows:</p>\n<pre><code class=\"language-lua\">server.replicate_commands() -- Enable effects replication in versions lower than Redis OSS v7.0\nserver.call(&#39;SET&#39;, KEYS[1], ARGV[1])\nserver.set_repl(server.REPL_NONE)\nserver.call(&#39;SET&#39;, KEYS[2], ARGV[2])\nserver.set_repl(server.REPL_ALL)\nserver.call(&#39;SET&#39;, KEYS[3], ARGV[3])\n</code></pre>\n<p>If you run this script by calling <code>EVAL &quot;...&quot; 3 A B C 1 2 3</code>, the result will be that only the keys <em>A</em> and <em>C</em> are created on the replicas and AOF.</p>\n<h3><a name=\"server.replicate_commands\"></a> <code>server.replicate_commands()</code></h3>\n<ul>\n<li>Until version: 7.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p>This function switches the script&#39;s replication mode from verbatim replication to effects replication.<br>You can use it to override the default verbatim script replication mode used by Redis OSS until version 7.0.</p>\n<p><strong>Note:</strong><br>Verbatim script replication is no longer supported.<br>The only script replication mode supported is script effects&#39; replication.<br>For more information, please refer to <a href=\"eval-intro.md#replicating-commands-instead-of-scripts\"><code>Replicating commands instead of scripts</code></a></p>\n<h3><a name=\"server.breakpoint\"></a>  <code>server.breakpoint()</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p>This function triggers a breakpoint when using the <a href=\"ldb.md\">Valkey Lua debugger</a>.</p>\n<h3><a name=\"server.debug\"></a> <code>server.debug(x)</code></h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: no</li>\n</ul>\n<p>This function prints its argument in the <a href=\"ldb.md\">Valkey Lua debugger</a> console.</p>\n<h3><a name=\"server.acl_check_cmd\"></a> <code>server.acl_check_cmd(command [,arg...])</code></h3>\n<ul>\n<li>Since version: 7.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function is used for checking if the current user running the script has <a href=\"acl.md\">ACL</a> permissions to execute the given command with the given arguments.</p>\n<p>The return value is a boolean <code>true</code> in case the current user has permissions to execute the command (via a call to <a href=\"#server.call\">server.call</a> or <a href=\"#server.pcall\">server.pcall</a>) or <code>false</code> in case they don&#39;t.</p>\n<p>The function will raise an error if the passed command or its arguments are invalid.</p>\n<h3><a name=\"server.register_function\"></a> <code>server.register_function</code></h3>\n<ul>\n<li>Since version: 7.0.0</li>\n<li>Available in scripts: no</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>This function is only available from the context of the <code>FUNCTION LOAD</code> command.<br>When called, it registers a function to the loaded library.<br>The function can be called either with positional or named arguments.</p>\n<h4><a name=\"server.register_function_pos_args\"></a> positional arguments: <code>server.register_function(name, callback)</code></h4>\n<p>The first argument to <code>server.register_function</code> is a Lua string representing the function name.<br>The second argument to <code>server.register_function</code> is a Lua function.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LOAD &quot;#!lua name=mylib\\n server.register_function(&#39;noop&#39;, function() end)&quot;\n</code></pre>\n<h4><a name=\"server.register_function_named_args\"></a> Named arguments:  <code>server.register_function{function_name=name, callback=callback, flags={flag1, flag2, ..}, description=description}</code></h4>\n<p>The named arguments variant accepts the following arguments:</p>\n<ul>\n<li><em>function_name</em>: the function&#39;s name.</li>\n<li><em>callback</em>: the function&#39;s callback.</li>\n<li><em>flags</em>: an array of strings, each a function flag (optional).</li>\n<li><em>description</em>: function&#39;s description (optional).</li>\n</ul>\n<p>Both <em>function_name</em> and <em>callback</em> are mandatory.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LOAD &quot;#!lua name=mylib\\n server.register_function{function_name=&#39;noop&#39;, callback=function() end, flags={ &#39;no-writes&#39; }, description=&#39;Does nothing&#39;}&quot;\n</code></pre>\n<h4><a name=\"script_flags\"></a> Script flags</h4>\n<p><strong>Important:</strong><br>Use script flags with care, which may negatively impact if misused.<br>Note that the default for Eval scripts are different than the default for functions that are mentioned below, see <a href=\"eval-intro.md#eval-flags\">Eval Flags</a></p>\n<p>When you register a function or load an Eval script, the server does not know how it accesses the database.<br>By default, Valkey assumes that all scripts read and write data.<br>This results in the following behavior:</p>\n<ol>\n<li>They can read and write data.</li>\n<li>They can run in cluster mode, and are not able to run commands accessing keys of different hash slots.</li>\n<li>Execution against a stale replica is denied to avoid inconsistent reads.</li>\n<li>Execution under low memory is denied to avoid exceeding the configured threshold.</li>\n</ol>\n<p>You can use the following flags and instruct the server to treat the scripts&#39; execution differently:</p>\n<ul>\n<li><p><code>no-writes</code>: this flag indicates that the script only reads data but never writes.</p>\n<p>  By default, Valkey will deny the execution of flagged scripts (Functions and Eval scripts with <a href=\"eval-intro.md#eval-flags\">shebang</a>) against read-only replicas, as they may attempt to perform writes.<br>  Similarly, the server will not allow calling scripts with <code>FCALL_RO</code> / <code>EVAL_RO</code>.<br>  Lastly, when data persistence is at risk due to a disk error, execution is blocked as well.</p>\n<p>  Using this flag allows executing the script:</p>\n<ol>\n<li>With <code>FCALL_RO</code> / <code>EVAL_RO</code></li>\n<li>On read-only replicas.</li>\n<li>Even if there&#39;s a disk error (Valkey is unable to persist so it rejects writes).</li>\n<li>When over the memory limit since it implies the script doesn&#39;t increase memory consumption (see <code>allow-oom</code> below)</li>\n</ol>\n<p>  However, note that the server will return an error if the script attempts to call a write command.<br>  Also note that currently <code>PUBLISH</code>, <code>SPUBLISH</code> and <code>PFCOUNT</code> are also considered write commands in scripts, because they could attempt to propagate commands to replicas and AOF file.</p>\n<p>  For more information please refer to <a href=\"programmability.md#read-only_scripts\">Read-only scripts</a></p>\n</li>\n<li><p><code>allow-oom</code>: use this flag to allow a script to execute when the server is out of memory (OOM).</p>\n<p>  Unless used, Valkey will deny the execution of flagged scripts (Functions and Eval scripts with <a href=\"eval-intro.md#eval-flags\">shebang</a>) when in an OOM state.<br>  Furthermore, when you use this flag, the script can call any Valkey command, including commands that aren&#39;t usually allowed in this state.<br>  Specifying <code>no-writes</code> or using <code>FCALL_RO</code> / <code>EVAL_RO</code> also implies the script can run in OOM state (without specifying <code>allow-oom</code>)</p>\n</li>\n<li><p><code>allow-stale</code>: a flag that enables running the flagged scripts (Functions and Eval scripts with <a href=\"eval-intro.md#eval-flags\">shebang</a>) against a stale replica when the <code>replica-serve-stale-data</code> config is set to <code>no</code> .</p>\n<p>  Valkey can be set to prevent data consistency problems from using old data by having stale replicas return a runtime error.<br>  For scripts that do not access the data, this flag can be set to allow stale Valkey replicas to run the script.<br>  Note however that the script will still be unable to execute any command that accesses stale data.</p>\n</li>\n<li><p><code>no-cluster</code>: the flag causes the script to return an error in Valkey cluster mode.</p>\n<p>  Valkey allows scripts to be executed both in standalone and cluster modes.<br>  Setting this flag prevents executing the script against nodes in the cluster.</p>\n</li>\n<li><p><code>allow-cross-slot-keys</code>: The flag that allows a script to access keys from multiple slots.</p>\n<p>  Valkey typically prevents any single command from accessing keys that hash to multiple slots.<br>  This flag allows scripts to break this rule and access keys within the script that access multiple slots.<br>  Declared keys to the script are still always required to hash to a single slot.<br>  Accessing keys from multiple slots is discouraged as applications should be designed to only access keys from a single slot at a time, allowing slots to move between Valkey servers.</p>\n<p>  This flag has no effect when cluster mode is disabled.</p>\n</li>\n</ul>\n<p>Please refer to <a href=\"functions-intro.md#function-flags\">Function Flags</a> and <a href=\"eval-intro.md#eval-flags\">Eval Flags</a> for a detailed example.</p>\n<h3><a name=\"server.server_version\"></a> <code>server.SERVER_VERSION</code></h3>\n<ul>\n<li>Since version: 7.2.5</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>Returns the current Valkey server version as a Lua string.<br>The reply&#39;s format is <code>MM.mm.PP</code>, where:</p>\n<ul>\n<li><strong>MM:</strong> is the major version.</li>\n<li><strong>mm:</strong> is the minor version.</li>\n<li><strong>PP:</strong> is the patch level.</li>\n</ul>\n<h3><a name=\"server.redis_version\"></a> <code>server.REDIS_VERSION</code></h3>\n<ul>\n<li>Since version: 7.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>Returns the current Redis compatibility version as a Lua string.<br>The reply&#39;s format is <code>MM.mm.PP</code>, where:</p>\n<ul>\n<li><strong>MM:</strong> is the major version.</li>\n<li><strong>mm:</strong> is the minor version.</li>\n<li><strong>PP:</strong> is the patch level.</li>\n</ul>\n<h3><a name=\"server.redis_version_num\"></a> <code>server.SERVER_VERSION_NUM</code></h3>\n<ul>\n<li>Since version: 7.2.5</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>Returns the current Valkey server version as a number.<br>The reply is a hexadecimal value structured as <code>0x00MMmmPP</code>, where:</p>\n<ul>\n<li><strong>MM:</strong> is the major version.</li>\n<li><strong>mm:</strong> is the minor version.</li>\n<li><strong>PP:</strong> is the patch level.</li>\n</ul>\n<h3><a name=\"server.redis_version_num\"></a> <code>server.REDIS_VERSION_NUM</code></h3>\n<ul>\n<li>Since version: 7.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>Returns the current Redis compatibility version as a number.<br>The reply is a hexadecimal value structured as <code>0x00MMmmPP</code>, where:</p>\n<ul>\n<li><strong>MM:</strong> is the major version.</li>\n<li><strong>mm:</strong> is the minor version.</li>\n<li><strong>PP:</strong> is the patch level.</li>\n</ul>\n<h2>Data type conversion</h2>\n<p>Unless a runtime exception is raised, <code>server.call()</code> and <code>server.pcall()</code> return the reply from the executed command to the Lua script.<br>Valkey&#39;s replies from these functions are converted automatically into Lua&#39;s native data types.</p>\n<p>Similarly, when a Lua script returns a reply with the <code>return</code> keyword,<br>that reply is automatically converted to RESP protocol.</p>\n<p>Put differently: There&#39;s a one-to-one mapping between Valkey&#39;s replies and Lua&#39;s data types and a one-to-one mapping between Lua&#39;s data types and the <a href=\"protocol.md\">RESP Protocol</a> data types.<br>The underlying design is such that if a RESP type is converted into a Lua type and converted back into a RESP type, the result is the same as the initial value.</p>\n<p>Type conversion from Valkey replies (i.e. the replies from <code>server.call()</code> and <code>server.pcall()</code>) to Lua data types depends on the RESP protocol version used by the script.<br>The default protocol version during script executions is RESP2.<br>The script may switch the replies&#39; protocol versions by calling the <code>server.setresp()</code> function.</p>\n<p>Type conversion from a script&#39;s returned Lua data type depends on the user&#39;s choice of protocol (see the <code>HELLO</code> command).</p>\n<p>The following sections describe the type conversion rules between Lua and Valkey per the protocol&#39;s version.</p>\n<h3>RESP2 to Lua type conversion</h3>\n<p>The following type conversion rules apply to the execution&#39;s context by default as well as after calling <code>server.setresp(2)</code>:</p>\n<ul>\n<li><a href=\"protocol.md#integers\">RESP2 integer reply</a> -&gt; Lua number</li>\n<li><a href=\"protocol.md#bulk-strings\">RESP2 bulk string reply</a> -&gt; Lua string</li>\n<li><a href=\"protocol.md#arrays\">RESP2 array reply</a> -&gt; Lua table (may have other Valkey data types nested)</li>\n<li><a href=\"protocol.md#simple-strings\">RESP2 status reply</a> -&gt; Lua table with a single <em>ok</em> field containing the status string</li>\n<li><a href=\"protocol.md#simple-errors\">RESP2 error reply</a> -&gt; Lua table with a single <em>err</em> field containing the error string</li>\n<li><a href=\"protocol.md#nulls\">RESP2 null bulk reply and null multi bulk reply</a> -&gt; Lua false boolean type</li>\n</ul>\n<h2>Lua to RESP2 type conversion</h2>\n<p>The following type conversion rules apply by default as well as after the user had called <code>HELLO 2</code>:</p>\n<ul>\n<li>Lua number -&gt; <a href=\"protocol.md#integers\">RESP2 integer reply</a> (the number is converted into an integer)</li>\n<li>Lua string -&gt; <a href=\"protocol.md#bulk-strings\">RESP bulk string reply</a></li>\n<li>Lua table (indexed, non-associative array) -&gt; <a href=\"protocol.md#arrays\">RESP2 array reply</a> (truncated at the first Lua <code>nil</code> value encountered in the table, if any)</li>\n<li>Lua table with a single <em>ok</em> field -&gt; <a href=\"protocol.md#simple-strings\">RESP2 status reply</a></li>\n<li>Lua table with a single <em>err</em> field -&gt; <a href=\"protocol.md#simple-errors\">RESP2 error reply</a></li>\n<li>Lua boolean false -&gt; <a href=\"protocol.md#nulls\">RESP2 null bulk reply</a></li>\n</ul>\n<p>There is an additional Lua-to-Valkey conversion rule that has no corresponding Valkey-to-Lua conversion rule:</p>\n<ul>\n<li>Lua Boolean <code>true</code> -&gt; <a href=\"protocol.md#integers\">RESP2 integer reply</a> with value of 1.</li>\n</ul>\n<p>There are three additional rules to note about converting Lua to Valkey data types:</p>\n<ul>\n<li>Lua has a single numerical type, Lua numbers.<br>There is no distinction between integers and floats.<br>So we always convert Lua numbers into integer replies, removing the decimal part of the number, if any.<br><strong>If you want to return a Lua float, it should be returned as a string</strong>,<br>exactly like Valkey itself does (see, for instance, the <code>ZSCORE</code> command).</li>\n<li>There&#39;s <a href=\"https://www.lua.org/pil/19.1.html\">no simple way to have nils inside Lua arrays</a> due<br>to Lua&#39;s table semantics.<br>Therefore, when Valkey converts a Lua array to RESP, the conversion stops when it encounters a Lua <code>nil</code> value.</li>\n<li>When a Lua table is an associative array that contains keys and their respective values, the converted Valkey reply will <strong>not</strong> include them.</li>\n</ul>\n<p>Lua to RESP2 type conversion examples:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return 10&quot; 0\n(integer) 10\n\n127.0.0.1:6379&gt; EVAL &quot;return { 1, 2, { 3, &#39;Hello World!&#39; } }&quot; 0\n1) (integer) 1\n2) (integer) 2\n3) 1) (integer) 3\n   1) &quot;Hello World!&quot;\n\n127.0.0.1:6379&gt; EVAL &quot;return server.call(&#39;get&#39;,&#39;foo&#39;)&quot; 0\n&quot;bar&quot;\n</code></pre>\n<p>The last example demonstrates receiving and returning the exact return value of <code>server.call()</code> (or <code>server.pcall()</code>) in Lua as it would be returned if the command had been called directly.</p>\n<p>The following example shows how floats and arrays that cont nils and keys are handled:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { 1, 2, 3.3333, somekey = &#39;somevalue&#39;, &#39;foo&#39;, nil , &#39;bar&#39; }&quot; 0\n1) (integer) 1\n2) (integer) 2\n3) (integer) 3\n4) &quot;foo&quot;\n</code></pre>\n<p>As you can see, the float value of <em>3.333</em> gets converted to an integer <em>3</em>, the <em>somekey</em> key and its value are omitted, and the string &quot;bar&quot; isn&#39;t returned as there is a <code>nil</code> value that precedes it.</p>\n<h3>RESP3 to Lua type conversion</h3>\n<p>RESP3 is a newer version of the <a href=\"protocol.md\">protocol</a> used by Valkey.<br>It is available as an opt-in choice.</p>\n<p>An executing script may call the <a href=\"#server.setresp\"><code>server.setresp</code></a> function during its execution and switch the protocol version that&#39;s used for returning replies from Valkey&#39;s commands (that can be invoked via <a href=\"#server.call\"><code>server.call()</code></a> or <a href=\"#server.pcall\"><code>server.pcall()</code></a>).</p>\n<p>Once Valkey&#39;s replies are in RESP3 protocol, all of the <a href=\"#resp2-to-lua-type-conversion\">RESP2 to Lua conversion</a> rules apply, with the following additions:</p>\n<ul>\n<li><a href=\"protocol.md#maps\">Map reply</a> -&gt; Lua table with a single <em>map</em> field containing a Lua table representing the fields and values of the map.</li>\n<li><a href=\"protocol.md#sets\">Set reply</a> -&gt; Lua table with a single <em>set</em> field containing a Lua table representing the elements of the set as fields, each with the Lua Boolean value of <code>true</code>.</li>\n<li><a href=\"protocol.md#nulls\">Null</a> -&gt; Lua <code>nil</code>.</li>\n<li><a href=\"protocol.md#booleans\">True reply</a> -&gt; Lua true boolean value.</li>\n<li><a href=\"protocol.md#booleans\">False reply</a> -&gt; Lua false boolean value.</li>\n<li><a href=\"protocol.md#doubles\">Double reply</a> -&gt; Lua table with a single <code>double</code> field containing a Lua number representing the double value.</li>\n<li><a href=\"protocol.md#big-numbers\">Big number reply</a> -&gt; Lua table with a single <code>big_number</code> field containing a Lua string representing the big number value (since Redis OSS 7.0).</li>\n<li><a href=\"protocol.md#verbatim-strings\">Verbatim string reply</a> -&gt; Lua table with a single <code>verbatim_string</code> field containing a Lua table with two fields, <code>string</code> and <code>format</code>, representing the verbatim string and its format, respectively (since Redis OSS 7.0).</li>\n</ul>\n<h3>Lua to RESP3 type conversion</h3>\n<p>Regardless of the script&#39;s choice of protocol version set for replies with the [<code>server.setresp()</code> function] when it calls <code>server.call()</code> or <code>server.pcall()</code>, the user may opt-in to using RESP3 (with the <code>HELLO 3</code> command) for the connection.<br>Although the default protocol for incoming client connections is RESP2, the script should honor the user&#39;s preference and return adequately-typed RESP3 replies, so the following rules apply on top of those specified in the <a href=\"#lua-to-resp2-type-conversion\">Lua to RESP2 type conversion</a> section when that is the case.</p>\n<ul>\n<li>Lua Boolean -&gt; <a href=\"protocol.md#booleans\">RESP3 Boolean reply</a> (note that this is a change compared to the RESP2, in which returning a Boolean Lua <code>true</code> returned the number 1 to the Valkey client, and returning a <code>false</code> used to return a <code>null</code>.</li>\n<li>Lua table with a single <code>map</code> field set to an associative Lua table -&gt; <a href=\"protocol.md#maps\">RESP3 map reply</a>.</li>\n<li>Lua table with a single <code>set</code> field set to an associative Lua table -&gt; <a href=\"protocol.md#sets\">RESP3 set reply</a>. Values can be set to anything and are discarded anyway.</li>\n<li>Lua table with a single <code>double</code> field to an associative Lua table -&gt; <a href=\"protocol.md#doubles\">RESP3 double reply</a>.</li>\n<li>Lua nil -&gt; <a href=\"protocol.md#nulls\">RESP3 null</a>.</li>\n</ul>\n<p>However, if the connection is set use the RESP2 protocol, and even if the script replies with RESP3-typed responses, Valkey will automatically perform a RESP3 to RESP2 conversion of the reply as is the case for regular commands.<br>That means, for example, that returning the RESP3 map type to a RESP2 connection will result in the reply being converted to a flat RESP2 array that consists of alternating field names and their values, rather than a RESP3 map.</p>\n<h2>Additional notes about scripting</h2>\n<h3>Using <code>SELECT</code> inside scripts</h3>\n<p>You can call the <code>SELECT</code> command from your Lua scripts, like you can with any normal client connection.<br>The database selected by the Lua script only affects the execution context of the script, and does not modify the database that&#39;s selected by the client calling the script.</p>\n<h2>Runtime libraries</h2>\n<p>The Valkey Lua runtime context always comes with several pre-imported libraries.</p>\n<p>The following <a href=\"https://www.lua.org/manual/5.1/manual.html#5\">standard Lua libraries</a> are available to use:</p>\n<ul>\n<li>The <a href=\"https://www.lua.org/manual/5.1/manual.html#5.4\"><em>String Manipulation (string)</em> library</a></li>\n<li>The <a href=\"https://www.lua.org/manual/5.1/manual.html#5.5\"><em>Table Manipulation (table)</em> library</a></li>\n<li>The <a href=\"https://www.lua.org/manual/5.1/manual.html#5.6\"><em>Mathematical Functions (math)</em> library</a></li>\n<li>The <a href=\"#os-library\"><em>Operating System Facilities (os)</em> library</a></li>\n</ul>\n<p>In addition, the following external libraries are loaded and accessible to scripts:</p>\n<ul>\n<li>The <a href=\"#struct-library\"><em>struct</em> library</a></li>\n<li>The <a href=\"#cjson-library\"><em>cjson</em> library</a></li>\n<li>The <a href=\"#cmsgpack-library\"><em>cmsgpack</em> library</a></li>\n<li>The <a href=\"#bitop-library\"><em>bitop</em> library</a></li>\n</ul>\n<h3><a name=\"os-library\"></a> <em>os</em> library</h3>\n<ul>\n<li>Since version: 8.0.0</li>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p><em>os</em> provides a set of functions for dealing with date, time, and system commands.<br>More details can be found in the <a href=\"https://www.lua.org/manual/5.1/manual.html#5.8\">Operating System Facilities</a>.<br>Note that for sandbox security, currently only the following os functions is exposed:</p>\n<ul>\n<li><code>os.clock()</code></li>\n</ul>\n<h3><a name=\"struct-library\"></a> <em>struct</em> library</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p><em>struct</em> is a library for packing and unpacking C-like structures in Lua.<br>It provides the following functions:</p>\n<ul>\n<li><a href=\"#struct.pack\"><code>struct.pack()</code></a></li>\n<li><a href=\"#struct.unpack\"><code>struct.unpack()</code></a></li>\n<li><a href=\"#struct.size\"><code>struct.size()</code></a></li>\n</ul>\n<p>All of <em>struct</em>&#39;s functions expect their first argument to be a <a href=\"#struct-formats\">format string</a>.</p>\n<h4><a name=\"struct-formats\"></a> <em>struct</em> formats</h4>\n<p>The following are valid format strings for <em>struct</em>&#39;s functions:</p>\n<ul>\n<li><code>&gt;</code>: big endian</li>\n<li><code>&lt;</code>: little endian</li>\n<li><code>![num]</code>: alignment</li>\n<li><code>x</code>: padding</li>\n<li><code>b/B</code>: signed/unsigned byte</li>\n<li><code>h/H</code>: signed/unsigned short</li>\n<li><code>l/L</code>: signed/unsigned long</li>\n<li><code>T</code>: size_t</li>\n<li><code>i/In</code>: signed/unsigned integer with size <em>n</em> (defaults to the size of int)</li>\n<li><code>cn</code>: sequence of <em>n</em> chars (from/to a string); when packing, n == 0 means the<br>whole string; when unpacking, n == 0 means use the previously read number as<br>the string&#39;s length.</li>\n<li><code>s</code>: zero-terminated string</li>\n<li><code>f</code>: float</li>\n<li><code>d</code>: double</li>\n<li><code> </code> (space): ignored</li>\n</ul>\n<h4><a name=\"struct.pack\"></a> <code>struct.pack(x)</code></h4>\n<p>This function returns a struct-encoded string from values.<br>It accepts a <a href=\"#struct-formats\"><em>struct</em> format string</a> as its first argument, followed by the values that are to be encoded.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return struct.pack(&#39;HH&#39;, 1, 2)&quot; 0\n&quot;\\x01\\x00\\x02\\x00&quot;\n</code></pre>\n<h4><a name=\"struct.unpack\"></a> <code>struct.unpack(x)</code></h4>\n<p>This function returns the decoded values from a struct.<br>It accepts a <a href=\"#struct-formats\"><em>struct</em> format string</a> as its first argument, followed by encoded struct&#39;s string.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return { struct.unpack(&#39;HH&#39;, ARGV[1]) }&quot; 0 &quot;\\x01\\x00\\x02\\x00&quot;\n1) (integer) 1\n2) (integer) 2\n3) (integer) 5\n</code></pre>\n<h4><a name=\"struct.size\"></a> <code>struct.size(x)</code></h4>\n<p>This function returns the size, in bytes, of a struct.<br>It accepts a <a href=\"#struct-formats\"><em>struct</em> format string</a> as its only argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return struct.size(&#39;HH&#39;)&quot; 0\n(integer) 4\n</code></pre>\n<h3><a name=\"cjson-library\"></a> <em>cjson</em> library</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <em>cjson</em> library provides fast <a href=\"https://json.org\">JSON</a> encoding and decoding from Lua.<br>It provides these functions.</p>\n<h4><a name=\"cjson.encode()\"></a> <code>cjson.encode(x)</code></h4>\n<p>This function returns a JSON-encoded string for the Lua data type provided as its argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return cjson.encode({ [&#39;foo&#39;] = &#39;bar&#39; })&quot; 0\n&quot;{\\&quot;foo\\&quot;:\\&quot;bar\\&quot;}&quot;\n</code></pre>\n<h4><a name=\"cjson.decode()\"></a> <code>cjson.decode(x)</code></h4>\n<p>This function returns a Lua data type from the JSON-encoded string provided as its argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return cjson.decode(ARGV[1])[&#39;foo&#39;]&quot; 0 &#39;{&quot;foo&quot;:&quot;bar&quot;}&#39;\n&quot;bar&quot;\n</code></pre>\n<h3><a name=\"cmsgpack-library\"></a> <em>cmsgpack</em> library</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <em>cmsgpack</em> library provides fast <a href=\"https://msgpack.org/index.html\">MessagePack</a> encoding and decoding from Lua.<br>It provides these functions.</p>\n<h4><a name=\"cmsgpack.pack()\"></a> <code>cmsgpack.pack(x)</code></h4>\n<p>This function returns the packed string encoding of the Lua data type it is given as an argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return cmsgpack.pack({&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;})&quot; 0\n&quot;\\x93\\xa3foo\\xa3bar\\xa3baz&quot;\n</code></pre>\n<h4><a name=\"cmsgpack.unpack()\"></a> <code>cmsgpack.unpack(x)</code></h4>\n<p>This function returns the unpacked values from decoding its input string argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &quot;return cmsgpack.unpack(ARGV[1])&quot; 0 &quot;\\x93\\xa3foo\\xa3bar\\xa3baz&quot;\n1) &quot;foo&quot;\n2) &quot;bar&quot;\n3) &quot;baz&quot;\n</code></pre>\n<h3><a name=\"bitop-library\"></a> <em>bit</em> library</h3>\n<ul>\n<li>Available in scripts: yes</li>\n<li>Available in functions: yes</li>\n</ul>\n<p>The <em>bit</em> library provides bitwise operations on numbers.<br>Its documentation resides at <a href=\"https://bitop.luajit.org/api.html\">Lua BitOp documentation</a><br>It provides the following functions.</p>\n<h4><a name=\"bit.tobit()\"></a> <code>bit.tobit(x)</code></h4>\n<p>Normalizes a number to the numeric range for bit operations and returns it.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &#39;return bit.tobit(1)&#39; 0\n(integer) 1\n</code></pre>\n<h4><a name=\"bit.tohex()\"></a> <code>bit.tohex(x [,n])</code></h4>\n<p>Converts its first argument to a hex string. The number of hex digits is given by the absolute value of the optional second argument.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &#39;return bit.tohex(422342)&#39; 0\n&quot;000671c6&quot;\n</code></pre>\n<h4><a name=\"bit.bnot()\"></a> <code>bit.bnot(x)</code></h4>\n<p>Returns the bitwise <strong>not</strong> of its argument.</p>\n<h4><a name=\"bit.ops\"></a> <code>bit.bnot(x)</code> <code>bit.bor(x1 [,x2...])</code>, <code>bit.band(x1 [,x2...])</code> and <code>bit.bxor(x1 [,x2...])</code></h4>\n<p>Returns either the bitwise <strong>or</strong>, bitwise <strong>and</strong>, or bitwise <strong>xor</strong> of all of its arguments.<br>Note that more than two arguments are allowed.</p>\n<p>Usage example:</p>\n<pre><code>127.0.0.1:6379&gt; EVAL &#39;return bit.bor(1,2,4,8,16,32,64,128)&#39; 0\n(integer) 255\n</code></pre>\n<h4><a name=\"bit.shifts\"></a> <code>bit.lshift(x, n)</code>, <code>bit.rshift(x, n)</code> and <code>bit.arshift(x, n)</code></h4>\n<p>Returns either the bitwise logical <strong>left-shift</strong>, bitwise logical <strong>right-shift</strong>, or bitwise <strong>arithmetic right-shift</strong> of its first argument by the number of bits given by the second argument.</p>\n<h4><a name=\"bit.ro\"></a> <code>bit.rol(x, n)</code> and <code>bit.ror(x, n)</code></h4>\n<p>Returns either the bitwise <strong>left rotation</strong>, or bitwise <strong>right rotation</strong> of its first argument by the number of bits given by the second argument.<br>Bits shifted out on one side are shifted back in on the other side.</p>\n<h4><a name=\"bit.bswap()\"></a> <code>bit.bswap(x)</code></h4>\n<p>Swaps the bytes of its argument and returns it.<br>This can be used to convert little-endian 32-bit numbers to big-endian 32-bit numbers and vice versa.</p>\n"
      },
      {
        "id": "functions-intro",
        "topicName": "Functions",
        "description": "Scripting with functions stored on the server\n",
        "htmlContent": "<p>Valkey Functions is an API for managing code to be executed on the server.<br>This feature is as a complement to <a href=\"eval-intro.md\">EVAL scripts</a>.</p>\n<h2>What&#39;s wrong with EVAL?</h2>\n<p>There&#39;s nothing wrong with <code>EVAL</code>, but there are some differences between EVAL scripts and Functions.<br>With the <a href=\"../commands/eval.md\"><code>EVAL</code></a> command, scripts are sent to the server for immediate execution.<br>The core use cases for <code>EVAL</code> scripts is executing part of your application logic inside Valkey, efficiently and atomically.<br>Such script can perform conditional updates across multiple keys, possibly combining several different data types.</p>\n<p>Using <code>EVAL</code> requires that the application sends the entire script for execution every time.<br>Because this results in network and script compilation overheads, Valkey provides an optimization in the form of the <a href=\"../commands/evalsha.md\"><code>EVALSHA</code></a> command.<br>By first calling <a href=\"../commands/script-load.md\"><code>SCRIPT LOAD</code></a> to obtain the script&#39;s SHA1, the application can invoke it repeatedly afterward with its digest alone.</p>\n<p>Valkey only caches the loaded scripts.<br>That means that the script cache can become lost at any time, such as after calling <code>SCRIPT FLUSH</code>, after restarting the server, or when failing over to a replica.<br>The application is responsible for reloading scripts during runtime if any are missing.<br>The underlying assumption is that scripts are a part of the application and not maintained by the Valkey server.</p>\n<p>This approach suits many light-weight scripting use cases, but introduces several difficulties once an application becomes complex and relies more heavily on scripting, namely:</p>\n<ol>\n<li>All client application instances must maintain a copy of all scripts. That means having some mechanism that applies script updates to all of the application&#39;s instances.</li>\n<li>Calling cached scripts within the context of a <a href=\"transactions.md\">transaction</a> increases the probability of the transaction failing because of a missing script. Being more likely to fail makes using cached scripts as building blocks of workflows less attractive.</li>\n<li>SHA1 digests are not readable for humans, making debugging the system hard (e.g. in a <a href=\"../commands/monitor.md\"><code>MONITOR</code></a> session).</li>\n<li>When used naively, <code>EVAL</code> promotes an anti-pattern in which the client application renders verbatim scripts instead of responsibly using the <a href=\"lua-api.md#runtime-globals\"><code>KEYS</code> and <code>ARGV</code> Lua APIs</a>.</li>\n<li>Because they are ephemeral, a script can&#39;t call another script. This makes sharing and reusing code between scripts nearly impossible, short of client-side preprocessing.</li>\n</ol>\n<p>To address these needs while avoiding breaking changes to already-established and well-liked ephemeral scripts, functions were introduced in version 7.0.</p>\n<h2>What are Valkey Functions?</h2>\n<p>Functions provide the same core functionality as scripts but are first-class artifacts of the database.<br>Valkey manages functions as an integral part of the database and ensures their availability via data persistence and replication.<br>Because functions are part of the database and therefore declared before use, applications aren&#39;t required to load them during runtime nor risk aborted transactions.<br>An application that uses functions depends only on their APIs rather than on the embedded script logic in the database.</p>\n<p>Whereas ephemeral scripts are considered a part of the application&#39;s domain, functions extend the database server itself with user-provided logic.<br>They can be loaded at startup and be used repeatedly by various applications and clients.<br>Functions are also persisted to the AOF file and replicated from primary to replicas, so they are as durable as the data itself.<br>When Valkey is used as an ephemeral cache, additional mechanisms (described below) are required to make functions more durable.</p>\n<p>Functions also simplify development by enabling code sharing.<br>Every function has a user-defined name and belongs to a library, and a library can consist of multiple functions.<br>The library&#39;s contents are immutable, and selective updates of its functions aren&#39;t allowed.<br>Instead, libraries are updated as a whole with all of their functions together in one operation.<br>This allows calling functions from other functions within the same library, or sharing code between functions by using a common code in library-internal methods, that can also take language native arguments.</p>\n<p>Like all other operations in Valkey, the execution of a function is atomic.<br>A function&#39;s execution blocks all server activities during its entire time, similarly to the semantics of <a href=\"transactions.md\">transactions</a>.<br>These semantics mean that all of the script&#39;s effects either have yet to happen or had already happened.<br>The blocking semantics of an executed function apply to all connected clients at all times.<br>Because running a function blocks the Valkey server, functions are meant to finish executing quickly, so you should avoid using long-running functions.</p>\n<p>Functions are written in <a href=\"lua-api.md\">Lua 5.1</a>.<br>Valkey functions can use all of Lua&#39;s available capabilities to ephemeral scripts,<br>with the only exception being the <a href=\"ldb.md\">Valkey Lua scripts debugger</a>.</p>\n<h2>Loading libraries and functions</h2>\n<p>Let&#39;s explore Valkey Functions via some tangible examples and Lua snippets.</p>\n<p>At this point, if you&#39;re unfamiliar with Lua in general and specifically in Valkey, you may benefit from reviewing some of the examples in <a href=\"eval-intro.md\">Introduction to Eval Scripts</a> and <a href=\"lua-api.md\">Lua API</a> pages for a better grasp of the language.</p>\n<p>Every Valkey function belongs to a library.<br>Loading a library to the database is done with the <a href=\"../commands/function-load.md\"><code>FUNCTION LOAD</code></a> command.<br>The library source code must start with a Shebang line that provides metadata about the library, like the language (always &quot;lua&quot;) and the library name.<br>The Shebang format is:</p>\n<pre><code>#!lua name=&lt;library name&gt;\n</code></pre>\n<p>Let&#39;s try loading an empty library:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LOAD &quot;#!lua name=mylib\\n&quot;\n(error) ERR No functions registered\n</code></pre>\n<p>The error is expected, as there are no functions in the loaded library. Every library needs to include at least one registered function to load successfully.<br>A registered function is named and acts as an entry point to the library.<br>When the target execution engine handles the <code>FUNCTION LOAD</code> command, it registers the library&#39;s functions.</p>\n<p>The Lua engine compiles and evaluates the library source code when loaded, and expects functions to be registered by calling the <code>server.register_function()</code> API.</p>\n<p>The following snippet demonstrates a simple library registering a single function named <em>knockknock</em>, returning a string reply:</p>\n<pre><code class=\"language-lua\">#!lua name=mylib\nserver.register_function(\n  &#39;knockknock&#39;,\n  function() return &#39;Who\\&#39;s there?&#39; end\n)\n</code></pre>\n<p>In the example above, we provide two arguments about the function to Lua&#39;s <code>server.register_function()</code> API: its registered name and a callback.</p>\n<p>We can load our library and use <code>FCALL</code> to call the registered function:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LOAD &quot;#!lua name=mylib\\nserver.register_function(&#39;knockknock&#39;, function() return &#39;Who\\\\&#39;s there?&#39; end)&quot;\nmylib\n127.0.0.1:6379&gt; FCALL knockknock 0\n&quot;Who&#39;s there?&quot;\n</code></pre>\n<p>Notice that the <code>FUNCTION LOAD</code> command returns the name of the loaded library, this name can later be used <code>FUNCTION LIST</code> and <code>FUNCTION DELETE</code>.</p>\n<p>We&#39;ve provided <a href=\"../commands/fcall.md\"><code>FCALL</code></a> with two arguments: the function&#39;s registered name and the numeric value <code>0</code>. This numeric value indicates the number of key names that follow it (the same way <code>EVAL</code> and <code>EVALSHA</code> works).</p>\n<p>We&#39;ll explain immediately how key names and additional arguments are available to the function. As this simple example doesn&#39;t involve keys, we simply use 0 for now.</p>\n<h2>Input keys and regular arguments</h2>\n<p>Before we move to the following example, it is vital to understand the distinction Valkey makes between arguments that are names of keys and those that aren&#39;t.</p>\n<p>While key names in Valkey are just strings, unlike any other string values, these represent keys in the database.<br>The name of a key is a fundamental concept in Valkey and is the basis for operating the Valkey Cluster.</p>\n<p><strong>Important:</strong><br>To ensure the correct execution of Valkey Functions, both in standalone and clustered deployments, all names of keys that a function accesses must be explicitly provided as input key arguments.</p>\n<p>Any input to the function that isn&#39;t the name of a key is a regular input argument.</p>\n<p>Now, let&#39;s pretend that our application stores some of its data in Hashes.<br>We want an <a href=\"../commands/hset.md\"><code>HSET</code></a>-like way to set and update fields in said Hashes and store the last modification time in a new field named <code>_last_modified_</code>.<br>We can implement a function to do all that.</p>\n<p>Our function will call <a href=\"../commands/time.md\"><code>TIME</code></a> to get the server&#39;s clock reading and update the target Hash with the new fields&#39; values and the modification&#39;s timestamp.<br>The function we&#39;ll implement accepts the following input arguments: the Hash&#39;s key name and the field-value pairs to update.</p>\n<p>The Lua API for Valkey Functions makes these inputs accessible as the first and second arguments to the function&#39;s callback.<br>The callback&#39;s first argument is a Lua table populated with all key names inputs to the function.<br>Similarly, the callback&#39;s second argument consists of all regular arguments.</p>\n<p>The following is a possible implementation for our function and its library registration:</p>\n<pre><code class=\"language-lua\">#!lua name=mylib\n\nlocal function my_hset(keys, args)\n  local hash = keys[1]\n  local time = server.call(&#39;TIME&#39;)[1]\n  return server.call(&#39;HSET&#39;, hash, &#39;_last_modified_&#39;, time, unpack(args))\nend\n\nserver.register_function(&#39;my_hset&#39;, my_hset)\n</code></pre>\n<p>If we create a new file named <em>mylib.lua</em> that consists of the library&#39;s definition, we can load it like so (without stripping the source code of helpful whitespaces):</p>\n<pre><code class=\"language-bash\">$ cat mylib.lua | valkey-cli -x FUNCTION LOAD REPLACE\n</code></pre>\n<p>We&#39;ve added the <code>REPLACE</code> modifier to the call to <code>FUNCTION LOAD</code> to tell Valkey that we want to overwrite the existing library definition.<br>Otherwise, we would have gotten an error from Valkey complaining that the library already exists.</p>\n<p>Now that the library&#39;s updated code is loaded to Valkey, we can proceed and call our function:</p>\n<pre><code>127.0.0.1:6379&gt; FCALL my_hset 1 myhash myfield &quot;some value&quot; another_field &quot;another value&quot;\n(integer) 3\n127.0.0.1:6379&gt; HGETALL myhash\n1) &quot;_last_modified_&quot;\n2) &quot;1640772721&quot;\n3) &quot;myfield&quot;\n4) &quot;some value&quot;\n5) &quot;another_field&quot;\n6) &quot;another value&quot;\n</code></pre>\n<p>In this case, we had invoked <code>FCALL</code> with <em>1</em> as the number of key name arguments.<br>That means that the function&#39;s first input argument is a name of a key (and is therefore included in the callback&#39;s <code>keys</code> table).<br>After that first argument, all following input arguments are considered regular arguments and constitute the <code>args</code> table passed to the callback as its second argument.</p>\n<h2>Expanding the library</h2>\n<p>We can add more functions to our library to benefit our application.<br>The additional metadata field we&#39;ve added to the Hash shouldn&#39;t be included in responses when accessing the Hash&#39;s data.<br>On the other hand, we do want to provide the means to obtain the modification timestamp for a given Hash key.</p>\n<p>We&#39;ll add two new functions to our library to accomplish these objectives:</p>\n<ol>\n<li>The <code>my_hgetall</code> Valkey Function will return all fields and their respective values from a given Hash key name, excluding the metadata (i.e., the <code>_last_modified_</code> field).</li>\n<li>The <code>my_hlastmodified</code> Valkey Function will return the modification timestamp for a given Hash key name.</li>\n</ol>\n<p>The library&#39;s source code could look something like the following:</p>\n<pre><code class=\"language-lua\">#!lua name=mylib\n\nlocal function my_hset(keys, args)\n  local hash = keys[1]\n  local time = server.call(&#39;TIME&#39;)[1]\n  return server.call(&#39;HSET&#39;, hash, &#39;_last_modified_&#39;, time, unpack(args))\nend\n\nlocal function my_hgetall(keys, args)\n  server.setresp(3)\n  local hash = keys[1]\n  local res = server.call(&#39;HGETALL&#39;, hash)\n  res[&#39;map&#39;][&#39;_last_modified_&#39;] = nil\n  return res\nend\n\nlocal function my_hlastmodified(keys, args)\n  local hash = keys[1]\n  return server.call(&#39;HGET&#39;, hash, &#39;_last_modified_&#39;)\nend\n\nserver.register_function(&#39;my_hset&#39;, my_hset)\nserver.register_function(&#39;my_hgetall&#39;, my_hgetall)\nserver.register_function(&#39;my_hlastmodified&#39;, my_hlastmodified)\n</code></pre>\n<p>While all of the above should be straightforward, note that the <code>my_hgetall</code> also calls <a href=\"lua-api.md#server.setresp\"><code>server.setresp(3)</code></a>.<br>That means that the function expects <a href=\"protocol.md\">RESP3</a> replies after calling <code>server.call()</code>, which, unlike the default RESP2 protocol, returns the replies as maps (associative arrays).<br>Doing so allows the function to delete (or set to <code>nil</code> as is the case with Lua tables) specific fields from the reply, and in our case, the <code>_last_modified_</code> field.</p>\n<p>Assuming you&#39;ve saved the library&#39;s implementation in the <em>mylib.lua</em> file, you can replace it with:</p>\n<pre><code class=\"language-bash\">$ cat mylib.lua | valkey-cli -x FUNCTION LOAD REPLACE\n</code></pre>\n<p>Once loaded, you can call the library&#39;s functions with <code>FCALL</code>:</p>\n<pre><code>127.0.0.1:6379&gt; FCALL my_hgetall 1 myhash\n1) &quot;myfield&quot;\n2) &quot;some value&quot;\n3) &quot;another_field&quot;\n4) &quot;another value&quot;\n127.0.0.1:6379&gt; FCALL my_hlastmodified 1 myhash\n&quot;1640772721&quot;\n</code></pre>\n<p>You can also get the library&#39;s details with the <code>FUNCTION LIST</code> command:</p>\n<pre><code>127.0.0.1:6379&gt; FUNCTION LIST\n1) 1) &quot;library_name&quot;\n   2) &quot;mylib&quot;\n   3) &quot;engine&quot;\n   4) &quot;LUA&quot;\n   5) &quot;functions&quot;\n   6) 1) 1) &quot;name&quot;\n         2) &quot;my_hset&quot;\n         3) &quot;description&quot;\n         4) (nil)\n         5) &quot;flags&quot;\n         6) (empty array)\n      2) 1) &quot;name&quot;\n         2) &quot;my_hgetall&quot;\n         3) &quot;description&quot;\n         4) (nil)\n         5) &quot;flags&quot;\n         6) (empty array)\n      3) 1) &quot;name&quot;\n         2) &quot;my_hlastmodified&quot;\n         3) &quot;description&quot;\n         4) (nil)\n         5) &quot;flags&quot;\n         6) (empty array)\n</code></pre>\n<p>You can see that it is easy to update our library with new capabilities.</p>\n<h2>Reusing code in the library</h2>\n<p>On top of bundling functions together into database-managed software artifacts, libraries also facilitate code sharing.<br>We can add to our library an error handling helper function called from other functions.<br>The helper function <code>check_keys()</code> verifies that the input <em>keys</em> table has a single key.<br>Upon success it returns <code>nil</code>, otherwise it returns an <a href=\"lua-api.md#server.error_reply\">error reply</a>.</p>\n<p>The updated library&#39;s source code would be:</p>\n<pre><code class=\"language-lua\">#!lua name=mylib\n\nlocal function check_keys(keys)\n  local error = nil\n  local nkeys = table.getn(keys)\n  if nkeys == 0 then\n    error = &#39;Hash key name not provided&#39;\n  elseif nkeys &gt; 1 then\n    error = &#39;Only one key name is allowed&#39;\n  end\n\n  if error ~= nil then\n    server.log(server.LOG_WARNING, error);\n    return server.error_reply(error)\n  end\n  return nil\nend\n\nlocal function my_hset(keys, args)\n  local error = check_keys(keys)\n  if error ~= nil then\n    return error\n  end\n\n  local hash = keys[1]\n  local time = server.call(&#39;TIME&#39;)[1]\n  return server.call(&#39;HSET&#39;, hash, &#39;_last_modified_&#39;, time, unpack(args))\nend\n\nlocal function my_hgetall(keys, args)\n  local error = check_keys(keys)\n  if error ~= nil then\n    return error\n  end\n\n  server.setresp(3)\n  local hash = keys[1]\n  local res = server.call(&#39;HGETALL&#39;, hash)\n  res[&#39;map&#39;][&#39;_last_modified_&#39;] = nil\n  return res\nend\n\nlocal function my_hlastmodified(keys, args)\n  local error = check_keys(keys)\n  if error ~= nil then\n    return error\n  end\n\n  local hash = keys[1]\n  return server.call(&#39;HGET&#39;, keys[1], &#39;_last_modified_&#39;)\nend\n\nserver.register_function(&#39;my_hset&#39;, my_hset)\nserver.register_function(&#39;my_hgetall&#39;, my_hgetall)\nserver.register_function(&#39;my_hlastmodified&#39;, my_hlastmodified)\n</code></pre>\n<p>After you&#39;ve replaced the library in Valkey with the above, you can immediately try out the new error handling mechanism:</p>\n<pre><code>127.0.0.1:6379&gt; FCALL my_hset 0 myhash nope nope\n(error) Hash key name not provided\n127.0.0.1:6379&gt; FCALL my_hgetall 2 myhash anotherone\n(error) Only one key name is allowed\n</code></pre>\n<p>And your Valkey log file should have lines in it that are similar to:</p>\n<pre><code>...\n20075:M 1 Jan 2022 16:53:57.688 # Hash key name not provided\n20075:M 1 Jan 2022 16:54:01.309 # Only one key name is allowed\n</code></pre>\n<h2>Functions in cluster</h2>\n<p>As noted above, Valkey automatically handles propagation of loaded functions to replicas.<br>In a <a href=\"cluster-tutorial.md\">cluster</a>, it is necessary to load functions to all primaries.</p>\n<p>As one of the goals of functions is to live separately from the client application, this should not be part of the Valkey client library responsibilities. Instead, <code>valkey-cli --cluster-only-primaries --cluster call host:port FUNCTION LOAD ...</code> can be used to execute the load command on all primary nodes.</p>\n<p>Also, note that <code>valkey-cli --cluster add-node</code> automatically takes care to propagate the loaded functions from one of the existing nodes to the new node.</p>\n<h2>Functions and ephemeral Valkey instances</h2>\n<p>In some cases there may be a need to start a fresh Valkey server with a set of functions pre-loaded. Common reasons for that could be:</p>\n<ul>\n<li>Starting Valkey in a new environment</li>\n<li>Re-starting an ephemeral (cache-only) Valkey, that uses functions</li>\n</ul>\n<p>In such cases, we need to make sure that the pre-loaded functions are available before Valkey accepts inbound user connections and commands.</p>\n<p>To do that, it is possible to use <code>valkey-cli --functions-rdb</code> to extract the functions from an existing server. This generates an RDB file that can be loaded by Valkey at startup.</p>\n<h2>Function flags</h2>\n<p>Valkey needs to have some information about how a function is going to behave when executed, in order to properly enforce resource usage policies and maintain data consistency.</p>\n<p>For example, Valkey needs to know that a certain function is read-only before permitting it to execute using <code>FCALL_RO</code> on a read-only replica.</p>\n<p>By default, Valkey assumes that all functions may perform arbitrary read or write operations. Function Flags make it possible to declare more specific function behavior at the time of registration. Let&#39;s see how this works.</p>\n<p>In our previous example, we defined two functions that only read data. We can try executing them using <code>FCALL_RO</code> against a read-only replica.</p>\n<pre><code>127.0.0.1:6379&gt; FCALL_RO my_hgetall 1 myhash\n(error) ERR Can not execute a function with write flag using fcall_ro.\n</code></pre>\n<p>Valkey returns this error because a function can, in theory, perform both read and write operations on the database.<br>As a safeguard and by default, Valkey assumes that the function does both, so it blocks its execution.<br>The server will reply with this error in the following cases:</p>\n<ol>\n<li>Executing a function with <code>FCALL</code> against a read-only replica.</li>\n<li>Using <code>FCALL_RO</code> to execute a function.</li>\n<li>A disk error was detected (Valkey is unable to persist so it rejects writes).</li>\n</ol>\n<p>In these cases, you can add the <code>no-writes</code> flag to the function&#39;s registration, disable the safeguard and allow them to run.<br>To register a function with flags use the <a href=\"lua-api.md#server.register_function_named_args\">named arguments</a> variant of <code>server.register_function</code>.</p>\n<p>The updated registration code snippet from the library looks like this:</p>\n<pre><code class=\"language-lua\">server.register_function(&#39;my_hset&#39;, my_hset)\nserver.register_function{\n  function_name=&#39;my_hgetall&#39;,\n  callback=my_hgetall,\n  flags={ &#39;no-writes&#39; }\n}\nserver.register_function{\n  function_name=&#39;my_hlastmodified&#39;,\n  callback=my_hlastmodified,\n  flags={ &#39;no-writes&#39; }\n}\n</code></pre>\n<p>Once we&#39;ve replaced the library, Valkey allows running both <code>my_hgetall</code> and <code>my_hlastmodified</code> with <code>FCALL_RO</code> against a read-only replica:</p>\n<pre><code>127.0.0.1:6379&gt; FCALL_RO my_hgetall 1 myhash\n1) &quot;myfield&quot;\n2) &quot;some value&quot;\n3) &quot;another_field&quot;\n4) &quot;another value&quot;\n127.0.0.1:6379&gt; FCALL_RO my_hlastmodified 1 myhash\n&quot;1640772721&quot;\n</code></pre>\n<p>For the complete documentation flags, please refer to <a href=\"lua-api.md#script_flags\">Script flags</a>.</p>\n"
      },
      {
        "id": "programmability",
        "topicName": "Programmability",
        "description": "Extending Valkey with Lua and Valkey Functions\n",
        "htmlContent": "<p>Valkey provides a programming interface that lets you execute custom scripts on the server itself.<br>You can use <a href=\"functions-intro.md\">Functions</a> to create, manage and run scripts.<br>You can also use <a href=\"eval-intro.md\">Lua scripting with the EVAL command</a> to program the server.</p>\n<h2>Background</h2>\n<p>Valkey is a <em>&quot;domain-specific language for abstract data types&quot;</em>.<br>The language that Valkey speaks consists of its <a href=\"../commands/\">commands</a>.<br>Most the commands specialize at manipulating core <a href=\"data-types.md\">data types</a> in different ways.<br>In many cases, these commands provide all the functionality that a developer requires for managing application data in Valkey.</p>\n<p>The term <strong>programmability</strong> in Valkey means having the ability to execute arbitrary user-defined logic by the server.<br>We refer to such pieces of logic as <strong>scripts</strong>.<br>In our case, scripts enable processing the data where it lives, a.k.a <em>data locality</em>.<br>Furthermore, the responsible embedding of programmatic workflows in the Valkey server can help in reducing network traffic and improving overall performance.<br>Developers can use this capability for implementing robust, application-specific APIs.<br>Such APIs can encapsulate business logic and maintain a data model across multiple keys and different data structures.</p>\n<p>User scripts are executed in Valkey by an embedded, sandboxed scripting engine.<br>Presently, Valkey supports a single scripting engine, the <a href=\"https://www.lua.org/\">Lua 5.1</a> interpreter.</p>\n<p>Please refer to the <a href=\"lua-api.md\">Valkey Lua API Reference</a> page for complete documentation.</p>\n<h2>Running scripts</h2>\n<p>Valkey provides two means for running scripts.</p>\n<p>Firstly, the <code>EVAL</code> command enables running server-side scripts.<br>Eval scripts provide a quick and straightforward way to have Valkey run your scripts ad-hoc.<br>However, using them means that the scripted logic is a part of your application (not an extension of the Valkey server).<br>Every applicative instance that runs a script must have the script&#39;s source code readily available for loading at any time.<br>That is because scripts are only cached by the server and are volatile.<br>As your application grows, this approach can become harder to develop and maintain.</p>\n<p>Secondly, added in v7.0, Valkey Functions are essentially scripts that are first-class database elements.<br>As such, functions decouple scripting from application logic and enable independent development, testing, and deployment of scripts.<br>To use functions, they need to be loaded first, and then they are available for use by all connected clients.<br>In this case, loading a function to the database becomes an administrative deployment task (such as loading a Valkey module, for example), which separates the script from the application.</p>\n<p>Please refer to the following pages for more information:</p>\n<ul>\n<li><a href=\"eval-intro.md\">Valkey Eval Scripts</a></li>\n<li><a href=\"functions-intro.md\">Valkey Functions</a></li>\n</ul>\n<p>When running a script or a function, Valkey guarantees its atomic execution.<br>The script&#39;s execution blocks all server activities during its entire time, similarly to the semantics of <a href=\"transactions.md\">transactions</a>.<br>These semantics mean that all of the script&#39;s effects either have yet to happen or had already happened.<br>The blocking semantics of an executed script apply to all connected clients at all times.</p>\n<p>Note that the potential downside of this blocking approach is that executing slow scripts is not a good idea.<br>It is not hard to create fast scripts because scripting&#39;s overhead is very low.<br>However, if you intend to use a slow script in your application, be aware that all other clients are blocked and can&#39;t execute any command while it is running.</p>\n<h2>Read-only scripts</h2>\n<p>A read-only script is a script that only executes commands that don&#39;t modify any keys within Valkey.<br>Read-only scripts can be executed either by adding the <code>no-writes</code> <a href=\"lua-api.md#script_flags\">flag</a> to the script or by executing the script with one of the read-only script command variants: <code>EVAL_RO</code>, <code>EVALSHA_RO</code>, or <code>FCALL_RO</code>.<br>They have the following properties:</p>\n<ul>\n<li>They can always be executed on replicas.</li>\n<li>They can always be killed by the <code>SCRIPT KILL</code> command. </li>\n<li>They never fail with OOM error when Valkey is over the memory limit.</li>\n<li>They are not blocked during write pauses, such as those that occur during coordinated failovers.</li>\n<li>They cannot execute any command that may modify the data set.</li>\n<li>Currently <code>PUBLISH</code>, <code>SPUBLISH</code> and <code>PFCOUNT</code> are also considered write commands in scripts, because they could attempt to propagate commands to replicas and AOF file.</li>\n</ul>\n<p>In addition to the benefits provided by all read-only scripts, the read-only script commands have the following advantages:</p>\n<ul>\n<li>They can be used to configure an ACL user to only be able to execute read-only scripts.</li>\n<li>Many clients also better support routing the read-only script commands to replicas for applications that want to use replicas for read scaling.</li>\n</ul>\n<h4>Read-only script history</h4>\n<p>Read-only scripts and read-only script commands were introduced in Redis OSS 7.0</p>\n<ul>\n<li>Before Redis OSS 7.0.1 <code>PUBLISH</code>, <code>SPUBLISH</code> and <code>PFCOUNT</code> were not considered write commands in scripts</li>\n<li>Before Redis OSS 7.0.1 the <code>no-writes</code> <a href=\"lua-api.md#script_flags\">flag</a> did not imply <code>allow-oom</code></li>\n<li>Before Redis OSS 7.0.1 the <code>no-writes</code> flag did not permit the script to run during write pauses.</li>\n</ul>\n<p>The recommended approach is to use the standard scripting commands with the <code>no-writes</code> flag unless you need one of the previously mentioned features.</p>\n<h2>Sandboxed script context</h2>\n<p>Valkey places the engine that executes user scripts inside a sandbox.<br>The sandbox attempts to prevent accidental misuse and reduce potential threats from the server&#39;s environment.</p>\n<p>Scripts should never try to access the Valkey server&#39;s underlying host systems, such as the file system, network, or attempt to perform any other system call other than those supported by the API.</p>\n<p>Scripts should operate solely on data stored in Valkey and data provided as arguments to their execution.</p>\n<h2>Maximum execution time</h2>\n<p>Scripts are subject to a maximum execution time (set by default to five seconds).<br>This default timeout is enormous since a script usually runs in less than a millisecond.<br>The limit is in place to handle accidental infinite loops created during development.</p>\n<p>It is possible to modify the maximum time a script can be executed with millisecond precision,<br>either via <code>valkey.conf</code> or by using the <code>CONFIG SET</code> command.<br>The configuration parameter affecting max execution time is called <code>busy-reply-threshold</code>.</p>\n<p>When a script reaches the timeout threshold, it isn&#39;t terminated by Valkey automatically.<br>Doing so would violate the contract between Valkey and the scripting engine that ensures that scripts are atomic.<br>Interrupting the execution of a script has the potential of leaving the dataset with half-written changes.</p>\n<p>Therefore, when a script executes longer than the configured timeout, the following happens:</p>\n<ul>\n<li>Valkey logs that a script is running for too long.</li>\n<li>It starts accepting commands again from other clients but will reply with a BUSY error to all the clients sending normal commands. The only commands allowed in this state are <code>SCRIPT KILL</code>, <code>FUNCTION KILL</code>, and <code>SHUTDOWN NOSAVE</code>.</li>\n<li>It is possible to terminate a script that only executes read-only commands using the <code>SCRIPT KILL</code> and <code>FUNCTION KILL</code> commands. These commands do not violate the scripting semantic as no data was written to the dataset by the script yet.</li>\n<li>If the script had already performed even a single write operation, the only command allowed is <code>SHUTDOWN NOSAVE</code> that stops the server without saving the current data set on disk (basically, the server is aborted).</li>\n</ul>\n"
      }
    ]
  },
  {
    "title": "HIGH AVAILABILITY",
    "items": [
      {
        "id": "replication",
        "topicName": "Replication",
        "description": "How Valkey supports high availability and failover with replication",
        "htmlContent": "<p>At the base of Valkey replication (excluding the high availability features provided as an additional layer by Valkey Cluster or Valkey Sentinel) there is a <em>leader follower</em> (primary-replica) replication that is simple to use and configure. It allows replica Valkey instances to be exact copies of primary instances. The replica will automatically reconnect to the primary every time the link breaks, and will attempt to be an exact copy of it <em>regardless</em> of what happens to the primary.</p>\n<p>This system works using three main mechanisms:</p>\n<ol>\n<li>When a primary and a replica instances are well-connected, the primary keeps the replica updated by sending a stream of commands to the replica to replicate the effects on the dataset happening in the primary side due to: client writes, keys expired or evicted, any other action changing the primary dataset.</li>\n<li>When the link between the primary and the replica breaks, for network issues or because a timeout is sensed in the primary or the replica, the replica reconnects and attempts to proceed with a partial resynchronization: it means that it will try to just obtain the part of the stream of commands it missed during the disconnection.</li>\n<li>When a partial resynchronization is not possible, the replica will ask for a full resynchronization. This will involve a more complex process in which the primary needs to create a snapshot of all its data, send it to the replica, and then continue sending the stream of commands as the dataset changes.</li>\n</ol>\n<p>Valkey uses by default asynchronous replication, which being low latency and<br>high performance, is the natural replication mode for the vast majority of Valkey<br>use cases. However, Valkey replicas asynchronously acknowledge the amount of data<br>they received periodically with the primary. So the primary does not wait every time<br>for a command to be processed by the replicas, however it knows, if needed, what<br>replica already processed what command. This allows having optional synchronous replication.</p>\n<p>Synchronous replication of certain data can be requested by the clients using<br>the <code>WAIT</code> command. However <code>WAIT</code> is only able to ensure there are the<br>specified number of acknowledged copies in the other Valkey instances, it does not<br>turn a set of Valkey instances into a CP system with strong consistency: acknowledged<br>writes can still be lost during a failover, depending on the exact configuration<br>of the Valkey persistence. However with <code>WAIT</code> the probability of losing a write<br>after a failure event is greatly reduced to certain hard to trigger failure<br>modes.</p>\n<p>You can check the Valkey Sentinel or Valkey Cluster documentation for more information<br>about high availability and failover. The rest of this document mainly describes the basic characteristics of Valkey basic replication.</p>\n<h3>Important facts about Valkey replication</h3>\n<ul>\n<li>Valkey uses asynchronous replication, with asynchronous replica-to-primary acknowledges of the amount of data processed.</li>\n<li>A primary can have multiple replicas.</li>\n<li>Replicas are able to accept connections from other replicas. Aside from connecting a number of replicas to the same primary, replicas can also be connected to other replicas in a cascading-like structure. All the sub-replicas will receive exactly the same replication stream from the primary.</li>\n<li>Valkey replication is non-blocking on the primary side. This means that the primary will continue to handle queries when one or more replicas perform the initial synchronization or a partial resynchronization.</li>\n<li>Replication is also largely non-blocking on the replica side. While the replica is performing the initial synchronization, it can handle queries using the old version of the dataset, assuming you configured Valkey to do so in valkey.conf.  Otherwise, you can configure Valkey replicas to return an error to clients if the replication stream is down. However, after the initial sync, the old dataset must be deleted and the new one must be loaded. The replica will block incoming connections during this brief window (that can be as long as many seconds for very large datasets). You can configure Valkey so that the deletion of the old data set happens in a different thread, however loading the new initial dataset will still happen in the main thread and block the replica.</li>\n<li>Replication can be used both for scalability, to have multiple replicas for read-only queries (for example, slow O(N) operations can be offloaded to replicas), or simply for improving data safety and high availability.</li>\n<li>You can use replication to avoid the cost of having the primary writing the full dataset to disk: a typical technique involves configuring your primary&#39;s <code>valkey.conf</code> to avoid persisting to disk at all, then connect a replica configured to save from time to time, or with AOF enabled. However, this setup must be handled with care, since a restarting primary will start with an empty dataset: if the replica tries to sync with it, the replica will be emptied as well.</li>\n</ul>\n<h2>Safety of replication when primary has persistence turned off</h2>\n<p>In setups where Valkey replication is used, it is strongly advised to have<br>persistence turned on in the primary and in the replicas. When this is not possible,<br>for example because of latency concerns due to very slow disks, instances should<br>be configured to <strong>avoid restarting automatically</strong> after a reboot.</p>\n<p>To better understand why primaries with persistence turned off configured to<br>auto restart are dangerous, check the following failure mode where data<br>is wiped from the primary and all its replicas:</p>\n<ol>\n<li>We have a setup with node A acting as primary, with persistence turned down, and nodes B and C replicating from node A.</li>\n<li>Node A crashes, however it has some auto-restart system, that restarts the process. However since persistence is turned off, the node restarts with an empty data set.</li>\n<li>Nodes B and C will replicate from node A, which is empty, so they&#39;ll effectively destroy their copy of the data.</li>\n</ol>\n<p>When Valkey Sentinel is used for high availability, also turning off persistence<br>on the primary, together with auto restart of the process, is dangerous. For example, the primary can restart fast enough for Sentinel to not detect a failure, so that the failure mode described above happens.</p>\n<p>Every time data safety is important, and replication is used with primary configured without persistence, auto restart of instances should be disabled.</p>\n<h2>How Valkey replication works</h2>\n<p>Every Valkey primary has a replication ID: it is a large pseudo random string<br>that marks a given story of the dataset. Each primary also takes an offset that<br>increments for every byte of replication stream that it is produced to be<br>sent to replicas, to update the state of the replicas with the new changes<br>modifying the dataset. The replication offset is incremented even if no replica<br>is actually connected, so basically every given pair of:</p>\n<pre><code>Replication ID, offset\n</code></pre>\n<p>Identifies an exact version of the dataset of a primary.</p>\n<p>When replicas connect to primaries, they use the <code>PSYNC</code> command to send<br>their old primary replication ID and the offsets they processed so far. This way<br>the primary can send just the incremental part needed. However if there is not<br>enough <em>backlog</em> in the primary buffers, or if the replica is referring to a<br>history (replication ID) which is no longer known, then a full resynchronization<br>happens: in this case the replica will get a full copy of the dataset, from scratch.</p>\n<p>This is how a full synchronization works in more details:</p>\n<p>The primary starts a background saving process to produce an RDB file. At the same time it starts to buffer all new write commands received from the clients. When the background saving is complete, the primary transfers the database file to the replica, which saves it on disk, and then loads it into memory. The primary will then send all buffered commands to the replica. This is done as a stream of commands and is in the same format of the Valkey protocol itself.</p>\n<p>You can try it yourself via telnet. Connect to the Valkey port while the<br>server is doing some work and issue the <code>SYNC</code> command. You&#39;ll see a bulk<br>transfer and then every command received by the primary will be re-issued<br>in the telnet session. Actually <code>SYNC</code> is an old protocol no longer used by<br>newer Valkey instances, but is still there for backward compatibility: it does<br>not allow partial resynchronizations, so now <code>PSYNC</code> is used instead.</p>\n<p>As already said, replicas are able to automatically reconnect when the primary-replica link goes down for some reason. If the primary receives multiple concurrent replica synchronization requests, it performs a single background save in to serve all of them.</p>\n<h2>Replication ID explained</h2>\n<p>In the previous section we said that if two instances have the same replication<br>ID and replication offset, they have exactly the same data. However it is useful<br>to understand what exactly is the replication ID, and why instances have actually<br>two replication IDs: the main ID and the secondary ID.</p>\n<p>A replication ID basically marks a given <em>history</em> of the data set. Every time<br>an instance restarts from scratch as a primary, or a replica is promoted to primary,<br>a new replication ID is generated for this instance. The replicas connected to<br>a primary will inherit its replication ID after the handshake. So two instances<br>with the same ID are related by the fact that they hold the same data, but<br>potentially at a different time. It is the offset that works as a logical time<br>to understand, for a given history (replication ID), who holds the most updated<br>data set.</p>\n<p>For instance, if two instances A and B have the same replication ID, but one<br>with offset 1000 and one with offset 1023, it means that the first lacks certain<br>commands applied to the data set. It also means that A, by applying just a few<br>commands, may reach exactly the same state of B.</p>\n<p>The reason why Valkey instances have two replication IDs is because of replicas<br>that are promoted to primaries. After a failover, the promoted replica requires<br>to still remember what was its past replication ID, because such replication ID<br>was the one of the former primary. In this way, when other replicas will sync<br>with the new primary, they will try to perform a partial resynchronization using the<br>old primary replication ID. This will work as expected, because when the replica<br>is promoted to primary, it sets its secondary ID to its main ID, remembering what<br>was the offset when this ID switch happened. Later it will select a new random<br>replication ID, because a new history begins. When handling the new replicas<br>connecting, the primary will match their IDs and offsets both with the current<br>ID and the secondary ID (up to a given offset, for safety). In short this means<br>that after a failover, replicas connecting to the newly promoted primary don&#39;t have<br>to perform a full sync.</p>\n<p>In case you wonder why a replica promoted to primary needs to change its<br>replication ID after a failover: it is possible that the old primary is still<br>working as a primary because of some network partition: retaining the same<br>replication ID would violate the fact that the same ID and same offset of any<br>two random instances mean they have the same data set.</p>\n<h2>Diskless replication</h2>\n<p>Normally a full resynchronization requires creating an RDB file on disk,<br>then reloading the same RDB from disk to feed the replicas with the data.</p>\n<p>With slow disks this can be a very stressing operation for the primary.<br>Valkey has support for diskless<br>replication. In this setup the child process directly sends the<br>RDB over the wire to replicas, without using the disk as intermediate storage.</p>\n<h2>Configuration</h2>\n<p>To configure basic Valkey replication is trivial: just add the following line to the replica configuration file:</p>\n<pre><code>replicaof 192.168.1.1 6379\n</code></pre>\n<p>Of course you need to replace 192.168.1.1 6379 with your primary IP address (or<br>hostname) and port. Alternatively, you can call the <code>REPLICAOF</code> command and the<br>primary host will start a sync with the replica.</p>\n<p>There are also a few parameters for tuning the replication backlog taken<br>in memory by the primary to perform the partial resynchronization. See the example<br><code>valkey.conf</code> shipped with the Valkey distribution for more information.</p>\n<p>Diskless replication can be enabled using the <code>repl-diskless-sync</code> configuration<br>parameter. The delay to start the transfer to wait for more replicas to<br>arrive after the first one is controlled by the <code>repl-diskless-sync-delay</code><br>parameter. Please refer to the example <code>valkey.conf</code> file in the Valkey distribution<br>for more details.</p>\n<h2>Read-only replica</h2>\n<p>Replicas are read-only by default.<br>This behavior is controlled by the <code>replica-read-only</code> option in the valkey.conf file, and can be enabled and disabled at runtime using <code>CONFIG SET</code>.</p>\n<p>Read-only replicas will reject all write commands, so that it is not possible to write to a replica because of a mistake. This does not mean that the feature is intended to expose a replica instance to the internet or more generally to a network where untrusted clients exist, because administrative commands like <code>DEBUG</code> or <code>CONFIG</code> are still enabled. The <a href=\"security.md\">Security</a> page describes how to secure a Valkey instance.</p>\n<p>You may wonder why it is possible to revert the read-only setting<br>and have replica instances that can be targeted by write operations.<br>The answer is that writable replicas exist only for historical reasons.<br>Using writable replicas can result in inconsistency between the primary and the replica, so it is not recommended to use writable replicas.<br>To understand in which situations this can be a problem, we need to understand how replication works.<br>Changes on the primary is replicated by propagating regular Valkey commands to the replica.<br>When a key expires on the primary, this is propagated as a DEL command.<br>If a key which exists on the primary but is deleted, expired or has a different type on the replica compared to the primary will react differently to commands like DEL, INCR or RPOP propagated from the primary than intended.<br>The propagated command may fail on the replica or result in a different outcome.<br>To minimize the risks (if you insist on using writable replicas) we suggest you follow these recommendations:</p>\n<ul>\n<li><p>Don&#39;t write to keys in a writable replica that are also used on the primary.<br>(This can be hard to guarantee if you don&#39;t have control over all the clients that write to the primary.)</p>\n</li>\n<li><p>Don&#39;t configure an instance as a writable replica as an intermediary step when upgrading a set of instances in a running system.<br>In general, don&#39;t configure an instance as a writable replica if it can ever be promoted to a primary if you want to guarantee data consistency.</p>\n</li>\n</ul>\n<p>Historically, there were some use cases that were considered legitimate for writable replicas.<br>As of version 7.0, these use cases are now all obsolete and the same can be achieved by other means.<br>For example:</p>\n<ul>\n<li><p>Computing slow Set or Sorted set operations and storing the result in temporary local keys using commands like <code>SUNIONSTORE</code> and <code>ZINTERSTORE</code>.<br>Instead, use commands that return the result without storing it, such as <code>SUNION</code> and <code>ZINTER</code>.</p>\n</li>\n<li><p>Using the <code>SORT</code> command (which is not considered a read-only command because of the optional STORE option and therefore cannot be used on a read-only replica).<br>Instead, use <code>SORT_RO</code>, which is a read-only command.</p>\n</li>\n<li><p>Using <code>EVAL</code> and <code>EVALSHA</code> are also not considered read-only commands, because the Lua script may call write commands.<br>Instead, use <code>EVAL_RO</code> and <code>EVALSHA_RO</code> where the Lua script can only call read-only commands.</p>\n</li>\n</ul>\n<p>While writes to a replica will be discarded if the replica and the primary resync or if the replica is restarted, there is no guarantee that they will sync automatically.</p>\n<p>Before version 4.0, writable replicas were incapable of expiring keys with a time to live set.<br>This means that if you use <code>EXPIRE</code> or other commands that set a maximum TTL for a key, the key will leak, and while you may no longer see it while accessing it with read commands, you will see it in the count of keys and it will still use memory.<br>Valkey is able to evict keys with TTL as primaries do, with the exceptions of keys written in DB numbers greater than 63 (but by default Valkey instances only have 16 databases).<br>Note though that even in versions greater than 4.0, using <code>EXPIRE</code> on a key that could ever exists on the primary can cause inconsistency between the replica and the primary.</p>\n<p>Also note that replica writes are only local, and are not propagated to sub-replicas attached to the instance. Sub-replicas instead will always receive the replication stream identical to the one sent by the top-level primary to the intermediate replicas. So for example in the following setup:</p>\n<pre><code>A ---&gt; B ---&gt; C\n</code></pre>\n<p>Even if <code>B</code> is writable, C will not see <code>B</code> writes and will instead have identical dataset as the primary instance <code>A</code>.</p>\n<h2>Setting a replica to authenticate to a primary</h2>\n<p>If your primary has a password via <code>requirepass</code>, it&#39;s trivial to configure the<br>replica to use that password in all sync operations.</p>\n<p>To do it on a running instance, use <code>valkey-cli</code> and type:</p>\n<pre><code>config set primaryauth &lt;password&gt;\n</code></pre>\n<p>To set it permanently, add this to your config file:</p>\n<pre><code>primaryauth &lt;password&gt;\n</code></pre>\n<h2>Allow writes only with N attached replicas</h2>\n<p>You can configure a Valkey primary to<br>accept write queries only if at least N replicas are currently connected to the<br>primary.</p>\n<p>However, because Valkey uses asynchronous replication it is not possible to ensure<br>the replica actually received a given write, so there is always a window for data<br>loss.</p>\n<p>This is how the feature works:</p>\n<ul>\n<li>Valkey replicas ping the primary every second, acknowledging the amount of replication stream processed.</li>\n<li>Valkey primaries will remember the last time it received a ping from every replica.</li>\n<li>The user can configure a minimum number of replicas that have a lag not greater than a maximum number of seconds.</li>\n</ul>\n<p>If there are at least N replicas, with a lag less than M seconds, then the write will be accepted.</p>\n<p>You may think of it as a best effort data safety mechanism, where consistency is not ensured for a given write, but at least the time window for data loss is restricted to a given number of seconds. In general bound data loss is better than unbound one.</p>\n<p>If the conditions are not met, the primary will instead reply with an error and the write will not be accepted.</p>\n<p>There are two configuration parameters for this feature:</p>\n<ul>\n<li>min-replicas-to-write <code>&lt;number of replicas&gt;</code></li>\n<li>min-replicas-max-lag <code>&lt;number of seconds&gt;</code></li>\n</ul>\n<p>For more information, please check the example <code>valkey.conf</code> file shipped with the<br>Valkey source distribution.</p>\n<h2>How Valkey replication deals with expires on keys</h2>\n<p>Valkey expires allow keys to have a limited time to live (TTL). Such a feature depends<br>on the ability of an instance to count the time, however Valkey replicas correctly<br>replicate keys with expires, even when such keys are altered using Lua<br>scripts.</p>\n<p>To implement such a feature Valkey cannot rely on the ability of the primary and<br>replica to have synced clocks, since this is a problem that cannot be solved<br>and would result in race conditions and diverging data sets, so Valkey<br>uses three main techniques to make the replication of expired keys<br>able to work:</p>\n<ol>\n<li>Replicas don&#39;t expire keys, instead they wait for primaries to expire the keys. When a primary expires a key (or evicts it because of LRU), it synthesizes a <code>DEL</code> command which is transmitted to all the replicas.</li>\n<li>However because of primary-driven expire, sometimes replicas may still have in memory keys that are already logically expired, since the primary was not able to provide the <code>DEL</code> command in time. To deal with that the replica uses its logical clock to report that a key does not exist <strong>only for read operations</strong> that don&#39;t violate the consistency of the data set (as new commands from the primary will arrive). In this way replicas avoid reporting logically expired keys that are still existing. In practical terms, an HTML fragments cache that uses replicas to scale will avoid returning items that are already older than the desired time to live.</li>\n<li>During Lua scripts executions no key expiries are performed. As a Lua script runs, conceptually the time in the primary is frozen, so that a given key will either exist or not for all the time the script runs. This prevents keys expiring in the middle of a script, and is needed to send the same script to the replica in a way that is guaranteed to have the same effects in the data set.</li>\n</ol>\n<p>Once a replica is promoted to a primary it will start to expire keys independently, and will not require any help from its old primary.</p>\n<h2>Configuring replication in Docker and NAT</h2>\n<p>When Docker, or other types of containers using port forwarding, or Network Address Translation is used, Valkey replication needs some extra care, especially when using Valkey Sentinel or other systems where the primary <code>INFO</code> or <code>ROLE</code> commands output is scanned to discover replicas&#39; addresses.</p>\n<p>The problem is that the <code>ROLE</code> command, and the replication section of<br>the <code>INFO</code> output, when issued into a primary instance, will show replicas<br>as having the IP address they use to connect to the primary, which, in<br>environments using NAT may be different compared to the logical address of the<br>replica instance (the one that clients should use to connect to replicas).</p>\n<p>Similarly the replicas will be listed with the listening port configured<br>into <code>valkey.conf</code>, that may be different from the forwarded port in case<br>the port is remapped.</p>\n<p>To fix both issues, it is possible to force<br>a replica to announce an arbitrary pair of IP and port to the primary.<br>The two configurations directives to use are:</p>\n<pre><code>replica-announce-ip 5.5.5.5\nreplica-announce-port 1234\n</code></pre>\n<p>And are documented in the example <code>valkey.conf</code> of recent Valkey distributions.</p>\n<h2>The INFO and ROLE command</h2>\n<p>There are two Valkey commands that provide a lot of information on the current<br>replication parameters of primary and replica instances. One is <code>INFO</code>. If the<br>command is called with the <code>replication</code> argument as <code>INFO replication</code> only<br>information relevant to the replication are displayed. Another more<br>computer-friendly command is <code>ROLE</code>, that provides the replication status of<br>primaries and replicas together with their replication offsets, list of connected<br>replicas and so forth.</p>\n<h2>Partial sync after restarts and failovers</h2>\n<p>When an instance is promoted to primary after a failover,<br>it will still be able to perform a partial resynchronization with the replicas<br>of the old primary. To do so, the replica remembers the old replication ID and<br>offset of its former primary, so can provide part of the backlog to the connecting<br>replicas even if they ask for the old replication ID.</p>\n<p>However the new replication ID of the promoted replica will be different, since it<br>constitutes a different history of the data set. For example, the primary can<br>return available and can continue accepting writes for some time, so using the<br>same replication ID in the promoted replica would violate the rule that a<br>replication ID and offset pair identifies only a single data set.</p>\n<p>Moreover, replicas - when powered off gently and restarted - are able to store<br>in the <code>RDB</code> file the information needed to resync with their<br>primary. This is useful in case of upgrades. When this is needed, it is better to<br>use the <code>SHUTDOWN</code> command in order to perform a <code>save &amp; quit</code> operation on the<br>replica.</p>\n<p>It is not possible to partially sync a replica that restarted via the<br>AOF file. However the instance may be turned to RDB persistence before shutting<br>down it, than can be restarted, and finally AOF can be enabled again.</p>\n<h2><code>Maxmemory</code> on replicas</h2>\n<p>By default, a replica will ignore <code>maxmemory</code> (unless it is promoted to a primary after a failover or manually).<br>It means that the eviction of keys will be handled by the primary, sending the DEL commands to the replica as keys evict in the primary side.</p>\n<p>This behavior ensures that primaries and replicas stay consistent, which is usually what you want.<br>However, if your replica is writable, or you want the replica to have a different memory setting, and you are sure all the writes performed to the replica are idempotent, then you may change this default (but be sure to understand what you are doing).</p>\n<p>Note that since the replica by default does not evict, it may end up using more memory than what is set via <code>maxmemory</code> (since there are certain buffers that may be larger on the replica, or data structures may sometimes take more memory and so forth).<br>Make sure you monitor your replicas, and make sure they have enough memory to never hit a real out-of-memory condition before the primary hits the configured <code>maxmemory</code> setting.</p>\n<p>To change this behavior, you can allow a replica to not ignore the <code>maxmemory</code>. The configuration directives to use is:</p>\n<pre><code>replica-ignore-maxmemory no\n</code></pre>\n"
      },
      {
        "id": "sentinel",
        "topicName": "High availability with Valkey Sentinel",
        "description": "High availability for non-clustered Valkey",
        "htmlContent": "<h2>Usage</h2>\n<p><strong><code>valkey-sentinel</code></strong> <em>/path/to/sentinel.conf</em></p>\n<p><strong><code>valkey-server</code></strong> <em>/path/to/sentinel.conf</em> <strong><code>--sentinel</code></strong></p>\n<h2>Description</h2>\n<p>Valkey Sentinel provides high availability for Valkey when not using <a href=\"cluster-tutorial.md\">Valkey Cluster</a>. </p>\n<p>Valkey Sentinel also provides other collateral tasks such as monitoring,<br>notifications and acts as a configuration provider for clients.</p>\n<p>This is the full list of Sentinel capabilities at a macroscopic level (i.e. the <em>big picture</em>):</p>\n<ul>\n<li><strong>Monitoring</strong>. Sentinel constantly checks if your primary and replica instances are working as expected.</li>\n<li><strong>Notification</strong>. Sentinel can notify the system administrator, or other computer programs, via the API, that something is wrong with one of the monitored Valkey instances.</li>\n<li><strong>Automatic failover</strong>. If a primary is not working as expected, Sentinel can start a failover process where a replica is promoted to primary, the other additional replicas are reconfigured to use the new primary, and the applications using the Valkey server are informed about the new address to use when connecting.</li>\n<li><strong>Configuration provider</strong>. Sentinel acts as a source of authority for clients service discovery: clients connect to Sentinels in order to ask for the address of the current Valkey primary responsible for a given service. If a failover occurs, Sentinels will report the new address.</li>\n</ul>\n<h2>Sentinel as a distributed system</h2>\n<p>Valkey Sentinel is a distributed system:</p>\n<p>Sentinel itself is designed to run in a configuration where there are multiple Sentinel processes cooperating together. The advantage of having multiple Sentinel processes cooperating are the following:</p>\n<ol>\n<li>Failure detection is performed when multiple Sentinels agree about the fact a given primary is no longer available. This lowers the probability of false positives.</li>\n<li>Sentinel works even if not all the Sentinel processes are working, making the system robust against failures. There is no fun in having a failover system which is itself a single point of failure, after all.</li>\n</ol>\n<p>The sum of Sentinels, Valkey instances (primaries and replicas) and clients<br>connecting to Sentinel and Valkey, are also a larger distributed system with<br>specific properties. In this document concepts will be introduced gradually<br>starting from basic information needed in order to understand the basic<br>properties of Sentinel, to more complex information (that are optional) in<br>order to understand how exactly Sentinel works.</p>\n<h2>Sentinel quick start</h2>\n<p>Valkey Sentinel is included in Valkey.</p>\n<h3>Running Sentinel</h3>\n<p>If you are using the <code>valkey-sentinel</code> executable (or if you have a symbolic<br>link with that name to the <code>valkey-server</code> executable) you can run Sentinel<br>with the following command line:</p>\n<pre><code>valkey-sentinel /path/to/sentinel.conf\n</code></pre>\n<p>Otherwise you can use directly the <code>valkey-server</code> executable starting it in<br>Sentinel mode:</p>\n<pre><code>valkey-server /path/to/sentinel.conf --sentinel\n</code></pre>\n<p>Both ways work the same.</p>\n<p>However <strong>it is mandatory</strong> to use a configuration file when running Sentinel, as this file will be used by the system in order to save the current state that will be reloaded in case of restarts. Sentinel will simply refuse to start if no configuration file is given or if the configuration file path is not writable.</p>\n<p>Sentinels by default run <strong>listening for connections to TCP port 26379</strong>, so<br>for Sentinels to work, port 26379 of your servers <strong>must be open</strong> to receive<br>connections from the IP addresses of the other Sentinel instances.<br>Otherwise Sentinels can&#39;t talk and can&#39;t agree about what to do, so failover<br>will never be performed.</p>\n<h3>Fundamental things to know about Sentinel before deploying</h3>\n<ol>\n<li>You need at least three Sentinel instances for a robust deployment.</li>\n<li>The three Sentinel instances should be placed into computers or virtual machines that are believed to fail in an independent way. So for example different physical servers or Virtual Machines executed on different availability zones.</li>\n<li>Sentinel + Valkey distributed system does not guarantee that acknowledged writes are retained during failures, since Valkey uses asynchronous replication. However there are ways to deploy Sentinel that make the window to lose writes limited to certain moments, while there are other less secure ways to deploy it.</li>\n<li>You need Sentinel support in your clients. Popular client libraries have Sentinel support, but not all.</li>\n<li>There is no HA setup which is safe if you don&#39;t test from time to time in development environments, or even better, if you can in production environments, if they work. You may have a misconfiguration that will become apparent only when it&#39;s too late (at 3am when your primary stops working).</li>\n<li><strong>Sentinel, Docker, or other forms of Network Address Translation or Port Mapping should be mixed with care</strong>: Docker performs port remapping, breaking Sentinel auto discovery of other Sentinel processes and the list of replicas for a primary. Check the <a href=\"#sentinel-docker-nat-and-possible-issues\">section about <em>Sentinel and Docker</em></a> later in this document for more information.</li>\n</ol>\n<h3>Configuring Sentinel</h3>\n<p>The Valkey source distribution contains a file called <code>sentinel.conf</code><br>that is a self-documented example configuration file you can use to<br>configure Sentinel, however a typical minimal configuration file looks like the<br>following:</p>\n<pre><code>sentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 60000\nsentinel failover-timeout mymaster 180000\nsentinel parallel-syncs mymaster 1\n\nsentinel monitor resque 192.168.1.3 6380 4\nsentinel down-after-milliseconds resque 10000\nsentinel failover-timeout resque 180000\nsentinel parallel-syncs resque 5\n</code></pre>\n<p>You only need to specify the primaries to monitor, giving to each separated<br>primary (that may have any number of replicas) a different name. There is no<br>need to specify replicas, which are auto-discovered. Sentinel will update the<br>configuration automatically with additional information about replicas (in<br>order to retain the information in case of restart). The configuration is<br>also rewritten every time a replica is promoted to primary during a failover<br>and every time a new Sentinel is discovered.</p>\n<p>The example configuration above basically monitors two sets of Valkey<br>instances, each composed of a primary and an undefined number of replicas.<br>One set of instances is called <code>mymaster</code>, and the other <code>resque</code>.</p>\n<p>The meaning of the arguments of <code>sentinel monitor</code> statements is the following:</p>\n<pre><code>sentinel monitor &lt;primary-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;\n</code></pre>\n<p>For the sake of clarity, let&#39;s check line by line what the configuration<br>options mean:</p>\n<p>The first line is used to tell Valkey to monitor a primary called <em>mymaster</em>,<br>that is at address 127.0.0.1 and port 6379, with a quorum of 2. Everything<br>is pretty obvious but the <strong>quorum</strong> argument:</p>\n<ul>\n<li>The <strong>quorum</strong> is the number of Sentinels that need to agree about the fact the primary is not reachable, in order to really mark the primary as failing, and eventually start a failover procedure if possible.</li>\n<li>However <strong>the quorum is only used to detect the failure</strong>. In order to actually perform a failover, one of the Sentinels need to be elected leader for the failover and be authorized to proceed. This only happens with the vote of the <strong>majority of the Sentinel processes</strong>.</li>\n</ul>\n<p>So for example if you have 5 Sentinel processes, and the quorum for a given<br>primary is set to the value of 2, this is what happens:</p>\n<ul>\n<li>If two Sentinels agree at the same time about the primary being unreachable, one of the two will try to start a failover.</li>\n<li>If there are at least a total of three Sentinels reachable, the failover will be authorized and will actually start.</li>\n</ul>\n<p>In practical terms this means during failures <strong>Sentinel never starts a failover if the majority of Sentinel processes are unable to talk</strong> (aka no failover in the minority partition).</p>\n<h3>Other Sentinel options</h3>\n<p>The other options are almost always in the form:</p>\n<pre><code>sentinel &lt;option_name&gt; &lt;primary_name&gt; &lt;option_value&gt;\n</code></pre>\n<p>And are used for the following purposes:</p>\n<ul>\n<li><code>down-after-milliseconds</code> is the time in milliseconds an instance should not<br>be reachable (either does not reply to our PINGs or it is replying with an<br>error) for a Sentinel starting to think it is down.</li>\n<li><code>parallel-syncs</code> sets the number of replicas that can be reconfigured to use<br>the new primary after a failover at the same time. The lower the number, the<br>more time it will take for the failover process to complete, however if the<br>replicas are configured to serve old data, you may not want all the replicas to<br>re-synchronize with the primary at the same time. While the replication<br>process is mostly non blocking for a replica, there is a moment when it stops to<br>load the bulk data from the primary. You may want to make sure only one replica<br>at a time is not reachable by setting this option to the value of 1.</li>\n</ul>\n<p>Additional options are described in the rest of this document and<br>documented in the example <code>sentinel.conf</code> file shipped with the Valkey<br>distribution.</p>\n<p>Configuration parameters can be modified at runtime:</p>\n<ul>\n<li>Master-specific configuration parameters are modified using <code>SENTINEL SET</code>.</li>\n<li>Global configuration parameters are modified using <code>SENTINEL CONFIG SET</code>.</li>\n</ul>\n<p>See the <a href=\"#reconfiguring-sentinel-at-runtime\"><em>Reconfiguring Sentinel at runtime</em> section</a> for more information.</p>\n<h3>Example Sentinel deployments</h3>\n<p>Now that you know the basic information about Sentinel, you may wonder where<br>you should place your Sentinel processes, how many Sentinel processes you need<br>and so forth. This section shows a few example deployments.</p>\n<p>We use ASCII art in order to show you configuration examples in a <em>graphical</em><br>format, this is what the different symbols means:</p>\n<pre><code>+--------------------+\n| This is a computer |\n| or VM that fails   |\n| independently. We  |\n| call it a &quot;box&quot;    |\n+--------------------+\n</code></pre>\n<p>We write inside the boxes what they are running:</p>\n<pre><code>+--------------------+\n| Valkey primary M1   |\n| Valkey Sentinel S1 |\n+--------------------+\n</code></pre>\n<p>Different boxes are connected by lines, to show that they are able to talk:</p>\n<pre><code>+-------------+               +-------------+\n| Sentinel S1 |---------------| Sentinel S2 |\n+-------------+               +-------------+\n</code></pre>\n<p>Network partitions are shown as interrupted lines using slashes:</p>\n<pre><code>+-------------+                +-------------+\n| Sentinel S1 |------ // ------| Sentinel S2 |\n+-------------+                +-------------+\n</code></pre>\n<p>Also note that:</p>\n<ul>\n<li>Primaries are called M1, M2, M3, ..., Mn.</li>\n<li>Replicas are called R1, R2, R3, ..., Rn (R stands for <em>replica</em>).</li>\n<li>Sentinels are called S1, S2, S3, ..., Sn.</li>\n<li>Clients are called C1, C2, C3, ..., Cn.</li>\n<li>When an instance changes role because of Sentinel actions, we put it inside square brackets, so [M1] means an instance that is now a primary because of Sentinel intervention.</li>\n</ul>\n<p>Note that we will never show <strong>setups where just two Sentinels are used</strong>, since<br>Sentinels always need <strong>to talk with the majority</strong> in order to start a<br>failover.</p>\n<h4>Example 1: just two Sentinels, DON&#39;T DO THIS</h4>\n<pre><code>+----+         +----+\n| M1 |---------| R1 |\n| S1 |         | S2 |\n+----+         +----+\n\nConfiguration: quorum = 1\n</code></pre>\n<ul>\n<li>In this setup, if the primary M1 fails, R1 will be promoted since the two Sentinels can reach agreement about the failure (obviously with quorum set to 1) and can also authorize a failover because the majority is two. So apparently it could superficially work, however check the next points to see why this setup is broken.</li>\n<li>If the box where M1 is running stops working, also S1 stops working. The Sentinel running in the other box S2 will not be able to authorize a failover, so the system will become not available.</li>\n</ul>\n<p>Note that a majority is needed in order to order different failovers, and later propagate the latest configuration to all the Sentinels. Also note that the ability to failover in a single side of the above setup, without any agreement, would be very dangerous:</p>\n<pre><code>+----+           +------+\n| M1 |----//-----| [M1] |\n| S1 |           | S2   |\n+----+           +------+\n</code></pre>\n<p>In the above configuration we created two primaries (assuming S2 could failover<br>without authorization) in a perfectly symmetrical way. Clients may write<br>indefinitely to both sides, and there is no way to understand when the<br>partition heals what configuration is the right one, in order to prevent<br>a <em>permanent split brain condition</em>.</p>\n<p>So please <strong>deploy at least three Sentinels in three different boxes</strong> always.</p>\n<h4>Example 2: basic setup with three boxes</h4>\n<p>This is a very simple setup, that has the advantage to be simple to tune<br>for additional safety. It is based on three boxes, each box running both<br>a Valkey process and a Sentinel process.</p>\n<pre><code>       +----+\n       | M1 |\n       | S1 |\n       +----+\n          |\n+----+    |    +----+\n| R2 |----+----| R3 |\n| S2 |         | S3 |\n+----+         +----+\n\nConfiguration: quorum = 2\n</code></pre>\n<p>If the primary M1 fails, S2 and S3 will agree about the failure and will<br>be able to authorize a failover, making clients able to continue.</p>\n<p>In every Sentinel setup, as Valkey uses asynchronous replication, there is<br>always the risk of losing some writes because a given acknowledged write<br>may not be able to reach the replica which is promoted to primary. However in<br>the above setup there is a higher risk due to clients being partitioned away<br>with an old primary, like in the following picture:</p>\n<pre><code>         +----+\n         | M1 |\n         | S1 | &lt;- C1 (writes will be lost)\n         +----+\n            |\n            /\n            /\n+------+    |    +----+\n| [M2] |----+----| R3 |\n| S2   |         | S3 |\n+------+         +----+\n</code></pre>\n<p>In this case a network partition isolated the old primary M1, so the<br>replica R2 is promoted to primary. However clients, like C1, that are<br>in the same partition as the old primary, may continue to write data<br>to the old primary. This data will be lost forever since when the partition<br>will heal, the primary will be reconfigured as a replica of the new primary,<br>discarding its data set.</p>\n<p>This problem can be mitigated using the following Valkey replication<br>feature, that allows to stop accepting writes if a primary detects that<br>it is no longer able to transfer its writes to the specified number of replicas.</p>\n<pre><code>min-replicas-to-write 1\nmin-replicas-max-lag 10\n</code></pre>\n<p>With the above configuration (please see the self-commented <code>valkey.conf</code> example in the Valkey distribution for more information) a Valkey instance, when acting as a primary, will stop accepting writes if it can&#39;t write to at least 1 replica. Since replication is asynchronous <em>not being able to write</em> actually means that the replica is either disconnected, or is not sending us asynchronous acknowledges for more than the specified <code>max-lag</code> number of seconds.</p>\n<p>Using this configuration, the old Valkey primary M1 in the above example, will become unavailable after 10 seconds. When the partition heals, the Sentinel configuration will converge to the new one, the client C1 will be able to fetch a valid configuration and will continue with the new primary.</p>\n<p>However there is no free lunch. With this refinement, if the two replicas are<br>down, the primary will stop accepting writes. It&#39;s a trade off.</p>\n<h4>Example 3: Sentinel in the client boxes</h4>\n<p>Sometimes we have only two Valkey boxes available, one for the primary and<br>one for the replica. The configuration in the example 2 is not viable in<br>that case, so we can resort to the following, where Sentinels are placed<br>where clients are:</p>\n<pre><code>            +----+         +----+\n            | M1 |----+----| R1 |\n            |    |    |    |    |\n            +----+    |    +----+\n                      |\n         +------------+------------+\n         |            |            |\n         |            |            |\n      +----+        +----+      +----+\n      | C1 |        | C2 |      | C3 |\n      | S1 |        | S2 |      | S3 |\n      +----+        +----+      +----+\n\n      Configuration: quorum = 2\n</code></pre>\n<p>In this setup, the point of view Sentinels is the same as the clients: if<br>a primary is reachable by the majority of the clients, it is fine.<br>C1, C2, C3 here are generic clients, it does not mean that C1 identifies<br>a single client connected to Valkey. It is more likely something like<br>an application server, a Rails app, or something like that.</p>\n<p>If the box where M1 and S1 are running fails, the failover will happen<br>without issues, however it is easy to see that different network partitions<br>will result in different behaviors. For example Sentinel will not be able<br>to setup if the network between the clients and the Valkey servers is<br>disconnected, since the Valkey primary and replica will both be unavailable.</p>\n<p>Note that if C3 gets partitioned with M1 (hardly possible with<br>the network described above, but more likely possible with different<br>layouts, or because of failures at the software layer), we have a similar<br>issue as described in Example 2, with the difference that here we have<br>no way to break the symmetry, since there is just a replica and a primary, so<br>the primary can&#39;t stop accepting queries when it is disconnected from its replica,<br>otherwise the primary would never be available during replica failures.</p>\n<p>So this is a valid setup but the setup in the Example 2 has advantages<br>such as the HA system of Valkey running in the same boxes as Valkey itself<br>which may be simpler to manage, and the ability to put a bound on the amount<br>of time a primary in the minority partition can receive writes.</p>\n<h4>Example 4: Sentinel client side with less than three clients</h4>\n<p>The setup described in the Example 3 cannot be used if there are less than<br>three boxes in the client side (for example three web servers). In this<br>case we need to resort to a mixed setup like the following:</p>\n<pre><code>            +----+         +----+\n            | M1 |----+----| R1 |\n            | S1 |    |    | S2 |\n            +----+    |    +----+\n                      |\n               +------+-----+\n               |            |\n               |            |\n            +----+        +----+\n            | C1 |        | C2 |\n            | S3 |        | S4 |\n            +----+        +----+\n\n      Configuration: quorum = 3\n</code></pre>\n<p>This is similar to the setup in Example 3, but here we run four Sentinels<br>in the four boxes we have available. If the primary M1 becomes unavailable<br>the other three Sentinels will perform the failover.</p>\n<p>In theory this setup works removing the box where C2 and S4 are running, and<br>setting the quorum to 2. However it is unlikely that we want HA in the<br>Valkey side without having high availability in our application layer.</p>\n<h3>Sentinel, Docker, NAT, and possible issues</h3>\n<p>Docker uses a technique called port mapping: programs running inside Docker<br>containers may be exposed with a different port compared to the one the<br>program believes to be using. This is useful in order to run multiple<br>containers using the same ports, at the same time, in the same server.</p>\n<p>Docker is not the only software system where this happens, there are other<br>Network Address Translation setups where ports may be remapped, and sometimes<br>not ports but also IP addresses.</p>\n<p>Remapping ports and addresses creates issues with Sentinel in two ways:</p>\n<ol>\n<li>Sentinel auto-discovery of other Sentinels no longer works, since it is based on <em>hello</em> messages where each Sentinel announce at which port and IP address they are listening for connection. However Sentinels have no way to understand that an address or port is remapped, so it is announcing an information that is not correct for other Sentinels to connect.</li>\n<li>Replicas are listed in the <code>INFO</code> output of a Valkey primary in a similar way: the address is detected by the primary checking the remote peer of the TCP connection, while the port is advertised by the replica itself during the handshake, however the port may be wrong for the same reason as exposed in point 1.</li>\n</ol>\n<p>Since Sentinels auto detect replicas using primaries <code>INFO</code> output information,<br>the detected replicas will not be reachable, and Sentinel will never be able to<br>failover the primary, since there are no good replicas from the point of view of<br>the system, so there is currently no way to monitor with Sentinel a set of<br>primary and replica instances deployed with Docker, <strong>unless you instruct Docker<br>to map the port 1:1</strong>.</p>\n<p>For the first problem, in case you want to run a set of Sentinel<br>instances using Docker with forwarded ports (or any other NAT setup where ports<br>are remapped), you can use the following two Sentinel configuration directives<br>in order to force Sentinel to announce a specific set of IP and port:</p>\n<pre><code>sentinel announce-ip &lt;ip&gt;\nsentinel announce-port &lt;port&gt;\n</code></pre>\n<p>Note that Docker has the ability to run in <em>host networking mode</em> (check the <code>--net=host</code> option for more information). This should create no issues since ports are not remapped in this setup.</p>\n<h3>IP Addresses and DNS names</h3>\n<p>Older versions of Sentinel did not support host names and required IP addresses to be specified everywhere.<br>Starting with version 6.2, Sentinel has <em>optional</em> support for host names.</p>\n<p><strong>This capability is disabled by default. If you&#39;re going to enable DNS/hostnames support, please note:</strong></p>\n<ol>\n<li>The name resolution configuration on your Valkey and Sentinel nodes must be reliable and be able to resolve addresses quickly. Unexpected delays in address resolution may have a negative impact on Sentinel.</li>\n<li>You should use hostnames everywhere and avoid mixing hostnames and IP addresses. To do that, use <code>replica-announce-ip &lt;hostname&gt;</code> and <code>sentinel announce-ip &lt;hostname&gt;</code> for all Valkey and Sentinel instances, respectively.</li>\n</ol>\n<p>Enabling the <code>resolve-hostnames</code> global configuration allows Sentinel to accept host names:</p>\n<ul>\n<li>As part of a <code>sentinel monitor</code> command</li>\n<li>As a replica address, if the replica uses a host name value for <code>replica-announce-ip</code></li>\n</ul>\n<p>Sentinel will accept host names as valid inputs and resolve them, but will still refer to IP addresses when announcing an instance, updating configuration files, etc.</p>\n<p>Enabling the <code>announce-hostnames</code> global configuration makes Sentinel use host names instead. This affects replies to clients, values written in configuration files, the <code>REPLICAOF</code> command issued to replicas, etc.</p>\n<p>This behavior may not be compatible with all Sentinel clients, that may explicitly expect an IP address.</p>\n<p>Using host names may be useful when clients use TLS to connect to instances and require a name rather than an IP address in order to perform certificate ASN matching.</p>\n<h2>A quick tutorial</h2>\n<p>In the next sections of this document, all the details about <a href=\"#sentinel-api\"><em>Sentinel API</em></a>,<br>configuration and semantics will be covered incrementally. However for people<br>that want to play with the system ASAP, this section is a tutorial that shows<br>how to configure and interact with 3 Sentinel instances.</p>\n<p>Here we assume that the instances are executed at port 5000, 5001, 5002.<br>We also assume that you have a running Valkey primary at port 6379 with a<br>replica running at port 6380. We will use the IPv4 loopback address 127.0.0.1<br>everywhere during the tutorial, assuming you are running the simulation<br>on your personal computer.</p>\n<p>The three Sentinel configuration files should look like the following:</p>\n<pre><code>port 5000\nsentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 5000\nsentinel failover-timeout mymaster 60000\nsentinel parallel-syncs mymaster 1\n</code></pre>\n<p>The other two configuration files will be identical but using 5001 and 5002<br>as port numbers.</p>\n<p>A few things to note about the above configuration:</p>\n<ul>\n<li>The primary set is called <code>mymaster</code>. It identifies the primary and its replicas. Since each <em>primary set</em> has a different name, Sentinel can monitor different sets of primaries and replicas at the same time.</li>\n<li>The quorum was set to the value of 2 (last argument of <code>sentinel monitor</code> configuration directive).</li>\n<li>The <code>down-after-milliseconds</code> value is 5000 milliseconds, that is 5 seconds, so primaries will be detected as failing as soon as we don&#39;t receive any reply from our pings within this amount of time.</li>\n</ul>\n<p>Once you start the three Sentinels, you&#39;ll see a few messages they log, like:</p>\n<pre><code>+monitor master mymaster 127.0.0.1 6379 quorum 2\n</code></pre>\n<p>This is a Sentinel event, and you can receive this kind of events via Pub/Sub<br>if you <code>SUBSCRIBE</code> to the event name as specified later in <a href=\"#pubsub-messages\"><em>Pubsub Messages</em> section</a>.</p>\n<p>Sentinel generates and logs different events during failure detection and<br>failover.</p>\n<h2>Asking Sentinel about the state of a primary</h2>\n<p>The most obvious thing to do with Sentinel to get started, is check if the<br>primary it is monitoring is doing well:</p>\n<pre><code>$ valkey-cli -p 5000\n127.0.0.1:5000&gt; sentinel master mymaster\n 1) &quot;name&quot;\n 2) &quot;mymaster&quot;\n 3) &quot;ip&quot;\n 4) &quot;127.0.0.1&quot;\n 5) &quot;port&quot;\n 6) &quot;6379&quot;\n 7) &quot;runid&quot;\n 8) &quot;953ae6a589449c13ddefaee3538d356d287f509b&quot;\n 9) &quot;flags&quot;\n10) &quot;master&quot;\n11) &quot;link-pending-commands&quot;\n12) &quot;0&quot;\n13) &quot;link-refcount&quot;\n14) &quot;1&quot;\n15) &quot;last-ping-sent&quot;\n16) &quot;0&quot;\n17) &quot;last-ok-ping-reply&quot;\n18) &quot;735&quot;\n19) &quot;last-ping-reply&quot;\n20) &quot;735&quot;\n21) &quot;down-after-milliseconds&quot;\n22) &quot;5000&quot;\n23) &quot;info-refresh&quot;\n24) &quot;126&quot;\n25) &quot;role-reported&quot;\n26) &quot;master&quot;\n27) &quot;role-reported-time&quot;\n28) &quot;532439&quot;\n29) &quot;config-epoch&quot;\n30) &quot;1&quot;\n31) &quot;num-slaves&quot;\n32) &quot;1&quot;\n33) &quot;num-other-sentinels&quot;\n34) &quot;2&quot;\n35) &quot;quorum&quot;\n36) &quot;2&quot;\n37) &quot;failover-timeout&quot;\n38) &quot;60000&quot;\n39) &quot;parallel-syncs&quot;\n40) &quot;1&quot;\n</code></pre>\n<p>As you can see, it prints a number of information about the primary. There are<br>a few that are of particular interest for us:</p>\n<ol>\n<li><code>num-other-sentinels</code> is 2, so we know the Sentinel already detected two more Sentinels for this primary. If you check the logs you&#39;ll see the <code>+sentinel</code> events generated.</li>\n<li><code>flags</code> is just <code>master</code>. If the primary was down we could expect to see <code>s_down</code> or <code>o_down</code> flag as well here.</li>\n<li><code>num-slaves</code> is correctly set to 1, so Sentinel also detected that there is an attached replica to our primary.</li>\n</ol>\n<p>In order to explore more about this instance, you may want to try the following<br>two commands:</p>\n<pre><code>SENTINEL replicas mymaster\nSENTINEL sentinels mymaster\n</code></pre>\n<p>The first will provide similar information about the replicas connected to the<br>primary, and the second about the other Sentinels.</p>\n<h2>Obtaining the address of the current primary</h2>\n<p>As we already specified, Sentinel also acts as a configuration provider for<br>clients that want to connect to a set of primary and replicas. Because of<br>possible failovers or reconfigurations, clients have no idea about who is<br>the currently active primary for a given set of instances, so Sentinel exports<br>an API to ask this question:</p>\n<pre><code>127.0.0.1:5000&gt; SENTINEL get-master-addr-by-name mymaster\n1) &quot;127.0.0.1&quot;\n2) &quot;6379&quot;\n</code></pre>\n<h3>Testing the failover</h3>\n<p>At this point our toy Sentinel deployment is ready to be tested. We can<br>just kill our primary and check if the configuration changes. To do so<br>we can just do:</p>\n<pre><code>valkey-cli -p 6379 DEBUG sleep 30\n</code></pre>\n<p>This command will make our primary no longer reachable, sleeping for 30 seconds.<br>It basically simulates a primary hanging for some reason.</p>\n<p>If you check the Sentinel logs, you should be able to see a lot of action:</p>\n<ol>\n<li>Each Sentinel detects the primary is down with an <code>+sdown</code> event.</li>\n<li>This event is later escalated to <code>+odown</code>, which means that multiple Sentinels agree about the fact the primary is not reachable.</li>\n<li>Sentinels vote a Sentinel that will start the first failover attempt.</li>\n<li>The failover happens.</li>\n</ol>\n<p>If you ask again what is the current primary address for <code>mymaster</code>, eventually<br>we should get a different reply this time:</p>\n<pre><code>127.0.0.1:5000&gt; SENTINEL get-master-addr-by-name mymaster\n1) &quot;127.0.0.1&quot;\n2) &quot;6380&quot;\n</code></pre>\n<p>So far so good... At this point you may jump to create your Sentinel deployment<br>or can read more to understand all the Sentinel commands and internals.</p>\n<h2>Sentinel API</h2>\n<p>Sentinel provides an API in order to inspect its state, check the health<br>of monitored primaries and replicas, subscribe in order to receive specific<br>notifications, and change the Sentinel configuration at run time.</p>\n<p>By default Sentinel runs using TCP port 26379 (note that 6379 is the normal<br>Valkey port). Sentinels accept commands using the Valkey protocol, so you can<br>use <code>valkey-cli</code> or any other unmodified Valkey client in order to talk with<br>Sentinel.</p>\n<p>It is possible to directly query a Sentinel to check what is the state of<br>the monitored Valkey instances from its point of view, to see what other<br>Sentinels it knows, and so forth. Alternatively, using Pub/Sub, it is possible<br>to receive <em>push style</em> notifications from Sentinels, every time some event<br>happens, like a failover, or an instance entering an error condition, and<br>so forth.</p>\n<h3>Sentinel commands</h3>\n<p>The <code>SENTINEL</code> command is the main API for Sentinel. The following is the list of its subcommands (minimal version is noted for where applicable):</p>\n<ul>\n<li><strong>SENTINEL CONFIG GET <code>&lt;name&gt;</code></strong> (<code>&gt;= 6.2</code>) Get the current value of a global Sentinel configuration parameter. The specified name may be a wildcard, similar to the Valkey <code>CONFIG GET</code> command.</li>\n<li><strong>SENTINEL CONFIG SET <code>&lt;name&gt;</code> <code>&lt;value&gt;</code></strong> (<code>&gt;= 6.2</code>) Set the value of a global Sentinel configuration parameter.</li>\n<li><strong>SENTINEL CKQUORUM <code>&lt;primary name&gt;</code></strong> Check if the current Sentinel configuration is able to reach the quorum needed to failover a primary, and the majority needed to authorize the failover. This command should be used in monitoring systems to check if a Sentinel deployment is ok.</li>\n<li><strong>SENTINEL FLUSHCONFIG</strong> Force Sentinel to rewrite its configuration on disk, including the current Sentinel state. Normally Sentinel rewrites the configuration every time something changes in its state (in the context of the subset of the state which is persisted on disk across restart). However sometimes it is possible that the configuration file is lost because of operation errors, disk failures, package upgrade scripts or configuration managers. In those cases a way to force Sentinel to rewrite the configuration file is handy. This command works even if the previous configuration file is completely missing.</li>\n<li><strong>SENTINEL FAILOVER <code>&lt;primary name&gt;</code></strong> Force a failover as if the primary was not reachable, and without asking for agreement to other Sentinels (however a new version of the configuration will be published so that the other Sentinels will update their configurations).</li>\n<li><strong>SENTINEL GET-MASTER-ADDR-BY-NAME <code>&lt;primary name&gt;</code></strong> Return the ip and port number of the primary with that name. If a failover is in progress or terminated successfully for this primary it returns the address and port of the promoted replica.</li>\n<li><strong>SENTINEL INFO-CACHE</strong> Return cached <code>INFO</code> output from primaries and replicas.</li>\n<li><strong>SENTINEL IS-MASTER-DOWN-BY-ADDR <ip> <port> <current-epoch> <runid></strong> Check if the primary specified by ip:port is down from current Sentinel&#39;s point of view. This command is mostly for internal use.</li>\n<li><strong>SENTINEL MASTER <code>&lt;primary name&gt;</code></strong> Show the state and info of the specified primary.</li>\n<li><strong>SENTINEL MASTERS</strong> Show a list of monitored primaries and their state.</li>\n<li><strong>SENTINEL MONITOR</strong> Start Sentinel&#39;s monitoring. Refer to the <a href=\"#reconfiguring-sentinel-at-runtime\"><em>Reconfiguring Sentinel at Runtime</em> section</a> for more information.</li>\n<li><strong>SENTINEL MYID</strong> (<code>&gt;= 6.2</code>) Return the ID of the Sentinel instance.</li>\n<li><strong>SENTINEL PENDING-SCRIPTS</strong> This command returns information about pending scripts.</li>\n<li><strong>SENTINEL REMOVE</strong> Stop Sentinel&#39;s monitoring. Refer to the <a href=\"#reconfiguring-sentinel-at-runtime\"><em>Reconfiguring Sentinel at Runtime</em> section</a> for more information.</li>\n<li><strong>SENTINEL REPLICAS <code>&lt;primary name&gt;</code></strong> Show a list of replicas for this primary, and their state.</li>\n<li><strong>SENTINEL SENTINELS <code>&lt;primary name&gt;</code></strong> Show a list of sentinel instances for this primary, and their state.</li>\n<li><strong>SENTINEL SET</strong> Set Sentinel&#39;s monitoring configuration. Refer to the <a href=\"#reconfiguring-sentinel-at-runtime\"><em>Reconfiguring Sentinel at Runtime</em> section</a> for more information.</li>\n<li><strong>SENTINEL SIMULATE-FAILURE (crash-after-election|crash-after-promotion|help)</strong> This command simulates different Sentinel crash scenarios.</li>\n<li><strong>SENTINEL RESET <code>&lt;pattern&gt;</code></strong> This command will reset all the primaries with matching name. The pattern argument is a glob-style pattern. The reset process clears any previous state in a primary (including a failover in progress), and removes every replica and sentinel already discovered and associated with the primary.</li>\n</ul>\n<p>For connection management and administration purposes, Sentinel supports the following subset of Valkey&#39;s commands:</p>\n<ul>\n<li><strong>ACL</strong> (<code>&gt;= 6.2</code>) This command manages the Sentinel Access Control List. For more information refer to the <a href=\"acl.md\">ACL</a> documentation page and the <a href=\"#sentinel-access-control-list-authentication\"><em>Sentinel Access Control List authentication</em></a>.</li>\n<li><strong>AUTH</strong> Authenticate a client connection. For more information refer to the <code>AUTH</code> command and the <a href=\"#configuring-sentinel-instances-with-authentication\"><em>Configuring Sentinel instances with authentication</em> section</a>.</li>\n<li><strong>CLIENT</strong> This command manages client connections. For more information refer to its subcommands&#39; pages.</li>\n<li><strong>COMMAND</strong> (<code>&gt;= 6.2</code>) This command returns information about commands. For more information refer to the <code>COMMAND</code> command and its various subcommands.</li>\n<li><strong>HELLO</strong> (<code>&gt;= 6.0</code>) Switch the connection&#39;s protocol. For more information refer to the <code>HELLO</code> command.</li>\n<li><strong>INFO</strong> Return information and statistics about the Sentinel server. For more information see the <code>INFO</code> command.</li>\n<li><strong>PING</strong> This command simply returns PONG.</li>\n<li><strong>ROLE</strong> This command returns the string &quot;sentinel&quot; and a list of monitored primaries. For more information refer to the <code>ROLE</code> command.</li>\n<li><strong>SHUTDOWN</strong> Shut down the Sentinel instance.</li>\n</ul>\n<p>Lastly, Sentinel also supports the <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code> and <code>PUNSUBSCRIBE</code> commands. Refer to the <a href=\"#pubsub-messages\"><em>Pub/Sub Messages</em> section</a> for more details.</p>\n<h3>Reconfiguring Sentinel at Runtime</h3>\n<p>Sentinel provides an API in order to add, remove, or change the configuration of a given primary. Note that if you have multiple sentinels you should apply the changes to all to your instances for Valkey Sentinel to work properly. This means that changing the configuration of a single Sentinel does not automatically propagate the changes to the other Sentinels in the network.</p>\n<p>The following is a list of <code>SENTINEL</code> subcommands used in order to update the configuration of a Sentinel instance.</p>\n<ul>\n<li><strong>SENTINEL MONITOR <code>&lt;name&gt;</code> <code>&lt;ip&gt;</code> <code>&lt;port&gt;</code> <code>&lt;quorum&gt;</code></strong> This command tells the Sentinel to start monitoring a new primary with the specified name, ip, port, and quorum. It is identical to the <code>sentinel monitor</code> configuration directive in <code>sentinel.conf</code> configuration file, with the difference that you can&#39;t use a hostname in as <code>ip</code>, but you need to provide an IPv4 or IPv6 address.</li>\n<li><strong>SENTINEL REMOVE <code>&lt;name&gt;</code></strong> is used in order to remove the specified primary: the primary will no longer be monitored, and will totally be removed from the internal state of the Sentinel, so it will no longer listed by <code>SENTINEL masters</code> and so forth.</li>\n<li><strong>SENTINEL SET <code>&lt;name&gt;</code> [<code>&lt;option&gt;</code> <code>&lt;value&gt;</code> ...]</strong> The SET command is very similar to the <code>CONFIG SET</code> command of Valkey, and is used in order to change configuration parameters of a specific primary. Multiple option / value pairs can be specified (or none at all). All the configuration parameters that can be configured via <code>sentinel.conf</code> are also configurable using the SET command.</li>\n</ul>\n<p>The following is an example of <code>SENTINEL SET</code> command in order to modify the <code>down-after-milliseconds</code> configuration of a primary called <code>objects-cache</code>:</p>\n<pre><code>SENTINEL SET objects-cache-master down-after-milliseconds 1000\n</code></pre>\n<p>As already stated, <code>SENTINEL SET</code> can be used to set all the configuration parameters that are settable in the startup configuration file. Moreover it is possible to change just the primary quorum configuration without removing and re-adding the primary with <code>SENTINEL REMOVE</code> followed by <code>SENTINEL MONITOR</code>, but simply using:</p>\n<pre><code>SENTINEL SET objects-cache-master quorum 5\n</code></pre>\n<p>Note that there is no equivalent GET command since <code>SENTINEL MASTER</code> provides all the configuration parameters in a simple to parse format (as a field/value pairs array).</p>\n<p>Sentinel also allows getting and setting global configuration parameters which were only supported in the configuration file prior to that.</p>\n<ul>\n<li><strong>SENTINEL CONFIG GET <code>&lt;name&gt;</code></strong> Get the current value of a global Sentinel configuration parameter. The specified name may be a wildcard, similar to the Valkey <code>CONFIG GET</code> command.</li>\n<li><strong>SENTINEL CONFIG SET <code>&lt;name&gt;</code> <code>&lt;value&gt;</code></strong> Set the value of a global Sentinel configuration parameter.</li>\n</ul>\n<p>Global parameters that can be manipulated include:</p>\n<ul>\n<li><code>resolve-hostnames</code>, <code>announce-hostnames</code>. See <a href=\"#ip-addresses-and-dns-names\"><em>IP addresses and DNS names</em></a>.</li>\n<li><code>announce-ip</code>, <code>announce-port</code>. See <a href=\"#sentinel-docker-nat-and-possible-issues\"><em>Sentinel, Docker, NAT, and possible issues</em></a>.</li>\n<li><code>sentinel-user</code>, <code>sentinel-pass</code>. See <a href=\"#configuring-sentinel-instances-with-authentication\"><em>Configuring Sentinel instances with authentication</em></a>.</li>\n</ul>\n<h3>Adding or removing Sentinels</h3>\n<p>Adding a new Sentinel to your deployment is a simple process because of the<br>auto-discover mechanism implemented by Sentinel. All you need to do is to<br>start the new Sentinel configured to monitor the currently active primary.<br>Within 10 seconds the Sentinel will acquire the list of other Sentinels and<br>the set of replicas attached to the primary.</p>\n<p>If you need to add multiple Sentinels at once, it is suggested to add it<br>one after the other, waiting for all the other Sentinels to already know<br>about the first one before adding the next. This is useful in order to still<br>guarantee that majority can be achieved only in one side of a partition,<br>in the chance failures should happen in the process of adding new Sentinels.</p>\n<p>This can be easily achieved by adding every new Sentinel with a 30 seconds delay, and during absence of network partitions.</p>\n<p>At the end of the process it is possible to use the command<br><code>SENTINEL MASTER &lt;primary name&gt;</code> in order to check if all the Sentinels agree about<br>the total number of Sentinels monitoring the primary.</p>\n<p>Removing a Sentinel is a bit more complex: <strong>Sentinels never forget already seen<br>Sentinels</strong>, even if they are not reachable for a long time, since we don&#39;t<br>want to dynamically change the majority needed to authorize a failover and<br>the creation of a new configuration number. So in order to remove a Sentinel<br>the following steps should be performed in absence of network partitions:</p>\n<ol>\n<li>Stop the Sentinel process of the Sentinel you want to remove.</li>\n<li>Send a <code>SENTINEL RESET *</code> command to all the other Sentinel instances (instead of <code>*</code> you can use the exact primary name if you want to reset just a single primary). One after the other, waiting at least 30 seconds between instances.</li>\n<li>Check that all the Sentinels agree about the number of Sentinels currently active, by inspecting the output of <code>SENTINEL MASTER &lt;primary name&gt;</code> of every Sentinel.</li>\n</ol>\n<h3>Removing the old primary or unreachable replicas</h3>\n<p>Sentinels never forget about replicas of a given primary, even when they are<br>unreachable for a long time. This is useful, because Sentinels should be able<br>to correctly reconfigure a returning replica after a network partition or a<br>failure event.</p>\n<p>Moreover, after a failover, the failed over primary is virtually added as a<br>replica of the new primary, this way it will be reconfigured to replicate with<br>the new primary as soon as it will be available again.</p>\n<p>However sometimes you want to remove a replica (that may be the old primary)<br>forever from the list of replicas monitored by Sentinels.</p>\n<p>In order to do this, you need to send a <code>SENTINEL RESET &lt;primary name&gt;</code> command<br>to all the Sentinels: they&#39;ll refresh the list of replicas within the next<br>10 seconds, only adding the ones listed as correctly replicating from the<br>current primary <code>INFO</code> output.</p>\n<h3>Pubsub messages</h3>\n<p>A client can use a Sentinel as a Valkey-compatible Pub/Sub server<br>(but you can&#39;t use <code>PUBLISH</code>) in order to <code>SUBSCRIBE</code> or <code>PSUBSCRIBE</code> to<br>channels and get notified about specific events.</p>\n<p>The channel name is the same as the name of the event. For instance the<br>channel named <code>+sdown</code> will receive all the notifications related to instances<br>entering an <code>SDOWN</code> (SDOWN means the instance is no longer reachable from<br>the point of view of the Sentinel you are querying) condition.</p>\n<p>To get all the messages simply subscribe using <code>PSUBSCRIBE *</code>.</p>\n<p>The following is a list of channels and message formats you can receive using<br>this API. The first word is the channel / event name, the rest is the format of the data.</p>\n<p>Note: where <em>instance details</em> is specified it means that the following arguments are provided to identify the target instance:</p>\n<pre><code>&lt;instance-type&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;primary-name&gt; &lt;primary-ip&gt; &lt;primary-port&gt;\n</code></pre>\n<p>The part identifying the primary (from the @ argument to the end) is optional<br>and is only specified if the instance is not a primary itself.</p>\n<ul>\n<li><strong>+reset-master</strong> <code>&lt;instance details&gt;</code> -- The primary was reset.</li>\n<li><strong>+slave</strong> <code>&lt;instance details&gt;</code> -- A new replica was detected and attached.</li>\n<li><strong>+failover-state-reconf-slaves</strong> <code>&lt;instance details&gt;</code> -- Failover state changed to <code>reconf-slaves</code> state.</li>\n<li><strong>+failover-detected</strong> <code>&lt;instance details&gt;</code> -- A failover started by another Sentinel or any other external entity was detected (An attached replica turned into a primary).</li>\n<li><strong>+slave-reconf-sent</strong> <code>&lt;instance details&gt;</code> -- The leader sentinel sent the <code>REPLICAOF</code> command to this instance in order to reconfigure it for the new replica.</li>\n<li><strong>+slave-reconf-inprog</strong> <code>&lt;instance details&gt;</code> -- The replica being reconfigured showed to be a replica of the new primary ip:port pair, but the synchronization process is not yet complete.</li>\n<li><strong>+slave-reconf-done</strong> <code>&lt;instance details&gt;</code> -- The replica is now synchronized with the new primary.</li>\n<li><strong>-dup-sentinel</strong> <code>&lt;instance details&gt;</code> -- One or more sentinels for the specified primary were removed as duplicated (this happens for instance when a Sentinel instance is restarted).</li>\n<li><strong>+sentinel</strong> <code>&lt;instance details&gt;</code> -- A new sentinel for this primary was detected and attached.</li>\n<li><strong>+sdown</strong> <code>&lt;instance details&gt;</code> -- The specified instance is now in Subjectively Down state.</li>\n<li><strong>-sdown</strong> <code>&lt;instance details&gt;</code> -- The specified instance is no longer in Subjectively Down state.</li>\n<li><strong>+odown</strong> <code>&lt;instance details&gt;</code> -- The specified instance is now in Objectively Down state.</li>\n<li><strong>-odown</strong> <code>&lt;instance details&gt;</code> -- The specified instance is no longer in Objectively Down state.</li>\n<li><strong>+new-epoch</strong> <code>&lt;instance details&gt;</code> -- The current epoch was updated.</li>\n<li><strong>+try-failover</strong> <code>&lt;instance details&gt;</code> -- New failover in progress, waiting to be elected by the majority.</li>\n<li><strong>+elected-leader</strong> <code>&lt;instance details&gt;</code> -- Won the election for the specified epoch, can do the failover.</li>\n<li><strong>+failover-state-select-slave</strong> <code>&lt;instance details&gt;</code> -- New failover state is <code>select-slave</code>: we are trying to find a suitable replica for promotion.</li>\n<li><strong>no-good-slave</strong> <code>&lt;instance details&gt;</code> -- There is no good replica to promote. Currently we&#39;ll try after some time, but probably this will change and the state machine will abort the failover at all in this case.</li>\n<li><strong>selected-slave</strong> <code>&lt;instance details&gt;</code> -- We found the specified good replica to promote.</li>\n<li><strong>failover-state-send-slaveof-noone</strong> <code>&lt;instance details&gt;</code> -- We are trying to reconfigure the promoted replica as primary, waiting for it to switch.</li>\n<li><strong>failover-end-for-timeout</strong> <code>&lt;instance details&gt;</code> -- The failover terminated for timeout, replicas will eventually be configured to replicate with the new primary anyway.</li>\n<li><strong>failover-end</strong> <code>&lt;instance details&gt;</code> -- The failover terminated with success. All the replicas appear to be reconfigured to replicate with the new primary.</li>\n<li><strong>switch-master</strong> <code>&lt;primary name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;</code> -- The primary new IP and address is the specified one after a configuration change. This is <strong>the message most external users are interested in</strong>.</li>\n<li><strong>+tilt</strong> -- Tilt mode entered.</li>\n<li><strong>-tilt</strong> -- Tilt mode exited.</li>\n</ul>\n<h3>Handling of -BUSY state</h3>\n<p>The -BUSY error is returned by a Valkey instance when a Lua script is running for<br>more time than the configured Lua script time limit. When this happens before<br>triggering a fail over Valkey Sentinel will try to send a <code>SCRIPT KILL</code><br>command, that will only succeed if the script was read-only.</p>\n<p>If the instance is still in an error condition after this try, it will<br>eventually be failed over.</p>\n<h2>Replicas priority</h2>\n<p>Valkey instances have a configuration parameter called <code>replica-priority</code>.<br>This information is exposed by Valkey replica instances in their <code>INFO</code> output,<br>and Sentinel uses it in order to pick a replica among the ones that can be<br>used in order to failover a primary:</p>\n<ol>\n<li>If the replica priority is set to 0, the replica is never promoted to primary.</li>\n<li>Replicas with a <em>lower</em> priority number are preferred by Sentinel.</li>\n</ol>\n<p>For example if there is a replica S1 in the same data center of the current<br>primary, and another replica S2 in another data center, it is possible to set<br>S1 with a priority of 10 and S2 with a priority of 100, so that if the primary<br>fails and both S1 and S2 are available, S1 will be preferred.</p>\n<p>For more information about the way replicas are selected, please check the <a href=\"#replica-selection-and-priority\"><em>Replica selection and priority</em> section</a> of this documentation.</p>\n<h3>Sentinel and Valkey authentication</h3>\n<p>When the primary is configured to require authentication from clients,<br>as a security measure, replicas need to also be aware of the credentials in<br>order to authenticate with the primary and create the primary-replica connection<br>used for the asynchronous replication protocol.</p>\n<h2>Valkey Access Control List authentication</h2>\n<p>User authentication and permission is managed with the <a href=\"acl.md\">Access Control List (ACL)</a>.</p>\n<p>In order for Sentinels to connect to Valkey server instances when they are<br>configured with ACL, the Sentinel configuration must include the<br>following directives:</p>\n<pre><code>sentinel auth-user &lt;primary-name&gt; &lt;username&gt;\nsentinel auth-pass &lt;primary-name&gt; &lt;password&gt;\n</code></pre>\n<p>Where <code>&lt;username&gt;</code> and <code>&lt;password&gt;</code> are the username and password for accessing the group&#39;s instances. These credentials should be provisioned on all of the group&#39;s Valkey instances with the minimal control permissions. For example:</p>\n<pre><code>127.0.0.1:6379&gt; ACL SETUSER sentinel-user ON &gt;somepassword allchannels +multi +slaveaof +ping +exec +subscribe +config|rewrite +role +publish +info +client|setname +client|kill +script|kill\n</code></pre>\n<h3>Valkey password-only authentication</h3>\n<p>Before ACL was introduced, authentication could be achieved using the following configuration directives:</p>\n<ul>\n<li><code>requirepass</code> in the primary, in order to set the authentication password, and to make sure the instance will not process requests for non authenticated clients.</li>\n<li><code>masterauth</code> in the replicas in order for the replicas to authenticate with the primary in order to correctly replicate data from it.</li>\n</ul>\n<p>When Sentinel is used, there is not a single primary, since after a failover<br>replicas may play the role of primaries, and old primaries can be reconfigured in<br>order to act as replicas, so what you want to do is to set the above directives<br>in all your instances, both primaries and replicas.</p>\n<p>This is also usually a sane setup since you don&#39;t want to protect<br>data only in the primary, having the same data accessible in the replicas.</p>\n<p>However, in the uncommon case where you need a replica that is accessible<br>without authentication, you can still do it by setting up <strong>a replica priority<br>of zero</strong>, to prevent this replica from being promoted to primary, and<br>configuring in this replica only the <code>masterauth</code> directive, without<br>using the <code>requirepass</code> directive, so that data will be readable by<br>unauthenticated clients.</p>\n<p>In order for Sentinels to connect to Valkey server instances when they are<br>configured with <code>requirepass</code>, the Sentinel configuration must include the<br><code>sentinel auth-pass</code> directive, in the format:</p>\n<pre><code>sentinel auth-pass &lt;primary-name&gt; &lt;password&gt;\n</code></pre>\n<h2>Configuring Sentinel instances with authentication</h2>\n<p>Sentinel instances themselves can be secured by requiring clients to authenticate via the <code>AUTH</code> command. Starting with Redis OSS 6.2, the <a href=\"acl.md\">Access Control List (ACL)</a> is available, whereas older versions support password-only authentication.</p>\n<p>Note that Sentinel&#39;s authentication configuration should be <strong>applied to each of the instances</strong> in your deployment, and <strong>all instances should use the same configuration</strong>. Furthermore, ACL and password-only authentication should not be used together.</p>\n<h3>Sentinel Access Control List authentication</h3>\n<p>The first step in securing a Sentinel instance with ACL is preventing any unauthorized access to it. To do that, you&#39;ll need to disable the default superuser (or at the very least set it up with a strong password) and create a new one and allow it access to Pub/Sub channels:</p>\n<pre><code>127.0.0.1:5000&gt; ACL SETUSER admin ON &gt;admin-password allchannels +@all\nOK\n127.0.0.1:5000&gt; ACL SETUSER default off\nOK\n</code></pre>\n<p>The default user is used by Sentinel to connect to other instances. You can provide the credentials of another superuser with the following configuration directives:</p>\n<pre><code>sentinel sentinel-user &lt;username&gt;\nsentinel sentinel-pass &lt;password&gt;\n</code></pre>\n<p>Where <code>&lt;username&gt;</code> and <code>&lt;password&gt;</code> are the Sentinel&#39;s superuser and password, respectively (e.g. <code>admin</code> and <code>admin-password</code> in the example above).</p>\n<p>Lastly, for authenticating incoming client connections, you can create a Sentinel restricted user profile such as the following:</p>\n<pre><code>127.0.0.1:5000&gt; ACL SETUSER sentinel-user ON &gt;user-password -@all +auth +client|getname +client|id +client|setname +command +hello +ping +role +sentinel|get-master-addr-by-name +sentinel|master +sentinel|myid +sentinel|replicas +sentinel|sentinels\n</code></pre>\n<p>Refer to the documentation of your Sentinel client of choice for further information.</p>\n<h3>Sentinel password-only authentication</h3>\n<p>To use Sentinel with password-only authentication, add the <code>requirepass</code> configuration directive to <strong>all</strong> your Sentinel instances as follows:</p>\n<pre><code>requirepass &quot;your_password_here&quot;\n</code></pre>\n<p>When configured this way, Sentinels will do two things:</p>\n<ol>\n<li>A password will be required from clients in order to send commands to Sentinels. This is obvious since this is how such configuration directive works in Valkey in general.</li>\n<li>Moreover the same password configured to access the local Sentinel, will be used by this Sentinel instance in order to authenticate to all the other Sentinel instances it connects to.</li>\n</ol>\n<p>This means that <strong>you will have to configure the same <code>requirepass</code> password in all the Sentinel instances</strong>. This way every Sentinel can talk with every other Sentinel without any need to configure for each Sentinel the password to access all the other Sentinels, that would be very impractical.</p>\n<p>Before using this configuration, make sure your client library can send the <code>AUTH</code> command to Sentinel instances.</p>\n<h3>Sentinel clients implementation</h3>\n<hr>\n<p>Sentinel requires explicit client support, unless the system is configured to execute a script that performs a transparent redirection of all the requests to the new primary instance (virtual IP or other similar systems). The topic of client libraries implementation is covered in the document <a href=\"sentinel-clients.md\">Sentinel clients guidelines</a>.</p>\n<h2>More advanced concepts</h2>\n<p>In the following sections we&#39;ll cover a few details about how Sentinel works,<br>without resorting to implementation details and algorithms that will be<br>covered in the final part of this document.</p>\n<h3>SDOWN and ODOWN failure state</h3>\n<p>Valkey Sentinel has two different concepts of <em>being down</em>, one is called<br>a <em>Subjectively Down</em> condition (SDOWN) and is a down condition that is<br>local to a given Sentinel instance. Another is called <em>Objectively Down</em><br>condition (ODOWN) and is reached when enough Sentinels (at least the<br>number configured as the <code>quorum</code> parameter of the monitored primary) have<br>an SDOWN condition, and get feedback from other Sentinels using<br>the <code>SENTINEL is-master-down-by-addr</code> command.</p>\n<p>From the point of view of a Sentinel an SDOWN condition is reached when it<br>does not receive a valid reply to PING requests for the number of seconds<br>specified in the configuration as <code>is-master-down-after-milliseconds</code><br>parameter.</p>\n<p>An acceptable reply to PING is one of the following:</p>\n<ul>\n<li>PING replied with +PONG.</li>\n<li>PING replied with -LOADING error.</li>\n<li>PING replied with -MASTERDOWN error.</li>\n</ul>\n<p>Any other reply (or no reply at all) is considered non valid.<br>However note that <strong>a logical primary that advertises itself as a replica in<br>the INFO output is considered to be down</strong>.</p>\n<p>Note that SDOWN requires that no acceptable reply is received for the whole<br>interval configured, so for instance if the interval is 30000 milliseconds<br>(30 seconds) and we receive an acceptable ping reply every 29 seconds, the<br>instance is considered to be working.</p>\n<p>SDOWN is not enough to trigger a failover: it only means a single Sentinel<br>believes a Valkey instance is not available. To trigger a failover, the<br>ODOWN state must be reached.</p>\n<p>To switch from SDOWN to ODOWN no strong consensus algorithm is used, but<br>just a form of gossip: if a given Sentinel gets reports that a primary<br>is not working from enough Sentinels <strong>in a given time range</strong>, the SDOWN is<br>promoted to ODOWN. If this acknowledge is later missing, the flag is cleared.</p>\n<p>A more strict authorization that uses an actual majority is required in<br>order to really start the failover, but no failover can be triggered without<br>reaching the ODOWN state.</p>\n<p>The ODOWN condition <strong>only applies to primaries</strong>. For other kind of instances<br>Sentinel doesn&#39;t require to act, so the ODOWN state is never reached for replicas<br>and other sentinels, but only SDOWN is.</p>\n<p>However SDOWN has also semantic implications. For example a replica in SDOWN<br>state is not selected to be promoted by a Sentinel performing a failover.</p>\n<h2>Sentinels and replicas auto discovery</h2>\n<p>Sentinels stay connected with other Sentinels in order to reciprocally<br>check the availability of each other, and to exchange messages. However you<br>don&#39;t need to configure a list of other Sentinel addresses in every Sentinel<br>instance you run, as Sentinel uses the Valkey instances Pub/Sub capabilities<br>in order to discover the other Sentinels that are monitoring the same primaries<br>and replicas.</p>\n<p>This feature is implemented by sending <em>hello messages</em> into the channel named<br><code>__sentinel__:hello</code>.</p>\n<p>Similarly you don&#39;t need to configure what is the list of the replicas attached<br>to a primary, as Sentinel will auto discover this list querying Valkey.</p>\n<ul>\n<li>Every Sentinel publishes a message to every monitored primary and replica Pub/Sub channel <code>__sentinel__:hello</code>, every two seconds, announcing its presence with ip, port, runid.</li>\n<li>Every Sentinel is subscribed to the Pub/Sub channel <code>__sentinel__:hello</code> of every primary and replica, looking for unknown sentinels. When new sentinels are detected, they are added as sentinels of this primary.</li>\n<li>Hello messages also include the full current configuration of the primary. If the receiving Sentinel has a configuration for a given primary which is older than the one received, it updates to the new configuration immediately.</li>\n<li>Before adding a new sentinel to a primary a Sentinel always checks if there is already a sentinel with the same runid or the same address (ip and port pair). In that case all the matching sentinels are removed, and the new added.</li>\n</ul>\n<h2>Sentinel reconfiguration of instances outside the failover procedure</h2>\n<p>Even when no failover is in progress, Sentinels will always try to set the<br>current configuration on monitored instances. Specifically:</p>\n<ul>\n<li>Replicas (according to the current configuration) that claim to be primaries, will be configured as replicas to replicate with the current primary.</li>\n<li>Replicas connected to a wrong primary, will be reconfigured to replicate with the right primary.</li>\n</ul>\n<p>For Sentinels to reconfigure replicas, the wrong configuration must be observed for some time, that is greater than the period used to broadcast new configurations.</p>\n<p>This prevents Sentinels with a stale configuration (for example because they just rejoined from a partition) will try to change the replicas configuration before receiving an update.</p>\n<p>Also note how the semantics of always trying to impose the current configuration makes the failover more resistant to partitions:</p>\n<ul>\n<li>Masters failed over are reconfigured as replicas when they return available.</li>\n<li>Replicas partitioned away during a partition are reconfigured once reachable.</li>\n</ul>\n<p>The important lesson to remember about this section is: <strong>Sentinel is a system where each process will always try to impose the last logical configuration to the set of monitored instances</strong>.</p>\n<h3>Replica selection and priority</h3>\n<p>When a Sentinel instance is ready to perform a failover, since the primary<br>is in <code>ODOWN</code> state and the Sentinel received the authorization to failover<br>from the majority of the Sentinel instances known, a suitable replica needs<br>to be selected.</p>\n<p>The replica selection process evaluates the following information about replicas:</p>\n<ol>\n<li>Disconnection time from the primary.</li>\n<li>Replica priority.</li>\n<li>Replication offset processed.</li>\n<li>Run ID.</li>\n</ol>\n<p>A replica that is found to be disconnected from the primary for more than ten<br>times the configured primary timeout (down-after-milliseconds option), plus<br>the time the primary is also not available from the point of view of the<br>Sentinel doing the failover, is considered to be not suitable for the failover<br>and is skipped.</p>\n<p>In more rigorous terms, a replica whose the <code>INFO</code> output suggests it has been<br>disconnected from the primary for more than:</p>\n<pre><code>(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state\n</code></pre>\n<p>Is considered to be unreliable and is disregarded entirely.</p>\n<p>The replica selection only considers the replicas that passed the above test,<br>and sorts it based on the above criteria, in the following order.</p>\n<ol>\n<li>The replicas are sorted by <code>replica-priority</code> as configured in the <code>valkey.conf</code> file of the Valkey instance. A lower priority will be preferred.</li>\n<li>If the priority is the same, the replication offset processed by the replica is checked, and the replica that received more data from the primary is selected.</li>\n<li>If multiple replicas have the same priority and processed the same data from the primary, a further check is performed, selecting the replica with the lexicographically smaller run ID. Having a lower run ID is not a real advantage for a replica, but is useful in order to make the process of replica selection more deterministic, instead of resorting to select a random replica.</li>\n</ol>\n<p>In most cases, <code>replica-priority</code> does not need to be set explicitly so all<br>instances will use the same default value. If there is a particular fail-over<br>preference, <code>replica-priority</code> must be set on all instances, including primaries,<br>as a primary may become a replica at some future point in time - and it will then<br>need the proper <code>replica-priority</code> settings.</p>\n<p>A Valkey instance can be configured with a special <code>replica-priority</code> of zero<br>in order to be <strong>never selected</strong> by Sentinels as the new primary.<br>However a replica configured in this way will still be reconfigured by<br>Sentinels in order to replicate with the new primary after a failover, the<br>only difference is that it will never become a primary itself.</p>\n<h2>Algorithms and internals</h2>\n<p>In the following sections we will explore the details of Sentinel behavior.<br>It is not strictly needed for users to be aware of all the details, but a<br>deep understanding of Sentinel may help to deploy and operate Sentinel in<br>a more effective way.</p>\n<h3>Quorum</h3>\n<p>The previous sections showed that every primary monitored by Sentinel is associated to a configured <strong>quorum</strong>. It specifies the number of Sentinel processes<br>that need to agree about the unreachability or error condition of the primary in<br>order to trigger a failover.</p>\n<p>However, after the failover is triggered, in order for the failover to actually be performed, <strong>at least a majority of Sentinels must authorize the Sentinel to<br>failover</strong>. Sentinel never performs a failover in the partition where a<br>minority of Sentinels exist.</p>\n<p>Let&#39;s try to make things a bit more clear:</p>\n<ul>\n<li>Quorum: the number of Sentinel processes that need to detect an error condition in order for a primary to be flagged as <strong>ODOWN</strong>.</li>\n<li>The failover is triggered by the <strong>ODOWN</strong> state.</li>\n<li>Once the failover is triggered, the Sentinel trying to failover is required to ask for authorization to a majority of Sentinels (or more than the majority if the quorum is set to a number greater than the majority).</li>\n</ul>\n<p>The difference may seem subtle but is actually quite simple to understand and use.  For example if you have 5 Sentinel instances, and the quorum is set to 2, a failover will be triggered as soon as 2 Sentinels believe that the primary is not reachable, however one of the two Sentinels will be able to failover only if it gets authorization at least from 3 Sentinels.</p>\n<p>If instead the quorum is configured to 5, all the Sentinels must agree about the primary error condition, and the authorization from all Sentinels is required in order to failover.</p>\n<p>This means that the quorum can be used to tune Sentinel in two ways:</p>\n<ol>\n<li>If a quorum is set to a value smaller than the majority of Sentinels we deploy, we are basically making Sentinel more sensitive to primary failures, triggering a failover as soon as even just a minority of Sentinels is no longer able to talk with the primary.</li>\n<li>If a quorum is set to a value greater than the majority of Sentinels, we are making Sentinel able to failover only when there are a very large number (larger than majority) of well connected Sentinels which agree about the primary being down.</li>\n</ol>\n<h3>Configuration epochs</h3>\n<p>Sentinels require to get authorizations from a majority in order to start a<br>failover for a few important reasons:</p>\n<p>When a Sentinel is authorized, it gets a unique <strong>configuration epoch</strong> for the primary it is failing over. This is a number that will be used to version the new configuration after the failover is completed. Because a majority agreed that a given version was assigned to a given Sentinel, no other Sentinel will be able to use it. This means that every configuration of every failover is versioned with a unique version. We&#39;ll see why this is so important.</p>\n<p>Moreover Sentinels have a rule: if a Sentinel voted another Sentinel for the failover of a given primary, it will wait some time to try to failover the same primary again. This delay is the <code>2 * failover-timeout</code> you can configure in <code>sentinel.conf</code>. This means that Sentinels will not try to failover the same primary at the same time, the first to ask to be authorized will try, if it fails another will try after some time, and so forth.</p>\n<p>Valkey Sentinel guarantees the <em>liveness</em> property that if a majority of Sentinels are able to talk, eventually one will be authorized to failover if the primary is down.</p>\n<p>Valkey Sentinel also guarantees the <em>safety</em> property that every Sentinel will failover the same primary using a different <em>configuration epoch</em>.</p>\n<h3>Configuration propagation</h3>\n<p>Once a Sentinel is able to failover a primary successfully, it will start to broadcast the new configuration so that the other Sentinels will update their information about a given primary.</p>\n<p>For a failover to be considered successful, it requires that the Sentinel was able to send the <code>REPLICAOF NO ONE</code> command to the selected replica, and that the switch to primary was later observed in the <code>INFO</code> output of the primary.</p>\n<p>At this point, even if the reconfiguration of the replicas is in progress, the failover is considered to be successful, and all the Sentinels are required to start reporting the new configuration.</p>\n<p>The way a new configuration is propagated is the reason why we need that every<br>Sentinel failover is authorized with a different version number (configuration epoch).</p>\n<p>Every Sentinel continuously broadcast its version of the configuration of a primary using Valkey Pub/Sub messages, both in the primary and all the replicas.  At the same time all the Sentinels wait for messages to see what is the configuration<br>advertised by the other Sentinels.</p>\n<p>Configurations are broadcast in the <code>__sentinel__:hello</code> Pub/Sub channel.</p>\n<p>Because every configuration has a different version number, the greater version<br>always wins over smaller versions.</p>\n<p>So for example the configuration for the primary <code>mymaster</code> start with all the<br>Sentinels believing the primary is at 192.168.1.50:6379. This configuration<br>has version 1. After some time a Sentinel is authorized to failover with version 2. If the failover is successful, it will start to broadcast a new configuration, let&#39;s say 192.168.1.50:9000, with version 2. All the other instances will see this configuration and will update their configuration accordingly, since the new configuration has a greater version.</p>\n<p>This means that Sentinel guarantees a second liveness property: a set of<br>Sentinels that are able to communicate will all converge to the same configuration with the higher version number.</p>\n<p>Basically if the net is partitioned, every partition will converge to the higher<br>local configuration. In the special case of no partitions, there is a single<br>partition and every Sentinel will agree about the configuration.</p>\n<h3>Consistency under partitions</h3>\n<p>Valkey Sentinel configurations are eventually consistent, so every partition will<br>converge to the higher configuration available.<br>However in a real-world system using Sentinel there are three different players:</p>\n<ul>\n<li>Valkey instances.</li>\n<li>Sentinel instances.</li>\n<li>Clients.</li>\n</ul>\n<p>In order to define the behavior of the system we have to consider all three.</p>\n<p>The following is a simple network where there are 3 nodes, each running<br>a Valkey instance, and a Sentinel instance:</p>\n<pre><code>            +--------------+\n            | Sentinel 1   |----- Client A\n            | Valkey 1 (M) |\n            +--------------+\n                    |\n                    |\n+--------------+    |          +-------------+\n| Sentinel 2   |----+-- // ----| Sentinel 3  |----- Client B\n| Valkey 2 (S) |               | Valkey 3 (M)|\n+--------------+               +-------------+\n</code></pre>\n<p>In this system the original state was that Valkey 3 was the primary, while<br>Valkey 1 and 2 were replicas. A partition occurred isolating the old primary.<br>Sentinels 1 and 2 started a failover promoting Sentinel 1 as the new primary.</p>\n<p>The Sentinel properties guarantee that Sentinel 1 and 2 now have the new<br>configuration for the primary. However Sentinel 3 has still the old configuration<br>since it lives in a different partition.</p>\n<p>We know that Sentinel 3 will get its configuration updated when the network<br>partition will heal, however what happens during the partition if there<br>are clients partitioned with the old primary?</p>\n<p>Clients will be still able to write to Valkey 3, the old primary. When the<br>partition will rejoin, Valkey 3 will be turned into a replica of Valkey 1, and<br>all the data written during the partition will be lost.</p>\n<p>Depending on your configuration you may want or not that this scenario happens:</p>\n<ul>\n<li>If you are using Valkey as a cache, it could be handy that Client B is still able to write to the old primary, even if its data will be lost.</li>\n<li>If you are using Valkey as a store, this is not good and you need to configure the system in order to partially prevent this problem.</li>\n</ul>\n<p>Since Valkey is asynchronously replicated, there is no way to totally prevent data loss in this scenario, however you can bound the divergence between Valkey 3 and Valkey 1<br>using the following Valkey configuration option:</p>\n<pre><code>min-replicas-to-write 1\nmin-replicas-max-lag 10\n</code></pre>\n<p>With the above configuration (please see the self-commented <code>valkey.conf</code> example in the Valkey distribution for more information) a Valkey instance, when acting as a primary, will stop accepting writes if it can&#39;t write to at least 1 replica. Since replication is asynchronous <em>not being able to write</em> actually means that the replica is either disconnected, or is not sending us asynchronous acknowledges for more than the specified <code>max-lag</code> number of seconds.</p>\n<p>Using this configuration the Valkey 3 in the above example will become unavailable after 10 seconds. When the partition heals, the Sentinel 3 configuration will converge to<br>the new one, and Client B will be able to fetch a valid configuration and continue.</p>\n<p>In general Valkey + Sentinel as a whole are an <strong>eventually consistent system</strong> where the merge function is <strong>last failover wins</strong>, and the data from old primaries are discarded to replicate the data of the current primary, so there is always a window for losing acknowledged writes. This is due to Valkey asynchronous<br>replication and the discarding nature of the &quot;virtual&quot; merge function of the system. Note that this is not a limitation of Sentinel itself, and if you orchestrate the failover with a strongly consistent replicated state machine, the same properties will still apply. There are only two ways to avoid losing acknowledged writes:</p>\n<ol>\n<li>Use synchronous replication (and a proper consensus algorithm to run a replicated state machine).</li>\n<li>Use an eventually consistent system where different versions of the same object can be merged.</li>\n</ol>\n<p>Valkey (like it&#39;s predecessor Redis OSS) is currently not able to use any of the above systems, and using them is currently outside the development goals. However, there are proxies implementing solution &quot;2&quot; on top of Redis OSS stores such as SoundCloud <a href=\"https://github.com/soundcloud/roshi\">Roshi</a>, or Netflix <a href=\"https://github.com/Netflix/dynomite\">Dynomite</a>.</p>\n<h2>Sentinel persistent state</h2>\n<p>Sentinel state is persisted in the sentinel configuration file. For example<br>every time a new configuration is received, or created (leader Sentinels), for<br>a primary, the configuration is persisted on disk together with the configuration<br>epoch. This means that it is safe to stop and restart Sentinel processes.</p>\n<h3>TILT mode</h3>\n<p>Valkey Sentinel is heavily dependent on the computer time: for instance in<br>order to understand if an instance is available it remembers the time of the<br>latest successful reply to the PING command, and compares it with the current<br>time to understand how old it is.</p>\n<p>However if the computer time changes in an unexpected way, or if the computer<br>is very busy, or the process blocked for some reason, Sentinel may start to<br>behave in an unexpected way.</p>\n<p>The TILT mode is a special &quot;protection&quot; mode that a Sentinel can enter when<br>something odd is detected that can lower the reliability of the system.<br>The Sentinel timer interrupt is normally called 10 times per second, so we<br>expect that more or less 100 milliseconds will elapse between two calls<br>to the timer interrupt.</p>\n<p>What a Sentinel does is to register the previous time the timer interrupt<br>was called, and compare it with the current call: if the time difference<br>is negative or unexpectedly big (2 seconds or more) the TILT mode is entered<br>(or if it was already entered the exit from the TILT mode postponed).</p>\n<p>When in TILT mode the Sentinel will continue to monitor everything, but:</p>\n<ul>\n<li>It stops acting at all.</li>\n<li>It starts to reply negatively to <code>SENTINEL is-master-down-by-addr</code> requests as the ability to detect a failure is no longer trusted.</li>\n</ul>\n<p>If everything appears to be normal for 30 seconds, the TILT mode is exited.</p>\n<p>In the Sentinel TILT mode, if we send the INFO command, we could get the following response:</p>\n<pre><code>$ valkey-cli -p 26379\n127.0.0.1:26379&gt; info\n(Other information from Sentinel server skipped.)\n\n# Sentinel\nsentinel_masters:1\nsentinel_tilt:0\nsentinel_tilt_since_seconds:-1\nsentinel_running_scripts:0\nsentinel_scripts_queue_length:0\nsentinel_simulate_failure_flags:0\nmaster0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=0,sentinels=1\n</code></pre>\n<p>The field &quot;sentinel_tilt_since_seconds&quot; indicates how many seconds the Sentinel already is in the TILT mode.<br>If it is not in TILT mode, the value will be -1.</p>\n<p>Note that in some ways TILT mode could be replaced using the monotonic clock<br>API that many kernels offer. However it is not still clear if this is a good<br>solution since the current system avoids issues in case the process is just<br>suspended or not executed by the scheduler for a long time.</p>\n<p><strong>A note about the words &quot;master&quot; and &quot;slave&quot; used in this man page</strong>: If not for backward compatibility, the Valkey project no longer uses the words &quot;master&quot; and &quot;slave&quot;. Unfortunately in this command these words are part of the protocol, so we&#39;ll be able to remove such occurrences only when this API will be naturally deprecated.</p>\n"
      },
      {
        "id": "cluster-tutorial",
        "topicName": "Cluster tutorial",
        "description": "Horizontal scaling with Valkey Cluster",
        "htmlContent": "<p>Valkey scales horizontally with a deployment topology called Valkey Cluster.<br>This topic will teach you how to set up, test, and operate Valkey Cluster in production.<br>You will learn about the availability and consistency characteristics of Valkey Cluster from the end user&#39;s point of view.</p>\n<p>If you plan to run a production Valkey Cluster deployment or want to understand better how Valkey Cluster works internally, consult the <a href=\"cluster-spec.md\">Valkey Cluster specification</a>.</p>\n<h2>Valkey Cluster 101</h2>\n<p>Valkey Cluster provides a way to run a Valkey installation where data is automatically sharded across multiple Valkey nodes.<br>Valkey Cluster also provides some degree of availability during partitions&mdash;in practical terms, the ability to continue operations when some nodes fail or are unable to communicate.<br>However, the cluster will become unavailable in the event of larger failures (for example, when the majority of primaries are unavailable).</p>\n<p>So, with Valkey Cluster, you get the ability to:</p>\n<ul>\n<li>Automatically split your dataset among multiple nodes.</li>\n<li>Continue operations when a subset of the nodes are experiencing failures or are unable to communicate with the rest of the cluster.</li>\n</ul>\n<h4>Valkey Cluster TCP ports</h4>\n<p>Every Valkey Cluster node requires two open TCP connections: a Valkey TCP port used to serve clients, e.g., 6379, and second port known as the <em>cluster bus port</em>.<br>By default, the cluster bus port is set by adding 10000 to the data port (e.g., 16379); however, you can override this in the <code>cluster-port</code> configuration.</p>\n<p>Cluster bus is a node-to-node communication channel that uses a binary protocol, which is more suited to exchanging information between nodes due to<br>little bandwidth and processing time.<br>Nodes use the cluster bus for failure detection, configuration updates, failover authorization, and so forth.<br>Clients should never try to communicate with the cluster bus port, but rather use the Valkey command port.<br>However, make sure you open both ports in your firewall, otherwise Valkey cluster nodes won&#39;t be able to communicate.</p>\n<p>For a Valkey Cluster to work properly you need, for each node:</p>\n<ol>\n<li>The client communication port (usually 6379) used to communicate with clients and be open to all the clients that need to reach the cluster, plus all the other cluster nodes that use the client port for key migrations.</li>\n<li>The cluster bus port must be reachable from all the other cluster nodes.</li>\n</ol>\n<p>If you don&#39;t open both TCP ports, your cluster will not work as expected.</p>\n<h4>Valkey Cluster and Docker</h4>\n<p>Currently, Valkey Cluster does not support NATted environments and in general<br>environments where IP addresses or TCP ports are remapped.</p>\n<p>Docker uses a technique called <em>port mapping</em>: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.<br>This is useful for running multiple containers using the same ports, at the same time, in the same server.</p>\n<p>To make Docker compatible with Valkey Cluster, you need to use Docker&#39;s <em>host networking mode</em>.<br>Please see the <code>--net=host</code> option in the <a href=\"https://docs.docker.com/engine/userguide/networking/dockernetworks/\">Docker documentation</a> for more information.</p>\n<h4>Valkey Cluster data sharding</h4>\n<p>Valkey Cluster does not use consistent hashing, but a different form of sharding<br>where every key is conceptually part of what we call a <strong>hash slot</strong>.</p>\n<p>There are 16384 hash slots in Valkey Cluster, and to compute the hash<br>slot for a given key, we simply take the CRC16 of the key modulo<br>16384.</p>\n<p>Every node in a Valkey Cluster is responsible for a subset of the hash slots,<br>so, for example, you may have a cluster with 3 nodes, where:</p>\n<ul>\n<li>Node A contains hash slots from 0 to 5500.</li>\n<li>Node B contains hash slots from 5501 to 11000.</li>\n<li>Node C contains hash slots from 11001 to 16383.</li>\n</ul>\n<p>This makes it easy to add and remove cluster nodes. For example, if<br>I want to add a new node D, I need to move some hash slots from nodes A, B, C<br>to D. Similarly, if I want to remove node A from the cluster, I can just<br>move the hash slots served by A to B and C. Once node A is empty,<br>I can remove it from the cluster completely.</p>\n<p>Moving hash slots from a node to another does not require stopping<br>any operations; therefore, adding and removing nodes, or changing the percentage of hash slots held by a node, requires no downtime.</p>\n<p>Valkey Cluster supports multiple key operations as long as all of the keys involved in a single command execution (or whole transaction, or Lua script<br>execution) belong to the same hash slot. The user can force multiple keys<br>to be part of the same hash slot by using a feature called <em>hash tags</em>.</p>\n<p>Hash tags are documented in the Valkey Cluster specification, but the gist is<br>that if there is a substring between {} brackets in a key, only what is<br>inside the string is hashed. For example, the keys <code>user:{123}:profile</code> and <code>user:{123}:account</code> are guaranteed to be in the same hash slot because they share the same hash tag. As a result, you can operate on these two keys in the same multi-key operation.</p>\n<h4>Valkey Cluster primary-replica model</h4>\n<p>To remain available when a subset of primary nodes are failing or are<br>not able to communicate with the majority of nodes, Valkey Cluster uses a<br>primary-replica model where every hash slot has from 1 (the primary itself) to N<br>replicas (N-1 additional replica nodes).</p>\n<p>In our example cluster with nodes A, B, C, if node B fails the cluster is not<br>able to continue, since we no longer have a way to serve hash slots in the<br>range 5501-11000.</p>\n<p>However, when the cluster is created (or at a later time), we add a replica<br>node to every primary, so that the final cluster is composed of A, B, C<br>that are primary nodes, and A1, B1, C1 that are replica nodes.<br>This way, the system can continue if node B fails.</p>\n<p>Node B1 replicates B, and B fails, the cluster will promote node B1 as the new<br>primary and will continue to operate correctly.</p>\n<p>However, note that if nodes B and B1 fail at the same time, Valkey Cluster will not be able to continue to operate.</p>\n<h4>Valkey Cluster consistency guarantees</h4>\n<p>Valkey Cluster does not guarantee <strong>strong consistency</strong>. In practical<br>terms this means that under certain conditions it is possible that Valkey<br>Cluster will lose writes that were acknowledged by the system to the client.</p>\n<p>The first reason why Valkey Cluster can lose writes is because it uses<br>asynchronous replication. This means that during writes the following<br>happens:</p>\n<ul>\n<li>Your client writes to the primary B.</li>\n<li>The primary B replies OK to your client.</li>\n<li>The primary B propagates the write to its replicas B1, B2 and B3.</li>\n</ul>\n<p>As you can see, B does not wait for an acknowledgement from B1, B2, B3 before<br>replying to the client, since this would be a prohibitive latency penalty<br>for Valkey, so if your client writes something, B acknowledges the write,<br>but crashes before being able to send the write to its replicas, one of the<br>replicas (that did not receive the write) can be promoted to primary, losing<br>the write forever.</p>\n<p>This is very similar to what happens with most databases that are<br>configured to flush data to disk every second, so it is a scenario you<br>are already able to reason about because of past experiences with traditional<br>database systems not involving distributed systems. Similarly you can<br>improve consistency by forcing the database to flush data to disk before<br>replying to the client, but this usually results in prohibitively low<br>performance. That would be the equivalent of synchronous replication in<br>the case of Valkey Cluster.</p>\n<p>Basically, there is a trade-off to be made between performance and consistency.</p>\n<p>Valkey Cluster has support for synchronous writes when absolutely needed,<br>implemented via the <code>WAIT</code> command. This makes losing writes a lot less<br>likely. However, note that Valkey Cluster does not implement strong consistency<br>even when synchronous replication is used: it is always possible, under more<br>complex failure scenarios, that a replica that was not able to receive the write<br>will be elected as primary.</p>\n<p>There is another notable scenario where Valkey Cluster will lose writes, that<br>happens during a network partition where a client is isolated with a minority<br>of instances including at least a primary.</p>\n<p>Take as an example our 6 nodes cluster composed of A, B, C, A1, B1, C1,<br>with 3 primaries and 3 replicas. There is also a client, that we will call Z1.</p>\n<p>After a partition occurs, it is possible that in one side of the<br>partition we have A, C, A1, B1, C1, and in the other side we have B and Z1.</p>\n<p>Z1 is still able to write to B, which will accept its writes. If the<br>partition heals in a very short time, the cluster will continue normally.<br>However, if the partition lasts enough time for B1 to be promoted to primary<br>on the majority side of the partition, the writes that Z1 has sent to B<br>in the meantime will be lost.</p>\n<p><strong>Note:</strong><br>There is a <strong>maximum window</strong> to the amount of writes Z1 will be able<br>to send to B: if enough time has elapsed for the majority side of the<br>partition to elect a replica as primary, every primary node in the minority<br>side will have stopped accepting writes.</p>\n<p>This amount of time is a very important configuration directive of Valkey<br>Cluster, and is called the <strong>node timeout</strong>.</p>\n<p>After node timeout has elapsed, a primary node is considered to be failing,<br>and can be replaced by one of its replicas.<br>Similarly, after node timeout has elapsed without a primary node to be able<br>to sense the majority of the other primary nodes, it enters an error state<br>and stops accepting writes.</p>\n<h2>Valkey Cluster configuration parameters</h2>\n<p>We are about to create an example cluster deployment.<br>Before we continue, let&#39;s introduce the configuration parameters that Valkey Cluster introduces<br>in the <code>valkey.conf</code> file.</p>\n<ul>\n<li><strong>cluster-enabled <code>&lt;yes/no&gt;</code></strong>: If yes, enables Valkey Cluster support in a specific Valkey instance. Otherwise the instance starts as a standalone instance as usual.</li>\n<li><strong>cluster-config-file <code>&lt;filename&gt;</code></strong>: Note that despite the name of this option, this is not a user editable configuration file, but the file where a Valkey Cluster node automatically persists the cluster configuration (the state, basically) every time there is a change, in order to be able to re-read it at startup. The file lists things like the other nodes in the cluster, their state, persistent variables, and so forth. Often this file is rewritten and flushed on disk as a result of some message reception.</li>\n<li><strong>cluster-node-timeout <code>&lt;milliseconds&gt;</code></strong>: The maximum amount of time a Valkey Cluster node can be unavailable, without it being considered as failing. If a primary node is not reachable for more than the specified amount of time, it will be failed over by its replicas. This parameter controls other important things in Valkey Cluster. Notably, every node that can&#39;t reach the majority of primary nodes for the specified amount of time, will stop accepting queries.</li>\n<li><strong>cluster-replica-validity-factor <code>&lt;factor&gt;</code></strong>: If set to zero, a replica will always consider itself valid, and will therefore always try to failover a primary, regardless of the amount of time the link between the primary and the replica remained disconnected. If the value is positive, a maximum disconnection time is calculated as the <em>node timeout</em> value multiplied by the factor provided with this option, and if the node is a replica, it will not try to start a failover if the primary link was disconnected for more than the specified amount of time. For example, if the node timeout is set to 5 seconds and the validity factor is set to 10, a replica disconnected from the primary for more than 50 seconds will not try to failover its primary. Note that any value different than zero may result in Valkey Cluster being unavailable after a primary failure if there is no replica that is able to failover it. In that case the cluster will return to being available only when the original primary rejoins the cluster.</li>\n<li><strong>cluster-migration-barrier <code>&lt;count&gt;</code></strong>: Minimum number of replicas a primary will remain connected with, for another replica to migrate to a primary which is no longer covered by any replica. See the appropriate section about replica migration in this tutorial for more information.</li>\n<li><strong>cluster-require-full-coverage <code>&lt;yes/no&gt;</code></strong>: If this is set to yes, as it is by default, the cluster stops accepting writes if some percentage of the key space is not covered by any node. If the option is set to no, the cluster will still serve queries even if only requests about a subset of keys can be processed.</li>\n<li><strong>cluster-allow-reads-when-down <code>&lt;yes/no&gt;</code></strong>: If this is set to no, as it is by default, a node in a Valkey Cluster will stop serving all traffic when the cluster is marked as failed, either when a node can&#39;t reach a quorum of primaries or when full coverage is not met. This prevents reading potentially inconsistent data from a node that is unaware of changes in the cluster. This option can be set to yes to allow reads from a node during the fail state, which is useful for applications that want to prioritize read availability but still want to prevent inconsistent writes. It can also be used for when using Valkey Cluster with only one or two shards, as it allows the nodes to continue serving writes when a primary fails but automatic failover is impossible.</li>\n</ul>\n<h2>Create and use a Valkey Cluster</h2>\n<p>To create and use a Valkey Cluster, follow these steps:</p>\n<ul>\n<li><a href=\"#create-a-valkey-cluster\">Create a Valkey Cluster</a></li>\n<li><a href=\"#interact-with-the-cluster\">Interact with the cluster</a></li>\n<li><a href=\"#write-an-example-app-with-redis-rb-cluster\">Write an example app with redis-rb-cluster</a></li>\n<li><a href=\"#reshard-the-cluster\">Reshard the cluster</a></li>\n<li><a href=\"#a-more-interesting-example-application\">A more interesting example application</a></li>\n<li><a href=\"#test-the-failover\">Test the failover</a></li>\n<li><a href=\"#manual-failover\">Manual failover</a></li>\n<li><a href=\"#add-a-new-node\">Add a new node</a></li>\n<li><a href=\"#remove-a-node\">Remove a node</a></li>\n<li><a href=\"#replica-migration\">Replica migration</a></li>\n<li><a href=\"#upgrade-nodes-in-a-valkey-cluster\">Upgrade nodes in a Valkey Cluster</a></li>\n<li><a href=\"#migrate-to-valkey-cluster\">Migrate to Valkey Cluster</a></li>\n</ul>\n<p>But, first, familiarize yourself with the requirements for creating a cluster.</p>\n<h4>Requirements to create a Valkey Cluster</h4>\n<p>To create a cluster, the first thing you need is to have a few empty Valkey instances running in <em>cluster mode</em>. </p>\n<p>At minimum, set the following directives in the <code>valkey.conf</code> file:</p>\n<pre><code>port 7000\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\nappendonly yes\n</code></pre>\n<p>To enable cluster mode, set the <code>cluster-enabled</code> directive to <code>yes</code>.<br>Every instance also contains the path of a file where the<br>configuration for this node is stored, which by default is <code>nodes.conf</code>.<br>This file is never touched by humans; it is simply generated at startup<br>by the Valkey Cluster instances, and updated every time it is needed.</p>\n<p>Note that the <strong>minimal cluster</strong> that works as expected must contain<br>at least three primary nodes. For deployment, we strongly recommend<br>a six-node cluster, with three primaries and three replicas.</p>\n<p>You can test this locally by creating the following directories named<br>after the port number of the instance you&#39;ll run inside any given directory.</p>\n<p>For example:</p>\n<pre><code>mkdir cluster-test\ncd cluster-test\nmkdir 7000 7001 7002 7003 7004 7005\n</code></pre>\n<p>Create a <code>valkey.conf</code> file inside each of the directories, from 7000 to 7005.<br>As a template for your configuration file just use the small example above,<br>but make sure to replace the port number <code>7000</code> with the right port number<br>according to the directory name.</p>\n<p>You can start each instance as follows, each running in a separate terminal tab:</p>\n<pre><code>cd 7000\nvalkey-server ./valkey.conf\n</code></pre>\n<p>You&#39;ll see from the logs that every node assigns itself a new ID:</p>\n<pre><code>[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&#39;m 97a3a64667477371c4479320d683e4c8db5858b1\n</code></pre>\n<p>This ID will be used forever by this specific instance in order for the instance<br>to have a unique name in the context of the cluster. Every node<br>remembers every other node using this IDs, and not by IP or port.<br>IP addresses and ports may change, but the unique node identifier will never<br>change for all the life of the node. We call this identifier simply <strong>Node ID</strong>.</p>\n<h4>Create a Valkey Cluster</h4>\n<p>Now that we have a number of instances running, you need to create your cluster by writing some meaningful configuration to the nodes.</p>\n<p>You can configure and execute individual instances manually or use the create-cluster script.<br>Let&#39;s go over how you do it manually.</p>\n<p>To create the cluster, run:</p>\n<pre><code>valkey-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\\n127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\\n--cluster-replicas 1\n</code></pre>\n<p>The command used here is <strong>create</strong>, since we want to create a new cluster.<br>The option <code>--cluster-replicas 1</code> means that we want a replica for every primary created.</p>\n<p>The other arguments are the list of addresses of the instances I want to use<br>to create the new cluster.</p>\n<p><code>valkey-cli</code> will propose a configuration. Accept the proposed configuration by typing <strong>yes</strong>.<br>The cluster will be configured and <em>joined</em>, which means that instances will be<br>bootstrapped into talking with each other. Finally, if everything has gone well, you&#39;ll see a message like this:</p>\n<pre><code>[OK] All 16384 slots covered\n</code></pre>\n<p>This means that there is at least one primary instance serving each of the<br>16384 available slots.</p>\n<p>If you don&#39;t want to create a Valkey Cluster by configuring and executing<br>individual instances manually as explained above, there is a much simpler<br>system (but you&#39;ll not learn the same amount of operational details).</p>\n<p>Find the <code>utils/create-cluster</code> directory in the Valkey distribution.<br>There is a script called <code>create-cluster</code> inside (same name as the directory<br>it is contained into), it&#39;s a simple bash script. In order to start<br>a 6 nodes cluster with 3 primaries and 3 replicas just type the following<br>commands:</p>\n<ol>\n<li><code>create-cluster start</code></li>\n<li><code>create-cluster create</code></li>\n</ol>\n<p>Reply to <code>yes</code> in step 2 when the <code>valkey-cli</code> utility wants you to accept<br>the cluster layout.</p>\n<p>You can now interact with the cluster, the first node will start at port 30001<br>by default. When you are done, stop the cluster with:</p>\n<ol start=\"3\">\n<li><code>create-cluster stop</code></li>\n</ol>\n<p>Please read the <code>README</code> inside this directory for more information on how<br>to run the script.</p>\n<h4>Interact with the cluster</h4>\n<p>To connect to Valkey Cluster, you&#39;ll need a cluster-aware Valkey client.<br>See the documentation for your <a href=\"../clients/\">client of choice</a> to determine its cluster support.</p>\n<p>You can also test your Valkey Cluster using the <code>valkey-cli</code> command line utility:</p>\n<pre><code>$ valkey-cli -c -p 7000\n127.0.0.1:7000&gt; set foo bar\n-&gt; Redirected to slot [12182] located at 127.0.0.1:7002\nOK\n127.0.0.1:7002&gt; set hello world\n-&gt; Redirected to slot [866] located at 127.0.0.1:7000\nOK\n127.0.0.1:7000&gt; get foo\n-&gt; Redirected to slot [12182] located at 127.0.0.1:7002\n&quot;bar&quot;\n127.0.0.1:7002&gt; get hello\n-&gt; Redirected to slot [866] located at 127.0.0.1:7000\n&quot;world&quot;\n</code></pre>\n<p><strong>Note:</strong><br>If you created the cluster using the script, your nodes may listen<br>on different ports, starting from 30001 by default.</p>\n<p>The <code>valkey-cli</code> cluster support is very basic, so it always uses the fact that<br>Valkey Cluster nodes are able to redirect a client to the right node.<br>A serious client is able to do better than that, and cache the map between<br>hash slots and nodes addresses, to directly use the right connection to the<br>right node. The map is refreshed only when something changed in the cluster<br>configuration, for example after a failover or after the system administrator<br>changed the cluster layout by adding or removing nodes.</p>\n<h4>Write an example app with redis-rb-cluster</h4>\n<p>Before going forward showing how to operate the Valkey Cluster, doing things<br>like a failover, or a resharding, we need to create some example application<br>or at least to be able to understand the semantics of a simple Valkey Cluster<br>client interaction.</p>\n<p>In this way we can run an example and at the same time try to make nodes<br>failing, or start a resharding, to see how Valkey Cluster behaves under real<br>world conditions. It is not very helpful to see what happens while nobody<br>is writing to the cluster.</p>\n<p>This section explains some basic usage of<br><a href=\"https://github.com/antirez/redis-rb-cluster\">redis-rb-cluster</a> showing two<br>examples.<br>The first is the following, and is the<br><a href=\"https://github.com/antirez/redis-rb-cluster/blob/master/example.rb\"><code>example.rb</code></a><br>file inside the redis-rb-cluster distribution:</p>\n<pre><code class=\"language-ruby\">require &#39;./cluster&#39;\n\nif ARGV.length != 2\n    startup_nodes = [\n        {:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7000},\n        {:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7001}\n    ]\nelse\n    startup_nodes = [\n        {:host =&gt; ARGV[0], :port =&gt; ARGV[1].to_i}\n    ]\nend\n\nrc = RedisCluster.new(startup_nodes,32,:timeout =&gt; 0.1)\n\nlast = false\n\nwhile not last\n    begin\n        last = rc.get(&quot;__last__&quot;)\n        last = 0 if !last\n    rescue =&gt; e\n        puts &quot;error #{e.to_s}&quot;\n        sleep 1\n    end\nend\n\n((last.to_i+1)..1000000000).each{|x|\n    begin\n        rc.set(&quot;foo#{x}&quot;,x)\n        puts rc.get(&quot;foo#{x}&quot;)\n        rc.set(&quot;__last__&quot;,x)\n    rescue =&gt; e\n        puts &quot;error #{e.to_s}&quot;\n    end\n    sleep 0.1\n}\n</code></pre>\n<p>The application does a very simple thing, it sets keys in the form <code>foo&lt;number&gt;</code> to <code>number</code>, one after the other. So if you run the program the result is the<br>following stream of commands:</p>\n<ul>\n<li>SET foo0 0</li>\n<li>SET foo1 1</li>\n<li>SET foo2 2</li>\n<li>And so forth...</li>\n</ul>\n<p>The program looks more complex than it should usually as it is designed to<br>show errors on the screen instead of exiting with an exception, so every<br>operation performed with the cluster is wrapped by <code>begin</code> <code>rescue</code> blocks.</p>\n<p>The <strong>line 14</strong> is the first interesting line in the program. It creates the<br>Valkey Cluster object, using as argument a list of <em>startup nodes</em>, the maximum<br>number of connections this object is allowed to take against different nodes,<br>and finally the timeout after a given operation is considered to be failed.</p>\n<p>The startup nodes don&#39;t need to be all the nodes of the cluster. The important<br>thing is that at least one node is reachable. Also note that redis-rb-cluster<br>updates this list of startup nodes as soon as it is able to connect with the<br>first node. You should expect such a behavior with any other serious client.</p>\n<p>Now that we have the Valkey Cluster object instance stored in the <strong>rc</strong> variable,<br>we are ready to use the object like if it was a normal Valkey object instance.</p>\n<p>This is exactly what happens in <strong>line 18 to 26</strong>: when we restart the example<br>we don&#39;t want to start again with <code>foo0</code>, so we store the counter inside<br>Valkey itself. The code above is designed to read this counter, or if the<br>counter does not exist, to assign it the value of zero.</p>\n<p>However note how it is a while loop, as we want to try again and again even<br>if the cluster is down and is returning errors. Normal applications don&#39;t need<br>to be so careful.</p>\n<p><strong>Lines between 28 and 37</strong> start the main loop where the keys are set or<br>an error is displayed.</p>\n<p>Note the <code>sleep</code> call at the end of the loop. In your tests you can remove<br>the sleep if you want to write to the cluster as fast as possible (relatively<br>to the fact that this is a busy loop without real parallelism of course, so<br>you&#39;ll get the usually 10k ops/second in the best of the conditions).</p>\n<p>Normally writes are slowed down in order for the example application to be<br>easier to follow by humans.</p>\n<p>Starting the application produces the following output:</p>\n<pre><code>ruby ./example.rb\n1\n2\n3\n4\n5\n6\n7\n8\n9\n^C (I stopped the program here)\n</code></pre>\n<p>This is not a very interesting program and we&#39;ll use a better one in a moment<br>but we can already see what happens during a resharding when the program<br>is running.</p>\n<h4>Reshard the cluster</h4>\n<p>Now we are ready to try a cluster resharding. To do this, please<br>keep the example.rb program running, so that you can see if there is some<br>impact on the program running. Also, you may want to comment the <code>sleep</code><br>call to have some more serious write load during resharding.</p>\n<p>Resharding basically means to move hash slots from a set of nodes to another<br>set of nodes.<br>Like cluster creation, it is accomplished using the valkey-cli utility.</p>\n<p>To start a resharding, just type:</p>\n<pre><code>valkey-cli --cluster reshard 127.0.0.1:7000\n</code></pre>\n<p>You only need to specify a single node, valkey-cli will find the other nodes<br>automatically.</p>\n<p>Currently valkey-cli is only able to reshard with the administrator support,<br>you can&#39;t just say move 5% of slots from this node to the other one (but<br>this is pretty trivial to implement). So it starts with questions. The first<br>is how much of a resharding do you want to do:</p>\n<pre><code>How many slots do you want to move (from 1 to 16384)?\n</code></pre>\n<p>We can try to reshard 1000 hash slots, that should already contain a non<br>trivial amount of keys if the example is still running without the sleep<br>call.</p>\n<p>Then valkey-cli needs to know what is the target of the resharding, that is,<br>the node that will receive the hash slots.<br>I&#39;ll use the first primary node, that is, 127.0.0.1:7000, but I need<br>to specify the Node ID of the instance. This was already printed in a<br>list by valkey-cli, but I can always find the ID of a node with the following<br>command if I need:</p>\n<pre><code>$ valkey-cli -p 7000 cluster nodes | grep myself\n97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460\n</code></pre>\n<p>Ok so my target node is 97a3a64667477371c4479320d683e4c8db5858b1.</p>\n<p>Now you&#39;ll get asked from what nodes you want to take those keys.<br>I&#39;ll just type <code>all</code> in order to take a bit of hash slots from all the<br>other primary nodes.</p>\n<p>After the final confirmation you&#39;ll see a message for every slot that<br>valkey-cli is going to move from a node to another, and a dot will be printed<br>for every actual key moved from one side to the other.</p>\n<p>While the resharding is in progress you should be able to see your<br>example program running unaffected. You can stop and restart it multiple times<br>during the resharding if you want.</p>\n<p>At the end of the resharding, you can test the health of the cluster with<br>the following command:</p>\n<pre><code>valkey-cli --cluster check 127.0.0.1:7000\n</code></pre>\n<p>All the slots will be covered as usual, but this time the primary at<br>127.0.0.1:7000 will have more hash slots, something around 6461.</p>\n<p>Resharding can be performed automatically without the need to manually<br>enter the parameters in an interactive way. This is possible using a command<br>line like the following:</p>\n<pre><code>valkey-cli --cluster reshard &lt;host&gt;:&lt;port&gt; --cluster-from &lt;node-id&gt; --cluster-to &lt;node-id&gt; --cluster-slots &lt;number of slots&gt; --cluster-yes\n</code></pre>\n<p>This allows to build some automatism if you are likely to reshard often,<br>however currently there is no way for <code>valkey-cli</code> to automatically<br>rebalance the cluster checking the distribution of keys across the cluster<br>nodes and intelligently moving slots as needed. This feature will be added<br>in the future.</p>\n<p>The <code>--cluster-yes</code> option instructs the cluster manager to automatically answer<br>&quot;yes&quot; to the command&#39;s prompts, allowing it to run in a non-interactive mode.<br>Note that this option can also be activated by setting the<br><code>REDISCLI_CLUSTER_YES</code> environment variable.</p>\n<h4>A more interesting example application</h4>\n<p>The example application we wrote early is not very good.<br>It writes to the cluster in a simple way without even checking if what was<br>written is the right thing.</p>\n<p>From our point of view the cluster receiving the writes could just always<br>write the key <code>foo</code> to <code>42</code> to every operation, and we would not notice at<br>all.</p>\n<p>So in the <code>redis-rb-cluster</code> repository, there is a more interesting application<br>that is called <code>consistency-test.rb</code>. It uses a set of counters, by default 1000, and sends <code>INCR</code> commands in order to increment the counters.</p>\n<p>However instead of just writing, the application does two additional things:</p>\n<ul>\n<li>When a counter is updated using <code>INCR</code>, the application remembers the write.</li>\n<li>It also reads a random counter before every write, and check if the value is what we expected it to be, comparing it with the value it has in memory.</li>\n</ul>\n<p>What this means is that this application is a simple <strong>consistency checker</strong>,<br>and is able to tell you if the cluster lost some write, or if it accepted<br>a write that we did not receive acknowledgment for. In the first case we&#39;ll<br>see a counter having a value that is smaller than the one we remember, while<br>in the second case the value will be greater.</p>\n<p>Running the consistency-test application produces a line of output every<br>second:</p>\n<pre><code>$ ruby consistency-test.rb\n925 R (0 err) | 925 W (0 err) |\n5030 R (0 err) | 5030 W (0 err) |\n9261 R (0 err) | 9261 W (0 err) |\n13517 R (0 err) | 13517 W (0 err) |\n17780 R (0 err) | 17780 W (0 err) |\n22025 R (0 err) | 22025 W (0 err) |\n25818 R (0 err) | 25818 W (0 err) |\n</code></pre>\n<p>The line shows the number of <strong>R</strong>eads and <strong>W</strong>rites performed, and the<br>number of errors (query not accepted because of errors since the system was<br>not available).</p>\n<p>If some inconsistency is found, new lines are added to the output.<br>This is what happens, for example, if I reset a counter manually while<br>the program is running:</p>\n<pre><code>$ valkey-cli -h 127.0.0.1 -p 7000 set key_217 0\nOK\n\n(in the other tab I see...)\n\n94774 R (0 err) | 94774 W (0 err) |\n98821 R (0 err) | 98821 W (0 err) |\n102886 R (0 err) | 102886 W (0 err) | 114 lost |\n107046 R (0 err) | 107046 W (0 err) | 114 lost |\n</code></pre>\n<p>When I set the counter to 0 the real value was 114, so the program reports<br>114 lost writes (<code>INCR</code> commands that are not remembered by the cluster).</p>\n<p>This program is much more interesting as a test case, so we&#39;ll use it<br>to test the Valkey Cluster failover.</p>\n<h4>Test the failover</h4>\n<p>To trigger the failover, the simplest thing we can do (that is also<br>the semantically simplest failure that can occur in a distributed system)<br>is to crash a single process, in our case a single primary.</p>\n<p><strong>Note:</strong><br>During this test, you should take a tab open with the consistency test<br>application running.</p>\n<p>We can identify a primary and crash it with the following command:</p>\n<pre><code>$ valkey-cli -p 7000 cluster nodes | grep master\n3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383\n97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422\n</code></pre>\n<p>Ok, so 7000, 7001, and 7002 are primaries. Let&#39;s crash node 7002 with the<br><strong>DEBUG SEGFAULT</strong> command:</p>\n<pre><code>$ valkey-cli -p 7002 debug segfault\nError: Server closed the connection\n</code></pre>\n<p>Now we can look at the output of the consistency test to see what it reported.</p>\n<pre><code>18849 R (0 err) | 18849 W (0 err) |\n23151 R (0 err) | 23151 W (0 err) |\n27302 R (0 err) | 27302 W (0 err) |\n\n... many error warnings here ...\n\n29659 R (578 err) | 29660 W (577 err) |\n33749 R (578 err) | 33750 W (577 err) |\n37918 R (578 err) | 37919 W (577 err) |\n42077 R (578 err) | 42078 W (577 err) |\n</code></pre>\n<p>As you can see during the failover the system was not able to accept 578 reads and 577 writes, however no inconsistency was created in the database. This may<br>sound unexpected as in the first part of this tutorial we stated that Valkey<br>Cluster can lose writes during the failover because it uses asynchronous<br>replication. What we did not say is that this is not very likely to happen<br>because Valkey sends the reply to the client, and the commands to replicate<br>to the replicas, about at the same time, so there is a very small window to<br>lose data. However the fact that it is hard to trigger does not mean that it<br>is impossible, so this does not change the consistency guarantees provided<br>by Valkey cluster.</p>\n<p>We can now check what is the cluster setup after the failover (note that<br>in the meantime I restarted the crashed instance so that it rejoins the<br>cluster as a replica):</p>\n<pre><code>$ valkey-cli -p 7000 cluster nodes\n3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected\na211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected\n97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422\n3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383\n3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected\n</code></pre>\n<p>Now the primaries are running on ports 7000, 7001 and 7005. What was previously<br>a primary, that is the Valkey instance running on port 7002, is now a replica of<br>7005.</p>\n<p>The output of the <code>CLUSTER NODES</code> command may look intimidating, but it is actually pretty simple, and is composed of the following tokens:</p>\n<ul>\n<li>Node ID</li>\n<li>ip:port</li>\n<li>flags: master, replica, myself, fail, ...</li>\n<li>if it is a replica, the Node ID of the master</li>\n<li>Time of the last pending PING still waiting for a reply.</li>\n<li>Time of the last PONG received.</li>\n<li>Configuration epoch for this node (see the Cluster specification).</li>\n<li>Status of the link to this node.</li>\n<li>Slots served...</li>\n</ul>\n<h4>Manual failover</h4>\n<p>Sometimes it is useful to force a failover without actually causing any problem<br>on a primary. For example, to upgrade the Valkey process of one of the<br>primary nodes it is a good idea to failover it to turn it into a replica<br>with minimal impact on availability.</p>\n<p>Manual failovers are supported by Valkey Cluster using the <code>CLUSTER FAILOVER</code><br>command, that must be executed in one of the replicas of the primary you want<br>to failover.</p>\n<p>Manual failovers are special and are safer compared to failovers resulting from<br>actual primary failures. They occur in a way that avoids data loss in the<br>process, by switching clients from the original primary to the new primary only<br>when the system is sure that the new primary processed all the replication stream<br>from the old one.</p>\n<p>This is what you see in the replica log when you perform a manual failover:</p>\n<pre><code># Manual failover user request accepted.\n# Received replication offset for paused primary manual failover: 347540\n# All primary replication stream processed, manual failover can start.\n# Start of election delayed for 0 milliseconds (rank #0, offset 347540).\n# Starting a failover election for epoch 7545.\n# Failover election won: I&#39;m the new primary.\n</code></pre>\n<p>Clients sending write commands to the primary are blocked during the failover.<br>When the primary sends its replication offset to the replica, the replica<br>waits to reach the offset on its side. When the replication offset is reached,<br>the failover starts, and the old primary is informed about the configuration<br>switch. When the switch is complete, the clients are unblocked on the old<br>primary and they are redirected to the new primary.</p>\n<p><strong>Note:</strong><br>To promote a replica to primary, it must first be known as a replica by a majority of the primaries in the cluster.<br>  Otherwise, it cannot win the failover election.<br>  If the replica has just been added to the cluster (see <a href=\"#add-a-new-node-as-a-replica\">Add a new node as a replica</a>), you may need to wait a while before sending the <code>CLUSTER FAILOVER</code> command, to make sure the primaries in cluster are aware of the new replica.</p>\n<h4>Add a new node</h4>\n<p>Adding a new node is basically the process of adding an empty node and then<br>moving some data into it, in case it is a new primary, or telling it to<br>setup as a replica of a known node, in case it is a replica.</p>\n<p>We&#39;ll show both, starting with the addition of a new primary instance.</p>\n<p>In both cases the first step to perform is <strong>adding an empty node</strong>.</p>\n<p>This is as simple as to start a new node in port 7006 (we already used<br>from 7000 to 7005 for our existing 6 nodes) with the same configuration<br>used for the other nodes, except for the port number, so what you should<br>do in order to conform with the setup we used for the previous nodes:</p>\n<ul>\n<li>Create a new tab in your terminal application.</li>\n<li>Enter the <code>cluster-test</code> directory.</li>\n<li>Create a directory named <code>7006</code>.</li>\n<li>Create a valkey.conf file inside, similar to the one used for the other nodes but using 7006 as port number.</li>\n<li>Finally start the server with <code>../valkey-server ./valkey.conf</code></li>\n</ul>\n<p>At this point the server should be running.</p>\n<p>Now we can use <strong>valkey-cli</strong> as usual in order to add the node to<br>the existing cluster.</p>\n<pre><code>valkey-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000\n</code></pre>\n<p>As you can see I used the <strong>add-node</strong> command specifying the address of the<br>new node as first argument, and the address of a random existing node in the<br>cluster as second argument.</p>\n<p>In practical terms valkey-cli here did very little to help us, it just<br>sent a <code>CLUSTER MEET</code> message to the node, something that is also possible<br>to accomplish manually. However valkey-cli also checks the state of the<br>cluster before to operate, so it is a good idea to perform cluster operations<br>always via valkey-cli even when you know how the internals work.</p>\n<p>Now we can connect to the new node to see if it really joined the cluster:</p>\n<pre><code>valkey 127.0.0.1:7006&gt; cluster nodes\n3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921\n3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected\nf093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected\na211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected\n97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422\n3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383\n</code></pre>\n<p>Note that since this node is already connected to the cluster it is already<br>able to redirect client queries correctly and is generally speaking part of<br>the cluster. However it has two peculiarities compared to the other primaries:</p>\n<ul>\n<li>It holds no data as it has no assigned hash slots.</li>\n<li>Because it is a primary without assigned slots, it does not participate in the election process when a replica wants to become a primary.</li>\n</ul>\n<p>Now it is possible to assign hash slots to this node using the resharding<br>feature of <code>valkey-cli</code>.<br>It is basically useless to show this as we already<br>did in a previous section, there is no difference, it is just a resharding<br>having as a target the empty node.</p>\n<h5>Add a new node as a replica</h5>\n<p>Adding a new replica can be performed in two ways. The obvious one is to<br>use valkey-cli again, but with the --cluster-replica option, like this:</p>\n<pre><code>valkey-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-replica\n</code></pre>\n<p>Note that the command line here is exactly like the one we used to add<br>a new primary, so we are not specifying to which primary we want to add<br>the replica. In this case, what happens is that valkey-cli will add the new<br>node as replica of a random primary among the primaries with fewer replicas.</p>\n<p>However you can specify exactly what primary you want to target with your<br>new replica with the following command line:</p>\n<pre><code>valkey-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-replica --cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\n</code></pre>\n<p>This way we assign the new replica to a specific primary.</p>\n<p>A more manual way to add a replica to a specific primary is to add the new<br>node as an empty primary, and then turn it into a replica using the<br><code>CLUSTER REPLICATE</code> command. This also works if the node was added as a replica<br>but you want to move it as a replica of a different primary.</p>\n<p>For example in order to add a replica for the node 127.0.0.1:7005 that is<br>currently serving hash slots in the range 11423-16383, that has a Node ID<br>3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e, all I need to do is to connect<br>with the new node (already added as empty primary) and send the command:</p>\n<pre><code>valkey 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\n</code></pre>\n<p>That&#39;s it. Now we have a new replica for this set of hash slots, and all<br>the other nodes in the cluster already know (after a few seconds needed to<br>update their config). We can verify with the following command:</p>\n<pre><code>$ valkey-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\nf093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 replica 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 replica 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected\n</code></pre>\n<p>The node 3c3a0c... now has two replicas, running on ports 7002 (the existing one) and 7006 (the new one).</p>\n<h4>Remove a node</h4>\n<p>To remove a replica node just use the <code>del-node</code> command of valkey-cli:</p>\n<pre><code>valkey-cli --cluster del-node 127.0.0.1:7000 `&lt;node-id&gt;`\n</code></pre>\n<p>The first argument is just a random node in the cluster, the second argument<br>is the ID of the node you want to remove.</p>\n<p>You can remove a primary node in the same way as well, <strong>however in order to<br>remove a primary node it must be empty</strong>. If the primary is not empty you need<br>to reshard data away from it to all the other primary nodes before.</p>\n<p>An alternative to remove a primary node is to perform a manual failover of it<br>over one of its replicas and remove the node after it turned into a replica of the<br>new primary. Obviously this does not help when you want to reduce the actual<br>number of primaries in your cluster, in that case, a resharding is needed.</p>\n<p>There is a special scenario where you want to remove a failed node.<br>You should not use the <code>del-node</code> command because it tries to connect to all nodes and you will encounter a &quot;connection refused&quot; error.<br>Instead, you can use the <code>call</code> command:</p>\n<pre><code>valkey-cli --cluster call 127.0.0.1:7000 cluster forget `&lt;node-id&gt;`\n</code></pre>\n<p>This command will execute <code>CLUSTER FORGET</code> command on every node. </p>\n<h4>Replica migration</h4>\n<p>In Valkey Cluster, you can reconfigure a replica to replicate with a<br>different primary at any time just using this command:</p>\n<pre><code>CLUSTER REPLICATE &lt;master-node-id&gt;\n</code></pre>\n<p>However there is a special scenario where you want replicas to move from one<br>primary to another one automatically, without the help of the system administrator.<br>The automatic reconfiguration of replicas is called <em>replicas migration</em> and is<br>able to improve the reliability of a Valkey Cluster.</p>\n<p><strong>Note:</strong><br>You can read the details of replicas migration in the <a href=\"cluster-spec.md\">Valkey Cluster Specification</a>, here we&#39;ll only provide some information about the<br>general idea and what you should do in order to benefit from it.</p>\n<p>The reason why you may want to let your cluster replicas to move from one primary<br>to another under certain condition, is that usually the Valkey Cluster is as<br>resistant to failures as the number of replicas attached to a given primary.</p>\n<p>For example a cluster where every primary has a single replica can&#39;t continue<br>operations if the primary and its replica fail at the same time, simply because<br>there is no other instance to have a copy of the hash slots the primary was<br>serving. However while net-splits are likely to isolate a number of nodes<br>at the same time, many other kind of failures, like hardware or software failures<br>local to a single node, are a very notable class of failures that are unlikely<br>to happen at the same time, so it is possible that in your cluster where<br>every primary has a replica, the replica is killed at 4am, and the primary is killed<br>at 6am. This still will result in a cluster that can no longer operate.</p>\n<p>To improve reliability of the system we have the option to add additional<br>replicas to every primary, but this is expensive. Replica migration allows to<br>add more replicas to just a few primaries. So you have 10 primaries with 1 replica<br>each, for a total of 20 instances. However you add, for example, 3 instances<br>more as replicas of some of your primaries, so certain primaries will have more<br>than a single replica.</p>\n<p>With replicas migration what happens is that if a primary is left without<br>replicas, a replica from a primary that has multiple replicas will migrate to<br>the <em>orphaned</em> primary. So after your replica goes down at 4am as in the example<br>we made above, another replica will take its place, and when the primary<br>will fail as well at 5am, there is still a replica that can be elected so that<br>the cluster can continue to operate.</p>\n<p>So what you should know about replicas migration in short?</p>\n<ul>\n<li>The cluster will try to migrate a replica from the primary that has the greatest number of replicas in a given moment.</li>\n<li>To benefit from replica migration you have just to add a few more replicas to a single primary in your cluster, it does not matter what primary.</li>\n<li>There is a configuration parameter that controls the replica migration feature that is called <code>cluster-migration-barrier</code>: you can read more about it in the example <code>valkey.conf</code> file provided with Valkey Cluster.</li>\n</ul>\n<h4>Upgrade nodes in a Valkey Cluster</h4>\n<p>Upgrading replica nodes is easy since you just need to stop the node and restart<br>it with an updated version of Valkey. If there are clients scaling reads using<br>replica nodes, they should be able to reconnect to a different replica if a given<br>one is not available.</p>\n<p>Upgrading primaries is a bit more complex. The suggested procedure is to trigger<br>a manual failover to turn the old primary into a replica and then upgrading it.</p>\n<p>A complete rolling upgrade of all nodes in a cluster can be performed by<br>repeating the following procedure for each shard (a primary and its replicas):</p>\n<ol>\n<li><p>Add one or more upgraded nodes as new replicas to the primary. This step is<br>optional but it ensures that the number of replicas is not compromised during<br>the rolling upgrade. To add a new node, use <a href=\"../commands/cluster-meet.md\"><code>CLUSTER MEET</code></a> and <a href=\"../commands/cluster-replicate.md\"><code>CLUSTER REPLICATE</code></a> or use <code>valkey-cli</code> as<br>described under <a href=\"#add-a-new-node-as-a-replica\">Add a new node as a replica</a>.</p>\n<p>An alternative is to upgrade one replica at a time and have fewer replicas<br>online during the upgrade.</p>\n</li>\n<li><p>Upgrade the old replicas you want to keep by restarting them with the updated<br>version of Valkey. If you&#39;re replacing all the old nodes with new nodes, you<br>can skip this step.</p>\n</li>\n<li><p>Select one of the upgraded replicas to be the new primary. Wait until this<br>replica has caught up the replication offset with the primary. You can use<br><a href=\"../commands/info.md\"><code>INFO REPLICATION</code></a> and check for the line<br><code>master_link_status:up</code> to be present. This indicates that the initial sync<br>with the primary is complete.</p>\n<p>After the initial full sync, the replica might still lag behind in<br>replication. Send <code>INFO REPLICATION</code> to the primary and the replica and<br>compare the field <code>master_repl_offset</code> returned by both nodes. If the offsets<br>match, it means that all writes have been replicated. However, if the primary<br>receives a constant stream of writes, it&#39;s possible that the offsets will<br>never be equal. In this step, you can accept a small difference. It&#39;s usually<br>enough to wait for some seconds to minimize the difference.</p>\n</li>\n<li><p>Check that the new replica is known by all nodes in the cluster, or at least<br>by the primaries in the cluster. You can send <a href=\"../commands/cluster-nodes.md\"><code>CLUSTER NODES</code></a> to each of the nodes in the cluster and<br>check that they all are aware of the new node. Wait for some time and repeat<br>the check if necessary.</p>\n</li>\n<li><p>Trigger a manual failover by sending <a href=\"../commands/cluster-failover.md\"><code>CLUSTER FAILOVER</code></a> to the replica node selected to<br>become the new primary. See the <a href=\"#manual-failover\">Manual failover</a> section<br>in this document for more information.</p>\n</li>\n<li><p>Wait for the failover to complete. To check, you can use<br><a href=\"../commands/role.md\"><code>ROLE</code></a>, <a href=\"../commands/info.md\"><code>INFO REPLICATION</code></a><br>(which indicates <code>role:master</code> after successful failover) or <a href=\"../commands/cluster-nodes.md\"><code>CLUSTER NODES</code></a> to verify that the state of the cluster<br>has changed shortly after the command was sent.</p>\n</li>\n<li><p>Take the old primary (now a replica) out of service, or upgrade it and add it<br>again as a replica. Remove additional replicas kept for redundancy during the<br>upgrade, if any.</p>\n</li>\n</ol>\n<p>Repeat this sequence for each shard (each primary and its replicas) until all<br>nodes in the cluster have been upgraded.</p>\n<h4>Migrate to Valkey Cluster</h4>\n<p>Users willing to migrate to Valkey Cluster may have just a single primary, or<br>may already using a preexisting sharding setup, where keys<br>are split among N nodes, using some in-house algorithm or a sharding algorithm<br>implemented by their client library or Valkey proxy.</p>\n<p>In both cases it is possible to migrate to Valkey Cluster easily, however<br>what is the most important detail is if multiple-keys operations are used<br>by the application, and how. There are three different cases:</p>\n<ol>\n<li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys, are not used. Keys are accessed independently (even if accessed via transactions or Lua scripts grouping multiple commands, about the same key, together).</li>\n<li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys are used but only with keys having the same <strong>hash tag</strong>, which means that the keys used together all have a <code>{...}</code> sub-string that happens to be identical. For example the following multiple keys operation is defined in the context of the same hash tag: <code>SUNION {user:1000}.foo {user:1000}.bar</code>.</li>\n<li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys are used with key names not having an explicit, or the same, hash tag.</li>\n</ol>\n<p>The third case is not handled by Valkey Cluster: the application requires to<br>be modified in order to not use multi keys operations or only use them in<br>the context of the same hash tag.</p>\n<p>Case 1 and 2 are covered, so we&#39;ll focus on those two cases, that are handled<br>in the same way, so no distinction will be made in the documentation.</p>\n<p>Assuming you have your preexisting data set split into N primaries, where<br>N=1 if you have no preexisting sharding, the following steps are needed<br>in order to migrate your data set to Valkey Cluster:</p>\n<ol>\n<li>Stop your clients. No automatic live-migration to Valkey Cluster is currently possible. You may be able to do it orchestrating a live migration in the context of your application / environment.</li>\n<li>Generate an append only file for all of your N primaries using the <code>BGREWRITEAOF</code> command, and waiting for the AOF file to be completely generated.</li>\n<li>Save your AOF files from aof-1 to aof-N somewhere. At this point you can stop your old instances if you wish (this is useful since in non-virtualized deployments you often need to reuse the same computers).</li>\n<li>Create a Valkey Cluster composed of N primaries and zero replicas. You&#39;ll add replicas later. Make sure all your nodes are using the append only file for persistence.</li>\n<li>Stop all the cluster nodes, substitute their append only file with your pre-existing append only files, aof-1 for the first node, aof-2 for the second node, up to aof-N.</li>\n<li>Restart your Valkey Cluster nodes with the new AOF files. They&#39;ll complain that there are keys that should not be there according to their configuration.</li>\n<li>Use <code>valkey-cli --cluster fix</code> command in order to fix the cluster so that keys will be migrated according to the hash slots each node is authoritative or not.</li>\n<li>Use <code>valkey-cli --cluster check</code> at the end to make sure your cluster is ok.</li>\n<li>Restart your clients modified to use a Valkey Cluster aware client library.</li>\n</ol>\n<p>There is an alternative way to import data from external instances to a Valkey<br>Cluster, which is to use the <code>valkey-cli --cluster import</code> command.</p>\n<p>The command moves all the keys of a running instance (deleting the keys from<br>the source instance) to the specified pre-existing Valkey Cluster. </p>\n<p><strong>Note:</strong><br>If not for backward compatibility, the Valkey project no longer uses the words &quot;master&quot; and &quot;slave&quot;. Unfortunately in this command these words are part of the protocol, so we&#39;ll be able to remove such occurrences only when this API will be naturally deprecated.</p>\n<h2>Learn more</h2>\n<ul>\n<li><a href=\"cluster-spec.md\">Valkey Cluster specification</a></li>\n<li><a href=\"https://docs.docker.com/engine/userguide/networking/dockernetworks/\">Docker documentation</a></li>\n</ul>\n"
      },
      {
        "id": "cluster-spec",
        "topicName": "Cluster specification",
        "description": "Detailed specification for Valkey cluster\n",
        "htmlContent": "<p>Welcome to the <strong>Valkey Cluster Specification</strong>. Here you&#39;ll find information<br>about the algorithms and design rationales of Valkey Cluster. This document is a work<br>in progress as it is continuously synchronized with the actual implementation<br>of Valkey.</p>\n<h2>Main properties and rationales of the design</h2>\n<h3>Valkey Cluster goals</h3>\n<p>Valkey Cluster is a distributed implementation of Valkey with the following goals in order of importance in the design:</p>\n<ul>\n<li>High performance and linear scalability up to 1000 nodes. There are no proxies, asynchronous replication is used, and no merge operations are performed on values.</li>\n<li>Acceptable degree of write safety: the system tries (in a best-effort way) to retain all the writes originating from clients connected with the majority of the primary nodes. Usually there are small windows where acknowledged writes can be lost. Windows to lose acknowledged writes are larger when clients are in a minority partition.</li>\n<li>Availability: Valkey Cluster is able to survive partitions where the majority of the primary nodes are reachable and there is at least one reachable replica for every primary node that is no longer reachable. Moreover using <em>replicas migration</em>, primaries no longer replicated by any replica will receive one from a primary which is covered by multiple replicas.</li>\n</ul>\n<h3>Implemented subset</h3>\n<p>Valkey Cluster implements all the single key commands available in the<br>non-distributed version of Valkey. Commands performing complex multi-key<br>operations like set unions and intersections are implemented for cases where<br>all of the keys involved in the operation hash to the same slot.</p>\n<p>Valkey Cluster implements a concept called <strong>hash tags</strong> that can be used<br>to force certain keys to be stored in the same hash slot. However, during<br>manual resharding, multi-key operations may become unavailable for some time<br>while single-key operations are always available.</p>\n<p>Valkey Cluster does not support multiple databases like the standalone version<br>of Valkey. We only support database <code>0</code>; the <code>SELECT</code> command is not allowed.</p>\n<h2>Client and Server roles in the Valkey cluster protocol</h2>\n<p>In Valkey Cluster, nodes are responsible for holding the data,<br>and taking the state of the cluster, including mapping keys to the right nodes.<br>Cluster nodes are also able to auto-discover other nodes, detect non-working<br>nodes, and promote replica nodes to primary when needed in order<br>to continue to operate when a failure occurs.</p>\n<p>To perform their tasks all the cluster nodes are connected using a<br>TCP bus and a binary protocol, called the <strong>Valkey Cluster Bus</strong>.<br>Every node is connected to every other node in the cluster using the cluster<br>bus. Nodes use a gossip protocol to propagate information about the cluster<br>in order to discover new nodes, to send ping packets to make sure all the<br>other nodes are working properly, and to send cluster messages needed to<br>signal specific conditions. The cluster bus is also used in order to<br>propagate Pub/Sub messages across the cluster and to orchestrate manual<br>failovers when requested by users (manual failovers are failovers which<br>are not initiated by the Valkey Cluster failure detector, but by the<br>system administrator directly).</p>\n<p>Since cluster nodes are not able to proxy requests, clients may be redirected<br>to other nodes using redirection errors <code>-MOVED</code> and <code>-ASK</code>.<br>The client is in theory free to send requests to all the nodes in the cluster,<br>getting redirected if needed, so the client is not required to hold the<br>state of the cluster. However clients that are able to cache the map between<br>keys and nodes can improve the performance in a sensible way.</p>\n<h3>Write safety</h3>\n<p>Valkey Cluster uses asynchronous replication between nodes, and <strong>last failover wins</strong> implicit merge function. This means that the last elected primary dataset eventually replaces all the other replicas. There is always a window of time when it is possible to lose writes during partitions. However these windows are very different in the case of a client that is connected to the majority of primaries, and a client that is connected to the minority of primaries.</p>\n<p>Valkey Cluster tries harder to retain writes that are performed by clients connected to the majority of primaries, compared to writes performed in the minority side.<br>The following are examples of scenarios that lead to loss of acknowledged<br>writes received in the majority partitions during failures:</p>\n<ol>\n<li><p>A write may reach a primary, but while the primary may be able to reply to the client, the write may not be propagated to replicas via the asynchronous replication used between primary and replica nodes. If the primary dies without the write reaching the replicas, the write is lost forever if the primary is unreachable for a long enough period that one of its replicas is promoted. This is usually hard to observe in the case of a total, sudden failure of a primary node since primaries try to reply to clients (with the acknowledge of the write) and replicas (propagating the write) at about the same time. However it is a real world failure mode.</p>\n</li>\n<li><p>Another theoretically possible failure mode where writes are lost is the following:</p>\n</li>\n</ol>\n<ul>\n<li>A primary is unreachable because of a partition.</li>\n<li>It gets failed over by one of its replicas.</li>\n<li>After some time it may be reachable again.</li>\n<li>A client with an out-of-date routing table may write to the old primary before it is converted into a replica (of the new primary) by the cluster.</li>\n</ul>\n<p>The second failure mode is unlikely to happen because primary nodes are unable to communicate with the majority of the other primaries for enough time to be failed over will no longer accept writes, and when the partition is fixed writes are still refused for a small amount of time to allow other nodes to inform about configuration changes. This failure mode also requires that the client&#39;s routing table has not yet been updated.</p>\n<p>Writes targeting the minority side of a partition have a larger window in which to get lost. For example, Valkey Cluster loses a non-trivial number of writes on partitions where there is a minority of primaries and at least one or more clients, since all the writes sent to the primaries may potentially get lost if the primaries are failed over in the majority side.</p>\n<p>Specifically, for a primary to be failed over it must be unreachable by the majority of primaries for at least <code>NODE_TIMEOUT</code>, so if the partition is fixed before that time, no writes are lost. When the partition lasts for more than <code>NODE_TIMEOUT</code>, all the writes performed in the minority side up to that point may be lost. However the minority side of a Valkey Cluster will start refusing writes as soon as <code>NODE_TIMEOUT</code> time has elapsed without contact with the majority, so there is a maximum window after which the minority becomes no longer available. Hence, no writes are accepted or lost after that time.</p>\n<h3>Availability</h3>\n<p>Valkey Cluster is not available in the minority side of the partition. In the majority side of the partition assuming that there are at least the majority of primaries and a replica for every unreachable primary, the cluster becomes available again after <code>NODE_TIMEOUT</code> time plus a few more seconds required for a replica to get elected and failover its primary (failovers are usually executed in a matter of 1 or 2 seconds).</p>\n<p>This means that Valkey Cluster is designed to survive failures of a few nodes in the cluster, but it is not a suitable solution for applications that require availability in the event of large net splits.</p>\n<p>In the example of a cluster composed of N primary nodes where every node has a single replica, the majority side of the cluster will remain available as long as a single node is partitioned away, and will remain available with a probability of <code>1-(1/(N*2-1))</code> when two nodes are partitioned away (after the first node fails we are left with <code>N*2-1</code> nodes in total, and the probability of the only primary without a replica to fail is <code>1/(N*2-1))</code>.</p>\n<p>For example, in a cluster with 5 nodes and a single replica per node, there is a <code>1/(5*2-1) = 11.11%</code> probability that after two nodes are partitioned away from the majority, the cluster will no longer be available.</p>\n<p>Thanks to a Valkey Cluster feature called <strong>replicas migration</strong> the Cluster<br>availability is improved in many real world scenarios by the fact that<br>replicas migrate to orphaned primaries (primaries no longer having replicas).<br>So at every successful failure event, the cluster may reconfigure the replicas<br>layout in order to better resist the next failure.</p>\n<h3>Performance</h3>\n<p>In Valkey Cluster nodes don&#39;t proxy commands to the right node in charge for a given key, but instead they redirect clients to the right nodes serving a given portion of the key space.</p>\n<p>Eventually clients obtain an up-to-date representation of the cluster and which node serves which subset of keys, so during normal operations clients directly contact the right nodes in order to send a given command.</p>\n<p>Because of the use of asynchronous replication, nodes do not wait for other nodes&#39; acknowledgment of writes (if not explicitly requested using the <code>WAIT</code> command).</p>\n<p>Also, because multi-key commands are only limited to <em>near</em> keys, data is never moved between nodes except when resharding.</p>\n<p>Normal operations are handled exactly as in the case of a single Valkey instance. This means that in a Valkey Cluster with N primary nodes you can expect the same performance as a single Valkey instance multiplied by N as the design scales linearly. At the same time the query is usually performed in a single round trip, since clients usually retain persistent connections with the nodes, so latency figures are also the same as the single standalone Valkey node case.</p>\n<p>Very high performance and scalability while preserving weak but<br>reasonable forms of data safety and availability is the main goal of<br>Valkey Cluster.</p>\n<h3>Why merge operations are avoided</h3>\n<p>The Valkey Cluster design avoids conflicting versions of the same key-value pair in multiple nodes as in the case of the Valkey data model this is not always desirable. Values in Valkey are often very large; it is common to see lists or sorted sets with millions of elements. Also data types are semantically complex. Transferring and merging these kind of values can be a major bottleneck and/or may require the non-trivial involvement of application-side logic, additional memory to store meta-data, and so forth.</p>\n<p>There are no strict technological limits here. CRDTs or synchronously replicated<br>state machines can model complex data types similar to Valkey. However, the<br>actual run time behavior of such systems would not be similar to Valkey Cluster.<br>Valkey Cluster was designed in order to cover the exact use cases of the<br>non-clustered Valkey deployment.</p>\n<h2>Overview of Valkey Cluster main components</h2>\n<h3>Key distribution model</h3>\n<p>The cluster&#39;s key space is split into 16384 slots, effectively setting an upper limit<br>for the cluster size of 16384 primary nodes (however, the suggested max size of<br>nodes is on the order of ~ 1000 nodes).</p>\n<p>Each primary node in a cluster handles a subset of the 16384 hash slots.<br>The cluster is <strong>stable</strong> when there is no cluster reconfiguration in<br>progress (i.e. where hash slots are being moved from one node to another).<br>When the cluster is stable, a single hash slot will be served by a single node<br>(however the serving node can have one or more replicas that will replace it in the case of net splits or failures,<br>and that can be used in order to scale read operations where reading stale data is acceptable).</p>\n<p>The base algorithm used to map keys to hash slots is the following<br>(read the next paragraph for the hash tag exception to this rule):</p>\n<pre><code>HASH_SLOT = CRC16(key) mod 16384\n</code></pre>\n<p>The CRC16 is specified as follows:</p>\n<ul>\n<li>Name: XMODEM (also known as ZMODEM or CRC-16/ACORN)</li>\n<li>Width: 16 bit</li>\n<li>Poly: 1021 (That is actually x^16 + x^12 + x^5 + 1)</li>\n<li>Initialization: 0000</li>\n<li>Reflect Input byte: False</li>\n<li>Reflect Output CRC: False</li>\n<li>Xor constant to output CRC: 0000</li>\n<li>Output for &quot;123456789&quot;: 31C3</li>\n</ul>\n<p>14 out of 16 CRC16 output bits are used (this is why there is<br>a modulo 16384 operation in the formula above).</p>\n<p>In our tests CRC16 behaved remarkably well in distributing different kinds of<br>keys evenly across the 16384 slots.</p>\n<p><strong>Note</strong>: A reference implementation of the CRC16 algorithm used is available in the Appendix A of this document.</p>\n<h3>Hash tags</h3>\n<p>There is an exception for the computation of the hash slot that is used in order<br>to implement <strong>hash tags</strong>. Hash tags are a way to ensure that multiple keys<br>are allocated in the same hash slot. This is used in order to implement<br>multi-key operations in Valkey Cluster.</p>\n<p>To implement hash tags, the hash slot for a key is computed in a<br>slightly different way in certain conditions.<br>If the key contains a &quot;{...}&quot; pattern only the substring between<br><code>{</code> and <code>}</code> is hashed in order to obtain the hash slot. However since it is<br>possible that there are multiple occurrences of <code>{</code> or <code>}</code> the algorithm is<br>well specified by the following rules:</p>\n<ul>\n<li>IF the key contains a <code>{</code> character.</li>\n<li>AND IF there is a <code>}</code> character to the right of <code>{</code>.</li>\n<li>AND IF there are one or more characters between the first occurrence of <code>{</code> and the first occurrence of <code>}</code>.</li>\n</ul>\n<p>Then instead of hashing the key, only what is between the first occurrence of <code>{</code> and the following first occurrence of <code>}</code> is hashed.</p>\n<p>Examples:</p>\n<ul>\n<li>The two keys <code>{user1000}.following</code> and <code>{user1000}.followers</code> will hash to the same hash slot since only the substring <code>user1000</code> will be hashed in order to compute the hash slot.</li>\n<li>For the key <code>foo{}{bar}</code> the whole key will be hashed as usually since the first occurrence of <code>{</code> is followed by <code>}</code> on the right without characters in the middle.</li>\n<li>For the key <code>foo{{bar}}zap</code> the substring <code>{bar</code> will be hashed, because it is the substring between the first occurrence of <code>{</code> and the first occurrence of <code>}</code> on its right.</li>\n<li>For the key <code>foo{bar}{zap}</code> the substring <code>bar</code> will be hashed, since the algorithm stops at the first valid or invalid (without bytes inside) match of <code>{</code> and <code>}</code>.</li>\n<li>What follows from the algorithm is that if the key starts with <code>{}</code>, it is guaranteed to be hashed as a whole. This is useful when using binary data as key names.</li>\n</ul>\n<h4>Glob-style patterns</h4>\n<p>Commands accepting a glob-style pattern, including <code>KEYS</code>, <code>SCAN</code> and <code>SORT</code>, are optimized for patterns that imply a single slot.<br>This means that if all keys that can match a pattern must belong to a specific slot, only this slot is searched for keys matching the pattern.<br>The pattern slot optimization is introduced in Valkey 8.0.</p>\n<p>The optimization kicks in when the pattern meets the following conditions:</p>\n<ul>\n<li>the pattern contains a hashtag,</li>\n<li>there are no wildcards or escape characters before the hashtag, and</li>\n<li>the hashtag within curly braces doesn&#39;t contain any wildcards or escape characters.</li>\n</ul>\n<p>For example, <code>SCAN 0 MATCH {abc}*</code> can successfully recognize the hashtag and scans only the slot corresponding to <code>abc</code>.<br>However, the patterns <code>*{abc}</code>, <code>{a*c}</code>, or <code>{a\\*bc}</code> cannot recognize the hashtag, so all slots need to be scanned.</p>\n<h4>Hash slot example code</h4>\n<p>Adding the hash tags exception, the following is an implementation of the <code>HASH_SLOT</code> function in Ruby and C language.</p>\n<p>Ruby example code:</p>\n<pre><code>def HASH_SLOT(key)\n    s = key.index &quot;{&quot;\n    if s\n        e = key.index &quot;}&quot;,s+1\n        if e &amp;&amp; e != s+1\n            key = key[s+1..e-1]\n        end\n    end\n    crc16(key) % 16384\nend\n</code></pre>\n<p>C example code:</p>\n<pre><code>unsigned int HASH_SLOT(char *key, int keylen) {\n    int s, e; /* start-end indexes of { and } */\n\n    /* Search the first occurrence of &#39;{&#39;. */\n    for (s = 0; s &lt; keylen; s++)\n        if (key[s] == &#39;{&#39;) break;\n\n    /* No &#39;{&#39; ? Hash the whole key. This is the base case. */\n    if (s == keylen) return crc16(key,keylen) &amp; 16383;\n\n    /* &#39;{&#39; found? Check if we have the corresponding &#39;}&#39;. */\n    for (e = s+1; e &lt; keylen; e++)\n        if (key[e] == &#39;}&#39;) break;\n\n    /* No &#39;}&#39; or nothing between {} ? Hash the whole key. */\n    if (e == keylen || e == s+1) return crc16(key,keylen) &amp; 16383;\n\n    /* If we are here there is both a { and a } on its right. Hash\n     * what is in the middle between { and }. */\n    return crc16(key+s+1,e-s-1) &amp; 16383;\n}\n</code></pre>\n<h3>Cluster node attributes</h3>\n<p>Every node has a unique name in the cluster. The node name is the<br>hex representation of a 160 bit random number, obtained the first time a<br>node is started (usually using /dev/urandom).<br>The node will save its ID in the node configuration file, and will use the<br>same ID forever, or at least as long as the node configuration file is not<br>deleted by the system administrator, or a <em>hard reset</em> is requested<br>via the <code>CLUSTER RESET</code> command.</p>\n<p>The node ID is used to identify every node across the whole cluster.<br>It is possible for a given node to change its IP address without any need<br>to also change the node ID. The cluster is also able to detect the change<br>in IP/port and reconfigure using the gossip protocol running over the cluster<br>bus.</p>\n<p>The node ID is not the only information associated with each node, but is<br>the only one that is always globally consistent. Every node has also the<br>following set of information associated. Some information is about the<br>cluster configuration detail of this specific node, and is eventually<br>consistent across the cluster. Some other information, like the last time<br>a node was pinged, is instead local to each node.</p>\n<p>Every node maintains the following information about other nodes that it is<br>aware of in the cluster: The node ID, IP and port of the node, a set of<br>flags, what is the primary of the node if it is flagged as <code>replica</code>, last time<br>the node was pinged and the last time the pong was received, the current<br><em>configuration epoch</em> of the node (explained later in this specification),<br>the link state and finally the set of hash slots served.</p>\n<p>A detailed <a href=\"../commands/cluster-nodes.md\">explanation of all the node fields</a> is described in the <code>CLUSTER NODES</code> documentation.</p>\n<p>The <code>CLUSTER NODES</code> command can be sent to any node in the cluster and provides the state of the cluster and the information for each node according to the local view the queried node has of the cluster.</p>\n<p>The following is sample output of the <code>CLUSTER NODES</code> command sent to a primary<br>node in a small cluster of three nodes.</p>\n<pre><code>$ valkey-cli cluster nodes\nd1861060fe6a534d42d8a19aeb36600e18785e04 127.0.0.1:6379 myself - 0 1318428930 1 connected 0-1364\n3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 2 connected 1365-2729\nd289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 3 connected 2730-4095\n</code></pre>\n<p>In the above listing the different fields are in order: node id, address:port, flags, last ping sent, last pong received, configuration epoch, link state, slots. Details about the above fields will be covered as soon as we talk of specific parts of Valkey Cluster.</p>\n<h3>The cluster bus</h3>\n<p>Every Valkey Cluster node has an additional TCP port for receiving<br>incoming connections from other Valkey Cluster nodes. This port will be derived by adding 10000 to the data port or it can be specified with the cluster-port config. </p>\n<p>Example 1:</p>\n<p>If a Valkey node is listening for client connections on port 6379,<br>and you do not add cluster-port parameter in valkey.conf,<br>the Cluster bus port 16379 will be opened.</p>\n<p>Example 2:</p>\n<p>If a Valkey node is listening for client connections on port 6379,<br>and you set cluster-port 20000 in valkey.conf,<br>the Cluster bus port 20000 will be opened.</p>\n<p>Node-to-node communication happens exclusively using the Cluster bus and<br>the Cluster bus protocol: a binary protocol composed of frames<br>of different types and sizes. The Cluster bus binary protocol is not<br>publicly documented since it is not intended for external software devices<br>to talk with Valkey Cluster nodes using this protocol. However you can<br>obtain more details about the Cluster bus protocol by reading the<br><code>cluster.h</code> and <code>cluster.c</code> files in the Valkey Cluster source code.</p>\n<h3>Cluster topology</h3>\n<p>Valkey Cluster is a full mesh where every node is connected with every other node using a TCP connection.</p>\n<p>In a cluster of N nodes, every node has N-1 outgoing TCP connections, and N-1 incoming connections.</p>\n<p>These TCP connections are kept alive all the time and are not created on demand.<br>When a node expects a pong reply in response to a ping in the cluster bus, before waiting long enough to mark the node as unreachable, it will try to<br>refresh the connection with the node by reconnecting from scratch.</p>\n<p>While Valkey Cluster nodes form a full mesh, <strong>nodes use a gossip protocol and<br>a configuration update mechanism in order to avoid exchanging too many<br>messages between nodes during normal conditions</strong>, so the number of messages<br>exchanged is not exponential.</p>\n<h3>Node handshake</h3>\n<p>Nodes always accept connections on the cluster bus port, and even reply to<br>pings when received, even if the pinging node is not trusted.<br>However, all other packets will be discarded by the receiving node if the<br>sending node is not considered part of the cluster.</p>\n<p>A node will accept another node as part of the cluster only in two ways:</p>\n<ul>\n<li><p>If a node presents itself with a <code>MEET</code> message (<code>CLUSTER MEET</code> command). A meet message is exactly<br>like a <code>PING</code> message, but forces the receiver to accept the node as part of<br>the cluster. Nodes will send <code>MEET</code> messages to other nodes <strong>only if</strong> the system administrator requests this via <code>CLUSTER MEET ip port</code>.</p>\n</li>\n<li><p>A node will also register another node as part of the cluster if a node that is already trusted will gossip about this other node. So if A knows B, and B knows C, eventually B will send gossip messages to A about C. When this happens, A will register C as part of the network, and will try to connect with C.</p>\n</li>\n</ul>\n<p>This means that as long as we join nodes in any connected graph, they&#39;ll eventually form a fully connected graph automatically. This means that the cluster is able to auto-discover other nodes, but only if there is a trusted relationship that was forced by the system administrator.</p>\n<p>This mechanism makes the cluster more robust but prevents different Valkey clusters from accidentally mixing after change of IP addresses or other network related events.</p>\n<h2>Redirection and resharding</h2>\n<h3>MOVED Redirection</h3>\n<p>A Valkey client is free to send queries to every node in the cluster, including<br>replica nodes. The node will analyze the query, and if it is acceptable<br>(that is, only a single key is mentioned in the query, or the multiple keys<br>mentioned are all to the same hash slot) it will lookup what<br>node is responsible for the hash slot where the key or keys belong.</p>\n<p>If the hash slot is served by the node, the query is simply processed, otherwise<br>the node will check its internal hash slot to node map, and will reply<br>to the client with a MOVED error, like in the following example:</p>\n<pre><code>GET x\n-MOVED 3999 127.0.0.1:6381\n</code></pre>\n<p>The error includes the hash slot of the key (3999) and the endpoint:port of the instance that can serve the query.<br>The client needs to reissue the query to the specified node&#39;s endpoint address and port.<br>The endpoint can be either an IP address, a hostname, or it can be empty (e.g. <code>-MOVED 3999 :6380</code>).<br>An empty endpoint indicates that the server node has an unknown endpoint, and the client should send the next request to the same endpoint as the current request but with the provided port. </p>\n<p>Note that even if the client waits a long time before reissuing the query,<br>and in the meantime the cluster configuration changed, the destination node<br>will reply again with a MOVED error if the hash slot 3999 is now served by<br>another node. The same happens if the contacted node had no updated information.</p>\n<p>So while from the point of view of the cluster nodes are identified by<br>IDs we try to simplify our interface with the client just exposing a map<br>between hash slots and Valkey nodes identified by endpoint:port pairs.</p>\n<p>The client is not required to, but should try to memorize that hash slot<br>3999 is served by 127.0.0.1:6381. This way once a new command needs to<br>be issued it can compute the hash slot of the target key and have a<br>greater chance of choosing the right node.</p>\n<p>An alternative is to just refresh the whole client-side cluster layout<br>using the <code>CLUSTER SHARDS</code>, or the deprecated <code>CLUSTER SLOTS</code>, command<br>when a MOVED redirection is received. When a redirection is encountered, it<br>is likely multiple slots were reconfigured rather than just one, so updating<br>the client configuration as soon as possible is often the best strategy.</p>\n<p>Note that when the Cluster is stable (no ongoing changes in the configuration),<br>eventually all the clients will obtain a map of hash slots -&gt; nodes, making<br>the cluster efficient, with clients directly addressing the right nodes<br>without redirections, proxies or other single point of failure entities.</p>\n<p>A client <strong>must be also able to handle -ASK redirections</strong> that are described<br>later in this document, otherwise it is not a complete Valkey Cluster client.</p>\n<h3>Live resharding</h3>\n<p>Valkey Cluster supports the ability to add and remove nodes while the cluster<br>is running. Adding or removing a node is abstracted into the same<br>operation: moving a hash slot from one node to another. This means<br>that the same basic mechanism can be used in order to rebalance the cluster, add<br>or remove nodes, and so forth.</p>\n<ul>\n<li>To add a new node to the cluster an empty node is added to the cluster and some set of hash slots are moved from existing nodes to the new node.</li>\n<li>To remove a node from the cluster the hash slots assigned to that node are moved to other existing nodes.</li>\n<li>To rebalance the cluster a given set of hash slots are moved between nodes.</li>\n</ul>\n<p>The core of the implementation is the ability to move hash slots around.<br>From a practical point of view a hash slot is just a set of keys, so<br>what Valkey Cluster really does during <em>resharding</em> is to move keys from<br>an instance to another instance. Moving a hash slot means moving all the keys<br>that happen to hash into this hash slot.</p>\n<p>To understand how this works we need to show the <code>CLUSTER</code> subcommands<br>that are used to manipulate the slots translation table in a Valkey Cluster node.</p>\n<p>The following subcommands are available (among others not useful in this case):</p>\n<ul>\n<li><code>CLUSTER ADDSLOTS</code> slot1 [slot2] ... [slotN]</li>\n<li><code>CLUSTER DELSLOTS</code> slot1 [slot2] ... [slotN]</li>\n<li><code>CLUSTER ADDSLOTSRANGE</code> start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]</li>\n<li><code>CLUSTER DELSLOTSRANGE</code> start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]</li>\n<li><code>CLUSTER SETSLOT</code> slot NODE node</li>\n<li><code>CLUSTER SETSLOT</code> slot MIGRATING node</li>\n<li><code>CLUSTER SETSLOT</code> slot IMPORTING node</li>\n</ul>\n<p>The first four commands, <code>ADDSLOTS</code>, <code>DELSLOTS</code>, <code>ADDSLOTSRANGE</code> and <code>DELSLOTSRANGE</code>, are simply used to assign<br>(or remove) slots to a Valkey node. Assigning a slot means to tell a given<br>primary node that it will be in charge of storing and serving content for<br>the specified hash slot.</p>\n<p>After the hash slots are assigned they will propagate across the cluster<br>using the gossip protocol, as specified later in the<br><em>configuration propagation</em> section.</p>\n<p>The <code>ADDSLOTS</code> and <code>ADDSLOTSRANGE</code> commands are usually used when a new cluster is created<br>from scratch to assign each primary node a subset of all the 16384 hash<br>slots available.</p>\n<p>The <code>DELSLOTS</code>  and <code>DELSLOTSRANGE</code> are mainly used for manual modification of a cluster configuration<br>or for debugging tasks: in practice it is rarely used.</p>\n<p>The <code>SETSLOT</code> subcommand is used to assign a slot to a specific node ID if<br>the <code>SETSLOT &lt;slot&gt; NODE</code> form is used. Otherwise the slot can be set in the<br>two special states <code>MIGRATING</code> and <code>IMPORTING</code>. Those two special states<br>are used in order to migrate a hash slot from one node to another.</p>\n<ul>\n<li>When a slot is set as MIGRATING, the node will accept all queries that<br>are about this hash slot, but only if the key in question<br>exists, otherwise the query is forwarded using a <code>-ASK</code> redirection to the<br>node that is target of the migration.</li>\n<li>When a slot is set as IMPORTING, the node will accept all queries that<br>are about this hash slot, but only if the request is<br>preceded by an <code>ASKING</code> command. If the <code>ASKING</code> command was not given<br>by the client, the query is redirected to the real hash slot owner via<br>a <code>-MOVED</code> redirection error, as would happen normally.</li>\n</ul>\n<p>Let&#39;s make this clearer with an example of hash slot migration.<br>Assume that we have two Valkey primary nodes, called A and B.<br>We want to move hash slot 8 from A to B, so we issue commands like this:</p>\n<ul>\n<li>We send B: CLUSTER SETSLOT 8 IMPORTING A</li>\n<li>We send A: CLUSTER SETSLOT 8 MIGRATING B</li>\n</ul>\n<p>All the other nodes will continue to point clients to node &quot;A&quot; every time<br>they are queried with a key that belongs to hash slot 8, so what happens<br>is that:</p>\n<ul>\n<li>All queries about existing keys are processed by &quot;A&quot;.</li>\n<li>All queries about non-existing keys in A are processed by &quot;B&quot;, because &quot;A&quot; will redirect clients to &quot;B&quot;.</li>\n</ul>\n<p>This way we no longer create new keys in &quot;A&quot;.<br>In the meantime, <code>valkey-cli</code> used during reshardings<br>and Valkey Cluster configuration will migrate existing keys in<br>hash slot 8 from A to B.<br>This is performed using the following command:</p>\n<pre><code>CLUSTER GETKEYSINSLOT slot count\n</code></pre>\n<p>The above command will return <code>count</code> keys in the specified hash slot.<br>For keys returned, <code>valkey-cli</code> sends node &quot;A&quot; a <code>MIGRATE</code> command, that<br>will migrate the specified keys from A to B in an atomic way (both instances<br>are locked for the time (usually very small time) needed to migrate keys so<br>there are no race conditions). This is how <code>MIGRATE</code> works:</p>\n<pre><code>MIGRATE target_host target_port &quot;&quot; target_database id timeout KEYS key1 key2 ...\n</code></pre>\n<p><code>MIGRATE</code> will connect to the target instance, send a serialized version of<br>the key, and once an OK code is received, the old key from its own dataset<br>will be deleted. From the point of view of an external client a key exists<br>either in A or B at any given time.</p>\n<p>In Valkey Cluster there is no need to specify a database other than 0, but<br><code>MIGRATE</code> is a general command that can be used for other tasks not<br>involving Valkey Cluster.<br><code>MIGRATE</code> is optimized to be as fast as possible even when moving complex<br>keys such as long lists, but in Valkey Cluster reconfiguring the<br>cluster where big keys are present is not considered a wise procedure if<br>there are latency constraints in the application using the database.</p>\n<p>When the migration process is finally finished, the <code>SETSLOT &lt;slot&gt; NODE &lt;node-id&gt;</code> command is sent to the two nodes involved in the migration in order to<br>set the slots to their normal state again. The same command is usually<br>sent to all other nodes to avoid waiting for the natural<br>propagation of the new configuration across the cluster.</p>\n<h4>Replication of <code>CLUSTER SETSLOT</code></h4>\n<p>Starting from Valkey 8.0, the <code>CLUSTER SETSLOT</code> command is replicated if the replicas are running Valkey version 8.0+.<br>The primary node waits up to 2 seconds, by default, for all healthy replicas to acknowledge the replication.<br>If not all health replicas acknowledge the replication within this time frame, the primary aborts the command,<br>and the client receives a <code>NOREPLICAS Not enough good replicas to write</code> error.<br>Operators can retry the command or customize the timeout using the <code>TIMEOUT</code> parameter to further increase the<br>reliability of live resharding:</p>\n<pre><code>CLUSTER SETSLOT slot [MIGRATING|IMPORTING|NODE] node-id [TIMEOUT timeout]\n</code></pre>\n<p>The <code>timeout</code> is specified in seconds, where a value of 0 indicates an indefinite wait time.</p>\n<p>Replicating the slot information and ensuring acknowledgement from health replicas significantly reduces<br>the likelihood of losing replication states if the primary fails after executing the command.<br>For example, consider a scenario where the target primary node <code>B</code> is finalizing a slot migration.<br>Before the <code>SETSLOT</code> command is replicated to its replica node <code>B</code>, <code>B</code> might send a cluster <code>PONG</code><br>message to the source primary node <code>A</code>, promoting <code>A</code> to relinquish its ownership of the slot in question.<br>If <code>B</code> crashes right after this point, the replica node <code>B</code>, which could be elected as the new primary,<br>would not be aware of the slot ownership transfer without the successful replication of <code>SETSLOT</code>.<br>This would leave the slot without an owner, leading to potential data loss and cluster topology inconsistency.</p>\n<h4>Election in empty shards</h4>\n<p>Starting from Valkey 8.0, Valkey clusters introduce the ability to elect a primary in empty shards.<br>This behavior ensures that even when a shard is in the process of receiving its first slot,<br>a primary can be elected. This prevents scenarios where there would be no primary available in the<br>empty shard to handle redirected requests from the official slot owner,<br>thereby maintaining availability during the live resharding.</p>\n<h3>ASK redirection</h3>\n<p>In the previous section, we briefly talked about ASK redirection. Why can&#39;t<br>we simply use MOVED redirection? Because while MOVED means that<br>we think the hash slot is permanently served by a different node and the<br>next queries should be tried against the specified node. ASK means to<br>send only the next query to the specified node.</p>\n<p>This is needed because the next query about hash slot 8 can be about a<br>key that is still in A, so we always want the client to try A and<br>then B if needed. Since this happens only for one hash slot out of 16384<br>available, the performance hit on the cluster is acceptable.</p>\n<p>We need to force that client behavior, so to make sure<br>that clients will only try node B after A was tried, node B will only<br>accept queries of a slot that is set as IMPORTING if the client sends the<br>ASKING command before sending the query.</p>\n<p>Basically the ASKING command sets a one-time flag on the client that forces<br>a node to serve a query about an IMPORTING slot.</p>\n<p>The full semantics of ASK redirection from the point of view of the client is as follows:</p>\n<ul>\n<li>If ASK redirection is received, send only the query that was redirected to the specified node but continue sending subsequent queries to the old node.</li>\n<li>Start the redirected query with the ASKING command.</li>\n<li>Don&#39;t yet update local client tables to map hash slot 8 to B.</li>\n</ul>\n<p>Once hash slot 8 migration is completed, A will send a MOVED message and<br>the client may permanently map hash slot 8 to the new endpoint and port pair.<br>Note that if a buggy client performs the map earlier this is not<br>a problem since it will not send the ASKING command before issuing the query,<br>so B will redirect the client to A using a MOVED redirection error.</p>\n<p>Slots migration is explained in similar terms but with different wording<br>(for the sake of redundancy in the documentation) in the <code>CLUSTER SETSLOT</code><br>command documentation.</p>\n<p>Starting from Valkey 8.0, when the primary in either the source or target shard fails during live resharding,<br>the primary in the other shard will automatically attempt to update its migrating/importing state to correctly pair<br>with the newly elected primary. If this update is successful, the ASK redirection will continue functioning without<br>requiring administrator intervention. In the event that slot migration fails, administrators can manually resume<br>the interrupted slot migration by running the command <code>valkey-cli --cluster fix &lt;ip:port&gt;</code>.</p>\n<p>Additionally, since Valkey 8.0, replicas are now able to return <code>ASK</code> redirects during slot migrations.<br>This capability was previously unavailable, as replicas were not aware of ongoing slot migrations in earlier versions.<br>See the <a href=\"../commands/readonly.md\">READONLY</a> command.</p>\n<h3>Client connections and redirection handling</h3>\n<p>To be efficient, Valkey Cluster clients maintain a map of the current slot<br>configuration. However, this configuration is not <em>required</em> to be up to date.<br>When contacting the wrong node results in a redirection, the client<br>can update its internal slot map accordingly.</p>\n<p>Clients usually need to fetch a complete list of slots and mapped node<br>addresses in two different situations:</p>\n<ul>\n<li>At startup, to populate the initial slots configuration</li>\n<li>When the client receives a <code>MOVED</code> redirection</li>\n</ul>\n<p>Note that a client may handle the <code>MOVED</code> redirection by updating just the<br>moved slot in its table; however this is usually not efficient because often<br>the configuration of multiple slots will be modified at once. For example, if a<br>replica is promoted to primary, all of the slots served by the old primary will<br>be remapped). It is much simpler to react to a <code>MOVED</code> redirection by<br>fetching the full map of slots to nodes from scratch.</p>\n<p>Client can issue a <code>CLUSTER SLOTS</code> command to retrieve an array of slot<br>ranges and the associated primary and replica nodes serving the specified ranges.</p>\n<p>The following is an example of output of <code>CLUSTER SLOTS</code>:</p>\n<pre><code>127.0.0.1:7000&gt; cluster slots\n1) 1) (integer) 5461\n   2) (integer) 10922\n   3) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7001\n   4) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7004\n2) 1) (integer) 0\n   2) (integer) 5460\n   3) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7000\n   4) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7003\n3) 1) (integer) 10923\n   2) (integer) 16383\n   3) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7002\n   4) 1) &quot;127.0.0.1&quot;\n      2) (integer) 7005\n</code></pre>\n<p>The first two sub-elements of every element of the returned array are the<br>start and end slots of the range. The additional elements represent address-port<br>pairs. The first address-port pair is the primary serving the slot, and the<br>additional address-port pairs are the replicas serving the same slot. Replicas<br>will be listed only when not in an error condition (i.e., when their FAIL flag is not set).</p>\n<p>The first element in the output above says that slots from 5461 to 10922<br>(start and end included) are served by 127.0.0.1:7001, and it is possible<br>to scale read-only load contacting the replica at 127.0.0.1:7004.</p>\n<p><code>CLUSTER SLOTS</code> is not guaranteed to return ranges that cover the full<br>16384 slots if the cluster is misconfigured, so clients should initialize the<br>slots configuration map filling the target nodes with NULL objects, and<br>report an error if the user tries to execute commands about keys<br>that belong to unassigned slots.</p>\n<p>Before returning an error to the caller when a slot is found to<br>be unassigned, the client should try to fetch the slots configuration<br>again to check if the cluster is now configured properly.</p>\n<h3>Multi-keys operations</h3>\n<p>Using hash tags, clients are free to use multi-key operations.<br>For example the following operation is valid:</p>\n<pre><code>MSET {user:1000}.name Angela {user:1000}.surname White\n</code></pre>\n<p>Multi-key operations may become unavailable when a resharding of the<br>hash slot the keys belong to is in progress.</p>\n<p>More specifically, even during a resharding the multi-key operations targeting<br>keys that all exist and all still hash to the same slot (either the source or<br>destination node) are still available.</p>\n<p>Operations on keys that don&#39;t exist or are - during the resharding - split<br>between the source and destination nodes, will generate a <code>-TRYAGAIN</code> error.<br>The client can try the operation after some time, or report back the error.</p>\n<p>As soon as migration of the specified hash slot has terminated, all<br>multi-key operations are available again for that hash slot.</p>\n<h3>Scaling reads using replica nodes</h3>\n<p>Normally replica nodes will redirect clients to the authoritative primary for<br>the hash slot involved in a given command, however clients can use replicas<br>in order to scale reads using the <code>READONLY</code> command.</p>\n<p><code>READONLY</code> tells a Valkey Cluster replica node that the client is ok reading<br>possibly stale data and is not interested in running write queries.</p>\n<p>When the connection is in readonly mode, the cluster will send a redirection<br>to the client only if the operation involves keys not served<br>by the replica&#39;s primary node. This may happen because:</p>\n<ol>\n<li>The client sent a command about hash slots never served by the primary of this replica.</li>\n<li>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</li>\n</ol>\n<p>When this happens the client should update its hash slot map as explained in<br>the previous sections.</p>\n<p>The readonly state of the connection can be cleared using the <code>READWRITE</code> command.</p>\n<h2>Fault Tolerance</h2>\n<h3>Heartbeat and gossip messages</h3>\n<p>Valkey Cluster nodes continuously exchange ping and pong packets. Those two kinds of packets have the same structure, and both carry important configuration information. The only actual difference is the message type field. We&#39;ll refer to the sum of ping and pong packets as <em>heartbeat packets</em>.</p>\n<p>Usually nodes send ping packets that will trigger the receivers to reply with pong packets. However this is not necessarily true. It is possible for nodes to just send pong packets to send information to other nodes about their configuration, without triggering a reply. This is useful, for example, in order to broadcast a new configuration as soon as possible.</p>\n<p>Usually a node will ping a few random nodes every second so that the total number of ping packets sent (and pong packets received) by each node is a constant amount regardless of the number of nodes in the cluster.</p>\n<p>However every node makes sure to ping every other node that hasn&#39;t sent a ping or received a pong for longer than half the <code>NODE_TIMEOUT</code> time. Before <code>NODE_TIMEOUT</code> has elapsed, nodes also try to reconnect the TCP link with another node to make sure nodes are not believed to be unreachable only because there is a problem in the current TCP connection.</p>\n<p>The number of messages globally exchanged can be sizable if <code>NODE_TIMEOUT</code> is set to a small figure and the number of nodes (N) is very large, since every node will try to ping every other node for which they don&#39;t have fresh information every half the <code>NODE_TIMEOUT</code> time.</p>\n<p>For example in a 100 node cluster with a node timeout set to 60 seconds, every node will try to send 99 pings every 30 seconds, with a total amount of pings of 3.3 per second. Multiplied by 100 nodes, this is 330 pings per second in the total cluster.</p>\n<p>There are ways to lower the number of messages, however there have been no<br>reported issues with the bandwidth currently used by Valkey Cluster failure<br>detection, so for now the obvious and direct design is used. Note that even<br>in the above example, the 330 packets per second exchanged are evenly<br>divided among 100 different nodes, so the traffic each node receives<br>is acceptable.</p>\n<h3>Heartbeat packet content</h3>\n<p>Ping and pong packets contain a header that is common to all types of packets (for instance packets to request a failover vote), and a special gossip section that is specific to Ping and Pong packets.</p>\n<p>The common header has the following information:</p>\n<ul>\n<li>Node ID, a 160 bit pseudorandom string that is assigned the first time a node is created and remains the same for all the life of a Valkey Cluster node.</li>\n<li>The <code>currentEpoch</code> and <code>configEpoch</code> fields of the sending node that are used to mount the distributed algorithms used by Valkey Cluster (this is explained in detail in the next sections). If the node is a replica the <code>configEpoch</code> is the last known <code>configEpoch</code> of its primary.</li>\n<li>The node flags, indicating if the node is a replica, a primary, and other single-bit node information.</li>\n<li>A bitmap of the hash slots served by the sending node, or if the node is a replica, a bitmap of the slots served by its primary.</li>\n<li>The sender TCP base port that is the port used by Valkey to accept client commands.</li>\n<li>The cluster port that is the port used by Valkey for node-to-node communication.</li>\n<li>The state of the cluster from the point of view of the sender (down or ok).</li>\n<li>The primary node ID of the sending node, if it is a replica.</li>\n</ul>\n<p>Ping and pong packets also contain a gossip section. This section offers to the receiver a view of what the sender node thinks about other nodes in the cluster. The gossip section only contains information about a few random nodes among the set of nodes known to the sender. The number of nodes mentioned in a gossip section is proportional to the cluster size.</p>\n<p>For every node added in the gossip section the following fields are reported:</p>\n<ul>\n<li>Node ID.</li>\n<li>IP and port of the node.</li>\n<li>Node flags.</li>\n</ul>\n<p>Gossip sections allow receiving nodes to get information about the state of other nodes from the point of view of the sender. This is useful both for failure detection and to discover other nodes in the cluster.</p>\n<h3>Failure detection</h3>\n<p>Valkey Cluster failure detection is used to recognize when a primary or replica node is no longer reachable by the majority of nodes and then respond by promoting a replica to the role of primary. When replica promotion is not possible the cluster is put in an error state to stop receiving queries from clients.</p>\n<p>As already mentioned, every node takes a list of flags associated with other known nodes. There are two flags that are used for failure detection that are called <code>PFAIL</code> and <code>FAIL</code>. <code>PFAIL</code> means <em>Possible failure</em>, and is a non-acknowledged failure type. <code>FAIL</code> means that a node is failing and that this condition was confirmed by a majority of primaries within a fixed amount of time.</p>\n<p><strong>PFAIL flag:</strong></p>\n<p>A node flags another node with the <code>PFAIL</code> flag when the node is not reachable for more than <code>NODE_TIMEOUT</code> time. Both primary and replica nodes can flag another node as <code>PFAIL</code>, regardless of its type.</p>\n<p>The concept of non-reachability for a Valkey Cluster node is that we have an <strong>active ping</strong> (a ping that we sent for which we have yet to get a reply) pending for longer than <code>NODE_TIMEOUT</code>. For this mechanism to work the <code>NODE_TIMEOUT</code> must be large compared to the network round trip time. In order to add reliability during normal operations, nodes will try to reconnect with other nodes in the cluster as soon as half of the <code>NODE_TIMEOUT</code> has elapsed without a reply to a ping. This mechanism ensures that connections are kept alive so broken connections usually won&#39;t result in false failure reports between nodes.</p>\n<p><strong>FAIL flag:</strong></p>\n<p>The <code>PFAIL</code> flag alone is just local information every node has about other nodes, but it is not sufficient to trigger a replica promotion. For a node to be considered down the <code>PFAIL</code> condition needs to be escalated to a <code>FAIL</code> condition.</p>\n<p>As outlined in the node heartbeats section of this document, every node sends gossip messages to every other node including the state of a few random known nodes. Every node eventually receives a set of node flags for every other node. This way every node has a mechanism to signal other nodes about failure conditions they have detected.</p>\n<p>A <code>PFAIL</code> condition is escalated to a <code>FAIL</code> condition when the following set of conditions are met:</p>\n<ul>\n<li>Some node, that we&#39;ll call A, has another node B flagged as <code>PFAIL</code>.</li>\n<li>Node A collected, via gossip sections, information about the state of B from the point of view of the majority of primaries in the cluster.</li>\n<li>The majority of primaries signaled the <code>PFAIL</code> or <code>FAIL</code> condition within <code>NODE_TIMEOUT * FAIL_REPORT_VALIDITY_MULT</code> time. (The validity factor is set to 2 in the current implementation, so this is just two times the <code>NODE_TIMEOUT</code> time).</li>\n</ul>\n<p>If all the above conditions are true, Node A will:</p>\n<ul>\n<li>Mark the node as <code>FAIL</code>.</li>\n<li>Send a <code>FAIL</code> message (as opposed to a <code>FAIL</code> condition within a heartbeat message) to all the reachable nodes.</li>\n</ul>\n<p>The <code>FAIL</code> message will force every receiving node to mark the node in <code>FAIL</code> state, whether or not it already flagged the node in <code>PFAIL</code> state.</p>\n<p>Note that <em>the FAIL flag is mostly one way</em>. That is, a node can go from <code>PFAIL</code> to <code>FAIL</code>, but a <code>FAIL</code> flag can only be cleared in the following situations:</p>\n<ul>\n<li>The node is already reachable and is a replica. In this case the <code>FAIL</code> flag can be cleared as replicas are not failed over.</li>\n<li>The node is already reachable and is a primary not serving any slot. In this case the <code>FAIL</code> flag can be cleared as primaries without slots do not really participate in the cluster and are waiting to be configured in order to join the cluster.</li>\n<li>The node is already reachable and is a primary, but a long time (N times the <code>NODE_TIMEOUT</code>) has elapsed without any detectable replica promotion. It&#39;s better for it to rejoin the cluster and continue in this case.</li>\n</ul>\n<p>It is useful to note that while the <code>PFAIL</code> -&gt; <code>FAIL</code> transition uses a form of agreement, the agreement used is weak:</p>\n<ol>\n<li>Nodes collect views of other nodes over some time period, so even if the majority of primary nodes need to &quot;agree&quot;, actually this is just state that we collected from different nodes at different times and we are not sure, nor we require, that at a given moment the majority of primaries agreed. However we discard failure reports which are old, so the failure was signaled by the majority of primaries within a window of time.</li>\n<li>While every node detecting the <code>FAIL</code> condition will force that condition on other nodes in the cluster using the <code>FAIL</code> message, there is no way to ensure the message will reach all the nodes. For instance a node may detect the <code>FAIL</code> condition and because of a partition will not be able to reach any other node.</li>\n</ol>\n<p>However the Valkey Cluster failure detection has a liveness requirement: eventually all the nodes should agree about the state of a given node. There are two cases that can originate from split brain conditions. Either some minority of nodes believe the node is in <code>FAIL</code> state, or a minority of nodes believe the node is not in <code>FAIL</code> state. In both the cases eventually the cluster will have a single view of the state of a given node:</p>\n<p><strong>Case 1</strong>: If a majority of primaries have flagged a node as <code>FAIL</code>, because of failure detection and the <em>chain effect</em> it generates, every other node will eventually flag the primary as <code>FAIL</code>, since in the specified window of time enough failures will be reported.</p>\n<p><strong>Case 2</strong>: When only a minority of primaries have flagged a node as <code>FAIL</code>, the replica promotion will not happen (as it uses a more formal algorithm that makes sure everybody knows about the promotion eventually) and every node will clear the <code>FAIL</code> state as per the <code>FAIL</code> state clearing rules above (i.e. no promotion after N times the <code>NODE_TIMEOUT</code> has elapsed).</p>\n<p><strong>The <code>FAIL</code> flag is only used as a trigger to run the safe part of the algorithm</strong> for the replica promotion. In theory a replica may act independently and start a replica promotion when its primary is not reachable, and wait for the primaries to refuse to provide the acknowledgment if the primary is actually reachable by the majority. However the added complexity of the <code>PFAIL -&gt; FAIL</code> state, the weak agreement, and the <code>FAIL</code> message forcing the propagation of the state in the shortest amount of time in the reachable part of the cluster, have practical advantages. Because of these mechanisms, usually all the nodes will stop accepting writes at about the same time if the cluster is in an error state. This is a desirable feature from the point of view of applications using Valkey Cluster. Also erroneous election attempts initiated by replicas that can&#39;t reach its primary due to local problems (the primary is otherwise reachable by the majority of other primary nodes) are avoided.</p>\n<h2>Configuration handling, propagation, and failovers</h2>\n<h3>Cluster current epoch</h3>\n<p>Valkey Cluster uses a concept similar to the Raft algorithm &quot;term&quot;. In Valkey Cluster the term is called epoch instead, and it is used in order to give incremental versioning to events. When multiple nodes provide conflicting information, it becomes possible for another node to understand which state is the most up to date.</p>\n<p>The <code>currentEpoch</code> is a 64 bit unsigned number.</p>\n<p>At node creation every Valkey Cluster node, both replicas and primary nodes, set the <code>currentEpoch</code> to 0.</p>\n<p>Every time a packet is received from another node, if the epoch of the sender (part of the cluster bus messages header) is greater than the local node epoch, the <code>currentEpoch</code> is updated to the sender epoch.</p>\n<p>Because of these semantics, eventually all the nodes will agree to the greatest <code>currentEpoch</code> in the cluster.</p>\n<p>This information is used when the state of the cluster is changed and a node seeks agreement in order to perform some action.</p>\n<p>Currently this happens only during replica promotion, as described in the next section. Basically the epoch is a logical clock for the cluster and dictates that given information wins over one with a smaller epoch.</p>\n<h3>Configuration epoch</h3>\n<p>Every primary always advertises its <code>configEpoch</code> in ping and pong packets along with a bitmap advertising the set of slots it serves.</p>\n<p>The <code>configEpoch</code> is set to zero in primaries when a new node is created.</p>\n<p>A new <code>configEpoch</code> is created during replica election. Replicas trying to replace<br>failing primaries increment their epoch and try to get authorization from<br>a majority of primaries. When a replica is authorized, a new unique <code>configEpoch</code><br>is created and the replica turns into a primary using the new <code>configEpoch</code>.</p>\n<p>As explained in the next sections the <code>configEpoch</code> helps to resolve conflicts when different nodes claim divergent configurations (a condition that may happen because of network partitions and node failures).</p>\n<p>Replica nodes also advertise the <code>configEpoch</code> field in ping and pong packets, but in the case of replicas the field represents the <code>configEpoch</code> of its primary as of the last time they exchanged packets. This allows other instances to detect when a replica has an old configuration that needs to be updated (primary nodes will not grant votes to replicas with an old configuration).</p>\n<p>Every time the <code>configEpoch</code> changes for some known node, it is permanently stored in the nodes.conf file by all the nodes that receive this information. The same also happens for the <code>currentEpoch</code> value. These two variables are guaranteed to be saved and <code>fsync-ed</code> to disk when updated before a node continues its operations.</p>\n<p>The <code>configEpoch</code> values generated using a simple algorithm during failovers<br>are guaranteed to be new, incremental, and unique.</p>\n<h3>Replica election and promotion</h3>\n<p>Replica election and promotion is handled by replica nodes, with the help of the primary nodes that vote for the replica to promote.<br>A replica election happens when a primary is in <code>FAIL</code> state from the point of view of at least one of its replicas that has the prerequisites in order to become a primary.</p>\n<p>In order for a replica to promote itself to primary, it needs to start an election and win it. All the replicas for a given primary can start an election if the primary is in <code>FAIL</code> state, however only one replica will win the election and promote itself to primary.</p>\n<p>A replica starts an election when the following conditions are met:</p>\n<ul>\n<li>The replica&#39;s primary is in <code>FAIL</code> state.</li>\n<li>The primary was serving a non-zero number of slots.</li>\n<li>The replica replication link was disconnected from the primary for no longer than a given amount of time, in order to ensure the promoted replica&#39;s data is reasonably fresh. This time is user configurable.</li>\n</ul>\n<p>In order to be elected, the first step for a replica is to increment its <code>currentEpoch</code> counter, and request votes from primary instances.</p>\n<p>Votes are requested by the replica by broadcasting a <code>FAILOVER_AUTH_REQUEST</code> packet to every primary node of the cluster. Then it waits for a maximum time of two times the <code>NODE_TIMEOUT</code> for replies to arrive (but always for at least 2 seconds).</p>\n<p>Once a primary has voted for a given replica, replying positively with a <code>FAILOVER_AUTH_ACK</code>, it can no longer vote for another replica of the same primary for a period of <code>NODE_TIMEOUT * 2</code>. In this period it will not be able to reply to other authorization requests for the same primary. This is not needed to guarantee safety, but useful for preventing multiple replicas from getting elected (even if with a different <code>configEpoch</code>) at around the same time, which is usually not wanted.</p>\n<p>A replica discards any <code>AUTH_ACK</code> replies with an epoch that is less than the <code>currentEpoch</code> at the time the vote request was sent. This ensures it doesn&#39;t count votes intended for a previous election.</p>\n<p>Once the replica receives ACKs from the majority of primaries, it wins the election.<br>Otherwise if the majority is not reached within the period of two times <code>NODE_TIMEOUT</code> (but always at least 2 seconds), the election is aborted and a new one will be tried again after <code>NODE_TIMEOUT * 4</code> (and always at least 4 seconds).</p>\n<h3>Replica rank</h3>\n<p>As soon as a primary is in <code>FAIL</code> state, a replica waits a short period of time before trying to get elected. That delay is computed as follows:</p>\n<pre><code>DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds +\n        REPLICA_RANK * 1000 milliseconds.\n</code></pre>\n<p>The fixed delay ensures that we wait for the <code>FAIL</code> state to propagate across the cluster, otherwise the replica may try to get elected while the primaries are still unaware of the <code>FAIL</code> state, refusing to grant their vote.</p>\n<p>The random delay is used to desynchronize replicas so they&#39;re unlikely to start an election at the same time.</p>\n<p>The <code>REPLICA_RANK</code> is the rank of this replica regarding the amount of replication data it has processed from the primary.<br>Replicas exchange messages when the primary is failing in order to establish a (best effort) rank:<br>the replica with the most updated replication offset is at rank 0, the second most updated at rank 1, and so forth.<br>In this way the most updated replicas try to get elected before others.</p>\n<p>Rank order is not strictly enforced; if a replica of higher rank fails to be<br>elected, the others will try shortly.</p>\n<p>Once a replica wins the election, it obtains a new unique and incremental <code>configEpoch</code> which is higher than that of any other existing primary. It starts advertising itself as primary in ping and pong packets, providing the set of served slots with a <code>configEpoch</code> that will win over the past ones.</p>\n<p>In order to speedup the reconfiguration of other nodes, a pong packet is broadcast to all the nodes of the cluster. Currently unreachable nodes will eventually be reconfigured when they receive a ping or pong packet from another node or will receive an <code>UPDATE</code> packet from another node if the information it publishes via heartbeat packets are detected to be out of date.</p>\n<p>The other nodes will detect that there is a new primary serving the same slots served by the old primary but with a greater <code>configEpoch</code>, and will upgrade their configuration. Replicas of the old primary (or the failed over primary if it rejoins the cluster) will not just upgrade the configuration but will also reconfigure to replicate from the new primary. How nodes rejoining the cluster are configured is explained in the next sections.</p>\n<h3>Masters reply to replica vote request</h3>\n<p>In the previous section, we discussed how replicas try to get elected. This section explains what happens from the point of view of a primary that is requested to vote for a given replica.</p>\n<p>Masters receive requests for votes in form of <code>FAILOVER_AUTH_REQUEST</code> requests from replicas.</p>\n<p>For a vote to be granted the following conditions need to be met:</p>\n<ol>\n<li>A primary only votes a single time for a given epoch, and refuses to vote for older epochs: every primary has a lastVoteEpoch field and will refuse to vote again as long as the <code>currentEpoch</code> in the auth request packet is not greater than the lastVoteEpoch. When a primary replies positively to a vote request, the lastVoteEpoch is updated accordingly, and safely stored on disk.</li>\n<li>A primary votes for a replica only if the replica&#39;s primary is flagged as <code>FAIL</code>.</li>\n<li>Auth requests with a <code>currentEpoch</code> that is less than the primary <code>currentEpoch</code> are ignored. Because of this the primary reply will always have the same <code>currentEpoch</code> as the auth request. If the same replica asks again to be voted, incrementing the <code>currentEpoch</code>, it is guaranteed that an old delayed reply from the primary can not be accepted for the new vote.</li>\n</ol>\n<p>Example of the issue caused by not using rule number 3:</p>\n<p>Primary <code>currentEpoch</code> is 5, lastVoteEpoch is 1 (this may happen after a few failed elections)</p>\n<ul>\n<li>Replica <code>currentEpoch</code> is 3.</li>\n<li>Replica tries to be elected with epoch 4 (3+1), primary replies with an ok with <code>currentEpoch</code> 5, however the reply is delayed.</li>\n<li>Replica will try to be elected again, at a later time, with epoch 5 (4+1), the delayed reply reaches the replica with <code>currentEpoch</code> 5, and is accepted as valid.</li>\n</ul>\n<ol start=\"4\">\n<li>Primaries don&#39;t vote for a replica of the same primary before <code>NODE_TIMEOUT * 2</code> has elapsed if a replica of that primary was already voted for. This is not strictly required as it is not possible for two replicas to win the election in the same epoch. However, in practical terms it ensures that when a replica is elected it has plenty of time to inform the other replicas and avoid the possibility that another replica will win a new election, performing an unnecessary second failover.</li>\n<li>Primaries make no effort to select the best replica in any way. If the replica&#39;s primary is in <code>FAIL</code> state and the primary did not vote in the current term, a positive vote is granted. The best replica is the most likely to start an election and win it before the other replicas, since it will usually be able to start the voting process earlier because of its <em>higher rank</em> as explained in the previous section.</li>\n<li>When a primary refuses to vote for a given replica there is no negative response, the request is simply ignored.</li>\n<li>Primaries don&#39;t vote for replicas sending a <code>configEpoch</code> that is less than any <code>configEpoch</code> in the primary table for the slots claimed by the replica. Remember that the replica sends the <code>configEpoch</code> of its primary, and the bitmap of the slots served by its primary. This means that the replica requesting the vote must have a configuration for the slots it wants to failover that is newer or equal the one of the primary granting the vote.</li>\n</ol>\n<h3>Practical example of configuration epoch usefulness during partitions</h3>\n<p>This section illustrates how the epoch concept is used to make the replica promotion process more resistant to partitions.</p>\n<ul>\n<li>A primary is no longer reachable indefinitely. The primary has three replicas A, B, C.</li>\n<li>Replica A wins the election and is promoted to primary.</li>\n<li>A network partition makes A not available for the majority of the cluster.</li>\n<li>Replica B wins the election and is promoted as primary.</li>\n<li>A partition makes B not available for the majority of the cluster.</li>\n<li>The previous partition is fixed, and A is available again.</li>\n</ul>\n<p>At this point B is down and A is available again with a role of primary (actually <code>UPDATE</code> messages would reconfigure it promptly, but here we assume all <code>UPDATE</code> messages were lost). At the same time, replica C will try to get elected in order to fail over B. This is what happens:</p>\n<ol>\n<li>C will try to get elected and will succeed, since for the majority of primaries its primary is actually down. It will obtain a new incremental <code>configEpoch</code>.</li>\n<li>A will not be able to claim to be the primary for its hash slots, because the other nodes already have the same hash slots associated with a higher configuration epoch (the one of B) compared to the one published by A.</li>\n<li>So, all the nodes will upgrade their table to assign the hash slots to C, and the cluster will continue its operations.</li>\n</ol>\n<p>As you&#39;ll see in the next sections, a stale node rejoining a cluster<br>will usually get notified as soon as possible about the configuration change<br>because as soon as it pings any other node, the receiver will detect it<br>has stale information and will send an <code>UPDATE</code> message.</p>\n<h3>Hash slots configuration propagation</h3>\n<p>An important part of Valkey Cluster is the mechanism used to propagate the information about which cluster node is serving a given set of hash slots. This is vital to both the startup of a fresh cluster and the ability to upgrade the configuration after a replica was promoted to serve the slots of its failing primary.</p>\n<p>The same mechanism allows nodes partitioned away for an indefinite amount of<br>time to rejoin the cluster in a sensible way.</p>\n<p>There are two ways hash slot configurations are propagated:</p>\n<ol>\n<li>Heartbeat messages. The sender of a ping or pong packet always adds information about the set of hash slots it (or its primary, if it is a replica) serves.</li>\n<li><code>UPDATE</code> messages. Since in every heartbeat packet there is information about the sender <code>configEpoch</code> and set of hash slots served, if a receiver of a heartbeat packet finds the sender information is stale, it will send a packet with new information, forcing the stale node to update its info.</li>\n</ol>\n<p>The receiver of a heartbeat or <code>UPDATE</code> message uses certain simple rules in<br>order to update its table mapping hash slots to nodes. When a new Valkey Cluster node is created, its local hash slot table is simply initialized to <code>NULL</code> entries so that each hash slot is not bound or linked to any node. This looks similar to the following:</p>\n<pre><code>0 -&gt; NULL\n1 -&gt; NULL\n2 -&gt; NULL\n...\n16383 -&gt; NULL\n</code></pre>\n<p>The first rule followed by a node in order to update its hash slot table is the following:</p>\n<p><strong>Rule 1</strong>: If a hash slot is unassigned (set to <code>NULL</code>), and a known node claims it, I&#39;ll modify my hash slot table and associate the claimed hash slots to it.</p>\n<p>So if we receive a heartbeat from node A claiming to serve hash slots 1 and 2 with a configuration epoch value of 3, the table will be modified to:</p>\n<pre><code>0 -&gt; NULL\n1 -&gt; A [3]\n2 -&gt; A [3]\n...\n16383 -&gt; NULL\n</code></pre>\n<p>When a new cluster is created, a system administrator needs to manually assign (using the <code>CLUSTER ADDSLOTS</code> command, via the valkey-cli command line tool, or by any other means) the slots served by each primary node only to the node itself, and the information will rapidly propagate across the cluster.</p>\n<p>However this rule is not enough. We know that hash slot mapping can change<br>during two events:</p>\n<ol>\n<li>A replica replaces its primary during a failover.</li>\n<li>A slot is resharded from a node to a different one.</li>\n</ol>\n<p>For now let&#39;s focus on failovers. When a replica fails over its primary, it obtains<br>a configuration epoch which is guaranteed to be greater than the one of its<br>primary (and more generally greater than any other configuration epoch<br>generated previously). For example node B, which is a replica of A, may failover<br>A with configuration epoch of 4. It will start to send heartbeat packets<br>(the first time mass-broadcasting cluster-wide) and because of the following<br>second rule, receivers will update their hash slot tables:</p>\n<p><strong>Rule 2</strong>: If a hash slot is already assigned, and a known node is advertising it using a <code>configEpoch</code> that is greater than the <code>configEpoch</code> of the primary currently associated with the slot, it&#39;ll rebind the hash slot to the new node.</p>\n<p>So after receiving messages from B that claim to serve hash slots 1 and 2 with configuration epoch of 4, the receivers will update their table in the following way:</p>\n<pre><code>0 -&gt; NULL\n1 -&gt; B [4]\n2 -&gt; B [4]\n...\n16383 -&gt; NULL\n</code></pre>\n<p>Liveness property: because of the second rule, eventually all nodes in the cluster will agree that the owner of a slot is the one with the greatest <code>configEpoch</code> among the nodes advertising it.</p>\n<p>This mechanism in Valkey Cluster is called <strong>last failover wins</strong>.</p>\n<p>The same happens during resharding. When a node importing a hash slot completes<br>the import operation, its configuration epoch is incremented to make sure the<br>change will be propagated throughout the cluster.</p>\n<h3>UPDATE messages, a closer look</h3>\n<p>With the previous section in mind, it is easier to see how update messages<br>work. Node A may rejoin the cluster after some time. It will send heartbeat<br>packets where it claims it serves hash slots 1 and 2 with configuration epoch<br>of 3. All the receivers with updated information will instead see that<br>the same hash slots are associated with node B having a higher configuration<br>epoch. Because of this they&#39;ll send an <code>UPDATE</code> message to A with the new<br>configuration for the slots. A will update its configuration because of the<br><strong>rule 2</strong> above.</p>\n<h3>How nodes rejoin the cluster</h3>\n<p>The same basic mechanism is used when a node rejoins a cluster.<br>Continuing with the example above, node A will be notified<br>that hash slots 1 and 2 are now served by B. Assuming that these two were<br>the only hash slots served by A, the count of hash slots served by A will<br>drop to 0! So A will <strong>reconfigure to be a replica of the new primary</strong>.</p>\n<p>The actual rule followed is a bit more complex than this. In general it may<br>happen that A rejoins after a lot of time, in the meantime it may happen that<br>hash slots originally served by A are served by multiple nodes, for example<br>hash slot 1 may be served by B, and hash slot 2 by C.</p>\n<p>So the actual <em>Valkey Cluster node role switch rule</em> is: <strong>A primary node will change its configuration to replicate (be a replica of) the node that stole its last hash slot</strong>.</p>\n<p>During reconfiguration, eventually the number of served hash slots will drop to zero, and the node will reconfigure accordingly. Note that in the base case this just means that the old primary will be a replica of the replica that replaced it after a failover. However in the general form the rule covers all possible cases.</p>\n<p>Replicas do exactly the same: they reconfigure to replicate the node that<br>stole the last hash slot of its former primary.</p>\n<h3>Replica migration</h3>\n<p>Valkey Cluster implements a concept called <em>replica migration</em> in order to<br>improve the availability of the system. The idea is that in a cluster with<br>a primary-replica setup, if the map between replicas and primaries is fixed<br>availability is limited over time if multiple independent failures of single<br>nodes happen.</p>\n<p>For example in a cluster where every primary has a single replica, the cluster<br>can continue operations as long as either the primary or the replica fail, but not<br>if both fail the same time. However there is a class of failures that are<br>the independent failures of single nodes caused by hardware or software issues<br>that can accumulate over time. For example:</p>\n<ul>\n<li>Master A has a single replica A1.</li>\n<li>Master A fails. A1 is promoted as new primary.</li>\n<li>Three hours later A1 fails in an independent manner (unrelated to the failure of A). No other replica is available for promotion since node A is still down. The cluster cannot continue normal operations.</li>\n</ul>\n<p>If the map between primaries and replicas is fixed, the only way to make the cluster<br>more resistant to the above scenario is to add replicas to every primary, however<br>this is costly as it requires more instances of Valkey to be executed, more<br>memory, and so forth.</p>\n<p>An alternative is to create an asymmetry in the cluster, and let the cluster<br>layout automatically change over time. For example the cluster may have three<br>primaries A, B, C. A and B have a single replica each, A1 and B1. However, the primary<br>C is different and has two replicas: C1 and C2.</p>\n<p>Replica migration is the process of automatic reconfiguration of a replica<br>in order to <em>migrate</em> to a primary that has no longer coverage (no working<br>replicas). With replica migration the scenario mentioned above turns into the<br>following:</p>\n<ul>\n<li>Master A fails. A1 is promoted.</li>\n<li>C2 migrates as replica of A1, that is otherwise not backed by any replica.</li>\n<li>Three hours later A1 fails as well.</li>\n<li>C2 is promoted as a new primary to replace A1.</li>\n<li>The cluster can continue the operations.</li>\n</ul>\n<h3>Replica migration algorithm</h3>\n<p>The migration algorithm does not use any form of agreement since the replica<br>layout in a Valkey Cluster is not part of the cluster configuration that needs<br>to be consistent and/or versioned with config epochs. Instead it uses an<br>algorithm to avoid mass-migration of replicas when a primary is not backed.<br>The algorithm guarantees that eventually (once the cluster configuration is<br>stable) every primary will be backed by at least one replica.</p>\n<p>This is how the algorithm works. To start we need to define what is a<br><em>good replica</em> in this context: a good replica is a replica not in <code>FAIL</code> state<br>from the point of view of a given node.</p>\n<p>The execution of the algorithm is triggered in every replica that detects that<br>there is at least a single primary without good replicas. However among all the<br>replicas detecting this condition, only a subset should act. This subset is<br>actually often a single replica unless different replicas have in a given moment<br>a slightly different view of the failure state of other nodes.</p>\n<p>The <em>acting replica</em> is the replica among the primaries with the maximum number<br>of attached replicas, that is not in FAIL state and has the smallest node ID.</p>\n<p>So for example if there are 10 primaries with 1 replica each, and 2 primaries with<br>5 replicas each, the replica that will try to migrate is - among the 2 primaries<br>having 5 replicas - the one with the lowest node ID. Given that no agreement<br>is used, it is possible that when the cluster configuration is not stable,<br>a race condition occurs where multiple replicas believe themselves to be<br>the non-failing replica with the lower node ID (it is unlikely for this to happen<br>in practice). If this happens, the result is multiple replicas migrating to the<br>same primary, which is harmless. If the race happens in a way that will leave<br>the ceding primary without replicas, as soon as the cluster is stable again<br>the algorithm will be re-executed again and will migrate a replica back to<br>the original primary.</p>\n<p>Eventually every primary will be backed by at least one replica. However,<br>the normal behavior is that a single replica migrates from a primary with<br>multiple replicas to an orphaned primary.</p>\n<p>The algorithm is controlled by a user-configurable parameter called<br><code>cluster-migration-barrier</code>: the number of good replicas a primary<br>must be left with before a replica can migrate away. For example, if this<br>parameter is set to 2, a replica can try to migrate only if its primary remains<br>with two working replicas.</p>\n<h3>configEpoch conflicts resolution algorithm</h3>\n<p>When new <code>configEpoch</code> values are created via replica promotion during<br>failovers, they are guaranteed to be unique.</p>\n<p>However there are two distinct events where new configEpoch values are<br>created in an unsafe way, just incrementing the local <code>currentEpoch</code> of<br>the local node and hoping there are no conflicts at the same time.<br>Both the events are system-administrator triggered:</p>\n<ol>\n<li><code>CLUSTER FAILOVER</code> command with <code>TAKEOVER</code> option is able to manually promote a replica node into a primary <em>without the majority of primaries being available</em>. This is useful, for example, in multi data center setups.</li>\n<li>Migration of slots for cluster rebalancing also generates new configuration epochs inside the local node without agreement for performance reasons.</li>\n</ol>\n<p>Specifically, during manual resharding, when a hash slot is migrated from<br>a node A to a node B, the resharding program will force B to upgrade<br>its configuration to an epoch which is the greatest found in the cluster,<br>plus 1 (unless the node is already the one with the greatest configuration<br>epoch), without requiring agreement from other nodes.<br>Usually a real world resharding involves moving several hundred hash slots<br>(especially in small clusters). Requiring an agreement to generate new<br>configuration epochs during resharding, for each hash slot moved, is<br>inefficient. Moreover it requires a fsync in each of the cluster nodes<br>every time in order to store the new configuration. Because of the way it is<br>performed instead, we only need a new config epoch when the first hash slot is moved,<br>making it much more efficient in production environments.</p>\n<p>However because of the two cases above, it is possible (though unlikely) to end<br>with multiple nodes having the same configuration epoch. A resharding operation<br>performed by the system administrator, and a failover happening at the same<br>time (plus a lot of bad luck) could cause <code>currentEpoch</code> collisions if<br>they are not propagated fast enough.</p>\n<p>Moreover, software bugs and filesystem corruptions can also contribute<br>to multiple nodes having the same configuration epoch.</p>\n<p>When primaries serving different hash slots have the same <code>configEpoch</code>, there<br>are no issues. It is more important that replicas failing over a primary have<br>unique configuration epochs.</p>\n<p>That said, manual interventions or resharding may change the cluster<br>configuration in different ways. The Valkey Cluster main liveness property<br>requires that slot configurations always converge, so under every circumstance<br>we really want all the primary nodes to have a different <code>configEpoch</code>.</p>\n<p>In order to enforce this, <strong>a conflict resolution algorithm</strong> is used in the<br>event that two nodes end up with the same <code>configEpoch</code>.</p>\n<ul>\n<li>IF a primary node detects another primary node is advertising itself with<br>the same <code>configEpoch</code>.</li>\n<li>AND IF the node has a lexicographically smaller Node ID compared to the other node claiming the same <code>configEpoch</code>.</li>\n<li>THEN it increments its <code>currentEpoch</code> by 1, and uses it as the new <code>configEpoch</code>.</li>\n</ul>\n<p>If there are any set of nodes with the same <code>configEpoch</code>, all the nodes but the one with the greatest Node ID will move forward, guaranteeing that, eventually, every node will pick a unique configEpoch regardless of what happened.</p>\n<p>This mechanism also guarantees that after a fresh cluster is created, all<br>nodes start with a different <code>configEpoch</code> (even if this is not actually<br>used) since <code>valkey-cli</code> makes sure to use <code>CLUSTER SET-CONFIG-EPOCH</code> at startup.<br>However if for some reason a node is left misconfigured, it will update<br>its configuration to a different configuration epoch automatically.</p>\n<h3>Node resets</h3>\n<p>Nodes can be software reset (without restarting them) in order to be reused<br>in a different role or in a different cluster. This is useful in normal<br>operations, in testing, and in cloud environments where a given node can<br>be reprovisioned to join a different set of nodes to enlarge or create a new<br>cluster.</p>\n<p>In Valkey Cluster nodes are reset using the <code>CLUSTER RESET</code> command. The<br>command is provided in two variants:</p>\n<ul>\n<li><code>CLUSTER RESET SOFT</code></li>\n<li><code>CLUSTER RESET HARD</code></li>\n</ul>\n<p>The command must be sent directly to the node to reset. If no reset type is<br>provided, a soft reset is performed.</p>\n<p>The following is a list of operations performed by a reset:</p>\n<ol>\n<li>Soft and hard reset: If the node is a replica, it is turned into a primary, and its dataset is discarded. If the node is a primary and contains keys the reset operation is aborted.</li>\n<li>Soft and hard reset: All the slots are released, and the manual failover state is reset.</li>\n<li>Soft and hard reset: All the other nodes in the nodes table are removed, so the node no longer knows any other node.</li>\n<li>Hard reset only: <code>currentEpoch</code>, <code>configEpoch</code>, and <code>lastVoteEpoch</code> are set to 0.</li>\n<li>Hard reset only: the Node ID is changed to a new random ID.</li>\n</ol>\n<p>Master nodes with non-empty data sets can&#39;t be reset (since normally you want to reshard data to the other nodes). However, under special conditions when this is appropriate (e.g. when a cluster is totally destroyed with the intent of creating a new one), <code>FLUSHALL</code> must be executed before proceeding with the reset.</p>\n<h3>Removing nodes from a cluster</h3>\n<p>It is possible to practically remove a node from an existing cluster by<br>resharding all its data to other nodes (if it is a primary node) and<br>shutting it down. However, the other nodes will still remember its node<br>ID and address, and will attempt to connect with it.</p>\n<p>For this reason, when a node is removed we want to also remove its entry<br>from all the other nodes tables. This is accomplished by using the<br><code>CLUSTER FORGET &lt;node-id&gt;</code> command.</p>\n<p>The command does two things:</p>\n<ol>\n<li>It removes the node with the specified node ID from the nodes table.</li>\n<li>It sets a 60 second ban which prevents a node with the same node ID from being re-added.</li>\n</ol>\n<p>The second operation is needed because Valkey Cluster uses gossip in order to auto-discover nodes, so removing the node X from node A, could result in node B gossiping about node X to A again. Because of the 60 second ban, the Valkey Cluster administration tools have 60 seconds in order to remove the node from all the nodes, preventing the re-addition of the node due to auto discovery.</p>\n<p>Further information is available in the <code>CLUSTER FORGET</code> documentation.</p>\n<h2>Publish/Subscribe</h2>\n<p>In a Valkey Cluster, clients can subscribe to every node, and can also<br>publish to every other node. The cluster will make sure that published<br>messages are forwarded as needed.</p>\n<p>The clients can send SUBSCRIBE to any node and can also send PUBLISH to any node.<br>It will simply broadcast each published message to all other nodes.</p>\n<p>Redis OSS 7.0 and later features sharded pub/sub, in which shard channels are assigned to slots by the same algorithm used to assign keys to slots.<br>A shard message must be sent to a node that owns the slot the shard channel is hashed to.<br>The cluster makes sure the published shard messages are forwarded to all nodes in the shard, so clients can subscribe to a shard channel by connecting to either the primary responsible for the slot, or to any of its replicas.</p>\n<h2>Appendix</h2>\n<h3>Appendix A: CRC16 reference implementation in ANSI C</h3>\n<pre><code>/*\n * Copyright 2001-2010 Georges Menie (www.menie.org)\n * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)\n * All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the University of California, Berkeley nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&#39;&#39; AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* CRC16 implementation according to CCITT standards.\n *\n * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the\n * following parameters:\n *\n * Name                       : &quot;XMODEM&quot;, also known as &quot;ZMODEM&quot;, &quot;CRC-16/ACORN&quot;\n * Width                      : 16 bit\n * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)\n * Initialization             : 0000\n * Reflect Input byte         : False\n * Reflect Output CRC         : False\n * Xor constant to output CRC : 0000\n * Output for &quot;123456789&quot;     : 31C3\n */\n\nstatic const uint16_t crc16tab[256]= {\n    0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,\n    0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,\n    0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,\n    0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,\n    0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,\n    0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,\n    0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,\n    0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,\n    0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,\n    0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,\n    0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,\n    0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,\n    0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,\n    0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,\n    0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,\n    0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,\n    0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,\n    0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,\n    0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,\n    0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,\n    0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,\n    0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,\n    0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,\n    0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,\n    0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,\n    0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,\n    0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,\n    0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,\n    0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,\n    0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,\n    0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,\n    0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0\n};\n\nuint16_t crc16(const char *buf, int len) {\n    int counter;\n    uint16_t crc = 0;\n    for (counter = 0; counter &lt; len; counter++)\n            crc = (crc&lt;&lt;8) ^ crc16tab[((crc&gt;&gt;8) ^ *buf++)&amp;0x00FF];\n    return crc;\n}\n</code></pre>\n"
      }
    ]
  },
  {
    "title": "ADMINISTRATION",
    "items": [
      {
        "id": "admin",
        "topicName": "Administration",
        "description": "Advice for configuring and managing Valkey in production",
        "htmlContent": "<h2>Valkey setup tips</h2>\n<h3>Linux</h3>\n<ul>\n<li><p>Deploy Valkey using the Linux operating system.<br>Valkey is also regularly tested on macOS and FreeBSD, and from time to time on other OpenBSD, NetBSD, DragonFlyBSD and Solaris-derived systems.<br>However, Linux is where most of the stress testing is performed, and where most production deployments are run.</p>\n</li>\n<li><p>Set the Linux kernel overcommit memory setting to 1. Add <code>vm.overcommit_memory = 1</code> to <code>/etc/sysctl.conf</code>. Then, reboot or run the command <code>sysctl vm.overcommit_memory=1</code> to activate the setting. See <a href=\"faq.md#background-saving-fails-with-a-fork-error-on-linux\">FAQ: Background saving fails with a fork() error on Linux?</a> for details. </p>\n</li>\n<li><p>To ensure the Linux kernel feature Transparent Huge Pages does not impact Valkey memory usage and latency, run the command: <code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code> to disable it. See <a href=\"latency.md#latency-induced-by-transparent-huge-pages\">Latency Diagnosis - Latency induced by transparent huge pages</a> for additional context.</p>\n</li>\n</ul>\n<h3>Memory</h3>\n<ul>\n<li><p>Ensured that swap is enabled and that your swap file size is equal to amount of memory on your system. If Linux does not have swap set up, and your Valkey instance accidentally consumes too much memory, Valkey can crash when it is out of memory, or the Linux kernel OOM killer can kill the Valkey process. When swapping is enabled, you can detect latency spikes and act on them.</p>\n</li>\n<li><p>Set an explicit <code>maxmemory</code> option limit in your instance to make sure that it will report errors instead of failing when the system memory limit is near to be reached. Note that <code>maxmemory</code> should be set by calculating the overhead for Valkey, other than data, and the fragmentation overhead. So if you think you have 10 GB of free memory, set it to 8 or 9.</p>\n</li>\n<li><p>If you are using Valkey in a write-heavy application, while saving an RDB file on disk or rewriting the AOF log, Valkey can use up to 2 times the memory normally used. The additional memory used is proportional to the number of memory pages modified by writes during the saving process, so it is often proportional to the number of keys (or aggregate types items) touched during this time. Make sure to size your memory accordingly.</p>\n</li>\n<li><p>See the <code>LATENCY DOCTOR</code> and <code>MEMORY DOCTOR</code> commands to assist in troubleshooting.</p>\n</li>\n</ul>\n<h3>Imaging</h3>\n<ul>\n<li>When running under daemontools, use <code>daemonize no</code>.</li>\n</ul>\n<h3>Replication</h3>\n<ul>\n<li><p>Set up a non-trivial replication backlog in proportion to the amount of memory Valkey is using. The backlog allows replicas to sync with the primary instance much more easily.</p>\n</li>\n<li><p>If you use replication, Valkey performs RDB saves even if persistence is disabled. (This does not apply to diskless replication.) If you don&#39;t have disk usage on the primary, enable diskless replication.</p>\n</li>\n<li><p>If you are using replication, ensure that either your primary has persistence enabled, or that it does not automatically restart on crashes. Replicas will try to maintain an exact copy of the primary, so if a primary restarts with an empty data set, replicas will be wiped as well.</p>\n</li>\n</ul>\n<h3>Security</h3>\n<ul>\n<li>By default, Valkey does not require any authentication and listens to all the network interfaces. This is a big security issue if you leave Valkey exposed on the internet or other places where attackers can reach it. Please check our <a href=\"security.md\">security page</a> and the <a href=\"quickstart.md\">quick start</a> for information about how to secure Valkey.</li>\n</ul>\n<h2>Running Valkey on EC2</h2>\n<ul>\n<li>Use HVM based instances, not PV based instances.</li>\n<li>The use of Valkey persistence with EC2 EBS volumes needs to be handled with care because sometimes EBS volumes have high latency characteristics.</li>\n<li>You may want to try diskless replication if you have issues when replicas are synchronizing with the primary.</li>\n</ul>\n<h2>Upgrading or restarting a Valkey instance without downtime</h2>\n<p>Valkey is designed to be a long-running process in your server. You can modify many configuration options without a restart using the <code>CONFIG SET</code> command. You can also switch from AOF to RDB snapshots persistence, or the other way around, without restarting Valkey. Check the output of the <code>CONFIG GET *</code> command for more information.</p>\n<p>From time to time, a restart is required, for example, to upgrade the Valkey process to a newer version, or when you need to modify a configuration parameter that is currently not supported by the <code>CONFIG</code> command.</p>\n<p>Follow these steps to avoid downtime.</p>\n<ul>\n<li><p>Set up your new Valkey instance as a replica for your current Valkey instance. In order to do so, you need a different server, or a server that has enough RAM to keep two instances of Valkey running at the same time.</p>\n</li>\n<li><p>If you use a single server, ensure that the replica is started on a different port than the primary instance, otherwise the replica cannot start.</p>\n</li>\n<li><p>Wait for the replication initial synchronization to complete. Check the replica&#39;s log file.</p>\n</li>\n<li><p>Using <code>INFO</code>, ensure the primary and replica have the same number of keys. Use <code>valkey-cli</code> to check that the replica is working as expected and is replying to your commands.</p>\n</li>\n<li><p>Allow writes to the replica using <code>CONFIG SET replica-read-only no</code>.</p>\n</li>\n<li><p>Configure all your clients to use the new instance (the replica). Note that you may want to use the <code>CLIENT PAUSE</code> command to ensure that no client can write to the old primary during the switch.</p>\n</li>\n<li><p>Once you confirm that the primary is no longer receiving any queries (you can check this using the <code>MONITOR</code> command), elect the replica to primary using the <code>REPLICAOF NO ONE</code> command, and then shut down your primary.</p>\n</li>\n</ul>\n<p>If you are using <a href=\"sentinel.md\">Valkey Sentinel</a> or <a href=\"cluster-tutorial.md\">Valkey Cluster</a>, the simplest way to upgrade to newer versions is to upgrade one replica after the other. Then you can perform a manual failover to promote one of the upgraded replicas to primary, and finally promote the last replica.</p>\n"
      },
      {
        "id": "security",
        "topicName": "Security",
        "description": "Security model and features in Valkey",
        "htmlContent": "<p>This document provides an introduction to the topic of security from the point of<br>view of Valkey. It covers the access control provided by Valkey, code security concerns,<br>attacks that can be triggered from the outside by selecting malicious inputs, and<br>other similar topics. </p>\n<p>For security-related contacts, open an issue on GitHub, or when you feel it<br>is really important to preserve the security of the communication, use the<br>GPG key at the end of this document.</p>\n<h2>Security model</h2>\n<p>Valkey is designed to be accessed by trusted clients inside trusted environments.<br>This means that usually it is not a good idea to expose the Valkey instance<br>directly to the internet or, in general, to an environment where untrusted<br>clients can directly access the Valkey TCP port or UNIX socket.</p>\n<p>For instance, in the common context of a web application implemented using Valkey<br>as a database, cache, or messaging system, the clients inside the front-end<br>(web side) of the application will query Valkey to generate pages or<br>to perform operations requested or triggered by the web application user.</p>\n<p>In this case, the web application mediates access between Valkey and<br>untrusted clients (the user browsers accessing the web application).</p>\n<p>In general, untrusted access to Valkey should<br>always be mediated by a layer implementing ACLs, validating user input,<br>and deciding what operations to perform against the Valkey instance.</p>\n<h2>Network security</h2>\n<p>Access to the Valkey port should be denied to everybody but trusted clients<br>in the network, so the servers running Valkey should be directly accessible<br>only by the computers implementing the application using Valkey.</p>\n<p>In the common case of a single computer directly exposed to the internet, such<br>as a virtualized Linux instance (Linode, EC2, ...), the Valkey port should be<br>firewalled to prevent access from the outside. Clients will still be able to<br>access Valkey using the loopback interface.</p>\n<p>Note that it is possible to bind Valkey to a single interface by adding a line<br>like the following to the <strong>valkey.conf</strong> file:</p>\n<pre><code>bind 127.0.0.1\n</code></pre>\n<p>Failing to protect the Valkey port from the outside can have a big security<br>impact because of the nature of Valkey. For instance, a single <code>FLUSHALL</code> command can be used by an external attacker to delete the whole data set.</p>\n<h2>Protected mode</h2>\n<p>Unfortunately, many users fail to protect Valkey instances from being accessed<br>from external networks. Many instances are simply left exposed on the<br>internet with public IPs. Valkey enters a special mode called <strong>protected mode</strong> when it is<br>executed with the default configuration (binding all the interfaces) and<br>without any password in order to access it. In this mode, Valkey only replies to queries from the<br>loopback interfaces, and replies to clients connecting from other<br>addresses with an error that explains the problem and how to configure<br>Valkey properly.</p>\n<p>We expect protected mode to seriously decrease the security issues caused<br>by unprotected Valkey instances executed without proper administration. However,<br>the system administrator can still ignore the error given by Valkey and<br>disable protected mode or manually bind all the interfaces.</p>\n<h2>Authentication</h2>\n<p>Valkey provides two ways to authenticate clients.<br>The recommended authentication method is via Access Control Lists, allowing named users to be created and assigned fine-grained permissions.<br>Read more about Access Control Lists <a href=\"acl.md\">here</a>.</p>\n<p>The legacy authentication method is enabled by editing the <strong>valkey.conf</strong> file, and providing a database password using the <code>requirepass</code> setting.<br>This password is then used by all clients.</p>\n<p>When the <code>requirepass</code> setting is enabled, Valkey will refuse any query by<br>unauthenticated clients. A client can authenticate itself by sending the<br><strong>AUTH</strong> command followed by the password.</p>\n<p>The password is set by the system administrator in clear text inside the<br>valkey.conf file. It should be long enough to prevent brute force attacks<br>for two reasons:</p>\n<ul>\n<li>Valkey is very fast at serving queries. Many passwords per second can be tested by an external client.</li>\n<li>The Valkey password is stored in the <strong>valkey.conf</strong> file and inside the client configuration. Since the system administrator does not need to remember it, the password can be very long.</li>\n</ul>\n<p>The goal of the authentication layer is to optionally provide a layer of<br>redundancy. If firewalling or any other system implemented to protect Valkey<br>from external attackers fail, an external client will still not be able to<br>access the Valkey instance without knowledge of the authentication password.</p>\n<p>Since the <code>AUTH</code> command, like every other Valkey command, is sent unencrypted, it<br>does not protect against an attacker that has enough access to the network to<br>perform eavesdropping.</p>\n<h2>TLS support</h2>\n<p>Valkey has optional support for TLS on all communication channels, including<br>client connections, replication links, and the Valkey Cluster bus protocol.</p>\n<h2>Attacks triggered by malicious inputs from external clients</h2>\n<p>There is a class of attacks that an attacker can trigger from the outside even<br>without external access to the instance. For example, an attacker might insert data into Valkey that triggers pathological (worst case)<br>algorithm complexity on data structures implemented inside Valkey internals.</p>\n<p>An attacker could supply, via a web form, a set of strings that<br>are known to hash to the same bucket in a hash table in order to turn the<br>O(1) expected time (the average time) to the O(N) worst case. This can consume more<br>CPU than expected and ultimately cause a Denial of Service.</p>\n<p>To prevent this specific attack, Valkey uses a per-execution, pseudo-random<br>seed to the hash function.</p>\n<p>Valkey implements the SORT command using the qsort algorithm. Currently,<br>the algorithm is not randomized, so it is possible to trigger a quadratic<br>worst-case behavior by carefully selecting the right set of inputs.</p>\n<h2>String escaping and NoSQL injection</h2>\n<p>The Valkey protocol has no concept of string escaping, so injection<br>is impossible under normal circumstances using a normal client library.<br>The protocol uses prefixed-length strings and is completely binary safe.</p>\n<p>Since Lua scripts executed by the <code>EVAL</code> and <code>EVALSHA</code> commands follow the<br>same rules, those commands are also safe.</p>\n<p>While it would be a strange use case, the application should avoid composing the body of the Lua script from strings obtained from untrusted sources.</p>\n<h2>Code security</h2>\n<p>Internally, Valkey uses all the well-known practices for writing secure code to<br>prevent buffer overflows, format bugs, and other memory corruption issues.</p>\n<p>Valkey does not require root privileges to run. It is recommended to<br>run it as an unprivileged <em>valkey</em> user that is only used for this purpose.</p>\n"
      },
      {
        "id": "encryption",
        "topicName": "TLS",
        "description": "Valkey TLS support",
        "htmlContent": "<p>SSL/TLS is supported by Valkey as an optional feature<br>that needs to be enabled at compile time.</p>\n<h2>Getting Started</h2>\n<h3>Building</h3>\n<p>To build with TLS support you&#39;ll need OpenSSL development libraries (e.g.<br><code>libssl-dev</code> on Debian/Ubuntu).</p>\n<p>Build Valkey with the following command:</p>\n<pre><code class=\"language-sh\">make BUILD_TLS=yes\n</code></pre>\n<h3>Tests</h3>\n<p>To run Valkey test suite with TLS, you&#39;ll need TLS support for TCL (i.e.<br><code>tcl-tls</code> package on Debian/Ubuntu).</p>\n<ol>\n<li><p>Run <code>./utils/gen-test-certs.sh</code> to generate a root CA and a server<br>certificate.</p>\n</li>\n<li><p>Run <code>./runtest --tls</code> or <code>./runtest-cluster --tls</code> to run Valkey and Valkey<br>Cluster tests in TLS mode.</p>\n</li>\n</ol>\n<h3>Running manually</h3>\n<p>To manually run a Valkey server with TLS mode (assuming <code>gen-test-certs.sh</code> was<br>invoked so sample certificates/keys are available):</p>\n<pre><code>./src/valkey-server --tls-port 6379 --port 0 \\\n    --tls-cert-file ./tests/tls/valkey.crt \\\n    --tls-key-file ./tests/tls/valkey.key \\\n    --tls-ca-cert-file ./tests/tls/ca.crt\n</code></pre>\n<p>To connect to this Valkey server with <code>valkey-cli</code>:</p>\n<pre><code>./src/valkey-cli --tls \\\n    --cert ./tests/tls/valkey.crt \\\n    --key ./tests/tls/valkey.key \\\n    --cacert ./tests/tls/ca.crt\n</code></pre>\n<h3>Certificate configuration</h3>\n<p>In order to support TLS, Valkey must be configured with a X.509 certificate and a<br>private key. In addition, it is necessary to specify a CA certificate bundle<br>file or path to be used as a trusted root when validating certificates. To<br>support DH based ciphers, a DH params file can also be configured. For example:</p>\n<pre><code>tls-cert-file /path/to/valkey.crt\ntls-key-file /path/to/valkey.key\ntls-ca-cert-file /path/to/ca.crt\ntls-dh-params-file /path/to/valkey.dh\n</code></pre>\n<h3>TLS listening port</h3>\n<p>The <code>tls-port</code> configuration directive enables accepting SSL/TLS connections on<br>the specified port. This is <strong>in addition</strong> to listening on <code>port</code> for TCP<br>connections, so it is possible to access Valkey on different ports using TLS and<br>non-TLS connections simultaneously.</p>\n<p>You may specify <code>port 0</code> to disable the non-TLS port completely. To enable only<br>TLS on the default Valkey port, use:</p>\n<pre><code>port 0\ntls-port 6379\n</code></pre>\n<h3>Client certificate authentication</h3>\n<p>By default, Valkey uses mutual TLS and requires clients to authenticate with a<br>valid certificate (authenticated against trusted root CAs specified by<br><code>ca-cert-file</code> or <code>ca-cert-dir</code>).</p>\n<p>You may use <code>tls-auth-clients no</code> to disable client authentication.</p>\n<h3>Replication</h3>\n<p>A Valkey primary server handles connecting clients and replica servers in the same<br>way, so the above <code>tls-port</code> and <code>tls-auth-clients</code> directives apply to<br>replication links as well.</p>\n<p>On the replica server side, it is necessary to specify <code>tls-replication yes</code> to<br>use TLS for outgoing connections to the primary.</p>\n<h3>Cluster</h3>\n<p>When Valkey Cluster is used, use <code>tls-cluster yes</code> in order to enable TLS for the<br>cluster bus and cross-node connections.</p>\n<h3>Sentinel</h3>\n<p>Sentinel inherits its networking configuration from the common Valkey<br>configuration, so all of the above applies to Sentinel as well.</p>\n<p>When connecting to primary servers, Sentinel will use the <code>tls-replication</code><br>directive to determine if a TLS or non-TLS connection is required.</p>\n<p>In addition, the very same <code>tls-replication</code> directive will determine whether Sentinel&#39;s<br>port, that accepts connections from other Sentinels, will support TLS as well. That is,<br>Sentinel will be configured with <code>tls-port</code> if and only if <code>tls-replication</code> is enabled. </p>\n<h3>Additional configuration</h3>\n<p>Additional TLS configuration is available to control the choice of TLS protocol<br>versions, ciphers and cipher suites, etc. Please consult the self documented<br><code>valkey.conf</code> for more information.</p>\n<h3>Performance considerations</h3>\n<p>TLS adds a layer to the communication stack with overheads due to writing/reading to/from an SSL connection, encryption/decryption and integrity checks. Consequently, using TLS results in a decrease of the achievable throughput per Valkey instance.</p>\n"
      },
      {
        "id": "persistence",
        "topicName": "Persistence",
        "description": "How Valkey writes data to disk",
        "htmlContent": "<p>Persistence refers to the writing of data to durable storage, such as a solid-state disk (SSD). Valkey provides a range of persistence options. These include:</p>\n<ul>\n<li><strong>RDB</strong> (Valkey Database): RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</li>\n<li><strong>AOF</strong> (Append Only File): AOF persistence logs every write operation received by the server. These operations can then be replayed again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Valkey protocol itself.</li>\n<li><strong>No persistence</strong>: You can disable persistence completely. This is sometimes used when caching.</li>\n<li><strong>RDB + AOF</strong>: You can also combine both AOF and RDB in the same instance.</li>\n</ul>\n<p>To learn more about how to evaluate your Valkey persistence strategy, read on.</p>\n<h2>RDB advantages</h2>\n<ul>\n<li>RDB is a very compact single-file point-in-time representation of your Valkey data. RDB files are perfect for backups. For instance you may want to archive your RDB files every hour for the latest 24 hours, and to save an RDB snapshot every day for 30 days. This allows you to easily restore different versions of the data set in case of disasters.</li>\n<li>RDB is very good for disaster recovery, being a single compact file that can be transferred to far data centers, or onto Amazon S3 (possibly encrypted).</li>\n<li>RDB maximizes Valkey performances since the only work the Valkey parent process needs to do in order to persist is forking a child that will do all the rest. The parent process will never perform disk I/O or alike.</li>\n<li>RDB allows faster restarts with big datasets compared to AOF.</li>\n<li>On replicas, RDB supports <a href=\"replication.md#partial-resynchronizations-after-restarts-and-failovers\">partial resynchronizations after restarts and failovers</a>.</li>\n</ul>\n<h2>RDB disadvantages</h2>\n<ul>\n<li>RDB is NOT good if you need to minimize the chance of data loss in case Valkey stops working (for example after a power outage). You can configure different <em>save points</em> where an RDB is produced (for instance after at least five minutes and 100 writes against the data set, you can have multiple save points). However you&#39;ll usually create an RDB snapshot every five minutes or more, so in case of Valkey stopping working without a correct shutdown for any reason you should be prepared to lose the latest minutes of data.</li>\n<li>RDB needs to fork() often in order to persist on disk using a child process. fork() can be time consuming if the dataset is big, and may result in Valkey stopping serving clients for some milliseconds or even for one second if the dataset is very big and the CPU performance is not great. AOF also needs to fork() but less frequently and you can tune how often you want to rewrite your logs without any trade-off on durability.</li>\n</ul>\n<h2>AOF advantages</h2>\n<ul>\n<li>Using AOF Valkey is much more durable: you can have different fsync policies: no fsync at all, fsync every second, fsync at every query. With the default policy of fsync every second, write performance is still great. fsync is performed using a background thread and the main thread will try hard to perform writes when no fsync is in progress, so you can only lose one second worth of writes.</li>\n<li>The AOF log is an append-only log, so there are no seeks, nor corruption problems if there is a power outage. Even if the log ends with a half-written command for some reason (disk full or other reasons) the valkey-check-aof tool is able to fix it easily.</li>\n<li>Valkey is able to automatically rewrite the AOF in background when it gets too big. The rewrite is completely safe as while Valkey continues appending to the old file, a completely new one is produced with the minimal set of operations needed to create the current data set, and once this second file is ready Valkey switches the two and starts appending to the new one.</li>\n<li>AOF contains a log of all the operations one after the other in an easy to understand and parse format. You can even easily export an AOF file. For instance even if you&#39;ve accidentally flushed everything using the <code>FLUSHALL</code> command, as long as no rewrite of the log was performed in the meantime, you can still save your data set just by stopping the server, removing the latest command, and restarting Valkey again.</li>\n</ul>\n<h2>AOF disadvantages</h2>\n<ul>\n<li>AOF files are usually bigger than the equivalent RDB files for the same dataset.</li>\n<li>AOF can be slower than RDB depending on the exact fsync policy. In general with fsync set to <em>every second</em> performance is still very high, and with fsync disabled it should be exactly as fast as RDB even under high load. Still RDB is able to provide more guarantees about the maximum latency even in the case of a huge write load.</li>\n</ul>\n<h2>Ok, so what should I use?</h2>\n<p>The general indication you should use both persistence methods is if<br>you want a degree of data safety comparable to what PostgreSQL can provide you.</p>\n<p>If you care a lot about your data, but still can live with a few minutes of<br>data loss in case of disasters, you can simply use RDB alone.</p>\n<p>There are many users using AOF alone, but we discourage it since to have an<br>RDB snapshot from time to time is a great idea for doing database backups,<br>for faster restarts, and in the event of bugs in the AOF engine.</p>\n<p>The following sections will illustrate a few more details about the two persistence models.</p>\n<h2>Snapshotting</h2>\n<p>By default Valkey saves snapshots of the dataset on disk, in a binary<br>file called <code>dump.rdb</code>. You can configure Valkey to have it save the<br>dataset every N seconds if there are at least M changes in the dataset,<br>or you can manually call the <code>SAVE</code> or <code>BGSAVE</code> commands.</p>\n<p>For example, this configuration will make Valkey automatically dump the<br>dataset to disk every 60 seconds if at least 1000 keys changed:</p>\n<pre><code>save 60 1000\n</code></pre>\n<p>This strategy is known as <em>snapshotting</em>.</p>\n<h2>No persistence</h2>\n<p>If you prefer <strong>not</strong> to have persistence (for example when using a Valkey instance solely as a cache) that is also a possibility.</p>\n<p>RDB snapshotting is enabled by default. To disable it, set the <code>save</code> configuration parameter to the empty string <code>&quot;&quot;</code> and remove any excess <code>save</code> lines that are present in the current configuration file.</p>\n<pre><code>save &quot;&quot;\n</code></pre>\n<p>Alternatively, you can also use the <code>--save &quot;&quot;</code> argument on the <code>valkey-server</code> binary.</p>\n<h3>How it works</h3>\n<p>Whenever Valkey needs to dump the dataset to disk, this is what happens:</p>\n<ul>\n<li><p>Valkey <a href=\"https://linux.die.net/man/2/fork\">forks</a>. We now have a child<br>and a parent process.</p>\n</li>\n<li><p>The child starts to write the dataset to a temporary RDB file.</p>\n</li>\n<li><p>When the child is done writing the new RDB file, it replaces the old<br>one.</p>\n</li>\n</ul>\n<p>This method allows Valkey to benefit from copy-on-write semantics.</p>\n<h2>Append-only file</h2>\n<p>Snapshotting is not very durable. If your computer running Valkey stops,<br>your power line fails, or you accidentally <code>kill -9</code> your instance, the<br>latest data written to Valkey will be lost.  While this may not be a big<br>deal for some applications, there are use cases for full durability, and<br>in these cases Valkey snapshotting alone is not a viable option.</p>\n<p>The <em>append-only file</em> is an alternative, fully-durable strategy for<br>Valkey.</p>\n<p>You can turn on the AOF in your configuration file:</p>\n<pre><code>appendonly yes\n</code></pre>\n<p>From now on, every time Valkey receives a command that changes the<br>dataset (e.g. <code>SET</code>) it will append it to the AOF.  When you restart<br>Valkey it will re-play the AOF to rebuild the state.</p>\n<p>Valkey uses a multi part AOF mechanism.<br>That is, the original single AOF file is split into base file (at most one) and incremental files (there may be more than one).<br>The base file represents an initial (RDB or AOF format) snapshot of the data present when the AOF is <a href=\"#log-rewriting\">rewritten</a>.<br>The incremental files contains incremental changes since the last base AOF file was created. All these files are put in a separate directory and are tracked by a manifest file.</p>\n<h3>Log rewriting</h3>\n<p>The AOF gets bigger and bigger as write operations are<br>performed.  For example, if you are incrementing a counter 100 times,<br>you&#39;ll end up with a single key in your dataset containing the final<br>value, but 100 entries in your AOF. 99 of those entries are not needed<br>to rebuild the current state.</p>\n<p>The rewrite is completely safe.<br>While Valkey continues appending to the old file,<br>a completely new one is produced with the minimal set of operations needed to create the current data set,<br>and once this second file is ready Valkey switches the two and starts appending to the new one.</p>\n<p>Valkey supports an interesting feature: it is able to rebuild the AOF in the background without interrupting service to clients.<br>Whenever you issue a <code>BGREWRITEAOF</code>, Valkey will write the shortest sequence of commands needed to rebuild the current dataset in memory.<br>Valkey will automatically trigger log rewriting automatically (see the example configuration file for more information).</p>\n<p>When an AOF rewrite is scheduled, the Valkey parent process opens a new incremental AOF file to continue writing.<br>The child process executes the rewrite logic and generates a new base AOF.<br>Valkey will use a temporary manifest file to track the newly generated base file and incremental file.<br>When they are ready, Valkey will perform an atomic replacement operation to make this temporary manifest file take effect.<br>In order to avoid the problem of creating many incremental files in case of repeated failures and retries of an AOF rewrite,<br>Valkey introduces an AOF rewrite limiting mechanism to ensure that failed AOF rewrites are retried at a slower and slower rate.</p>\n<h3>How durable is the append only file?</h3>\n<p>You can configure how many times Valkey will<br><a href=\"https://linux.die.net/man/2/fsync\"><code>fsync</code></a> data on disk. There are<br>three options:</p>\n<ul>\n<li><code>appendfsync always</code>: <code>fsync</code> every time new commands are appended to the AOF. Very very slow, very safe. Note that the commands are appended to the AOF after a batch of commands from multiple clients or a pipeline are executed, so it means a single write and a single fsync (before sending the replies).</li>\n<li><code>appendfsync everysec</code>: <code>fsync</code> every second. Fast enough and you may lose 1 second of data if there is a disaster.</li>\n<li><code>appendfsync no</code>: Never <code>fsync</code>, just put your data in the hands of the Operating System. The faster and less safe method. Normally Linux will flush data every 30 seconds with this configuration, but it&#39;s up to the kernel&#39;s exact tuning.</li>\n</ul>\n<p>The suggested (and default) policy is to <code>fsync</code> every second. It is<br>both fast and relatively safe. The <code>always</code> policy is very slow in<br>practice, but it supports group commit, so if there are multiple parallel<br>writes Valkey will try to perform a single <code>fsync</code> operation.</p>\n<h3>What should I do if my AOF gets truncated?</h3>\n<p>It is possible the server crashed while writing the AOF file, or the<br>volume where the AOF file is stored was full at the time of writing. When this happens the<br>AOF still contains consistent data representing a given point-in-time version<br>of the dataset (that may be old up to one second with the default AOF fsync<br>policy), but the last command in the AOF could be truncated.<br>The latest major versions of Valkey will be able to load the AOF anyway, just<br>discarding the last non well formed command in the file. In this case the<br>server will emit a log like the following:</p>\n<pre><code>* Reading RDB preamble from AOF file...\n* Reading the remaining AOF tail...\n# !!! Warning: short read while loading the AOF file !!!\n# !!! Truncating the AOF at offset 439 !!!\n# AOF loaded anyway because aof-load-truncated is enabled\n</code></pre>\n<p>You can change the default configuration to force Valkey to stop in such<br>cases if you want, but the default configuration is to continue regardless of<br>the fact the last command in the file is not well-formed, in order to guarantee<br>availability after a restart.</p>\n<p>Older versions of Valkey may not recover, and may require the following steps:</p>\n<ul>\n<li><p>Make a backup copy of your AOF file.</p>\n</li>\n<li><p>Fix the original file using the <code>valkey-check-aof</code> tool that ships with Valkey:</p>\n<pre><code>$ valkey-check-aof --fix &lt;filename&gt;\n</code></pre>\n</li>\n<li><p>Optionally use <code>diff -u</code> to check what is the difference between two files.</p>\n</li>\n<li><p>Restart the server with the fixed file.</p>\n</li>\n</ul>\n<h3>What should I do if my AOF gets corrupted?</h3>\n<p>If the AOF file is not just truncated, but corrupted with invalid byte<br>sequences in the middle, things are more complex. Valkey will complain<br>at startup and will abort:</p>\n<pre><code>* Reading the remaining AOF tail...\n# Bad file format reading the append only file: make a backup of your AOF file, then use ./valkey-check-aof --fix &lt;filename&gt;\n</code></pre>\n<p>The best thing to do is to run the <code>valkey-check-aof</code> utility, initially without<br>the <code>--fix</code> option, then understand the problem, jump to the given<br>offset in the file, and see if it is possible to manually repair the file:<br>The AOF uses the same format of the Valkey protocol and is quite simple to fix<br>manually. Otherwise it is possible to let the utility fix the file for us, but<br>in that case all the AOF portion from the invalid part to the end of the<br>file may be discarded, leading to a massive amount of data loss if the<br>corruption happened to be in the initial part of the file.</p>\n<h3>How it works</h3>\n<p>Log rewriting uses the same copy-on-write trick already in use for<br>snapshotting.  This is how it works:</p>\n<p><strong>Valkey multi-part AOF</strong></p>\n<ul>\n<li><p>Valkey <a href=\"https://linux.die.net/man/2/fork\">forks</a>, so now we have a child<br>and a parent process.</p>\n</li>\n<li><p>The child starts writing the new base AOF in a temporary file.</p>\n</li>\n<li><p>The parent opens a new increments AOF file to continue writing updates.<br>If the rewriting fails, the old base and increment files (if there are any) plus this newly opened increment file represent the complete updated dataset,<br>so we are safe.</p>\n</li>\n<li><p>When the child is done rewriting the base file, the parent gets a signal,<br>and uses the newly opened increment file and child generated base file to build a temp manifest,<br>and persist it.</p>\n</li>\n<li><p>Profit! Now Valkey does an atomic exchange of the manifest files so that the result of this AOF rewrite takes effect. Valkey also cleans up the old base file and any unused increment files.</p>\n</li>\n</ul>\n<h3>How I can switch to AOF, if I&#39;m currently using dump.rdb snapshots?</h3>\n<p>If you want to enable AOF in a server that is currently using RDB snapshots, you need to convert the data by enabling AOF via CONFIG command on the live server first.</p>\n<p><strong>IMPORTANT:</strong> not following this procedure (e.g. just changing the config and restarting the server) can result in data loss!</p>\n<p>Preparations:</p>\n<ul>\n<li>Make a backup of your latest dump.rdb file.</li>\n<li>Transfer this backup to a safe place.</li>\n</ul>\n<p>Switch to AOF on live database:</p>\n<ul>\n<li>Enable AOF: <code>valkey-cli config set appendonly yes</code></li>\n<li>Optionally disable RDB: <code>valkey-cli config set save &quot;&quot;</code></li>\n<li>Make sure writes are appended to the append only file correctly.</li>\n<li><strong>IMPORTANT:</strong> Update your <code>valkey.conf</code> (potentially through <code>CONFIG REWRITE</code>) and ensure that it matches the configuration above.<br>If you forget this step, when you restart the server, the configuration changes will be lost and the server will start again with the old configuration, resulting in a loss of your data.</li>\n</ul>\n<p>Next time you restart the server:</p>\n<ul>\n<li>Before restarting the server, wait for AOF rewrite to finish persisting the data.<br>You can do that by watching <code>INFO persistence</code>, waiting for <code>aof_rewrite_in_progress</code> and <code>aof_rewrite_scheduled</code> to be <code>0</code>, and validating that <code>aof_last_bgrewrite_status</code> is <code>ok</code>.</li>\n<li>After restarting the server, check that your database contains the same number of keys it contained previously.</li>\n</ul>\n<h2>Interactions between AOF and RDB persistence</h2>\n<p>Valkey makes sure to avoid triggering an AOF rewrite when an RDB<br>snapshotting operation is already in progress, or allowing a <code>BGSAVE</code> while the<br>AOF rewrite is in progress. This prevents two Valkey background processes<br>from doing heavy disk I/O at the same time.</p>\n<p>When snapshotting is in progress and the user explicitly requests a log<br>rewrite operation using <code>BGREWRITEAOF</code> the server will reply with an OK<br>status code telling the user the operation is scheduled, and the rewrite<br>will start once the snapshotting is completed.</p>\n<p>In the case both AOF and RDB persistence are enabled and Valkey restarts the<br>AOF file will be used to reconstruct the original dataset since it is<br>guaranteed to be the most complete.</p>\n<h2>Backing up Valkey data</h2>\n<p>Before starting this section, make sure to read the following sentence: <strong>Make Sure to Backup Your Database</strong>. Disks break, instances in the cloud disappear, and so forth: no backups means huge risk of data disappearing into /dev/null.</p>\n<p>Valkey is very data backup friendly since you can copy RDB files while the<br>database is running: the RDB is never modified once produced, and while it<br>gets produced it uses a temporary name and is renamed into its final destination<br>atomically using rename(2) only when the new snapshot is complete.</p>\n<p>This means that copying the RDB file is completely safe while the server is<br>running. This is what we suggest:</p>\n<ul>\n<li>Create a cron job in your server creating hourly snapshots of the RDB file in one directory, and daily snapshots in a different directory.</li>\n<li>Every time the cron script runs, make sure to call the <code>find</code> command to make sure too old snapshots are deleted: for instance you can take hourly snapshots for the latest 48 hours, and daily snapshots for one or two months. Make sure to name the snapshots with date and time information.</li>\n<li>At least one time every day make sure to transfer an RDB snapshot <em>outside your data center</em> or at least <em>outside the physical machine</em> running your Valkey instance.</li>\n</ul>\n<h3>Backing up AOF persistence</h3>\n<p>If you run a Valkey instance with only AOF persistence enabled, you can still perform backups.<br>AOF files are split into multiple files which reside in a single directory determined by the <code>appenddirname</code> configuration.<br>During normal operation all you need to do is copy/tar the files in this directory to achieve a backup. However, if this is done during a <a href=\"#log-rewriting\">rewrite</a>, you might end up with an invalid backup.<br>To work around this you must disable AOF rewrites during the backup:</p>\n<ol>\n<li>Turn off automatic rewrites with<br/><br><code>CONFIG SET</code> <code>auto-aof-rewrite-percentage 0</code><br/><br>Make sure you don&#39;t manually start a rewrite (using <code>BGREWRITEAOF</code>) during this time.</li>\n<li>Check there&#39;s no current rewrite in progress using<br/><br><code>INFO</code> <code>persistence</code><br/><br>and verifying <code>aof_rewrite_in_progress</code> is 0. If it&#39;s 1, then you&#39;ll need to wait for the rewrite to complete.</li>\n<li>Now you can safely copy the files in the <code>appenddirname</code> directory.</li>\n<li>Re-enable rewrites when done:<br/><br><code>CONFIG SET</code> <code>auto-aof-rewrite-percentage &lt;prev-value&gt;</code></li>\n</ol>\n<p><strong>Note:</strong> If you want to minimize the time AOF rewrites are disabled you may create hard links to the files in <code>appenddirname</code> (in step 3 above) and then re-enable rewrites (step 4) after the hard links are created.<br>Now you can copy/tar the hardlinks and delete them when done. This works because Valkey guarantees that it<br>only appends to files in this directory, or completely replaces them if necessary, so the content should be<br>consistent at any given point in time.</p>\n<p><strong>Note:</strong> If you want to handle the case of the server being restarted during the backup and make sure no rewrite will automatically start after the restart you can change step 1 above to also persist the updated configuration via <code>CONFIG REWRITE</code>.<br>Just make sure to re-enable automatic rewrites when done (step 4) and persist it with another <code>CONFIG REWRITE</code>.</p>\n<h2>Disaster recovery</h2>\n<p>Disaster recovery in the context of Valkey is basically the same story as<br>backups, plus the ability to transfer those backups in many different external<br>data centers. This way data is secured even in the case of some catastrophic<br>event affecting the main data center where Valkey is running and producing its<br>snapshots.</p>\n<p>We&#39;ll review the most interesting disaster recovery techniques<br>that don&#39;t have too high costs.</p>\n<ul>\n<li>Amazon S3 and other similar services are a good way for implementing your disaster recovery system. Simply transfer your daily or hourly RDB snapshot to S3 in an encrypted form. You can encrypt your data using <code>gpg -c</code> (in symmetric encryption mode). Make sure to store your password in many different safe places (for instance give a copy to the most important people of your organization). It is recommended to use multiple storage services for improved data safety.</li>\n<li>Transfer your snapshots using SCP (part of SSH) to far servers. This is a fairly simple and safe route: get a small VPS in a place that is very far from you, install ssh there, and generate a ssh client key without passphrase, then add it in the <code>authorized_keys</code> file of your small VPS. You are ready to transfer backups in an automated fashion. Get at least two VPS in two different providers<br>for best results.</li>\n</ul>\n<p>It is important to understand that this system can easily fail if not<br>implemented in the right way. At least, make absolutely sure that after the<br>transfer is completed you are able to verify the file size (that should match<br>the one of the file you copied) and possibly the SHA1 digest, if you are using<br>a VPS.</p>\n<p>You also need some kind of independent alert system if the transfer of fresh<br>backups is not working for some reason.</p>\n"
      },
      {
        "id": "signals",
        "topicName": "Signal handling",
        "description": "How Valkey handles common Unix signals",
        "htmlContent": "<p>This document provides information about how Valkey reacts to different POSIX signals such as <code>SIGTERM</code> and <code>SIGSEGV</code>.</p>\n<h2>SIGTERM and SIGINT</h2>\n<p>The <code>SIGTERM</code> and <code>SIGINT</code> signals tell Valkey to shut down gracefully. When the server receives this signal,<br>it does not immediately exit. Instead, it schedules<br>a shutdown similar to the one performed by the <code>SHUTDOWN</code> command. The scheduled shutdown starts as soon as possible, specifically as long as the<br>current command in execution terminates (if any), with a possible additional<br>delay of 0.1 seconds or less.</p>\n<p>If the server is blocked by a long-running Lua script,<br>kill the script with <code>SCRIPT KILL</code> if possible. The scheduled shutdown will<br>run just after the script is killed or terminates spontaneously.</p>\n<p>This shutdown process includes the following actions:</p>\n<ul>\n<li>If there are any replicas lagging behind in replication:<ul>\n<li>Pause clients attempting to write with <code>CLIENT PAUSE</code> and the <code>WRITE</code> option.</li>\n<li>Wait up to the configured <code>shutdown-timeout</code> (default 10 seconds) for replicas to catch up with the primary&#39;s replication offset.</li>\n</ul>\n</li>\n<li>If a background child is saving the RDB file or performing an AOF rewrite, the child process is killed.</li>\n<li>If the AOF is active, Valkey calls the <code>fsync</code> system call on the AOF file descriptor to flush the buffers on disk.</li>\n<li>If Valkey is configured to persist on disk using RDB files, a synchronous (blocking) save is performed. Since the save is synchronous, it doesn&#39;t use any additional memory.</li>\n<li>If the server is daemonized, the PID file is removed.</li>\n<li>If the Unix domain socket is enabled, it gets removed.</li>\n<li>The server exits with an exit code of zero.</li>\n</ul>\n<p>IF the RDB file can&#39;t be saved, the shutdown fails, and the server continues to run in order to ensure no data loss.<br>Likewise, if the user just turned on AOF, and the server triggered the first AOF rewrite in order to create the initial AOF file but this file can&#39;t be saved, the shutdown fails and the server continues to run.<br>No further attempt to shut down will be made unless a new <code>SIGTERM</code> is received or the <code>SHUTDOWN</code> command is issued.</p>\n<p>Since Redis OSS 7.0, the server waits for lagging replicas up to a configurable <code>shutdown-timeout</code>, 10 seconds by default, before shutting down.<br>This provides a best effort to minimize the risk of data loss in a situation where no save points are configured and AOF is deactivated.<br>Before version 7.0, shutting down a heavily loaded primary node in a diskless setup was more likely to result in data loss.<br>To minimize the risk of data loss in such setups, trigger a manual <code>FAILOVER</code> (or <code>CLUSTER FAILOVER</code>) to demote the primary to a replica and promote one of the replicas to a new primary before shutting down a primary node.</p>\n<h2>SIGSEGV, SIGBUS, SIGFPE and SIGILL</h2>\n<p>The following signals are handled as a Valkey crash:</p>\n<ul>\n<li>SIGSEGV</li>\n<li>SIGBUS</li>\n<li>SIGFPE</li>\n<li>SIGILL</li>\n</ul>\n<p>Once one of these signals is trapped, Valkey stops any current operation and performs the following actions:</p>\n<ul>\n<li>Adds a bug report to the log file. This includes a stack trace, dump of registers, and information about the state of clients.</li>\n<li>A fast memory test is performed as a first check of the reliability of the crashing system.</li>\n<li>If the server was daemonized, the PID file is removed.</li>\n<li>Finally the server unregisters its own signal handler for the received signal and resends the same signal to itself to make sure that the default action is performed, such as dumping the core on the file system.</li>\n</ul>\n<h2>What happens when a child process gets killed</h2>\n<p>When the child performing the Append Only File rewrite gets killed by a signal,<br>Valkey handles this as an error and discards the (probably partial or corrupted)<br>AOF file. It will attempt the rewrite again later.</p>\n<p>When the child performing an RDB save is killed, Valkey handles the<br>condition as a more severe error. While the failure of an<br>AOF file rewrite can cause AOF file enlargement, failed RDB file<br>creation reduces durability.</p>\n<p>As a result of the child producing the RDB file being killed by a signal,<br>or when the child exits with an error (non zero exit code), Valkey enters<br>a special error condition where no further write command is accepted.</p>\n<ul>\n<li>Valkey will continue to reply to read commands.</li>\n<li>Valkey will reply to all write commands with a <code>MISCONFIG</code> error.</li>\n</ul>\n<p>This error condition will persist until it becomes possible to create an RDB file successfully.</p>\n<h2>Kill the RDB file without errors</h2>\n<p>Sometimes the user may want to kill the RDB-saving child process without<br>generating an error. This can be done using the signal <code>SIGUSR1</code>. This signal is handled in a special way:<br>it kills the child process like any other signal, but the parent process will<br>not detect this as a critical error and will continue to serve write<br>requests.</p>\n"
      },
      {
        "id": "memory-optimization",
        "topicName": "Memory optimization",
        "description": "Strategies for optimizing memory usage in Valkey",
        "htmlContent": "<h2>Special encoding of small aggregate data types</h2>\n<p>Many data types are optimized to use less space up to a certain size.<br>Hashes, Lists, Sets composed of just integers, and Sorted Sets, when smaller than a given number of elements, and up to a maximum element size, are encoded in a very memory-efficient way that uses <em>up to 10 times less memory</em> (with 5 times less memory used being the average saving).</p>\n<p>This is completely transparent from the point of view of the user and API.<br>Since this is a CPU / memory tradeoff it is possible to tune the maximum<br>number of elements and maximum element size for special encoded types<br>using the following valkey.conf directives (defaults for Valkey 7.2 are shown):</p>\n<pre><code>hash-max-listpack-entries 512\nhash-max-listpack-value 64\nzset-max-listpack-entries 128\nzset-max-listpack-value 64\nset-max-intset-entries 512\nset-max-listpack-entries 128\nset-max-listpack-value 64\n</code></pre>\n<p>If a specially encoded value overflows the configured max size,<br>Valkey will automatically convert it into normal encoding.<br>This operation is very fast for small values,<br>but if you change the setting in order to use specially encoded values<br>for much larger aggregate types the suggestion is to run some<br>benchmarks and tests to check the conversion time.</p>\n<h2>Using 32-bit instances</h2>\n<p>When Valkey is compiled as a 32-bit target, it uses a lot less memory per key, since pointers are small,<br>but such an instance will be limited to 4 GB of maximum memory usage.<br>To compile Valkey as 32-bit binary use <em>make 32bit</em>.<br>RDB and AOF files are compatible between 32-bit and 64-bit instances<br>(and between little and big endian of course) so you can switch from 32 to 64-bit, or the contrary, without problems.</p>\n<h2>Bit and byte level operations</h2>\n<p>Valkey has bit and byte level operations: <code>GETRANGE</code>, <code>SETRANGE</code>, <code>GETBIT</code> and <code>SETBIT</code>.<br>Using these commands you can treat the String type as a random access array.<br>For instance, if you have an application where users are identified by a unique progressive integer number,<br>you can use a bitmap to save information about the subscription of users in a mailing list,<br>setting the bit for subscribed and clearing it for unsubscribed, or the other way around.<br>With 100 million users this data will take just 12 megabytes of RAM in a Valkey instance.<br>You can do the same using <code>GETRANGE</code> and <code>SETRANGE</code> to store one byte of information for each user.<br>This is just an example but it is possible to model several problems in very little space with these new primitives.</p>\n<h2>Use hashes when possible</h2>\n<p>Small hashes are encoded in a very small space, so you should try representing your data using hashes whenever possible.<br>For instance, if you have objects representing users in a web application,<br>instead of using different keys for name, surname, email, password, use a single hash with all the required fields.</p>\n<p>If you want to know more about this, read the next section.</p>\n<h2>Using hashes to abstract a very memory-efficient plain key-value store on top of Valkey</h2>\n<p>I understand the title of this section is a bit scary, but I&#39;m going to explain in detail what this is about.</p>\n<p>Basically it is possible to model a plain key-value store using Valkey<br>where values can just be just strings, which is not just more memory efficient<br>than Valkey plain keys but also much more memory efficient than memcached.</p>\n<p>Let&#39;s start with some facts: a few keys use a lot more memory than a single key<br>containing a hash with a few fields. How is this possible? We use a trick.<br>In theory to guarantee that we perform lookups in constant time<br>(also known as O(1) in big O notation) there is the need to use a data structure<br>with a constant time complexity in the average case, like a hash table.</p>\n<p>But many times hashes contain just a few fields. When hashes are small we can<br>instead just encode them in an O(N) data structure, like a linear<br>array with length-prefixed key-value pairs. Since we do this only when N<br>is small, the amortized time for <code>HGET</code> and <code>HSET</code> commands is still O(1): the<br>hash will be converted into a real hash table as soon as the number of elements<br>it contains grows too large (you can configure the limit in valkey.conf).</p>\n<p>This does not only work well from the point of view of time complexity, but<br>also from the point of view of constant times since a linear array of key-value pairs happens to play very well with the CPU cache (it has a better<br>cache locality than a hash table).</p>\n<p>However since hash fields and values are not (always) represented as full-featured Valkey objects, hash fields can&#39;t have an associated time to live<br>(expire) like a real key, and can only contain a string. But we are okay with<br>this, this was the intention anyway when the hash data type API was<br>designed (we trust simplicity more than features, so nested data structures<br>are not allowed, as expires of single fields are not allowed).</p>\n<p>So hashes are memory efficient. This is useful when using hashes<br>to represent objects or to model other problems when there are group of<br>related fields. But what about if we have a plain key value business?</p>\n<p>Imagine we want to use Valkey as a cache for many small objects, which can be JSON encoded objects, small HTML fragments, simple key -&gt; boolean values<br>and so forth. Basically, anything is a string -&gt; string map with small keys<br>and values.</p>\n<p>Now let&#39;s assume the objects we want to cache are numbered, like:</p>\n<ul>\n<li>object:102393</li>\n<li>object:1234</li>\n<li>object:5</li>\n</ul>\n<p>This is what we can do. Every time we perform a<br>SET operation to set a new value, we actually split the key into two parts,<br>one part used as a key, and the other part used as the field name for the hash. For instance, the<br>object named &quot;object:1234&quot; is actually split into:</p>\n<ul>\n<li>a Key named object:12</li>\n<li>a Field named 34</li>\n</ul>\n<p>So we use all the characters but the last two for the key, and the final<br>two characters for the hash field name. To set our key we use the following<br>command:</p>\n<pre><code>HSET object:12 34 somevalue\n</code></pre>\n<p>As you can see every hash will end up containing 100 fields, which is an optimal compromise between CPU and memory saved.</p>\n<p>There is another important thing to note, with this schema<br>every hash will have more or<br>less 100 fields regardless of the number of objects we cached. This is because our objects will always end with a number and not a random string. In some way, the final number can be considered as a form of implicit pre-sharding.</p>\n<p>What about small numbers? Like object:2? We handle this case using just<br>&quot;object:&quot; as a key name, and the whole number as the hash field name.<br>So object:2 and object:10 will both end inside the key &quot;object:&quot;, but one<br>as field name &quot;2&quot; and one as &quot;10&quot;.</p>\n<p>Every time a hash exceeds the number of elements or element size specified<br>it will be converted into a real hash table, and the memory saving will be lost.</p>\n<p>You may ask, why don&#39;t you do this implicitly in the normal key space so that<br>I don&#39;t have to care? There are two reasons: one is that we tend to make<br>tradeoffs explicit, and this is a clear tradeoff between many things: CPU,<br>memory, and max element size. The second is that the top-level key space must<br>support a lot of interesting things like expires, LRU data, and so<br>forth so it is not practical to do this in a general way.</p>\n<p>But the Valkey Way is that the user must understand how things work so that he can pick the best compromise and to understand how the system will<br>behave exactly.</p>\n<h2>Memory allocation</h2>\n<p>To store user keys, Valkey allocates at most as much memory as the <code>maxmemory</code><br>setting enables (however there are small extra allocations possible).</p>\n<p>The exact value can be set in the configuration file or set later via<br><code>CONFIG SET</code> (for more info, see <a href=\"lru-cache.md\">Using memory as an LRU cache</a>).<br>There are a few things that should be noted about how Valkey manages memory:</p>\n<ul>\n<li>Valkey will not always free up (return) memory to the OS when keys are removed.<br>This is not something special about Valkey, but it is how most malloc() implementations work.<br>For example, if you fill an instance with 5GB worth of data, and then<br>remove the equivalent of 2GB of data, the Resident Set Size (also known as<br>the RSS, which is the number of memory pages consumed by the process)<br>will probably still be around 5GB, even if Valkey will claim that the user<br>memory is around 3GB.  This happens because the underlying allocator can&#39;t easily release the memory.<br>For example, often most of the removed keys were allocated on the same pages as the other keys that still exist.</li>\n<li>The previous point means that you need to provision memory based on your<br><strong>peak memory usage</strong>. If your workload from time to time requires 10GB, even if<br>most of the time 5GB could do, you need to provision for 10GB.</li>\n<li>However allocators are smart and are able to reuse free chunks of memory,<br>so after you free 2GB of your 5GB data set, when you start adding more keys<br>again, you&#39;ll see the RSS (Resident Set Size) stay steady and not grow<br>more, as you add up to 2GB of additional keys. The allocator is basically<br>trying to reuse the 2GB of memory previously (logically) freed.</li>\n<li>Because of all this, the fragmentation ratio is not reliable when you<br>had a memory usage that at the peak is much larger than the currently used memory.<br>The fragmentation is calculated as the physical memory actually used (the RSS<br>value) divided by the amount of memory currently in use (as the sum of all<br>the allocations performed by Valkey). Because the RSS reflects the peak memory,<br>when the (virtually) used memory is low since a lot of keys/values were freed, but the RSS is high, the ratio <code>RSS / mem_used</code> will be very high.</li>\n</ul>\n<p>If <code>maxmemory</code> is not set Valkey will keep allocating memory as it sees<br>fit and thus it can (gradually) eat up all your free memory.<br>Therefore it is generally advisable to configure some limits. You may also<br>want to set <code>maxmemory-policy</code> to <code>noeviction</code> (which is <em>not</em> the default<br>value in some older versions of Valkey).</p>\n<p>It makes Valkey return an out-of-memory error for write commands if and when it reaches the<br>limit - which in turn may result in errors in the application but will not render the<br>whole machine dead because of memory starvation.</p>\n"
      }
    ]
  },
  {
    "title": "PERFORMANCE",
    "items": [
      {
        "id": "pipelining",
        "topicName": "Pipelining",
        "description": "How to optimize round-trip times by batching Valkey commands",
        "htmlContent": "<p>Valkey pipelining is a technique for improving performance by issuing multiple commands at once without waiting for the response to each individual command. Pipelining is supported by most Valkey clients. This document describes the problem that pipelining is designed to solve and how pipelining works in Valkey.</p>\n<h2>Request/Response protocols and round-trip time (RTT)</h2>\n<p>Valkey is a TCP server using the client-server model and what is called a <em>Request/Response</em> protocol.</p>\n<p>This means that usually a request is accomplished with the following steps:</p>\n<ul>\n<li>The client sends a query to the server, and reads from the socket, usually in a blocking way, for the server response.</li>\n<li>The server processes the command and sends the response back to the client.</li>\n</ul>\n<p>So for instance a four commands sequence is something like this:</p>\n<ul>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 1</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 2</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 3</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 4</li>\n</ul>\n<p>Clients and Servers are connected via a network link.<br>Such a link can be very fast (a loopback interface) or very slow (a connection established over the Internet with many hops between the two hosts).<br>Whatever the network latency is, it takes time for the packets to travel from the client to the server, and back from the server to the client to carry the reply.</p>\n<p>This time is called RTT (Round Trip Time).<br>It&#39;s easy to see how this can affect performance when a client needs to perform many requests in a row (for instance adding many elements to the same list, or populating a database with many keys).<br>For instance if the RTT time is 250 milliseconds (in the case of a very slow link over the Internet), even if the server is able to process 100k requests per second, we&#39;ll be able to process at max four requests per second.</p>\n<p>If the interface used is a loopback interface, the RTT is much shorter, typically sub-millisecond, but even this will add up to a lot if you need to perform many writes in a row.</p>\n<p>Fortunately there is a way to improve this use case.</p>\n<h2>Valkey Pipelining</h2>\n<p>A Request/Response server can be implemented so that it is able to process new requests even if the client hasn&#39;t already read the old responses.<br>This way it is possible to send <em>multiple commands</em> to the server without waiting for the replies at all, and finally read the replies in a single step.</p>\n<p>This is called pipelining, and is a technique widely in use for many decades.<br>For instance many POP3 protocol implementations already support this feature, dramatically speeding up the process of downloading new emails from the server.</p>\n<p>Valkey has supported pipelining since its early days, so whatever version you are running, you can use pipelining with Valkey.<br>This is an example using the raw netcat utility:</p>\n<pre><code class=\"language-bash\">$ (printf &quot;PING\\r\\nPING\\r\\nPING\\r\\n&quot;; sleep 1) | nc localhost 6379\n+PONG\n+PONG\n+PONG\n</code></pre>\n<p>This time we don&#39;t pay the cost of RTT for every call, but just once for the three commands.</p>\n<p>To be explicit, with pipelining the order of operations of our very first example will be the following:</p>\n<ul>\n<li><em>Client:</em> INCR X</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Client:</em> INCR X</li>\n<li><em>Server:</em> 1</li>\n<li><em>Server:</em> 2</li>\n<li><em>Server:</em> 3</li>\n<li><em>Server:</em> 4</li>\n</ul>\n<blockquote>\n<p><strong>IMPORTANT NOTE</strong>: While the client sends commands using pipelining, the server will be forced to queue the replies, using memory. So if you need to send a lot of commands with pipelining, it is better to send them as batches each containing a reasonable number, for instance 10k commands, read the replies, and then send another 10k commands again, and so forth. The speed will be nearly the same, but the additional memory used will be at most the amount needed to queue the replies for these 10k commands.</p>\n</blockquote>\n<h2>It&#39;s not just a matter of RTT</h2>\n<p>Pipelining is not just a way to reduce the latency cost associated with the<br>round trip time, it actually greatly improves the number of operations<br>you can perform per second in a given Valkey server.<br>This is because without using pipelining, serving each command is very cheap from<br>the point of view of accessing the data structures and producing the reply,<br>but it is very costly from the point of view of doing the socket I/O. This<br>involves calling the <code>read()</code> and <code>write()</code> syscall, that means going from user<br>land to kernel land.<br>The context switch is a huge speed penalty.</p>\n<p>When pipelining is used, many commands are usually read with a single <code>read()</code><br>system call, and multiple replies are delivered with a single <code>write()</code> system<br>call. Consequently, the number of total queries performed per second<br>initially increases almost linearly with longer pipelines, and eventually<br>reaches 10 times the baseline obtained without pipelining, as shown in this figure.</p>\n<p><img src=\"pipeline_iops.png\" alt=\"Pipeline size and IOPs\"></p>\n<h2>A real world code example</h2>\n<p>In the following benchmark we&#39;ll use a Ruby client, supporting pipelining, to test the speed improvement due to pipelining:</p>\n<pre><code class=\"language-ruby\">require &#39;rubygems&#39;\nrequire &#39;redis&#39;\n\ndef bench(descr)\n  start = Time.now\n  yield\n  puts &quot;#{descr} #{Time.now - start} seconds&quot;\nend\n\ndef without_pipelining\n  r = Redis.new\n  10_000.times do\n    r.ping\n  end\nend\n\ndef with_pipelining\n  r = Redis.new\n  r.pipelined do\n    10_000.times do\n      r.ping\n    end\n  end\nend\n\nbench(&#39;without pipelining&#39;) do\n  without_pipelining\nend\nbench(&#39;with pipelining&#39;) do\n  with_pipelining\nend\n</code></pre>\n<p>Running the above simple script yields the following figures on my MacOS system, running over the loopback interface, where pipelining will provide the smallest improvement as the RTT is already pretty low:</p>\n<pre><code>without pipelining 1.185238 seconds\nwith pipelining 0.250783 seconds\n</code></pre>\n<p>As you can see, using pipelining, we improved the transfer by a factor of five.</p>\n<h2>Pipelining vs Scripting</h2>\n<p>Using <a href=\"../commands/eval.md\">Valkey scripting</a>, a number of use cases for pipelining can be addressed more efficiently using scripts that perform a lot of the work needed at the server side.<br>A big advantage of scripting is that it is able to both read and write data with minimal latency, making operations like <em>read, compute, write</em> very fast (pipelining can&#39;t help in this scenario since the client needs the reply of the read command before it can call the write command).</p>\n<p>Sometimes the application may also want to send <code>EVAL</code> or <code>EVALSHA</code> commands in a pipeline.<br>This is entirely possible and Valkey explicitly supports it with the <a href=\"../commands/script-load.md\">SCRIPT LOAD</a> command (it guarantees that <code>EVALSHA</code> can be called without the risk of failing).</p>\n<h2>Appendix: Why are busy loops slow even on the loopback interface?</h2>\n<p>Even with all the background covered in this page, you may still wonder why<br>a Valkey benchmark like the following (in pseudo code), is slow even when<br>executed in the loopback interface, when the server and the client are running<br>in the same physical machine:</p>\n<pre><code class=\"language-sh\">FOR-ONE-SECOND:\n    Valkey.SET(&quot;foo&quot;,&quot;bar&quot;)\nEND\n</code></pre>\n<p>After all, if both the Valkey process and the benchmark are running in the same<br>box, isn&#39;t it just copying messages in memory from one place to another without<br>any actual latency or networking involved?</p>\n<p>The reason is that processes in a system are not always running, actually it is<br>the kernel scheduler that lets the process run.<br>So, for instance, when the benchmark is allowed to run, it reads the reply from the Valkey server (related to the last command executed), and writes a new command.<br>The command is now in the loopback interface buffer, but in order to be read by the server, the kernel should schedule the server process (currently blocked in a system call)<br>to run, and so forth.<br>So in practical terms the loopback interface still involves network-like latency, because of how the kernel scheduler works.</p>\n<p>Basically a busy loop benchmark is the silliest thing that can be done when<br>metering performances on a networked server. The wise thing is just avoiding<br>benchmarking in this way.</p>\n"
      },
      {
        "id": "latency-monitor",
        "topicName": "Latency monitoring",
        "description": "Discovering slow server events in Valkey",
        "htmlContent": "<p>Valkey is often used for demanding use cases, where it<br>serves a large number of queries per second per instance, but also has strict latency requirements for the average response<br>time and the worst-case latency.</p>\n<p>While Valkey is an in-memory system, it deals with the operating system in<br>different ways, for example, in the context of persisting to disk.<br>Moreover Valkey implements a rich set of commands. Certain commands<br>are fast and run in constant or logarithmic time. Other commands are slower<br>O(N) commands that can cause latency spikes.</p>\n<p>Finally, Valkey is single threaded. This is usually an advantage<br>from the point of view of the amount of work it can perform per core, and in<br>the latency figures it is able to provide. However, it poses<br>a challenge for latency, since the single<br>thread must be able to perform certain tasks incrementally, for<br>example key expiration, in a way that does not impact the other clients<br>that are served.</p>\n<p>For all these reasons, there is a feature called<br><strong>Latency Monitoring</strong>, that helps the user to check and troubleshoot possible<br>latency problems. Latency monitoring is composed of the following conceptual<br>parts:</p>\n<ul>\n<li>Latency hooks that sample different latency-sensitive code paths.</li>\n<li>Time series recording of latency spikes, split by different events.</li>\n<li>Reporting engine to fetch raw data from the time series.</li>\n<li>Analysis engine to provide human-readable reports and hints according to the measurements.</li>\n</ul>\n<p>The rest of this document covers the latency monitoring subsystem<br>details. For more information about the general topic of Valkey<br>and latency, see <a href=\"latency.md\">Valkey latency problems troubleshooting</a>.</p>\n<h2>Events and time series</h2>\n<p>Different monitored code paths have different names and are called <em>events</em>.<br>For example, <code>command</code> is an event that measures latency spikes of possibly slow<br>command executions, while <code>fast-command</code> is the event name for the monitoring<br>of the O(1) and O(log N) commands. Other events are less generic and monitor<br>specific operations performed by Valkey. For example, the <code>fork</code> event<br>only monitors the time taken by Valkey to execute the <code>fork(2)</code> system call.</p>\n<p>A latency spike is an event that takes more time to run than the configured latency<br>threshold. There is a separate time series associated with every monitored<br>event. This is how the time series work:</p>\n<ul>\n<li>Every time a latency spike happens, it is logged in the appropriate time series.</li>\n<li>Every time series is composed of 160 elements.</li>\n<li>Each element is a pair made of a Unix timestamp of the time the latency spike was measured and the number of milliseconds the event took to execute.</li>\n<li>Latency spikes for the same event that occur in the same second are merged by taking the maximum latency. Even if continuous latency spikes are measured for a given event, which could happen with a low threshold, at least 160 seconds of history are available.</li>\n<li>Records the all-time maximum latency for every element.</li>\n</ul>\n<p>The framework monitors and logs latency spikes in the execution time of these events:</p>\n<ul>\n<li><code>command</code>: regular commands.</li>\n<li><code>fast-command</code>: O(1) and O(log N) commands.</li>\n<li><code>fork</code>: the <code>fork(2)</code> system call.</li>\n<li><code>rdb-unlink-temp-file</code>: the <code>unlink(2)</code> system call.</li>\n<li><code>aof-fsync-always</code>: the <code>fsync(2)</code> system call when invoked by the <code>appendfsync allways</code> policy.</li>\n<li><code>aof-write</code>: writing to the AOF - a catchall event for <code>write(2)</code> system calls.</li>\n<li><code>aof-write-pending-fsync</code>: the <code>write(2)</code> system call when there is a pending fsync.</li>\n<li><code>aof-write-active-child</code>: the <code>write(2)</code> system call when there are active child processes.</li>\n<li><code>aof-write-alone</code>: the <code>write(2)</code> system call when no pending fsync and no active child process.</li>\n<li><code>aof-fstat</code>: the <code>fstat(2)</code> system call.</li>\n<li><code>aof-rename</code>: the <code>rename(2)</code> system call for renaming the temporary file after completing <code>BGREWRITEAOF</code>.</li>\n<li><code>aof-rewrite-diff-write</code>: writing the differences accumulated while performing <code>BGREWRITEAOF</code>.</li>\n<li><code>active-defrag-cycle</code>: the active defragmentation cycle.</li>\n<li><code>expire-cycle</code>: the expiration cycle.</li>\n<li><code>eviction-cycle</code>: the eviction cycle.</li>\n<li><code>eviction-del</code>: deletes during the eviction cycle.</li>\n</ul>\n<h2>How to enable latency monitoring</h2>\n<p>What is high latency for one use case may not be considered high latency for another. Some applications may require that all queries be served in less than 1 millisecond. For other applications, it may be acceptable for a small amount of clients to experience a 2 second latency on occasion.</p>\n<p>The first step to enable the latency monitor is to set a <strong>latency threshold</strong> in milliseconds. Only events that take longer than the specified threshold will be logged as latency spikes. The user should set the threshold according to their needs. For example, if the application requires a maximum acceptable latency of 100 milliseconds, the threshold should be set to log all the events blocking the server for a time equal or greater to 100 milliseconds.</p>\n<p>Enable the latency monitor at runtime in a production server<br>with the following command:</p>\n<pre><code>CONFIG SET latency-monitor-threshold 100\n</code></pre>\n<p>Monitoring is turned off by default (threshold set to 0), even if the actual cost of latency monitoring is near zero. While the memory requirements of latency monitoring are very small, there is no good reason to raise the baseline memory usage of a Valkey instance that is working well.</p>\n<h2>Report information with the LATENCY command</h2>\n<p>The user interface to the latency monitoring subsystem is the <code>LATENCY</code> command.<br>Like many other Valkey commands, <code>LATENCY</code> accepts subcommands that modify its behavior. These subcommands are:</p>\n<ul>\n<li><code>LATENCY LATEST</code> - returns the latest latency samples for all events.</li>\n<li><code>LATENCY HISTORY</code> - returns latency time series for a given event.</li>\n<li><code>LATENCY RESET</code> - resets latency time series data for one or more events.</li>\n<li><code>LATENCY GRAPH</code> - renders an ASCII-art graph of an event&#39;s latency samples.</li>\n<li><code>LATENCY DOCTOR</code> - replies with a human-readable latency analysis report.</li>\n</ul>\n<p>Refer to each subcommand&#39;s documentation page for further information.</p>\n"
      },
      {
        "id": "performance-on-cpu",
        "topicName": "CPU profiling",
        "description": "Performance engineering guide for on-CPU profiling and tracing\n",
        "htmlContent": "<h2>Filling the performance checklist</h2>\n<p>Valkey is developed with a great emphasis on performance. We do our best with<br>every release to make sure you&#39;ll experience a very stable and fast product. </p>\n<p>Nevertheless, if you&#39;re finding room to improve the efficiency of Valkey or<br>are pursuing a performance regression investigation you will need a concise<br>methodical way of monitoring and analyzing Valkey performance. </p>\n<p>To do so you can rely on different methodologies (some more suited than other<br>depending on the class of issues/analysis we intend to make). A curated list<br>of methodologies and their steps are enumerated by Brendan Greg at the<br><a href=\"https://www.brendangregg.com/methodology.html\">following link</a>. </p>\n<p>We recommend the Utilization Saturation and Errors (USE) Method for answering<br>the question of what is your bottleneck. Check the following mapping between<br>system resource, metric, and tools for a practical deep dive:<br><a href=\"https://www.brendangregg.com/USEmethod/use-rosetta.html\">USE method</a>. </p>\n<h3>Ensuring the CPU is your bottleneck</h3>\n<p>This guide assumes you&#39;ve followed one of the above methodologies to perform a<br>complete check of system health, and identified the bottleneck being the CPU.<br><strong>If you have identified that most of the time is spent blocked on I/O, locks,<br>timers, paging/swapping, etc., this guide is not for you</strong>. </p>\n<h3>Build Prerequisites</h3>\n<p>For a proper On-CPU analysis, Valkey (and any dynamically loaded library like<br>Valkey Modules) requires stack traces to be available to tracers, which you may<br>need to fix first. </p>\n<p>By default, Valkey is compiled with the <code>-O3</code> optimization flag (which we intent to keep<br>during profiling). This means that compiler optimizations are enabled which significantly<br>enhance the performance. Valkey is also compiled with the <code>-fno-omit-frame-pointer</code> flag<br>by default, ensuring that the frame pointer is preserved across function calls.<br>This combination allows for precise stack walking and call stack tracing,<br>which is essential for accurate profiling and debugging. Keeping the frame pointer<br>intact helps profiling tools like <code>perf</code>, <code>gdb</code>, and others correctly attribute on-CPU<br>time to deeper call stack frames, leading to more reliable insights into performance bottlenecks<br>and hotspots. This setup strikes a balance between maintaining a highly optimized executable<br>and ensuring that profiling and tracing tools provide accurate and actionable data.</p>\n<p>It&#39;s important that you ensure that:</p>\n<ul>\n<li>we still run with optimizations to get an accurate representation of production run times, meaning we will keep: <code>-O3</code></li>\n</ul>\n<p>You can do it as follows within valkey main repo:</p>\n<pre><code>$ make SERVER_CFLAGS=&quot;-g&quot;\n</code></pre>\n<h2>A set of instruments to identify performance regressions and/or potential <strong>on-CPU performance</strong> improvements</h2>\n<p>This document focuses specifically on <strong>on-CPU</strong> resource bottlenecks analysis,<br>meaning we&#39;re interested in understanding where threads are spending CPU cycles<br>while running on-CPU and, as importantly, whether those cycles are effectively<br>being used for computation or stalled waiting (not blocked!) for memory I/O,<br>and cache misses, etc.</p>\n<p>For that we will rely on toolkits (perf, bcc tools), and hardware specific PMCs<br>(Performance Monitoring Counters), to proceed with:</p>\n<ul>\n<li><p>Hotspot analysis (perf or bcc tools): to profile code execution and determine which functions are consuming the most time and thus are targets for optimization. We&#39;ll present two options to collect, report, and visualize hotspots either with perf or bcc/BPF tracing tools.</p>\n</li>\n<li><p>Call counts analysis: to count events including function calls, enabling us to correlate several calls/components at once, relying on bcc/BPF tracing tools.</p>\n</li>\n<li><p>Hardware event sampling: crucial for understanding CPU behavior, including memory I/O, stall cycles, and cache misses.</p>\n</li>\n</ul>\n<h3>Tool prerequisites</h3>\n<p>The following steps rely on Linux perf_events (aka <a href=\"https://man7.org/linux/man-pages/man1/perf.1.html\">&quot;perf&quot;</a>), <a href=\"https://github.com/iovisor/bcc\">bcc/BPF tracing tools</a>, and Brendan Gregs <a href=\"https://github.com/brendangregg/FlameGraph\">FlameGraph repo</a>.</p>\n<p>We assume beforehand you have:</p>\n<ul>\n<li>Installed the perf tool on your system. Most Linux distributions will likely package this as a package related to the kernel. More information about the perf tool can be found at perf <a href=\"https://perf.wiki.kernel.org/\">wiki</a>.</li>\n<li>Followed the install <a href=\"https://github.com/iovisor/bcc/blob/master/INSTALL.md#installing-bcc\">bcc/BPF</a> instructions to install bcc toolkit on your machine.</li>\n<li>Cloned Brendan Gregs <a href=\"https://github.com/brendangregg/FlameGraph\">FlameGraph repo</a> and made accessible the <code>difffolded.pl</code> and <code>flamegraph.pl</code> files, to generated the collapsed stack traces and Flame Graphs.</li>\n</ul>\n<h2>Hotspot analysis with perf or eBPF (stack traces sampling)</h2>\n<p>Profiling CPU usage by sampling stack traces at a timed interval is a fast and<br>easy way to identify performance-critical code sections (hotspots).</p>\n<h3>Sampling stack traces using perf</h3>\n<p>To profile both user- and kernel-level stacks of valkey-server for a specific<br>length of time, for example 60 seconds, at a sampling frequency of 999 samples<br>per second:</p>\n<pre><code>$ perf record -g --pid $(pgrep valkey-server) -F 999 -- sleep 60\n</code></pre>\n<h4>Displaying the recorded profile information using perf report</h4>\n<p>By default perf record will generate a perf.data file in the current working<br>directory. </p>\n<p>You can then report with a call-graph output (call chain, stack backtrace),<br>with a minimum call graph inclusion threshold of 0.5%, with:</p>\n<pre><code>$ perf report -g &quot;graph,0.5,caller&quot;\n</code></pre>\n<p>See the <a href=\"https://man7.org/linux/man-pages/man1/perf-report.1.html\">perf report</a><br>documentation for advanced filtering, sorting and aggregation capabilities.</p>\n<h4>Visualizing the recorded profile information using Flame Graphs</h4>\n<p><a href=\"https://www.brendangregg.com/flamegraphs.html\">Flame graphs</a> allow for a quick<br>and accurate visualization of frequent code-paths. They can be generated using<br>Brendan Greg&#39;s open source programs on <a href=\"https://github.com/brendangregg/FlameGraph\">github</a>,<br>which create interactive SVGs from folded stack files.</p>\n<p>Specifically, for perf we need to convert the generated perf.data into the<br>captured stacks, and fold each of them into single lines. You can then render<br>the on-CPU flame graph with:</p>\n<pre><code>$ perf script &gt; valkey.perf.stacks\n$ stackcollapse-perf.pl valkey.perf.stacks &gt; valkey.folded.stacks\n$ flamegraph.pl valkey.folded.stacks &gt; valkey.svg\n</code></pre>\n<p>By default, perf script will generate a perf.data file in the current working<br>directory. See the <a href=\"https://linux.die.net/man/1/perf-script\">perf script</a><br>documentation for advanced usage.</p>\n<p>See <a href=\"https://github.com/brendangregg/FlameGraph#options\">FlameGraph usage options</a><br>for more advanced stack trace visualizations (like the differential one).</p>\n<h4>Archiving and sharing recorded profile information</h4>\n<p>So that analysis of the perf.data contents can be possible on a machine other<br>than the one on which collection happened, you need to export along with the<br>perf.data file all object files with build-ids found in the record data file.<br>This can be easily done with the help of<br><a href=\"https://github.com/torvalds/linux/blob/master/tools/perf/perf-archive.sh\">perf-archive.sh</a><br>script:</p>\n<pre><code>$ perf-archive.sh perf.data\n</code></pre>\n<p>Now please run:</p>\n<pre><code>$ tar xvf perf.data.tar.bz2 -C ~/.debug\n</code></pre>\n<p>on the machine where you need to run <code>perf report</code>.</p>\n<h3>Sampling stack traces using bcc/BPF&#39;s profile</h3>\n<p>Similarly to perf, as of Linux kernel 4.9, BPF-optimized profiling is now fully<br>available with the promise of lower overhead on CPU (as stack traces are<br>frequency counted in kernel context) and disk I/O resources during profiling. </p>\n<p>Apart from that, and relying solely on bcc/BPF&#39;s profile tool, we have also<br>removed the perf.data and intermediate steps if stack traces analysis is our<br>main goal. You can use bcc&#39;s profile tool to output folded format directly, for<br>flame graph generation:</p>\n<pre><code>$ /usr/share/bcc/tools/profile -F 999 -f --pid $(pgrep valkey-server) --duration 60 &gt; valkey.folded.stacks\n</code></pre>\n<p>In that manner, we&#39;ve remove any preprocessing and can render the on-CPU flame<br>graph with a single command:</p>\n<pre><code>$ flamegraph.pl valkey.folded.stacks &gt; valkey.svg\n</code></pre>\n<h3>Visualizing the recorded profile information using Flame Graphs</h3>\n<h2>Call counts analysis with bcc/BPF</h2>\n<p>A function may consume significant CPU cycles either because its code is slow<br>or because it&#39;s frequently called. To answer at what rate functions are being<br>called, you can rely upon call counts analysis using BCC&#39;s <code>funccount</code> tool:</p>\n<pre><code>$ /usr/share/bcc/tools/funccount &#39;valkey-server:(call*|*Read*|*Write*)&#39; --pid $(pgrep valkey-server) --duration 60\nTracing 64 functions for &quot;valkey-server:(call*|*Read*|*Write*)&quot;... Hit Ctrl-C to end.\n\nFUNC                                    COUNT\ncall                                      334\nhandleClientsWithPendingWrites            388\nclientInstallWriteHandler                 388\npostponeClientRead                        514\nhandleClientsWithPendingReadsUsingThreads      735\nhandleClientsWithPendingWritesUsingThreads      735\nprepareClientToWrite                     1442\nDetaching...\n</code></pre>\n<p>The above output shows that, while tracing, the Valkey&#39;s call() function was<br>called 334 times, handleClientsWithPendingWrites() 388 times, etc.</p>\n<h2>Hardware event counting with Performance Monitoring Counters (PMCs)</h2>\n<p>Many modern processors contain a performance monitoring unit (PMU) exposing<br>Performance Monitoring Counters (PMCs). PMCs are crucial for understanding CPU<br>behavior, including memory I/O, stall cycles, and cache misses, and provide<br>low-level CPU performance statistics that aren&#39;t available anywhere else.</p>\n<p>The design and functionality of a PMU is CPU-specific and you should assess<br>your CPU supported counters and features by using <code>perf list</code>. </p>\n<p>To calculate the number of instructions per cycle, the number of micro ops<br>executed, the number of cycles during which no micro ops were dispatched, the<br>number stalled cycles on memory, including a per memory type stalls, for the<br>duration of 60s, specifically for the valkey-server process: </p>\n<pre><code>$ perf stat -e &quot;cpu-clock,cpu-cycles,instructions,uops_executed.core,uops_executed.stall_cycles,cache-references,cache-misses,cycle_activity.stalls_total,cycle_activity.stalls_mem_any,cycle_activity.stalls_l3_miss,cycle_activity.stalls_l2_miss,cycle_activity.stalls_l1d_miss&quot; --pid $(pgrep valkey-server) -- sleep 60\n\nPerformance counter stats for process id &#39;3038&#39;:\n\n  60046.411437      cpu-clock (msec)          #    1.001 CPUs utilized          \n  168991975443      cpu-cycles                #    2.814 GHz                      (36.40%)\n  388248178431      instructions              #    2.30  insn per cycle           (45.50%)\n  443134227322      uops_executed.core        # 7379.862 M/sec                    (45.51%)\n   30317116399      uops_executed.stall_cycles #  504.895 M/sec                    (45.51%)\n     670821512      cache-references          #   11.172 M/sec                    (45.52%)\n      23727619      cache-misses              #    3.537 % of all cache refs      (45.43%)\n   30278479141      cycle_activity.stalls_total #  504.251 M/sec                    (36.33%)\n   19981138777      cycle_activity.stalls_mem_any #  332.762 M/sec                    (36.33%)\n     725708324      cycle_activity.stalls_l3_miss #   12.086 M/sec                    (36.33%)\n    8487905659      cycle_activity.stalls_l2_miss #  141.356 M/sec                    (36.32%)\n   10011909368      cycle_activity.stalls_l1d_miss #  166.736 M/sec                    (36.31%)\n\n  60.002765665 seconds time elapsed\n</code></pre>\n<p>It&#39;s important to know that there are two very different ways in which PMCs can<br>be used (counting and sampling), and we&#39;ve focused solely on PMCs counting for<br>the sake of this analysis. Brendan Greg clearly explains it on the following<br><a href=\"https://www.brendangregg.com/blog/2017-05-04/the-pmcs-of-ec2.html\">link</a>.</p>\n"
      },
      {
        "id": "benchmark",
        "topicName": "Benchmarking tool",
        "description": "Using the valkey-benchmark utility on a Valkey server\n",
        "htmlContent": "<h2>Usage</h2>\n<p><strong><code>valkey-benchmark</code></strong> [ <em>OPTIONS</em> ] [ <em>COMMAND</em> <em>ARGS</em>... ]</p>\n<h2>Description</h2>\n<p>Valkey includes the <code>valkey-benchmark</code> utility that simulates running commands done<br>by N clients while at the same time sending M total queries. The utility provides<br>a default set of tests, or you can supply a custom set of tests.</p>\n<h2>Options</h2>\n<p><strong><code>-h</code></strong> <em>hostname</em><br>: Server hostname (default 127.0.0.1)</p>\n<p><strong><code>-p</code></strong> <em>port</em><br>: Server port (default 6379)</p>\n<p><strong><code>-s</code></strong> <em>socket</em><br>: Server socket (overrides host and port)</p>\n<p><strong><code>-a</code></strong> <em>password</em><br>: Password for Valkey Auth</p>\n<p><strong><code>--user</code></strong> <em>username</em><br>: Used to send ACL style &#39;AUTH username pass&#39;. Needs -a.</p>\n<p><strong><code>-u</code></strong> <em>uri</em><br>: Server URI on format <code>valkey://user:password@host:port/dbnum</code>.<br>  User, password and dbnum are optional. For authentication<br>  without a username, use username &#39;default&#39;. For TLS, use<br>  the scheme &#39;valkeys&#39;.</p>\n<p><strong><code>-c</code></strong> <em>clients</em><br>: Number of parallel connections (default 50).<br>  Note: If <code>--cluster</code> is used then number of clients has to be<br>  the same or higher than the number of nodes.</p>\n<p><strong><code>-n</code></strong> <em>requests</em><br>: Total number of requests (default 100000)</p>\n<p><strong><code>-d</code></strong> <em>size</em><br>: Data size of SET/GET value in bytes (default 3)</p>\n<p><strong><code>--dbnum</code></strong> <em>db</em><br>: SELECT the specified db number (default 0)</p>\n<p><strong><code>-3</code></strong><br>: Start session in RESP3 protocol mode.</p>\n<p><strong><code>--threads</code></strong> <em>num</em><br>: Enable multi-thread mode.</p>\n<p><strong><code>--cluster</code></strong><br>: Enable cluster mode.<br>  If the command is supplied on the command line in cluster<br>  mode, the key must contain &quot;{tag}&quot;. Otherwise, the<br>  command will not be sent to the right cluster node.</p>\n<p><strong><code>--rfr</code></strong> <em>mode</em><br>: Enable read from replicas in cluster mode.<br>  This command must be used with the <code>--cluster</code> option.<br>  There are three modes for reading from replicas:</p>\n<p>  <strong>no</strong> - sends read requests to primaries only (default).</p>\n<p>  <strong>yes</strong> - sends read requests to replicas only.</p>\n<p>  <strong>all</strong> - sends read requests to all nodes.</p>\n<p>   Since write commands will be rejected by replicas,<br>   it is recommended to enable read from replicas only for read command tests.</p>\n<p><strong><code>--enable-tracking</code></strong><br>: Send CLIENT TRACKING ON before starting benchmark.</p>\n<p><strong><code>-k</code></strong> <em>boolean</em><br>: 1=keep alive 0=reconnect (default 1)</p>\n<p><strong><code>-r</code></strong> <em>keyspacelen</em><br>: Use random keys for SET/GET/INCR, random values for SADD,<br>  random members and scores for ZADD.<br>  Using this option the benchmark will expand the string<br>  <code>__rand_int__</code> inside an argument with a 12 digits number in<br>  the specified range from 0 to keyspacelen - 1. The<br>  substitution changes every time a command is executed.<br>  Default tests use this to hit random keys in the specified<br>  range.<br>  Note: If <code>-r</code> is omitted, all commands in a benchmark will<br>  use the same key.</p>\n<p><strong><code>-P</code></strong> <em>numreq</em><br>: Pipeline <em>numreq</em> requests. Default 1 (no pipeline).</p>\n<p><strong><code>-q</code></strong><br>: Quiet. Just show query/sec values</p>\n<p><strong><code>--precision</code></strong><br>: Number of decimal places to display in latency output (default 0)</p>\n<p><strong><code>--csv</code></strong><br>: Output in CSV format</p>\n<p><strong><code>-l</code></strong><br>: Loop. Run the tests forever</p>\n<p><strong><code>-t</code></strong> <em>tests</em><br>: Only run the comma separated list of tests. The test<br>  names are the same as the ones produced as output.<br>  The <code>-t</code> option is ignored if a specific command is supplied<br>  on the command line.</p>\n<p><strong><code>-I</code></strong><br>: Idle mode. Just open N idle connections and wait.</p>\n<p><strong><code>-x</code></strong><br>: Read last argument from STDIN.</p>\n<p><strong><code>--seed</code></strong> <em>num</em><br>: Set the seed for random number generator. Default seed is based on time.</p>\n<p><strong><code>--tls</code></strong><br>: Establish a secure TLS connection.</p>\n<p><strong><code>--sni</code></strong> <em>host</em><br>: Server name indication for TLS.</p>\n<p><strong><code>--cacert</code></strong> <em>file</em><br>: CA Certificate file to verify with.</p>\n<p><strong><code>--cacertdir</code></strong> <em>dir</em><br>: Directory where trusted CA certificates are stored.<br>  If neither cacert nor cacertdir are specified, the default<br>  system-wide trusted root certs configuration will apply.</p>\n<p><strong><code>--insecure</code></strong><br>: Allow insecure TLS connection by skipping cert validation.</p>\n<p><strong><code>--cert</code></strong> <em>file</em><br>: Client certificate to authenticate with.</p>\n<p><strong><code>--key</code></strong> <em>file</em><br>: Private key file to authenticate with.</p>\n<p><strong><code>--tls-ciphers</code></strong> <em>list</em><br>: Sets the list of preferred ciphers (TLSv1.2 and below)<br>  in order of preference from highest to lowest separated by colon (&quot;:&quot;).<br>  See the <strong>ciphers</strong>(1ssl) manpage for more information about the syntax of this string.</p>\n<p><strong><code>--tls-ciphersuites</code></strong> <em>list</em><br>: Sets the list of preferred ciphersuites (TLSv1.3)<br>  in order of preference from highest to lowest separated by colon (&quot;:&quot;).<br>  See the <strong>ciphers</strong>(1ssl) manpage for more information about the syntax of this string,<br>  and specifically for TLSv1.3 ciphersuites.</p>\n<p><strong><code>--help</code></strong><br>: Output help and exit.</p>\n<p><strong><code>--version</code></strong><br>: Output version and exit.</p>\n<h2>Examples</h2>\n<p>Run the benchmark with the default configuration against 127.0.0.1:6379. You<br>need to have a running Valkey instance before launching the benchmark:</p>\n<pre><code>$ valkey-benchmark\n</code></pre>\n<p>Run a benchmark with 20 parallel clients, pipelining 10 commands at a time,<br>using 2 threads and less verbose output:</p>\n<pre><code>$ valkey-benchmark -c 20 -P 10 --threads 2 -q\n</code></pre>\n<p>Use 20 parallel clients, for a total of 100k requests, against 192.168.1.1:</p>\n<pre><code>$ valkey-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20\n</code></pre>\n<p>Fill 127.0.0.1:6379 with about 1 million keys only using the SET test:</p>\n<pre><code>$ valkey-benchmark -t set -n 1000000 -r 100000000\n</code></pre>\n<p>Benchmark 127.0.0.1:6379 for a few commands producing CSV output:</p>\n<pre><code>$ valkey-benchmark -t ping,set,get -n 100000 --csv\n</code></pre>\n<p>Benchmark a specific command line:</p>\n<pre><code>$ valkey-benchmark -r 10000 -n 10000 eval &#39;return redis.call(&quot;ping&quot;)&#39; 0\n</code></pre>\n<p>Fill a list with 10000 random elements:</p>\n<pre><code>$ valkey-benchmark -r 10000 -n 10000 lpush mylist __rand_int__\n</code></pre>\n<p>On user specified command lines <code>__rand_int__</code> is replaced with a random integer<br>with a range of values selected by the <code>-r</code> option.</p>\n<h3>Running only a subset of the tests</h3>\n<p>You don&#39;t need to run all the default tests every time you execute <code>valkey-benchmark</code>.<br>For example, to select only a subset of tests, use the <code>-t</code> option<br>as in the following example:</p>\n<pre><code>$ valkey-benchmark -t set,lpush -n 100000 -q\nSET: 74239.05 requests per second\nLPUSH: 79239.30 requests per second\n</code></pre>\n<p>This example runs the tests for the <code>SET</code> and <code>LPUSH</code> commands and uses quiet mode (see the <code>-q</code> switch).</p>\n<p>You can even benchmark a specific command:</p>\n<pre><code>$ valkey-benchmark -n 100000 -q script load &quot;server.call(&#39;set&#39;,&#39;foo&#39;,&#39;bar&#39;)&quot;\nscript load server.call(&#39;set&#39;,&#39;foo&#39;,&#39;bar&#39;): 69881.20 requests per second\n</code></pre>\n<h3>Selecting the size of the key space</h3>\n<p>By default, the benchmark runs against a single key. In Valkey the difference<br>between such a synthetic benchmark and a real one is not huge since it is an<br>in-memory system, however it is possible to stress cache misses and in general<br>to simulate a more real-world work load by using a large key space.</p>\n<p>This is obtained by using the <code>-r</code> switch. For instance if I want to run<br>one million SET operations, using a random key for every operation out of<br>100k possible keys, I&#39;ll use the following command line:</p>\n<pre><code>$ valkey-cli flushall\nOK\n\n$ valkey-benchmark -t set -r 100000 -n 1000000\n====== SET ======\n  1000000 requests completed in 13.86 seconds\n  50 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n99.76% `&lt;=` 1 milliseconds\n99.98% `&lt;=` 2 milliseconds\n100.00% `&lt;=` 3 milliseconds\n100.00% `&lt;=` 3 milliseconds\n72144.87 requests per second\n\n$ valkey-cli dbsize\n(integer) 99993\n</code></pre>\n<h3>Using pipelining</h3>\n<p>By default every client (the benchmark simulates 50 clients if not otherwise<br>specified with <code>-c</code>) sends the next command only when the reply of the previous<br>command is received, this means that the server will likely need a read call<br>in order to read each command from every client. Also RTT is paid as well.</p>\n<p>Valkey supports <a href=\"pipelining.md\">pipelining</a>, so it is possible to send<br>multiple commands at once, a feature often exploited by real world applications.<br>Valkey pipelining is able to dramatically improve the number of operations per<br>second a server is able do deliver.</p>\n<p>Consider this example of running the benchmark using a<br>pipelining of 16 commands:</p>\n<pre><code>$ valkey-benchmark -n 1000000 -t set,get -P 16 -q\nSET: 403063.28 requests per second\nGET: 508388.41 requests per second\n</code></pre>\n<p>Using pipelining results in a significant increase in performance.</p>\n<h3>Pitfalls and misconceptions</h3>\n<p>The first point is obvious: the golden rule of a useful benchmark is to<br>only compare apples and apples. You can compare different versions of Valkey on the same workload or the same version of Valkey, but with<br>different options. If you plan to compare Valkey to something else, then it is<br>important to evaluate the functional and technical differences, and take them<br>in account.</p>\n<ul>\n<li>Valkey is a server: all commands involve network or IPC round trips. It is meaningless to compare it to embedded data stores, because the cost of most operations is primarily in network/protocol management.</li>\n<li>Valkey commands return an acknowledgment for all usual commands. Some other data stores do not. Comparing Valkey to stores involving one-way queries is only mildly useful.</li>\n<li>Naively iterating on synchronous Valkey commands does not benchmark Valkey itself, but rather measure your network (or IPC) latency and the client library intrinsic latency. To really test Valkey, you need multiple connections (like valkey-benchmark) and/or to use pipelining to aggregate several commands and/or multiple threads or processes.</li>\n<li>Valkey is an in-memory data store with some optional persistence options. If you plan to compare it to transactional servers (MySQL, PostgreSQL, etc ...), then you should consider activating AOF and decide on a suitable fsync policy.</li>\n<li>Valkey primarily operates as a single-threaded server from the POV of commands execution. While the server can employ threads for I/O operations and command parsing, the core command execution remains sequential. For CPU-intensive workloads requiring multiple cores, users should consider running multiple Valkey instances in parallel. It is not really fair to compare one single Valkey instance to a multi-threaded data store.</li>\n</ul>\n<p>The <code>valkey-benchmark</code> program is a quick and useful way to get some figures and<br>evaluate the performance of a Valkey instance on a given hardware. However,<br>by default, it does not represent the maximum throughput a Valkey instance can<br>sustain. Actually, by using pipelining and a fast client (hiredis), it is fairly<br>easy to write a program generating more throughput than valkey-benchmark. The<br>default behavior of valkey-benchmark is to achieve throughput by exploiting<br>concurrency only (i.e. it creates several connections to the server).<br>It does not use pipelining or any parallelism at all (one pending query per<br>connection at most, and no multi-threading), if not explicitly enabled via<br>the <code>-P</code> parameter. So in some way using <code>valkey-benchmark</code> and, triggering, for<br>example, a <code>BGSAVE</code> operation in the background at the same time, will provide<br>the user with numbers more near to the <em>worst case</em> than to the best case.</p>\n<p>To run a benchmark using pipelining mode (and achieve higher throughput),<br>you need to explicitly use the -P option. Please note that it is still a<br>realistic behavior since a lot of Valkey based applications actively use<br>pipelining to improve performance. However you should use a pipeline size that<br>is more or less the average pipeline length you&#39;ll be able to use in your<br>application in order to get realistic numbers.</p>\n<p>The benchmark should apply the same operations, and work in the same way<br>with the multiple data stores you want to compare. It is absolutely pointless to<br>compare the result of valkey-benchmark to the result of another benchmark<br>program and extrapolate.</p>\n<p>For instance, Valkey and memcached in single-threaded mode can be compared on<br>GET/SET operations. Both are in-memory data stores, working mostly in the same<br>way at the protocol level. Provided their respective benchmark application is<br>aggregating queries in the same way (pipelining) and use a similar number of<br>connections, the comparison is actually meaningful.</p>\n<p>When you&#39;re benchmarking a high-performance, in-memory database like Valkey,<br>it may be difficult to saturate<br>the server. Sometimes, the performance bottleneck is on the client side,<br>and not the server-side. In that case, the client (i.e., the benchmarking program itself)<br>must be fixed, or perhaps scaled out, to reach the maximum throughput.</p>\n<h3>Factors impacting Valkey performance</h3>\n<p>There are multiple factors having direct consequences on Valkey performance.<br>We mention them here, since they can alter the result of any benchmarks.<br>Please note however, that a typical Valkey instance running on a low end,<br>untuned box usually provides good enough performance for most applications.</p>\n<ul>\n<li><p>Network bandwidth and latency usually have a direct impact on the performance.<br>It is a good practice to use the ping program to quickly check the latency<br>between the client and server hosts is normal before launching the benchmark.<br>Regarding the bandwidth, it is generally useful to estimate<br>the throughput in Gbit/s and compare it to the theoretical bandwidth<br>of the network. For instance a benchmark setting 4 KB strings<br>in Valkey at 100000 q/s, would actually consume 3.2 Gbit/s of bandwidth<br>and probably fit within a 10 Gbit/s link, but not a 1 Gbit/s one. In many real<br>world scenarios, Valkey throughput is limited by the network well before being<br>limited by the CPU. To consolidate several high-throughput Valkey instances<br>on a single server, it worth considering putting a 10 Gbit/s NIC<br>or multiple 1 Gbit/s NICs with TCP/IP bonding.</p>\n</li>\n<li><p>CPU is another important factor.</p>\n</li>\n<li><p>Speed of RAM and memory bandwidth seem less critical for global performance<br>especially for small objects. For large objects (&gt;10 KB), it may become<br>noticeable though. Usually, it is not really cost-effective to buy expensive<br>fast memory modules to optimize Valkey.</p>\n</li>\n<li><p>Valkey runs slower on a VM compared to running without virtualization using<br>the same hardware. If you have the chance to run Valkey on a physical machine<br>this is preferred. However this does not mean that Valkey is slow in<br>virtualized environments, the delivered performances are still very good<br>and most of the serious performance issues you may incur in virtualized<br>environments are due to over-provisioning, non-local disks with high latency,<br>or old hypervisor software that have slow <code>fork</code> syscall implementation.</p>\n</li>\n<li><p>When the server and client benchmark programs run on the same box, both<br>the TCP/IP loopback and unix domain sockets can be used. Depending on the<br>platform, unix domain sockets can achieve around 50% more throughput than<br>the TCP/IP loopback (on Linux for instance). The default behavior of<br>valkey-benchmark is to use the TCP/IP loopback.</p>\n</li>\n<li><p>The performance benefit of unix domain sockets compared to TCP/IP loopback<br>tends to decrease when pipelining is heavily used (i.e. long pipelines).</p>\n</li>\n<li><p>When an ethernet network is used to access Valkey, aggregating commands using<br>pipelining is especially efficient when the size of the data is kept under<br>the ethernet packet size (about 1500 bytes). Actually, processing 10 bytes,<br>100 bytes, or 1000 bytes queries almost result in the same throughput.<br>See the graph below.</p>\n<p>  <img src=\"Data_size.png\" alt=\"Data size impact\"></p>\n</li>\n<li><p>On multi CPU sockets servers, Valkey performance becomes dependent on the<br>NUMA configuration and process location. The most visible effect is that<br>valkey-benchmark results seem non-deterministic because client and server<br>processes are distributed randomly on the cores. To get deterministic results,<br>it is required to use process placement tools (on Linux: taskset or numactl).<br>The most efficient combination is always to put the client and server on two<br>different cores of the same CPU to benefit from the L3 cache.<br>Here are some results of 4 KB SET benchmark for 3 server CPUs (AMD Istanbul,<br>Intel Nehalem EX, and Intel Westmere) with different relative placements.<br>Please note this benchmark is not meant to compare CPU models between themselves<br>(CPUs exact model and frequency are therefore not disclosed).</p>\n<p>  <img src=\"NUMA_chart.gif\" alt=\"NUMA chart\"></p>\n</li>\n<li><p>With high-end configurations, the number of client connections is also an<br>important factor. Being based on epoll/kqueue, the Valkey event loop is quite<br>scalable. Valkey has already been benchmarked at more than 60000 connections,<br>and was still able to sustain 50000 q/s in these conditions. As a rule of thumb,<br>an instance with 30000 connections can only process half the throughput<br>achievable with 100 connections. Here is an example showing the throughput of<br>a Valkey instance per number of connections:</p>\n<p>  <img src=\"Connections_chart.png\" alt=\"connections chart\"></p>\n</li>\n<li><p>With high-end configurations, it is possible to achieve higher throughput by<br>tuning the NIC(s) configuration and associated interruptions. Best throughput<br>is achieved by setting an affinity between Rx/Tx NIC queues and CPU cores,<br>and activating RPS (Receive Packet Steering) support. More information in this<br><a href=\"https://groups.google.com/forum/#!msg/redis-db/gUhc19gnYgc/BruTPCOroiMJ\">thread</a>.<br>Jumbo frames may also provide a performance boost when large objects are used.</p>\n</li>\n<li><p>Depending on the platform, Valkey can be compiled against different memory<br>allocators (libc malloc, jemalloc, tcmalloc), which may have different behaviors<br>in term of raw speed, internal and external fragmentation.<br>If you did not compile Valkey yourself, you can use the INFO command to check<br>the <code>mem_allocator</code> field. Please note most benchmarks do not run long enough to<br>generate significant external fragmentation (contrary to production Valkey<br>instances).</p>\n</li>\n</ul>\n<h3>Other things to consider</h3>\n<p>One important goal of any benchmark is to get reproducible results, so they<br>can be compared to the results of other tests.</p>\n<ul>\n<li>A good practice is to try to run tests on isolated hardware as much as possible.<br>If it is not possible, then the system must be monitored to check the benchmark<br>is not impacted by some external activity.</li>\n<li>Some configurations (desktops and laptops for sure, some servers as well)<br>have a variable CPU core frequency mechanism. The policy controlling this<br>mechanism can be set at the OS level. Some CPU models are more aggressive than<br>others at adapting the frequency of the CPU cores to the workload. To get<br>reproducible results, it is better to set the highest possible fixed frequency<br>for all the CPU cores involved in the benchmark.</li>\n<li>An important point is to size the system accordingly to the benchmark.<br>The system must have enough RAM and must not swap. On Linux, do not forget<br>to set the <code>overcommit_memory</code> parameter correctly. Please note 32 and 64 bit<br>Valkey instances do not have the same memory footprint.</li>\n<li>If you plan to use RDB or AOF for your benchmark, please check there is no other<br>I/O activity in the system. Avoid putting RDB or AOF files on NAS or NFS shares,<br>or on any other devices impacting your network bandwidth and/or latency<br>(for instance, EBS on Amazon EC2).</li>\n<li>Set Valkey logging level (loglevel parameter) to warning or notice. Avoid putting<br>the generated log file on a remote filesystem.</li>\n<li>Avoid using monitoring tools which can alter the result of the benchmark. For<br>instance using INFO at regular interval to gather statistics is probably fine,<br>but MONITOR will impact the measured performance significantly.</li>\n<li>When running <code>valkey-benchmark</code> on the same machine as the <code>valkey-server</code><br>being tested, you may need to run the benchmark with at least two threads<br>(<code>--threads 2</code>) to prevent the benchmarking tool itself from being the<br>bottleneck, i.e. prevent that <code>valkey-benchmark</code> is running on 100% CPU while<br><code>valkey-server</code> is using less than 100% CPU.</li>\n</ul>\n<h3>Other Valkey benchmarking tools</h3>\n<p>There are several third-party tools that can be used for benchmarking Valkey. Refer to each tool&#39;s<br>documentation for more information about its goals and capabilities.</p>\n<ul>\n<li><a href=\"https://github.com/redislabs/memtier_benchmark\">memtier_benchmark</a> from <a href=\"https://twitter.com/RedisInc\">Redis Ltd.</a> is a NoSQL Valkey, Redis and Memcache traffic generation and benchmarking tool.</li>\n<li><a href=\"https://github.com/twitter/rpc-perf\">rpc-perf</a> from <a href=\"https://twitter.com/twitter\">Twitter</a> is a tool for benchmarking RPC services that supports Valkey and Memcache.</li>\n<li><a href=\"https://github.com/brianfrankcooper/YCSB\">YCSB</a> from <a href=\"https://twitter.com/Yahoo\">Yahoo @Yahoo</a> is a benchmarking framework with clients to many databases, including Valkey.</li>\n</ul>\n<h2>See also</h2>\n<p><a href=\"cli.md\">valkey-cli</a>, <a href=\"server.md\">valkey-server</a></p>\n"
      }
    ]
  },
  {
    "title": "TROUBLESHOOTING",
    "items": [
      {
        "id": "problems",
        "topicName": "Troubleshooting Valkey",
        "description": "Problems with Valkey? Start here.",
        "htmlContent": "<p>This page tries to help you with what to do if you have issues with Valkey. Part of the Valkey project is helping people that are experiencing problems because we don&#39;t like to leave people alone with their issues.</p>\n<ul>\n<li>If you have <strong>latency problems</strong> with Valkey, that in some way appears to be idle for some time, read our <a href=\"latency.md\">Valkey latency troubleshooting guide</a>.</li>\n<li>Valkey stable releases are usually very reliable, however in the rare event you are <strong>experiencing crashes</strong> the developers can help a lot more if you provide debugging information. Please read our <a href=\"debugging.md\">Debugging Valkey guide</a>.</li>\n<li>We have a long history of users experiencing crashes with Valkey that actually turned out to be servers with <strong>broken RAM</strong>. Please test your RAM using <strong>valkey-server --test-memory</strong> in case Valkey is not stable in your system. Valkey built-in memory test is fast and reasonably reliable, but if you can you should reboot your server and use <a href=\"https://memtest86.com\">memtest86</a>.</li>\n</ul>\n"
      },
      {
        "id": "debugging",
        "topicName": "Debugging",
        "description": "A guide to debugging Valkey server processes\n",
        "htmlContent": "<p>Valkey is developed with an emphasis on stability. We do our best with<br>every release to make sure you&#39;ll experience a stable product with no<br>crashes. However, if you ever need to debug the Valkey process itself, read on.</p>\n<p>When Valkey crashes, it produces a detailed report of what happened. However,<br>sometimes looking at the crash report is not enough, nor is it possible for<br>the Valkey core team to reproduce the issue independently. In this scenario, we<br>need help from the user who can reproduce the issue.</p>\n<p>This guide shows how to use GDB to provide the information the<br>Valkey developers will need to track the bug more easily.</p>\n<h2>What is GDB?</h2>\n<p>GDB is the Gnu Debugger: a program that is able to inspect the internal state<br>of another program. Usually tracking and fixing a bug is an exercise in<br>gathering more information about the state of the program at the moment the<br>bug happens, so GDB is an extremely useful tool.</p>\n<p>GDB can be used in two ways:</p>\n<ul>\n<li>It can attach to a running program and inspect the state of it at runtime.</li>\n<li>It can inspect the state of a program that already terminated using what is called a <em>core file</em>, that is, the image of the memory at the time the program was running.</li>\n</ul>\n<p>From the point of view of investigating Valkey bugs we need to use both of these<br>GDB modes. The user able to reproduce the bug attaches GDB to their running Valkey<br>instance, and when the crash happens, they create the <code>core</code> file that in turn<br>the developer will use to inspect the Valkey internals at the time of the crash.</p>\n<p>This way the developer can perform all the inspections in his or her computer<br>without the help of the user, and the user is free to restart Valkey in their<br>production environment.</p>\n<h2>Compiling Valkey without optimizations</h2>\n<p>By default, Valkey is compiled with the <code>-O3</code> optimization flag, which enables<br>a high level of compiler optimizations that aim to maximize runtime performance.<br>Valkey is also compiled with the <code>-fno-omit-frame-pointer</code> flag by default, ensuring that<br>the frame pointer is preserved across function calls. This combination allows for<br>precise stack walking and call stack tracing, which is essential for debugging.</p>\n<p>It is better to attach GDB to Valkey compiled without optimizations using the<br><code>make noopt</code> command (instead of just using the plain <code>make</code> command). However,<br>if you have an already running Valkey in production there is no need to recompile<br>and restart it if this is going to create problems on your side. GDB still works<br>against executables compiled with optimizations.</p>\n<p>You should not be overly concerned at the loss of performance from compiling Valkey<br>without optimizations. It is unlikely that this will cause problems in your<br>environment as Valkey is not very CPU-bound.</p>\n<h2>Attaching GDB to a running process</h2>\n<p>If you have an already running Valkey server, you can attach GDB to it, so that<br>if Valkey crashes it will be possible to both inspect the internals and generate<br>a <code>core dump</code> file.</p>\n<p>After you attach GDB to the Valkey process it will continue running as usual without<br>any loss of performance, so this is not a dangerous procedure.</p>\n<p>In order to attach GDB the first thing you need is the <em>process ID</em> of the running<br>Valkey instance (the <em>pid</em> of the process). You can easily obtain it using<br><code>valkey-cli</code>:</p>\n<pre><code>$ valkey-cli info | grep process_id\nprocess_id:58414\n</code></pre>\n<p>In the above example the process ID is <strong>58414</strong>.</p>\n<p>Login into your Valkey server.</p>\n<p>(Optional but recommended) Start <strong>screen</strong> or <strong>tmux</strong> or any other program that will make sure that your GDB session will not be closed if your ssh connection times out. You can learn more about screen in <a href=\"https://www.linuxjournal.com/article/6340\">this article</a>.</p>\n<p>Attach GDB to the running Valkey server by typing:</p>\n<pre><code>$ gdb &lt;path-to-valkey-executable&gt; &lt;pid&gt;\n</code></pre>\n<p>For example:</p>\n<pre><code>$ gdb /usr/local/bin/valkey-server 58414\n</code></pre>\n<p>GDB will start and will attach to the running server printing something like the following:</p>\n<pre><code>Reading symbols for shared libraries + done\n0x00007fff8d4797e6 in epoll_wait ()\n(gdb)\n</code></pre>\n<p>At this point GDB is attached but <strong>your Valkey instance is blocked by GDB</strong>. In<br>order to let the Valkey instance continue the execution just type <strong>continue</strong> at<br>the GDB prompt, and press enter.</p>\n<pre><code>(gdb) continue\nContinuing.\n</code></pre>\n<p>Done! Now your Valkey instance has GDB attached. Now you can wait for the next crash. :)</p>\n<p>Now it&#39;s time to detach your screen/tmux session, if you are running GDB using it, by<br>pressing <strong>Ctrl-a a</strong> key combination.</p>\n<h2>After the crash</h2>\n<p>Valkey has a command to simulate a segmentation fault (in other words a bad crash) using<br>the <code>DEBUG SEGFAULT</code> command (don&#39;t use it against a real production instance of course!<br>So I&#39;ll use this command to crash my instance to show what happens in the GDB side:</p>\n<pre><code>(gdb) continue\nContinuing.\n\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0xffffffffffffffff\ndebugCommand (c=0x7ffc32005000) at debug.c:220\n220         *((char*)-1) = &#39;x&#39;;\n</code></pre>\n<p>As you can see GDB detected that Valkey crashed, and was even able to show me<br>the file name and line number causing the crash. This is already much better<br>than the Valkey crash report back trace (containing just function names and<br>binary offsets).</p>\n<h2>Obtaining the stack trace</h2>\n<p>The first thing to do is to obtain a full stack trace with GDB. This is as<br>simple as using the <strong>bt</strong> command:</p>\n<pre><code>(gdb) bt\n#0  debugCommand (c=0x7ffc32005000) at debug.c:220\n#1  0x000000010d246d63 in call (c=0x7ffc32005000) at valkey.c:1163\n#2  0x000000010d247290 in processCommand (c=0x7ffc32005000) at valkey.c:1305\n#3  0x000000010d251660 in processInputBuffer (c=0x7ffc32005000) at networking.c:959\n#4  0x000000010d251872 in readQueryFromClient (el=0x0, fd=5, privdata=0x7fff76f1c0b0, mask=220924512) at networking.c:1021\n#5  0x000000010d243523 in aeProcessEvents (eventLoop=0x7fff6ce408d0, flags=220829559) at ae.c:352\n#6  0x000000010d24373b in aeMain (eventLoop=0x10d429ef0) at ae.c:397\n#7  0x000000010d2494ff in main (argc=1, argv=0x10d2b2900) at valkey.c:2046\n</code></pre>\n<p>This shows the backtrace, but we also want to dump the processor registers using the <strong>info registers</strong> command:</p>\n<pre><code>(gdb) info registers\nrax            0x0  0\nrbx            0x7ffc32005000   140721147367424\nrcx            0x10d2b0a60  4515891808\nrdx            0x7fff76f1c0b0   140735188943024\nrsi            0x10d299777  4515796855\nrdi            0x0  0\nrbp            0x7fff6ce40730   0x7fff6ce40730\nrsp            0x7fff6ce40650   0x7fff6ce40650\nr8             0x4f26b3f7   1327936503\nr9             0x7fff6ce40718   140735020271384\nr10            0x81 129\nr11            0x10d430398  4517462936\nr12            0x4b7c04f8babc0  1327936503000000\nr13            0x10d3350a0  4516434080\nr14            0x10d42d9f0  4517452272\nr15            0x10d430398  4517462936\nrip            0x10d26cfd4  0x10d26cfd4 &lt;debugCommand+68&gt;\neflags         0x10246  66118\ncs             0x2b 43\nss             0x0  0\nds             0x0  0\nes             0x0  0\nfs             0x0  0\ngs             0x0  0\n</code></pre>\n<p>Please <strong>make sure to include</strong> both of these outputs in your bug report.</p>\n<h2>Obtaining the core file</h2>\n<p>The next step is to generate the core dump, that is the image of the memory of the running Valkey process. This is done using the <code>gcore</code> command:</p>\n<pre><code>(gdb) gcore\nSaved corefile core.58414\n</code></pre>\n<p>Now you have the core dump to send to the Valkey developer, but <strong>it is important<br>to understand</strong> that this happens to contain all the data that was inside the<br>Valkey instance at the time of the crash; Valkey developers will make sure not to<br>share the content with anyone else, and will delete the file as soon as it is no<br>longer used for debugging purposes, but you are warned that by sending the core<br>file you are sending your data.</p>\n<h2>What to send to developers</h2>\n<p>Finally you can send everything to the Valkey core team:</p>\n<ul>\n<li>The Valkey executable you are using.</li>\n<li>The stack trace produced by the <strong>bt</strong> command, and the registers dump.</li>\n<li>The core file you generated with gdb.</li>\n<li>Information about the operating system and GCC version, and Valkey version you are using.</li>\n</ul>\n<h2>Thank you</h2>\n<p>Your help is extremely important! Many issues can only be tracked this way. So<br>thanks!</p>\n"
      },
      {
        "id": "ldb",
        "topicName": "Debugging Lua scripts",
        "description": "How to use the built-in Lua debugger",
        "htmlContent": "<p>Valkey includes a complete Lua debugger, that can be<br>used to make the task of writing complex Lua scripts much simpler.</p>\n<p>The Valkey Lua debugger, codenamed LDB, has the following important features:</p>\n<ul>\n<li>It uses a server-client model, so it&#39;s a remote debugger.<br>The Valkey server acts as the debugging server, while the default client is <code>valkey-cli</code>.<br>However other clients can be developed by following the simple protocol implemented by the server.</li>\n<li>By default every new debugging session is a forked session.<br>It means that while the Valkey Lua script is being debugged, the server does not block and is usable for development or in order to execute multiple debugging sessions in parallel.<br>This also means that changes are <strong>rolled back</strong> after the script debugging session finished, so that&#39;s possible to restart a new debugging session again, using exactly the same Valkey data set as the previous debugging session.</li>\n<li>An alternative synchronous (non forked) debugging model is available on demand, so that changes to the dataset can be retained.<br>In this mode the server blocks for the time the debugging session is active.</li>\n<li>Support for step by step execution.</li>\n<li>Support for static and dynamic breakpoints.</li>\n<li>Support from logging the debugged script into the debugger console.</li>\n<li>Inspection of Lua variables.</li>\n<li>Tracing of Valkey commands executed by the script.</li>\n<li>Pretty printing of Valkey and Lua values.</li>\n<li>Infinite loops and long execution detection, which simulates a breakpoint.</li>\n</ul>\n<h2>Quick start</h2>\n<p>A simple way to get started with the Lua debugger is to watch this video<br>introduction:</p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/IMvRfStaoyM\" frameborder=\"0\" allowfullscreen></iframe>\n\n<blockquote>\n<p>Important Note:  please make sure to avoid debugging Lua scripts using your Valkey production server.<br>Use a development server instead.<br>Also note that using the synchronous debugging mode (which is NOT the default) results in the Valkey server blocking for all the time the debugging session lasts.</p>\n</blockquote>\n<p>To start a new debugging session using <code>valkey-cli</code> do the following:</p>\n<ol>\n<li><p>Create your script in some file with your preferred editor. Let&#39;s assume you are editing your Valkey Lua script located at <code>/tmp/script.lua</code>.</p>\n</li>\n<li><p>Start a debugging session with:</p>\n<p> ./valkey-cli --ldb --eval /tmp/script.lua</p>\n</li>\n</ol>\n<p>Note that with the <code>--eval</code> option of <code>valkey-cli</code> you can pass key names and arguments to the script, separated by a comma, like in the following example:</p>\n<pre><code>./valkey-cli --ldb --eval /tmp/script.lua mykey somekey , arg1 arg2\n</code></pre>\n<p>You&#39;ll enter a special mode where <code>valkey-cli</code> no longer accepts its normal<br>commands, but instead prints a help screen and passes the unmodified debugging<br>commands directly to Valkey.</p>\n<p>The only commands which are not passed to the Valkey debugger are:</p>\n<ul>\n<li><code>quit</code> -- this will terminate the debugging session.<br>It&#39;s like removing all the breakpoints and using the <code>continue</code> debugging command.<br>Moreover the command will exit from <code>valkey-cli</code>.</li>\n<li><code>restart</code> -- the debugging session will restart from scratch, <strong>reloading the new version of the script from the file</strong>.<br>So a normal debugging cycle involves modifying the script after some debugging, and calling <code>restart</code> in order to start debugging again with the new script changes.</li>\n<li><code>help</code> -- this command is passed to the Valkey Lua debugger, that will print a list of commands like the following:</li>\n</ul>\n<pre><code>lua debugger&gt; help\nValkey Lua debugger help:\n[h]elp               Show this help.\n[s]tep               Run current line and stop again.\n[n]ext               Alias for step.\n[c]ontinue           Run till next breakpoint.\n[l]ist               List source code around current line.\n[l]ist [line]        List source code around [line].\n                     line = 0 means: current position.\n[l]ist [line] [ctx]  In this form [ctx] specifies how many lines\n                     to show before/after [line].\n[w]hole              List all source code. Alias for &#39;list 1 1000000&#39;.\n[p]rint              Show all the local variables.\n[p]rint &lt;var&gt;        Show the value of the specified variable.\n                     Can also show global vars KEYS and ARGV.\n[b]reak              Show all breakpoints.\n[b]reak &lt;line&gt;       Add a breakpoint to the specified line.\n[b]reak -&lt;line&gt;      Remove breakpoint from the specified line.\n[b]reak 0            Remove all breakpoints.\n[t]race              Show a backtrace.\n[e]val &lt;code&gt;        Execute some Lua code (in a different callframe).\n[r]edis &lt;cmd&gt;        Execute a Valkey command.\n[m]axlen [len]       Trim logged Valkey replies and Lua var dumps to len.\n                     Specifying zero as &lt;len&gt; means unlimited.\n[a]bort              Stop the execution of the script. In sync\n                     mode dataset changes will be retained.\n\nDebugger functions you can call from Lua scripts:\nserver.debug()        Produce logs in the debugger console.\nserver.breakpoint()   Stop execution as if there was a breakpoint in the\n                     next line of code.\n</code></pre>\n<p>Note that when you start the debugger it will start in <strong>stepping mode</strong>.<br>It will stop at the first line of the script that actually does something before executing it.</p>\n<p>From this point you usually call <code>step</code> in order to execute the line and go to the next line.<br>While you step Valkey will show all the commands executed by the server like in the following example:</p>\n<pre><code>* Stopped at 1, stop reason = step over\n-&gt; 1   server.call(&#39;ping&#39;)\nlua debugger&gt; step\n&lt;redis&gt; ping\n&lt;reply&gt; &quot;+PONG&quot;\n* Stopped at 2, stop reason = step over\n</code></pre>\n<p>The <code>&lt;redis&gt;</code> and <code>&lt;reply&gt;</code> lines show the command executed by the line just<br>executed, and the reply from the server. Note that this happens only in stepping mode.<br>If you use <code>continue</code> in order to execute the script till the next breakpoint, commands will not be dumped on the screen to prevent too much output.</p>\n<h2>Termination of the debugging session</h2>\n<p>When the scripts terminates naturally, the debugging session ends and<br><code>valkey-cli</code> returns in its normal non-debugging mode. You can restart the<br>session using the <code>restart</code> command as usual.</p>\n<p>Another way to stop a debugging session is just interrupting <code>valkey-cli</code><br>manually by pressing <code>Ctrl+C</code>. Note that also any event breaking the<br>connection between <code>valkey-cli</code> and the <code>valkey-server</code> will interrupt the<br>debugging session.</p>\n<p>All the forked debugging sessions are terminated when the server is shut<br>down.</p>\n<h2>Abbreviating debugging commands</h2>\n<p>Debugging can be a very repetitive task. For this reason every Valkey<br>debugger command starts with a different character, and you can use the single<br>initial character in order to refer to the command.</p>\n<p>So for example instead of typing <code>step</code> you can just type <code>s</code>.</p>\n<h2>Breakpoints</h2>\n<p>Adding and removing breakpoints is trivial as described in the online help.<br>Just use <code>b 1 2 3 4</code> to add a breakpoint in line 1, 2, 3, 4.<br>The command <code>b 0</code> removes all the breakpoints. Selected breakpoints can be<br>removed using as argument the line where the breakpoint we want to remove is, but prefixed by a minus sign.<br>So for example <code>b -3</code> removes the breakpoint from line 3.</p>\n<p>Note that adding breakpoints to lines that Lua never executes, like declaration of local variables or comments, will not work.<br>The breakpoint will be added but since this part of the script will never be executed, the program will never stop.</p>\n<h2>Dynamic breakpoints</h2>\n<p>Using the <code>breakpoint</code> command it is possible to add breakpoints into specific<br>lines. However sometimes we want to stop the execution of the program only<br>when something special happens. In order to do so, you can use the<br><code>server.breakpoint()</code> function inside your Lua script. When called it simulates<br>a breakpoint in the next line that will be executed.</p>\n<pre><code>if counter &gt; 10 then server.breakpoint() end\n</code></pre>\n<p>This feature is extremely useful when debugging, so that we can avoid<br>continuing the script execution manually multiple times until a given condition<br>is encountered.</p>\n<h2>Synchronous mode</h2>\n<p>As explained previously, but default LDB uses forked sessions with rollback<br>of all the data changes operated by the script while it has being debugged.<br>Determinism is usually a good thing to have during debugging, so that successive<br>debugging sessions can be started without having to reset the database content<br>to its original state.</p>\n<p>However for tracking certain bugs, you may want to retain the changes performed<br>to the key space by each debugging session. When this is a good idea you<br>should start the debugger using a special option, <code>ldb-sync-mode</code>, in <code>valkey-cli</code>.</p>\n<pre><code>./valkey-cli --ldb-sync-mode --eval /tmp/script.lua\n</code></pre>\n<blockquote>\n<p>Note: Valkey server will be unreachable during the debugging session in this mode, so use with care.</p>\n</blockquote>\n<p>In this special mode, the <code>abort</code> command can stop the script half-way taking the changes operated to the dataset.<br>Note that this is different compared to ending the debugging session normally.<br>If you just interrupt <code>valkey-cli</code> the script will be fully executed and then the session terminated.<br>Instead with <code>abort</code> you can interrupt the script execution in the middle and start a new debugging session if needed.</p>\n<h2>Logging from scripts</h2>\n<p>The <code>server.debug()</code> command is a powerful debugging facility that can be<br>called inside the Valkey Lua script in order to log things into the debug<br>console:</p>\n<pre><code>lua debugger&gt; list\n-&gt; 1   local a = {1,2,3}\n   2   local b = false\n   3   server.debug(a,b)\nlua debugger&gt; continue\n&lt;debug&gt; line 3: {1; 2; 3}, false\n</code></pre>\n<p>If the script is executed outside of a debugging session, <code>server.debug()</code> has no effects at all.<br>Note that the function accepts multiple arguments, that are separated by a comma and a space in the output.</p>\n<p>Tables and nested tables are displayed correctly in order to make values simple to observe for the programmer debugging the script.</p>\n<h2>Inspecting the program state with <code>print</code> and <code>eval</code></h2>\n<p>While the <code>server.debug()</code> function can be used in order to print values<br>directly from within the Lua script, often it is useful to observe the local<br>variables of a program while stepping or when stopped into a breakpoint.</p>\n<p>The <code>print</code> command does just that, and performs lookup in the call frames<br>starting from the current one back to the previous ones, up to top-level.<br>This means that even if we are into a nested function inside a Lua script,<br>we can still use <code>print foo</code> to look at the value of <code>foo</code> in the context<br>of the calling function. When called without a variable name, <code>print</code> will<br>print all variables and their respective values.</p>\n<p>The <code>eval</code> command executes small pieces of Lua scripts <strong>outside the context of the current call frame</strong> (evaluating inside the context of the current call frame is not possible with the current Lua internals).<br>However you can use this command in order to test Lua functions.</p>\n<pre><code>lua debugger&gt; e server.sha1hex(&#39;foo&#39;)\n&lt;retval&gt; &quot;0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33&quot;\n</code></pre>\n<h2>Debugging clients</h2>\n<p>LDB uses the client-server model where the Valkey server acts as a debugging server that communicates using <a href=\"protocol.md\">RESP</a>. While <code>valkey-cli</code> is the default debug client, any <a href=\"../clients/\">client</a> can be used for debugging as long as it meets one of the following conditions:</p>\n<ol>\n<li>The client provides a native interface for setting the debug mode and controlling the debug session.</li>\n<li>The client provides an interface for sending arbitrary commands over RESP.</li>\n<li>The client allows sending raw messages to the Valkey server.</li>\n</ol>\n"
      }
    ]
  }
];
